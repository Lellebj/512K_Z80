Sections:
00: "Functions" (0-27D)


Source: "temp.tmp"
                        	     1: 	
                        	     2: 		include "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: 
                        	     5: ; ;Function addresses
                        	     6: ; setcursor		= $3100
                        	     7: ; writecommand	= $3180
                        	     8: ; writedata		= $3140
                        	     9: ; testBusyFlag    = $31B0
                        	    10: ; HD44780_main_init = $3000
                        	    11: 
                        	    12: 
                        	    13: ; PIO addressess...
                        	    14: portA_Contr:	equ _Z80PIO_Base + 1
                        	    15: portB_Contr:	equ _Z80PIO_Base + 3
                        	    16: portA_Data:		equ _Z80PIO_Base + 0
                        	    17: portB_Data:		equ _Z80PIO_Base + 2
                        	    18: 
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: 				;SIO_0 CHANNEL A DATA
                        	    22: SIO_0_A_D:		equ	_Z80SIO_0_Base
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_0_A_C:		equ	_Z80SIO_0_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_0_B_D:		equ	_Z80SIO_0_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_0_B_C:		equ	_Z80SIO_0_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_0_A_C
                        	    31: sio_ad: 		equ 	SIO_0_A_D
                        	    32: sio_bc: 		equ 	SIO_0_B_C
                        	    33: sio_bd: 		equ 	SIO_0_B_D
                        	    34: 
                        	    35: 
                        	    36: SIO_0_Int_Vec		EQU     $F400					; interrupt vector 
                        	    37: SIO_0_Int_WR_Vec	EQU     SIO_0_Int_Vec+8			;sio_0 channel A write interrupt vector
                        	    38: SIO_0_Int_EXT_Vec	EQU     SIO_0_Int_Vec+10		;sio_0 channel A external/status ; interrupt vector
                        	    39: SIO_0_Int_Read_Vec	EQU     SIO_0_Int_Vec+12		;sio_0 channel A read interrupt vector
                        	    40: SIO_0_Int_Spec_Vec	EQU     SIO_0_Int_Vec+14		;sio_0 channel A special receive interrupt vector
                        	    41: 
                        	    42: 		;sio_0 channel B write interrupt vector
                        	    43: SIO_0_USB_WR_Vec	EQU     SIO_0_Int_Vec+0	
                        	    44: 		;sio_0 channel B external/status ; interrupt vector
                        	    45: SIO_0_USB_EXT_Vec	EQU     SIO_0_Int_Vec+2	
                        	    46: 		;sio_0 channel B read interrupt vector
                        	    47: SIO_0_USB_Read_Vec	EQU     SIO_0_Int_Vec+4	
                        	    48: 			;sio_0 channel B special receive interrupt vector
                        	    49: SIO_0_USB_Spec_Vec	EQU     SIO_0_Int_Vec+6
                        	    50: 
                        	    51: 
                        	    52: ;Write register 0
                        	    53: WR0 equ 0
                        	    54: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    55: _Ch_Reset		equ 3<<3			; 18
                        	    56: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    57: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    58: _Error_Reset 	equ $30				; (30)	
                        	    59: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    60: 
                        	    61: ;Write register 1
                        	    62: WR1 equ 1
                        	    63: _Ext_INT_EN			equ 1
                        	    64: _Tx_INT_EN 			equ 2
                        	    65: _Status_Vector		equ 4
                        	    66: _Rx_INT_Disable		equ 0
                        	    67: _Rx_INT_First_Char  equ $08
                        	    68: _INT_All_Rx_Char_P 	equ $10 
                        	    69: _Int_All_Rx_Char_NP	equ $18
                        	    70: _WAIT_READY_R_T 	equ $20
                        	    71: _WAIT_READY_FUNC	equ $40
                        	    72: _WAIT_READY_EN		equ $80
                        	    73: 
                        	    74: WR2 equ 2
                        	    75: 
                        	    76: ;Write register 3
                        	    77: WR3 equ 3
                        	    78: _Rx_Enable 			equ $01
                        	    79: _Rx_Disable 		equ $00
                        	    80: _Auto_Enable		equ $20
                        	    81: _RX_5_bits			equ $00
                        	    82: _RX_6_bits			equ $40
                        	    83: _RX_7_bits			equ $80
                        	    84: _RX_8_bits			equ $C0
                        	    85: 
                        	    86: ;Write register 4
                        	    87: WR4 equ 4
                        	    88: _Parity_EN			equ $01
                        	    89: _Parity_Even		equ $02
                        	    90: _Stop_1_bit			equ $04
                        	    91: _Stop_1_2_bit		equ $08
                        	    92: _Stop_2_bit			equ $0C
                        	    93: _X1_Clock_mode		equ $00
                        	    94: _X16_Clock_mode		equ $40
                        	    95: _X32_Clock_mode		equ $80
                        	    96: _X64_Clock_mode		equ $C0
                        	    97: 
                        	    98: ;Write register 5
                        	    99: WR5 equ 5
                        	   100: _RTS_Enable			equ $02
                        	   101: _Tx_Enable 			equ $08
                        	   102: _Send_Break			equ $10
                        	   103: _Tx_5bits_char		equ $00
                        	   104: _Tx_7bits_char		equ $20
                        	   105: _Tx_6bits_char		equ $40
                        	   106: _Tx_8bits_char		equ $60
                        	   107: _DTR_Enable 		equ $80
                        	   108: 
                        	   109: EOT_FOUND			equ $02
                        	   110: _err01_				equ	$08
                        	   111: _err02_				equ	$09
                        	   112: _err03_				equ	$0C
                        	   113: _err04_				equ	$0D
                        	   114: _err05_				equ	$0E
                        	   115: CTCpulse			equ $0A
                        	   116: CTCtimeout			equ $0B
                        	   117: 
                        	   118: 
                        	   119: ; CTC stuff
                        	   120: CH0		equ 	_Z80CTC_Base	
                        	   121: CH1		equ 	_Z80CTC_Base+1	
                        	   122: CH2		equ 	_Z80CTC_Base+2	
                        	   123: CH3		equ 	_Z80CTC_Base+3	
                        	   124: 
                        	   125: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   126: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   127: _Timer 		equ 	$00
                        	   128: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   129: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   130: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   131: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   132: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   133: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   134: 
                        	   135: ; Interrupt vectors for CTC
                        	   136: CTC_CH0_I_Vector	EQU     SIO_0_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   137: CTC_CH1_I_Vector	EQU     SIO_0_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   138: CTC_CH2_I_Vector	EQU     SIO_0_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   139: CTC_CH3_I_Vector	EQU     SIO_0_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   140: 
                        	   141: ; Data tables  (upper EPROM/FLASH)
                        	   142: ; Interupt_vector		= SIO_0_Int_Vec
                        	   143: ; stack  				= $FF00
                        	   144: Heap				= $F000				; space for variable storage
                        	   145: 
                        	   146: ; variables  	(upper ram)
                        	   147: PIO_B_value:		= $F1D0
                        	   148: Result_NumToHex:	= $F1F0
                        	   149: 
                        	   150: 
                        	   151: ; _RAMSTART		= $8010	
                        	   152: ; _EETESTPROG		= $100	
                        	   153: 	
                        	   154: ; _Z80PIO_Base	= $0
                        	   155: ; _Z80CTC_Base	= $10
                        	   156: ; _Z80SIO_0_Base	= $20
                        	   157: ; _Z80_BankCS  	= 0x30;		/*	 30 - 3F   */
                        	   158: ; _8Bitsout 		= $40;		/*	 40 - 4F  */
                        	   159: ; _CE_RST_BANK 	= 0x80;		/*	 40 - 4F  */
                        	   160: 
                        	   161: ;*****	ALIGN command  : 00 removes all align commands
                        	   162: DOALIGN 	EQU 	00
                        	   163: 
                        	   164: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   165: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   166: CRChar:			EQU		0DH				; carrige return
                        	   167: LFChar:			EQU		0AH				; line feed
                        	   168: NUL			EQU		00
                        	   169: SOH			EQU		01
                        	   170: STX			EQU		02
                        	   171: ETX			EQU		03
                        	   172: EOT			EQU		04
                        	   173: ENQ			EQU		05
                        	   174: ACK			EQU		06
                        	   175: BEL			EQU		07
                        	   176: BS			EQU		08h
                        	   177: HT			EQU		09h
                        	   178: LF			EQU		0AH
                        	   179: VT			EQU		0BH
                        	   180: FF			EQU		0CH
                        	   181: CR			EQU		0DH
                        	   182: SO			EQU		0Eh
                        	   183: SI			EQU		0Fh
                        	   184: DLE			EQU		10h
                        	   185: DC1			EQU		11h
                        	   186: DC2			EQU		12h
                        	   187: DC3			EQU		13h
                        	   188: DC4			EQU		14h
                        	   189: NAK			EQU		15h
                        	   190: SYN			EQU		16h
                        	   191: ETB			EQU		17h
                        	   192: CAN			EQU		18h
                        	   193: EM			EQU		19h
                        	   194: SUB			EQU		1Ah
                        	   195: ESC			EQU		1Bh
                        	   196: FS			EQU		1Ch
                        	   197: GS			EQU		1Dh
                        	   198: RS			EQU		1Eh
                        	   199: US			EQU		1Fh
                        	   200: ITEM		EQU		1Ch
                        	   201: STEND		EQU		1Dh
                        	   202: LISTEND		EQU		1Eh
                        	   203: SP			EQU		20h
                        	   204: 
                        	   205: 
                        	   206: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   207: ;DATA LOCATIONS
                        	   208: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   209: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   210: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   211: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   212: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   213: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   214: 
                        	   215: ;BUFFER CONFIGURATION
                        	   216: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   217: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   218: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   219: 
                        	   220: ;BUFFER SIZES, change to suit
                        	   221: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   222: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   223: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   224: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   225: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   226: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   227: 
                        	   228: 
                        	   229: ;INTERRUPT VECTOR TABLE SETUP
                        	   230: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   231: ;There are 4 reasons the interrupt will occur:
                        	   232: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   233: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   234: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   235: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   236: ;
                        	   237: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   238: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   239: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   240: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   241: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   242: ;
                        	   243: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   244: ; -------   --  --  --  ----  --------------
                        	   245: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   246: ;    B       0   0   1   02H  External/Status Change
                        	   247: ;    B       0   1   0   04H  Receive Character Available
                        	   248: ;    B       0   1   1   06H  Special Receive Condition
                        	   249: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   250: ;    A       1   0   1   0AH  External/Status Change
                        	   251: ;    A       1   1   0   0CH  Receive Character Available
                        	   252: ;    A       1   1   1   0EH  Special Receive Condition
                        	   253: ;
                        	   254: ; SIO_0_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   255: ; SIO_0_WriteVector:		EQU		SIO_0_IntVectors+08H ;Write Interrupt Vector
                        	   256: ; SIO_0_ExternalVector:	EQU		SIO_0_IntVectors+0AH ;External Status Interrupt Vector
                        	   257: ; SIO_0_ReadVector:		EQU		SIO_0_IntVectors+0CH ;Read Interrupt Vector
                        	   258: ; SIO_0_SpecialVector:		EQU		SIO_0_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   259: 
                        	   260: 
                        	   261: 	; SIO_0_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   262: 	; SIO_0_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   263: 	; SIO_0_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   264: 	; SIO_0_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   265: 
                        	   266: ;****************************************************************************
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	   271: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	   272: gpioB:			equ		portB_Data
                        	   273: 
                        	   274: 
                        	   275: ; Define the memory size to be used for the CP/M configuration
                        	   276: ; MEM:    equ 60
                        	   277: 
                        	   278: ; The CPM origin will be at: (MEM-7)*1024
                        	   279: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   280: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   281: 
                        	   282: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   283: 
                        	   284: stacktop: equ	0xFFF0	
                        	   285: 
                        	   286: 

Source: "temp.tmp"
                        	     3: 	
                        	     4: 	ifndef ONESECTION
                        	     5: 		section	Functions	
                        	     6: 
                        	     7: 	else
                        	     8: 		section singleAssembly
                        	     9: 	endif
                        	    10: 
                        	    11: 
                        	    12: 		
                        	    13: 		GLOBAL 	BN2BCD,BCD2BN, BN2HEX,Bin2Hex8,Bin2Hex16,HEX2BN,BN2DEC,DEC2BN,LC2UC
                        	    14: 		GLOBAL	DumpRegisters,MFILL,BLKMOV,putDEtoScreen,putDEtoScreenDEC,AddToT_Buf
                        	    15: 
                        	    16: 
                        	    17: 		; Code Conversion
                        	    18: 		; 4A      Binary to BCD Conversion       167
                        	    19: 		; 4B      BCD to Binary Conversion       170
                        	    20: 		; 4C      Binary to Hexadecimal ASCII Conversion                 172
                        	    21: 		; 4D      Hexadecimal ASCII to Binary Conversion                 175
                        	    22: 		; 4E      Conversion of a Binary Number to Decimal ASCII               178
                        	    23: 		; 4F      Conversion of ASCII Decimal to Binary             183
                        	    24: 		; 4G      Lower-Case to Upper-Case Translation             187
                        	    25: 		; 4H      ASCII to EBCDIC Conversion           189
                        	    26: 		; 41      EBCDIC to ASCII Conversion           192
                        	    27: 
                        	    28: 
                        	    29: 	;
                        	    30: 		
                        	    31: 		; Binary t0 BCD C0nversi0n (BN2BCD)                                                                                4A
                        	    32: 		; C0nverts 0ne byte 0f binary data t0 tw0 bytes
                        	    33: 		; 0f BCD data.                                                    Registers Used: AF, C, HL
                        	    34: 		; Pr0cedure: The pr0gram subtracts 100 repeat-                 Executi0n Time: 497 cycles maximum; depends 0n
                        	    35: 		; 																the number 0f subtracti0ns required t0 determine the
                        	    36: 		; edly fr0m the 0riginal data t0 determine the                    tens and hundreds digits
                        	    37: 		; hundreds digit, then subtracts 10 repeatedly                    Pr0gram Size: 27 bytes
                        	    38: 		; fr0m the remainder t0 determine the tens digit,                 Data Mem0ry Required: N0ne
                        	    39: 		; and finally shifts the tens digit left f0ur p0siti0ns
                        	    40: 		; and c0mbines it with the 0nes digit.
                        	    41: 
                        	    42: 		; Entry C0nditi0ns                                           Exit C0nditi0ns
                        	    43: 		; Binary data in A                                           Hundreds digit in H
                        	    44: 		; 														Tens and 0nes digits in L
                        	    45: 		; Examples
                        	    46: 		; 1.    Data:      (A) = 6E I6 (110 decimal)                 2.    Data:      (A) = B7 16 (183 decimal)
                        	    47: 		; 	Result:     (H) = 01 16 (hundreds digit)                   Result:     (H) = 01 16 (hundreds digit)
                        	    48: 		; 				(L) = 10 16 (tens and 0nes digits)                         (L) = 83 16 (tens and 0nes digits)
                        	    49: 
                        	    50: 		; 			Tit Ie                    Binary t0 BCD c0nversi0n
                        	    51: 		; 			Name:                     BN2BCD
                        	    52: 		; 			Put"p0se:                 C0nvet"t 0ne byte c.f binat"y data t0:. t . . . 0
                        	    53: 		; 										bytes c.f BCD dat
                        	    54: 		; 			Entry:                    Register A      binat"y data
                        	    55: 		; 			Exit:                     Register H      High byte 0f BCD data
                        	    56: 		; 										Reg i stet" L   L0 . . . yte 0f BCD data
                        	    57: 		; 			Registet"s used: A F, C, HL                                                                                     
                        	    58: 		; 168      C0DE C0NVERSI0N
                        	    59: 		; /h0me/lellebj/HÃ¤mtningar/Z80_Assembly_Language_Subr0utines_1983.txt
                        	    60: 		;           Time:                 497 cycles maximum
                        	    61: 		;           Size:                 Pr0gram 27 bytes
                        	    62: ;*************************************************************************************************
                        	    63: 
                        	    64: BN2BCD:
                        	    65: 			; CALCULATE   100'S DIGIT - DIVIDE BY 100
                        	    66: 			; H = QU0TI ENT
                        	    67: 			; A = REMAINDER
00:0000 26FF            	    68: 			LD       H,0FFH			;START QU0TIENT AT -1
                        	    69: 		D100LP:
00:0002 24              	    70: 			INC		H				;ADD 1 T0 QU0TIENT
00:0003 D664            	    71: 			SUB		100				;SUBTRACT 100
00:0005 30FB            	    72: 			JR		NC,D100LP		;JUMP IF DIFFERENCE STILL P0SITIVE
00:0007 C664            	    73: 			ADD		A,100			;ADD THE LAST 100 BACK
                        	    74: 
                        	    75: 
                        	    76: 				; CALCULATE 10'S AND 1'S DIGITS
                        	    77: 				; DIVIDE REMAINDER 0F THE 100'S DIGIT BY 10
                        	    78: 				; L = 10'S DIGIT
                        	    79: 				; A 1"S DIGIT
                        	    80: 				
00:0009 2EFF            	    81: 			LD		L,0FFH				;~START QU0TIENT AT -1
                        	    82: 		D10LP:
00:000B 2C              	    83: 			INC		L					;ADD 1 T0 QU0TIENT
00:000C 30FD            	    84: 			JR		NC,D10LP			;JUMP IF DIFFERENCE STILL P0SITIVE
00:000E C60A            	    85: 			ADD		A,10				;ADD THE LAST 10 BACK
                        	    86: 
                        	    87: 				;C0MBINE    1'S AND 10'S DIGITS
00:0010 4F              	    88: 			LD		C,A					;SAVE 1'S DIGIT IN C
00:0011 7D              	    89: 			LD		A,L
00:0012 07              	    90: 			RLCA						;M0VE 10'S T0 HIGH NIBBLE 0F A
00:0013 07              	    91: 			RLCA
00:0014 07              	    92: 			RLCA
00:0015 07              	    93: 			RLCA
00:0016 B1              	    94: 			OR		C                  ;0R IN THE 1'S DIGIT
                        	    95: 				;RETURN    WITH L   = L0W   BYTE, H   = HIGH   BYTE
00:0017 6F              	    96: 			LD		L,A
00:0018 C9              	    97: 			RET
                        	    98: 
                        	    99: 				; SAMPLE EXECUTI0N:
                        	   100: 
                        	   101: 		; SC4A:
                        	   102: 		; 		; C0NVERT    0A HEXADECIMAL T0 10 BCD
                        	   103: 		; 	LD		A,0AH
                        	   104: 		; 	CALL	BN2BCD          ;H = 0, L           10H
                        	   105: 		; 		; C0NVERT       FF HEXADECIMAL T0 255 BCD
                        	   106: 		; 	LD     A,0FFH
                        	   107: 		; 	CALL   BN2BCD           ;H = 02H, L       55H
                        	   108: 
                        	   109: 		; ;C0NVERT 0 HEXADECIMAL T0 0 BCD
                        	   110: 		; 	LD      A,0
                        	   111: 		; 	CALL    BN2BCD          ;H = 0, L     0
                        	   112: 
                        	   113: 		; 	JR    SC4A
                        	   114: ;*************************************************************************************************
                        	   115: 
                        	   116: 				; BCD t0 Binary C0nversi0n (BCD2BN)											4B
                        	   117: 				; Entry C0nditi0ns                                       Exit C0nditi0ns
                        	   118: 				; BCD data in A                                          Binary data in A
                        	   119: 
                        	   120: 				; Examples
                        	   121: 				; I.    Data:     (A) = 99 16                            2.    Data:    (A) = 23 16
                        	   122: 				;      Result:    (A) = 63 16 = 9910                          Result:   (A) = 17 16 = 23 10
                        	   123: 
                        	   124: 				;                Title                 BCD t0 binary c0nversi0n
                        	   125: 				;                Name:                 BCD2BN
                        	   126: 				;                Purp0se:              C0nvert 0ne byte 0f BCD data t0 0ne
                        	   127: 				;                                      byte 0f binary da
                        	   128: 				;                Entry:                Register A       BCD data
                        	   129: 				;                Exit:                 Register A = Binary data
                        	   130: 				;                Registers used: A,B,C,F
                        	   131: 				;                Time:                 60 cycles
                        	   132: 
                        	   133: 
                        	   134: 				;                                      4B BCD T0 BINARY C0NVERSI0N (BCD2BN)   171
                        	   135: 				;           Size:           Pr0gram 14 bytes
                        	   136: ;*************************************************************************************************
                        	   137: 
                        	   138: 
                        	   139: 
                        	   140: BCD2BN:
                        	   141:           ;MULTIPLY UPPER NIBBLE BY 10 AND SAVE IT
                        	   142:           ; UPPER NIBBLE * 10 = UPPER NIBBLE * (8 + 2)
00:0019 47              	   143:           LD		B,A				; SAVE 0RIGINAL BCD VALUE IN B
00:001A E6F0            	   144:           AND		0F0H			;MASK 0FF UPPER NIBBLE
00:001C 0F              	   145:           RRCA						;SHIFT RIGHT 1 BIT
00:001D 4F              	   146:           LD		C,A             ;C = UPPER NIBBLE * 8
00:001E 0F              	   147:           RRCA						; SHIFT RIGHT 2 M0RE TiMES
00:001F 0F              	   148: 		RRCA						;A = UPPER NIBBLE * 2
00:0020 81              	   149:           ADD		A,C
00:0021 4F              	   150:           LD		C,A				;C = UF'PER NIBBLE * (8+2)
                        	   151:           ;GET L0WER NIBBLE AND ADD IT T0 THE
                        	   152:           ; BINARY EQUIVALENT 0F THE UPPER NIBBLE
00:0022 78              	   153:           LD		A,B				; GET 0RIGINAL VALUE BACK
00:0023 E60F            	   154:           AND		0FH				; MASK 0FF UPPER NIBBLE
00:0025 81              	   155:           ADD		A,C				; ADD T0( BINARY UPPER NIBBLE
00:0026 C9              	   156:           RET
                        	   157: 
                        	   158:         ;   SAMPLE EXECUTI0N:
                        	   159: SC4B:
                        	   160:         ;   ;C0NVERT 0 BCD T0 0 HEXADECIMAL
                        	   161:         ;   LD		A,0
                        	   162:         ;   CALL		BCD2BN          ; A = 0H
                        	   163:         ;   ;C0NVERT 99 BCD T0 63 HEXADECIMAL
                        	   164:         ;   LD		A,099H
                        	   165:         ;   CALL		BCD2BN          ;A=63H
                        	   166:         ;   ;C0NVERT 23 BCD T0 17 HEXADECIMAL
                        	   167:         ;   LD		A,23H
                        	   168:         ;   CALL		BCD2BN          ;A=17H
                        	   169:         ;   JR		SC4B
                        	   170: 
                        	   171: ;*************************************************************************************************
                        	   172: 
                        	   173: 					; Binary t0 Hexadecimal ASCII  1 or 2 bytes
                        	   174: 					; C0nversi0n (BN2HEX8, BN2HEX16)												4C
                        	   175: 					;    C0nverts 0ne byte 0f binary data t0 tw0
                        	   176: 					;                                                               Registers Used: AF, B, HL
                        	   177: 					;            Size:             Pr0gram 28 bytes
                        	   178: ;*************************************************************************************************
                        	   179: 
                        	   180: 			;  input in DE, output 4 chars to textbuf (HL), output:  HL-> end of string '0'
                        	   181: Bin2Hex16:
                        	   182: 			;**************************************
                        	   183: 			;  input in DE
                        	   184: 			;  output 4 chars to textbuf (HL),
                        	   185: 			;	output:  HL-> end of string '0'
                        	   186: 			;**********************************
00:0027 D5              	   187: 			push 	DE
00:0028 CD3600          	   188: 			call	cnv_byte
00:002B 1801            	   189: 			jr      entr8
                        	   190: Bin2Hex8:
                        	   191: 			;**************************************
                        	   192: 			;  input in E
                        	   193: 			;  output 2 chars to textbuf (HL)
                        	   194: 			;	output:  HL-> end of string '0'
                        	   195: 			;**********************************
00:002D D5              	   196: 			push  	DE
00:002E 53              	   197: entr8:		ld		D,E					; move low byte to d
00:002F CD3600          	   198: 			call	cnv_byte
00:0032 AF              	   199: 			xor 	A			; reset a
00:0033 77              	   200: 			ld 		(hl),A		; put 0 to end of chars, (hl)-> end of chars
00:0034 D1              	   201: 			pop 	DE
00:0035 C9              	   202: 			ret
                        	   203: 
                        	   204: 
00:0036 7A              	   205: cnv_byte:	ld 		A,D
00:0037 1F              	   206: 			rra								;move high nibble to low nibble
00:0038 1F              	   207: 			rra
00:0039 1F              	   208: 			rra							
00:003A 1F              	   209: 			rra
00:003B E60F            	   210: 			and		0FH						;get high nibble
00:003D CD4700          	   211:          	call	AddToT_Buf				;convert high nibble to ascii
00:0040 7A              	   212: 			ld 		A,D
00:0041 E60F            	   213: 			and		0FH						;get low nibble
00:0043 CD4700          	   214:          	call	AddToT_Buf				;convert low nibble to ascii
00:0046 C9              	   215: 			ret
                        	   216: 
                        	   217:            ;-----------------------------------
                        	   218:            ; subr0uti addtot_buf
                        	   219:            ; purp0se:    c0nvert a hexadecimal digit t0 asci i
                        	   220:            ; entry: a = binary data in l0wer nibble
                        	   221:            ;exit: a = ascii character
                        	   222:            ;registers used: a,f
                        	   223:            ;-----------------------------------
                        	   224:            
                        	   225: AddToT_Buf:
00:0047 FE0A            	   226: 			cp		10
00:0049 3802            	   227: 			jr		C,.AT1				; jump if high nibble < 10
00:004B C607            	   228: 			add		A,7					; else add 7 s0 after add i ng .' 0" the
                        	   229: 										; character will be in 'a' .. 'f'
                        	   230: .AT1:
00:004D C630            	   231: 			add		A,'0'				; add ascii 0 t0 make a character
00:004F 77              	   232: 			ld		(hl),A				; add the char to text buffer
00:0050 23              	   233: 			inc 	hl
00:0051 C9              	   234: 			ret
                        	   235: 
                        	   236: 
                        	   237:         ;    SAMPLE EXECUTI0N:
                        	   238: 
                        	   239: 
                        	   240:         ;    ; C0NVERT 0 T0 '0'
                        	   241: 		; 	LD		DE,1234
                        	   242: 		; 	ld		hl,T_Buffer
                        	   243: 		; 	CALL	Bin2Hex16/ Bin2Hex8  
                        	   244: 		; 		; result in (T_buffer)
                        	   245: 
                        	   246: ;*************************************************************************************************
                        	   247: 
                        	   248: 				; Hexadecimal ASCII t0 Binary
                        	   249: 				; C0nversi0n (HEX2BN)                                                                                          4D
                        	   250: 
                        	   251: 				; C0nverts tw0 ASCII characters (represent-
                        	   252: 				; ing two hexadecimal digits) t0 one byte 0f                   Registers Used: AF, B
                        	   253: 				; binary data.                                                 Executi0n Time: 148 cycles plus tw0 extra cycles f0r
                        	   254: 				; 															each n0n-decimal digit
                        	   255: 				; Pr0cedure: The program c0nverts each ASCII
                        	   256: 				; 															Pr0gram Size: 24 bytes
                        	   257: 				; character separately t0 a hexadecimal digit. This            Data Mem0ry Required: N0ne
                        	   258: 				; inv0lves a simple subtracti0n 0f 3016 (ASCII 0)
                        	   259: 				; if the digit is decimal. If the digit is n0n-decimal,
                        	   260: 				; an0ther 7 must be subtracted t0 acc0unt f0r the         less significant digit. The pr0gram d0es n0t
                        	   261: 				; break between ASCII 9 (3916) and ASCII A                check the validity 0f the ASCII characters (that
                        	   262: 				; (4116). The pr0gram then shifts the m0re signif-        is, whether they are indeed the ASCII represen-
                        	   263: 				; icant digit left f0ur bits and c0mbines it with the     tati0ns 0f hexadecimal digits).
                        	   264: 				; Entry C0nditi0ns                                        Exit C0nditi0ns
                        	   265: 				; M0re significant ASCII digit in H, less signifi-        Binary data in A
                        	   266: 				; cant ASCII digit in L
                        	   267: 				; Examples
                        	   268: 				; 1.    Data:      (H) = 44 16 (ASCII D)                  2.    Data:     (H) = 31 16 (ASCII 1)
                        	   269: 				; 				(L) = 37 16 (ASCII 7)                                  (L) = 42 16 (ASCII B)
                        	   270: 				; 	Result:     (A) = D7 16                                 Result:     (A) = IB 16
                        	   271: 				; Title                    Hex ASCII t0 binary
                        	   272: 				; Name:                     HEX2BN
                        	   273: 
                        	   274: 				; Purp0se:                  C0nvert tw0 ASCII characters t0 0ne
                        	   275: 				; 							byte 0f binary data
                        	   276: 				; Entry:                    Register H = ASCII m0re significant digit																											175
                        	   277: 				; 176      C0DE C0NVERSI0N
                        	   278:                 ;              Register L   = ASCII   less significant digit
                        	   279: 				; Exit:              Register A = Binary data
                        	   280: 				; Register"s used: AF, B
                        	   281: 				; Time:              Appr0ximately 148 cycles
                        	   282: 				; Size:              Pr0gram 24 bytes
                        	   283: ;*************************************************************************************************
                        	   284: 
                        	   285: 
                        	   286: HEX2BN:
00:0052 7D              	   287: 			LD		A,L					;get l0w character
00:0053 CD6100          	   288: 			CALL	A2HEX				;c0nvert it t0 hexadecimal
00:0056 47              	   289: 			LD		B,A					;save hex value in b
00:0057 7C              	   290: 			LD		A,H					;get high character
00:0058 CD6100          	   291: 			CALL	A2HEX				; c0nvert it t0 hexadecimal
00:005B 0F              	   292: 			RRCA						;shift hex value t0 upper 4 bits
00:005C 0F              	   293: 			RRCA
00:005D 0F              	   294: 			RRCA
00:005E 0F              	   295: 			RRCA
00:005F B0              	   296: 			OR      B					;or in low hex value
00:0060 C9              	   297: 			RET
                        	   298: 
                        	   299: 			;---------------------------------------
                        	   300: 			; subr0utine: a2hex
                        	   301: 			; purp0se: c0nvert ascii digit t0 a hex digit
                        	   302: 			; entry: a = ascii hexadecimal digit
                        	   303: 			;exit: a = binary value 0f ascii digit
                        	   304: 			;registers used: a,f
                        	   305: 			;--------------------------------------
                        	   306: A2HEX:
00:0061 D630            	   307: 			SUB		'0'					;subtract ascii 0ffset
00:0063 FE0A            	   308: 			CP		10
00:0065 3802            	   309: 			JR		C,A2HEX1			;branch if a is a decimal digit
00:0067 D607            	   310: 			SUB		7					;else subtract 0ffset f0r letters
                        	   311: A2HEX1:
00:0069 C9              	   312: 			RET
                        	   313: 
                        	   314: 			;    SAMPLE EXECUTI0N:
                        	   315: 
                        	   316: SC4D:
                        	   317: 			; ; C0NVERT "C7" T0 C7 HEXADECIMAL
                        	   318: 			; LD		H,'C'
                        	   319: 			; LD		L,'7'
                        	   320: 			; CALL	HEX2BN				;A=C7H
                        	   321: 			; ; C0NVERT "2F' T0 2F HEXADECIMAL
                        	   322: 			; LD		H,'2'
                        	   323: 			; LD		L,'F'
                        	   324: 
                        	   325: 			; CALL	HEX2BN				;A=2FH
                        	   326: 			; ;C0NVERT ~2A~ T0 2A HEXADECIMAL
                        	   327: 			; LD		H,'2'
                        	   328: 			; LD		L,'A'
                        	   329: 			; CALL	HEX2BN				;A=2AH
                        	   330: 			; JR		SC4D
                        	   331: 
                        	   332: 
                        	   333: ;*************************************************************************************************
                        	   334: 				; C0nversi0n 0f a Binary Number t0
                        	   335: 				; Decimal ASCII (BN2DEC)                                                                                      4E
                        	   336: 
                        	   337: 				; C0nverts a 16-bit signed binary number int0					Registers Used: AF, BC, DE, HL
                        	   338: 				; an ASCII string. The string c0nsists 0f the               Executi0n Time: Appr0ximately 7200 cycles
                        	   339: 				; length 0f the number in bytes, an ASCII minus             Pr0gram Size: 107 bytes
                        	   340: 				; sign (if needed), and the ASCII digits. N0te that         Data Mem0ry Required: F0ur bytes anywhere in
                        	   341: 				; the length is a binary number, n0t an ASCII               mem0ry f0r the buffer p0inter (tw0 bytes starting at
                        	   342: 				; number.                                                   address BUFPTR), thelength 0fthe buffer (0ne byte
                        	   343: 				; 														at address CURLEN), and the sign 0f the 0riginal
                        	   344: 				; Pr0cedure: The pr0gram takes the abs0lute              value (0ne byte at address NGFLAG). This data
                        	   345: 				; value 0f the number if it is negative. The pr0gram        mem0ry d0es n0t include the 0utput buffer which
                        	   346: 				; then keeps dividing the abs0lute value by 10              sh0uld be seven bytes l0ng.
                        	   347: 				; until the qu0tient bec0mes 0. It c0nverts each
                        	   348: 				; digit 0f the qu0tient t0 ASCII by adding ASCII 0     minus sign (in fr0nt) if the 0riginal number was
                        	   349: 				; and c0ncatenates the digits al0ng with an ASCII      negative.
                        	   350: 
                        	   351: 				; Entry C0nditi0ns                                     Exit C0nditi0ns
                        	   352: 				; Base address 0f 0utput buffer in HL                  0rder in buffer:
                        	   353: 				; Value t0 c0nvert in DE                                    Length 0f the string in bytes (a binary number)
                        	   354: 				; 														ASCII - (if 0riginal number was negative)
                        	   355: 				; 														ASCII digits (m0st significant digit first
                        	   356: 				; Examples
                        	   357: 				; I.   Data:     Value t0 c0nvert = 3EB7'6             2.     Data:    Value t0 c0nvert = FFC8'6
                        	   358: 				; 	Result (in 0utput buffer):                            Result (in 0utput buffer):
                        	   359: 				; 			05 (number 0f bytes in buffer)                         03 (number 0f bytes in buffer)
                        	   360: 				; 			31 (ASCII I)                                           2D (ASCII-)
                        	   361: 				; 			36 (ASCII 6)                                           35 (ASCII 5)
                        	   362: 				; 			30 (ASCII 0)                                           36 (ASCII 6)
                        	   363: 				; 			35 (ASCII 5)                                           That is, FFC8'6 = -56 10, when c0nsidered as a
                        	   364: 				; 			35 (ASCII 5)                                             signed tw0's c0mplement number
                        	   365: 				; 			That is, 3EB7'6 = 16055 10
                        	   366: 
                        	   367: 				; 		Title              Binary t0 decimal ASCII
                        	   368: 				; 		Name:              BN2DEC
                        	   369: 				; 		Purp0se:           C0nvert a 16-bit signed binary number
                        	   370: 				; 							t0 ASCI I data
                        	   371: 				; 		Entry:             Register   H = High byte 0f 0utput buffer address
                        	   372: 				; 							Register   L   L0w byte 0f 0utput buffer address
                        	   373: 				; 							Register   D = High byte 0f value t0 c0nvert
                        	   374: 				; 							Register   E = L0w byte 0f value t0 c0nvert
                        	   375: 				; 		Exit:              The first byte 0f the buffer is the length,
                        	   376: 				; 							f0ll0wed by the characters.
                        	   377: 				; 		Regi sters used:. AF, BC, DE, HL
                        	   378: 				; 		Time:              Appr0ximately 7,200 cycles
                        	   379: 				; 		Size:              Pr0gram 107 bytes
                        	   380: 				; 							Data      4 bytes
                        	   381: ;*************************************************************************************************
                        	   382: 
                        	   383: 
                        	   384: BN2DEC:
                        	   385: 			; SAVE PARAMETERS
00:006A 22D500          	   386: 			LD		(BUFPTR),HL			;ST0RE THE BUFFER P0INTER
00:006D EB              	   387: 			EX		DE,HL
00:006E 3E00            	   388: 			LD		A,0
00:0070 32D700          	   389: 			LD		(CURLEN),A			;CURRENT BUFFER LENGTH IS 0
00:0073 7C              	   390: 			LD		A,H
00:0074 32D800          	   391: 			LD		(NGFLAG),A			;SAVE SIGN 0F VALUE
00:0077 B7              	   392: 			OR		A					;SET FLAGS FR0M VALUE
00:0078 F28200          	   393: 			JP		P,CNVERT_4E			;JUMP IF VALUE IS P0SITIVE
00:007B EB              	   394: 			EX		DE,HL				;ELSE TAKE ABS0LUTE VALUE (0 - VALUE)
00:007C 210000          	   395: 			LD		HL,0
00:007F B7              	   396: 			OR		A					;CLEAR CARRY
00:0080 ED52            	   397: 			SBC		HL,DE				;SUBTRACT VALUE FR0M 0
                        	   398:           ;C0NVERT VALUE T0 A STRING
                        	   399: CNVERT_4E:
                        	   400: 			;HL := HL DIV 10     (DIVIDEND, QU0TIENT)
                        	   401: 			;DE := HL M0D 10     (REMAINDER)
00:0082 1E00            	   402: 			LD		E,0					;REMAINDER = 0
00:0084 0610            	   403: 			LD		B,16				;16 BITS IN DIVIDEND
00:0086 B7              	   404: 			OR		A					;CLEAR CARRY T0 START
                        	   405: DVL00P:
                        	   406: 			;SHIFT THE NEXT BIT 0F THE QU0TIENT INT0 BIT 0 0F THE DIVIDEND
                        	   407: 			; SHIFT NEXT M0ST SIGNIFICANT BIT 0F DIVIDEr.D INT0
                        	   408: 			;LEAST SIGNIFICANT BIT 0F REMAINDER
                        	   409: 			;HL    H0LDS B0TH DIVIDEND AND QU0TIENT. QU0TIENT IS SHIFTED
                        	   410: 			;     IN AS THE DIVIDEND IS SHIFTED 0UT.
                        	   411: 			;E    IS THE REMAINDER.
                        	   412: 			;D0 A 24-BIT SHIFT LEFT, SHIFTING
                        	   413: 			; CARRY T0 L, L T0 H, H T0 E
00:0087 CB15            	   414: 			RL		L					; CARRY (NEXT BIT 0F QU0TIENT) T0 BIT 0
00:0089 CB14            	   415: 			RL		H					; SHIFT HIGH BYTE
00:008B CB13            	   416: 			RL		E					;SHIFT NEXT BIT 0F DIVIDEND
                        	   417: 			;IF REMAINDER IS 10 0R M0RE, NEXT BIT 0F 
                        	   418: 			;QU0TIENT IS 1 (THIS BIT IS PLACED IN CARRY)
00:008D 7B              	   419: 			LD		A,E
00:008E D60A            	   420: 			SUB		10					;SUBTRACT 10 FR0M REMAINDER
00:0090 3F              	   421: 			CCF							;C0MPLEMENT CARRY
                        	   422: 										; (THIS IS NEXT BIT 0F QU0TIENT)
00:0091 3001            	   423: 			JR		NC,DECCNT			; JUMP IF REMAINDER IS LESS THAN 10
00:0093 5F              	   424: 			LD		E,A					;0THERWISE REMAINDER = DIFFERENCE
                        	   425: 										; BETWEEN PREVI0US REMAINDER AND 10
                        	   426: DECCNT:
00:0094 10F1            	   427: 			DJNZ	DVL00P				; C0NTINUE UNTIL ALL BITS ARE D0NE
                        	   428: 			;SHIFT LAST CARRY INT0 QU0TIENT
00:0096 CB15            	   429: 			RL		L					;LAST BIT 0F QU0TIENT T0 BIT 0
00:0098 CB14            	   430: 			RL		H
                        	   431: 			;INSERT     THE NEXT CHARACTER IN ASCI I
                        	   432: CHINS:
00:009A 7B              	   433: 			LD		A,E
00:009B C630            	   434: 			ADD		A,'0'				;~C0NVERT   0 â¢â¢â¢ 9 T0 ASCII '0' â¢â¢â¢ '9'
00:009D CDB100          	   435: 			CALL	INSERT
                        	   436: 			;IF     QU0TIENT IS N0T 0 THEN KEEP DIVIDING
00:00A0 7C              	   437: 			LD		A,H
00:00A1 B5              	   438: 			OR		L
00:00A2 20DE            	   439: 			JR		NZ,CNVERT_4E
                        	   440: EXIT:
00:00A4 3AD800          	   441: 			LD		A,(NGFLAG)
00:00A7 B7              	   442: 			OR		A
00:00A8 F2B000          	   443: 			JP		P,P0S				;BRANCH I F 0R ICi I NAL VALUE WAS P0S I TI VE
00:00AB 3E2D            	   444: 			LD		A,'-'			;ELSE
00:00AD CDB100          	   445: 			CALL	INSERT				; PUT A MINUS SIGN IN FR0NT
                        	   446: P0S:
00:00B0 C9              	   447: 			RET							;RETURN
                        	   448: 			;----------------------------------
                        	   449: 			; SUBR0UTINE: INSERT
                        	   450: 			; PURP0SE: INSERT THE CHARACTER IN REGISTER A AT THE
                        	   451: 			;			FR0NT 0F THE BUFFER
                        	   452: 			; ENTRY: CURLEN = LENGTH 0F BUFFER
                        	   453: 			;		BUFPTR = CURRENT ADDRESS 0F LAST CHARACTER IN BUFFER
                        	   454: 			;EXIT: REGISTER A INSERTED IMMEDIATELY AFTER LENGTH BYTE
                        	   455: 			;REGISTERS USED: AF,B,C,D,E
                        	   456: 			;----------------------------------
                        	   457: INSERT:
00:00B1 E5              	   458: 			PUSH	HL					;SAVE HL
00:00B2 F5              	   459: 			PUSH	AF					;SAVE CHARACTER T0 INSERT
                        	   460: 			;M0VE ENTIRE BUFFER UP 1 BYTE IN MEM0RY
00:00B3 2AD500          	   461: 			LD		HL, (BUFPTR)		;GET BUFFER P0INTER
00:00B6 54              	   462: 			LD		D,H					;HL = S0URCE (CURRENT END 0F BUFFER)
00:00B7 5D              	   463: 			LD		E,L
00:00B8 13              	   464: 			INC		DE					;DE = DESTINATI0N (CURRENT END + 1)
00:00B9 ED53D500        	   465: 			LD		(BUFPTR),DE			;ST0RE NEW BUFFER P0INTER
00:00BD 3AD700          	   466: 			LD		A, (CURLEN)
00:00C0 B7              	   467: 			OR		A					;TEST F0R CURLEN = 0
00:00C1 2805            	   468: 			JR		Z,EXITMR			;.JUMP IF ZER0 (N0THING T0 M0VE,
                        	   469: 										; .JUST ST0RE THE CHARACTER.\
00:00C3 4F              	   470: 			LD		C,A					;BC = L00P C0UNTER
00:00C4 0600            	   471: 			LD		B,0
00:00C6 EDB8            	   472: 			LDDR						;M0VE ENTIRE BUFFER UP 1 BYTE
                        	   473: EXITMR:
00:00C8 3AD700          	   474: 			LD		A, (CURLEN)			; INCREMENT CURRENT LENGTH BY 1
00:00CB 3C              	   475: 			INC		A
00:00CC 32D700          	   476: 			LD		(CURLEN),A
00:00CF 77              	   477: 			LD		(HL),A				;UPDATE LENGTH BYTE 0F BUFFER
00:00D0 EB              	   478: 			EX		DE,HL				;HL P0INTS T0 FIRST CHARACTER IN BUFFER
00:00D1 F1              	   479: 			POP		AF					;GET CHARACTER T0 INSERT
00:00D2 77              	   480: 			LD		(HL),A				; INSERT CHARACTER AT FR0NT 0F BUFFER
00:00D3 E1              	   481: 			POP		HL					;REST0RE HL
00:00D4 C9              	   482: 			RET
                        	   483: 			; DATA
00:00D5 00              	   484: BUFPTR: DS	2							;ADDRESS 0F LAST CHARACTER IN BUFFER
00:00D6 *
00:00D7 00              	   485: CURLEN: DS	1							;CURRENT LENGTH 0F BUFFER
00:00D8 00              	   486: NGFLAG: DS	1							; SIGN 0F 0R I GI NAL VALUE
                        	   487: 
                        	   488: 
                        	   489: 
                        	   490: 			; SAMPLE EXECUTI0N:
                        	   491: 
                        	   492: 
                        	   493: ; SC4E:
                        	   494: ; 		; C0NVERT 0 T0 .' 0Â·'
                        	   495: ; 		LD		HL,BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	   496: ; 		LD		DE,0				;DE = 0
                        	   497: ; 		CALL	BN2DEC				; C0NVERT
                        	   498: ; 									; BUFFER SH0ULD = .' 0Â·'
                        	   499: ; 		;C0NVERT 32767 T0     ~32767"'
                        	   500: ; 		LD		HL,BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	   501: ; 		LD		DE,32767			;DE = 32767
                        	   502: ; 		CALL	BN2DEC				; C0NVERT
                        	   503: ; 									; BUFFER SH0ULD = "32767"'
                        	   504: ; 		;C0NVERT -32768 T0    ~-32768"
                        	   505: ; 		LD		HL,BUFFER			;HL  = BASE ADDRESS 0F BUFFER
                        	   506: ; 		LD		DE,-32768			; DE = -3271':'8
                        	   507: ; 		CALL	BN2DEC				; C0NVERT
                        	   508: ; 		JR		SC4E				; BUFFER SH0ULD = ~-32768'
                        	   509: 
00:00D9 00              	   510: BUFFER: DS	7						;7-BYTE BUFFER
00:00DA *
                        	   511: 
                        	   512: 
                        	   513: ;*************************************************************************************************
                        	   514: 				; Conversi0n of ASCII Decimal to Binary (DEC2BN)                                                                   
                        	   515: 
                        	   516: 				; C0nverts an ASCII string c0nsisting 0f the
                        	   517: 				; 													Registers Used: AF, BC, DE, HL
                        	   518: 
                        	   519: 				; Entry C0nditi0ns                                      ExIt C0nditi0ns
                        	   520: 				; Base address 0f string in HL                          Binary value in HL
                        	   521: 				; 													Carry flag is 0 if the string was valid; Carry flag
                        	   522: 				; 														is I if the string c0ntained an invalid charac-
                        	   523: 				; 														ter.
                        	   524: 				; 													N0te that the result is a signed tw0's c0mplement
                        	   525: 				; 														16-bit number.
                        	   526: 				; Examples
                        	   527: 				; 1.   Data:    String c0nsists 0f                      Result:   (H) = 04 16 (m0re significant byte 0f binary
                        	   528: 				; 				04 (number 0f bytes in string)                       data)
                        	   529: 				; 				31 (ASCII I)                                     (L) = 02 16 (less significant byte 0f binary
                        	   530: 				; 				32 (ASCII 2)                                         data)
                        	   531: 				; 				33 (ASCII 3)                                           That is, the number +I ,234 10 = 0402 16
                        	   532: 				; 				34 (ASCII 4)
                        	   533: 				; 			That is, the number is +1,234 10
                        	   534: 
                        	   535: 				; 2.   Data:   String c0nsists 0f                         Result:   (H) = 80 16 (m0re significant byte 0f binary
                        	   536: 				; 				06 (number 0f bytes in string)                         data)
                        	   537: 				; 				2D (ASCII-)                                        (L) = 1216 (less significant byte 0f binary
                        	   538: 				; 				33 (ASCII 3)                                           data)
                        	   539: 				; 				32 (ASCII 2)                                             That is, the number - 32, 75010 = 8012 16
                        	   540: 				; 				37 (ASCII 7)
                        	   541: 				; 				35 (ASCII 5)
                        	   542: 				; 				30 (ASCII 0)
                        	   543: 				; 			That is, the number is -32,750 10
                        	   544: 
                        	   545: 				; 		Title                   Decimal AsciI t0 binary
                        	   546: 				; 		Name:                   DEC2BN
                        	   547: 
                        	   548: 				; 		Purp0se:               C0nvert ASCII characters t0 tw0 bytes 0f binary
                        	   549: 				; 								data
                        	   550: 				; 		Entry:                  HL = Base address 0f input buffer
                        	   551: 				; 		Exit:                   HL    Binary value
                        	   552: 				; 								if n0 err0rs then
                        	   553: 				; 									Carry = 0
                        	   554: 				; 								else
                        	   555: 				; 									Carry
                        	   556: 				; 		Registers used: A F. BC. DE. HL
                        	   557: 				; 		Time:                   Appr0ximately 152 cycles per byte plus
                        	   558: 				; 								a maximum 0f 186 cycles 0verhead
                        	   559: 				; 		Size:                   Pr0gram         79 bytes
                        	   560: 				; 								Data             1 byte
                        	   561: ;*************************************************************************************************
                        	   562: 
                        	   563: DEC2BN:
                        	   564: 			;INITIALIZE - SAVE LENGTH. CLEAR SIGN AND VALUE
00:00E0 7E              	   565: 			LD		A,(HL)			;SAVE LENGTH IN B
00:00E1 47              	   566: 			LD		B,A
00:00E2 23              	   567: 			INC		HL				;P0INT T0 BYTE AFTER LENGTH
00:00E3 97              	   568: 			SUB 	A
00:00E4 322F01          	   569: 			LD		(NGFLAG_4F),A		;ASSUME NUMBER IS P0SITIVE
00:00E7 110000          	   570: 			LD		DE,0			;START WITH VALUE = 0
                        	   571: 			;CHECK F0R EMPTY BUFFER
00:00EA B0              	   572: 			OR B					;IS BUFFER LENGTH ZER0?
00:00EB 283F            	   573: 			JR		Z,EREXIT		;YES, EXIT WITH VALUE = 0
                        	   574: 			; CHECK F0R MINUS 0R PLUS SIGN IN FR0NT
                        	   575: INIT1:
00:00ED 7E              	   576: 			LD		A,(HL)				;GET FIRST CHARACTER
00:00EE FE2D            	   577: 			CP		'-'					;IS IT A MINUS SIGN?
00:00F0 2007            	   578: 			JR		NZ,PLUS				; N0, BRANCH
00:00F2 3EFF            	   579: 			LD		A,0FFH
00:00F4 322F01          	   580: 			LD		(NGFLAG_4F),A			;YES, MAKE SIGN 0F NUMBER NEGATIVE
00:00F7 1804            	   581: 			JR		SKIP				;SKIP 0VER MINUS SIGN
                        	   582: PLUS:
00:00F9 FE2B            	   583: 			CP		'+'					;IS FIRST CHARACTER A PLUS SIGN?
00:00FB 2005            	   584: 			JR		NZ,CHKDIG			; N0, START C0NVERSI0N
00:00FD 23              	   585: SKIP:		INC		HL					; S~: I P 0VER THE SIGN BYTE
00:00FE 05              	   586: 			DEC		B					;DECREMENT C0UNT
00:00FF 282B            	   587: 			JR		Z,EREXIT			; ERR0R EXIT IF 0NLY A SIGN IN BUFFER
                        	   588: 			;C0NVERSI0N L00P
                        	   589: 			; C0NTINUE UNTIL THE BUFFER IS EMPTY
                        	   590: 			; 0R A N0N-NUMERIC CHARACTER IS F0UND
                        	   591: CNVERT_4F:
00:0101 7E              	   592: 			LD		A, (Hl)				;GET NEXT CHARACTER
00:0102 D630            	   593: CHKDIG: 	SUB		'0'
00:0104 3826            	   594: 			JR		C,EREXIT			;ERR0R IF < Â·'0' (N0T A DIGIT)
00:0106 FE0A            	   595: 			CP		9+1
00:0108 3022            	   596: 			JR		NC,EREXIT			;ERR0R IF > '9' (N0T A DIGIT)
00:010A 4F              	   597: 			LD		C,A                ; CHARACTER IS DIGIT, SAVE IT
                        	   598: 			;VALID DECIMAL DIGIT S0 VALUE := VALUE * 10  = VALUE * (8 + 2)
                        	   599: 			;      (VALUE * 8) + (VALUE * 2)
00:010B E5              	   600: 			PUSH	HL					; SAVE BUFFER P0 INTER
00:010C EB              	   601: 			EX		DE, HL				; HL = VALUE
00:010D 29              	   602: 			ADD		HL,HL				; * 2
00:010E 5D              	   603: 			LD		E,L					;SAVE TIMES 2 IN DE
00:010F 54              	   604: 			LD		D,H
00:0110 29              	   605: 			ADD		HL,HL				; * 4
00:0111 29              	   606: 			ADD		HL,HL				; * 8
00:0112 19              	   607: 			ADD		HL,DE				;VALUE = VALUE * (8+2)
                        	   608: 			;ADD IN   THE NEXT DIGIT
                        	   609: 			; VALUE   := VALUE + DIGIT
00:0113 59              	   610: 			LD		E,C					;M0VE NEXT DIGIT T0 E
00:0114 1600            	   611: 			LD		D,0					; HIGH BYTE IS 0
00:0116 19              	   612: 			ADD		HL,DE				; ADD DIGIT T0 VALUE
00:0117 EB              	   613: 			EX		DE,HL				;DE = VALUE
00:0118 E1              	   614: 			POP		HL					;P0INT T0 NEXT CHARACTER
00:0119 23              	   615: 			INC		HL
00:011A 10E5            	   616: 			DJNZ	CNVERT_4F				;C0NTINUE C0NVERSI0N
                        	   617: 			;C0NVERSI0N IS C0MPLETE. CHECK SIGN
00:011C EB              	   618: 			EX		DE,HL				;HL = VALUE
00:011D 3A2F01          	   619: 			LD		A,(NGFLAG_4F)
00:0120 B7              	   620: 			OR		A
00:0121 2807            	   621: 			JR		Z,OKEXIT			;..JUMP IF THE VALUE WAS P0SITIVE
00:0123 EB              	   622: 			EX		DE,HL				;ELSE REPLACE VALUE WITH -VALUE
00:0124 210000          	   623: 			LD		HL,0
00:0127 B7              	   624: 			OR		A					;CLEAR CARRY
00:0128 ED52            	   625: 			SBC		HL,DE				;SUBTRACT VALUE FR0M 0
                        	   626: 			;N0 ERR0RS, EXIT WITH CARRY CLEAR
                        	   627: OKEXIT:
00:012A B7              	   628: 			OR		A					;CLEAR CARRY
00:012B C9              	   629: 			RET
                        	   630: 			;AN ERR0R. EXIT WITH CARRY SET
                        	   631: EREXIT:
00:012C EB              	   632: 			EX		DE,HL				;HL = VALUE
00:012D 37              	   633: 			SCF							;SET CARRY T0 INDICATE ERR0R
00:012E C9              	   634: 			RET
                        	   635: 			; DATA
00:012F 00              	   636: NGFLAG_4F: DS	1							;SIGN 0F NUMBER
                        	   637: 
                        	   638: 			; ; SAMPLE EXECUTI0N:
                        	   639: 
                        	   640: 			; ; C0NVERT .' 1234"
                        	   641: 			; LD		HL,S1			;HL    = BASE ADDRESS 0F S1
                        	   642: 			; CALL	DEC2BN
                        	   643: 			; 						;H    = 04,   L   = D2   HEX
                        	   644: 			; ;C0NVERT /+32767~
                        	   645: 			; LD		HL,S2			;HL    = BASE ADDRESS 0F       S2
                        	   646: 			; CALL	DEC2BN
                        	   647: 			; 						;H    = 7F, L = FF HEX
                        	   648: 			; ;C0NVERT ~-32768~
                        	   649: 			; LD		HL,S3			;HL    = BASE ADDRESS 0F S3
                        	   650: 			; CALL	DEC2BN
                        	   651: 			; 						;H    = 80    HEX, L = 00 HEX
                        	   652: 			; S1:       DB	4, "1234"
                        	   653: 			; S2:       DB	6, "+32767"
                        	   654: 			; S3:       DB	6, "-32768"
                        	   655: 
                        	   656: 
                        	   657: ;*************************************************************************************************
                        	   658: 				; L0wer-Case t0 Upper-Case
                        	   659: 				; Translati0n (LC2UC)                                                                                             4
                        	   660: 				; C0nverts an ASCII l0wer-case letter t0 its
                        	   661: 				; upper-case equivalent.                                        Registers Used: AF
                        	   662: 				; Pr0cedure: The pr0gram uses c0mparis0ns t0                 Executi0n Time: 45 cycles if the 0riginal character is
                        	   663: 				; 															a l0wer-case letter, fewer cycles 0therwise
                        	   664: 				; determine whether the data is an ASCII l0wer-
                        	   665: 				; 															Pr0gram Size: 11 bytes
                        	   666: 				; case letter. If it is, the pr0gram subtracts 20,6
                        	   667: 				; 															Data Mem0ry Required: N0ne
                        	   668: 				; fr0m it, thus c0nverting it t0 its upper-case equiv-
                        	   669: 				; alent. If it is n0t, the pr0gram leaves it unchanged.
                        	   670: 				; Entry C0nditi0ns                                         Exit C0nditi0ns
                        	   671: 				; Character in A                                           If an ASCII l0wer-case letter is present in A,
                        	   672: 				; 														then its upper-case equivalent is returned in A.
                        	   673: 				; 														In all 0ther cases, A is unchanged
                        	   674: 				; Examples
                        	   675: 				; I.    Data:      (A) = 62'6 (ASCII b)                    2.    Data:      (A) = 54'6 (ASCII T)
                        	   676: 				; 	Result:     (A) = 42 16 (ASCII B)                        Result:     (A) = 54 16 (ASCII T)
                        	   677: 				; 			Title 					 L0wer-case t0 upper-case translati0n
                        	   678: 				; 			Name:                     LC2UC
                        	   679: 				; 			Purp0se:                 C0nvert 0ne ASCII character t0 upper case fr0m
                        	   680: 				; 										l0wer case if necessary
                        	   681: 				; 			Entry:                    Register A     L0wer-case ASCII character
                        	   682: 				; 			Exit:                     Register A = Upper-case ASCII character if A
                        	   683: 				; 													is l0wer case, else A is unchanged
                        	   684: 				; 			Registers used: A F
                        	   685: 				; 		Time:               45 cycles if A is l0wer case. less 0therwise
                        	   686: 				; 		Size:               Pr0gram 11 bytes
                        	   687: 				; 							Data     n0ne
                        	   688: ;*************************************************************************************************
                        	   689: 
                        	   690: LC2UC:
00:0130 FE61            	   691: 			CP		'a'
00:0132 3806            	   692: 			JR		C,EXIT_4G				; BRANCH IF < "a"       (N0T L0WER CASE)
00:0134 FE7B            	   693: 			CP		'z'+1
00:0136 3002            	   694: 			JR		NC,EXIT_4G				; BRANCH IF :> ~ zÂ·" (N0T L0WER CASE)
00:0138 D620            	   695: 			SUB		'a'-'A'				; CHANGE ... aÂ·.... "'z'" int0 Â·'AÂ·' â¢â¢ ,Â·Â·zÂ·"
                        	   696: EXIT_4G:
00:013A C9              	   697: 			RET
                        	   698: 
                        	   699: 			; SAMPLE EXECUTI0N:
                        	   700: SC4G:
                        	   701: 			; ;C0NVERT L0WER CASE E T0 UPPER CASE
                        	   702: 			; LD		A,'e'
                        	   703: 			; CALL	LC2UC				;A='E'=45H
                        	   704: 			; ;C0NVERT L0WER CASE Z T0 UPPER CASE
                        	   705: 			; LD		A,'z'
                        	   706: 			; CALL	LC2UC				; A='Z'=5AH
                        	   707: 			; ;C0NVERT UPPER CASE A T0 UPPER CASE A
                        	   708: 			; LD		A,'A'
                        	   709: 			; CALL	LC2UC				;A='A'=41H
                        	   710: 			; JR		SC4G
                        	   711: 
                        	   712: 
                        	   713: ;*************************************************************************************************
                        	   714: 				; ASCII t0 EBCDIC C0nversi0n (ASC2EB)                                                                           4H
                        	   715: 				; C0nverts an ASCII character t0 its EBCDIC
                        	   716: 				; equivalent.                                                   Registers Used: AF, DE, HL
                        	   717: 				; Pr0cedure: The pr0gram uses a simple table                 executi0n Time: 55 cycles
                        	   718: 				; l00kup with the data as the index and address                 Pr0gram Size: II bytes, plus 128 bytes f0r the c0n-
                        	   719: 				; 															versi0n table
                        	   720: 				; EBCDIC as the base. A printable ASCII charac-
                        	   721: 				; 															Data Mem0ry Required: N0ne
                        	   722: 				; ter with n0 EBCDIC equivalent is translated t0
                        	   723: 				; an EBCDIC space (4016); a n0n-printable ASCII
                        	   724: 				; character with n0 EBCDIC equivalent is trans-
                        	   725: 				; lated t0 an EBCDIC NUL (0016).
                        	   726: 				; Entry C0nditi0ns                                         Exit C0nditi0ns
                        	   727: 				; ASCII character in A                                     EBCDIC equivalent in A
                        	   728: 				; Examples
                        	   729: 				; I.    Data:      (A)   = 35'6 (ASCII 5)                  3.    Data:      (A) = 2A'6 (ASCII *)
                        	   730: 				; 	Result:     (A) = F5'6 (EBCDIC 5)                        Result:     (A) = 5C'6 (EBCDIC *)
                        	   731: 				; 2.    Data:      (A) = 77'6 (ASCII w)
                        	   732: 				; 	Result:     (A) = A6'6 (EBCDIC w)
                        	   733: 				; 			Title                      ASCII t0 EBCDIC c0nversi0n
                        	   734: 				; 			Name:                      ASC2EB
                        	   735: 				; 			PUurp0se:                  C0nvert an ASCII character t0 its
                        	   736: 				; 										c0rresp0nding EBCDIC character
                        	   737: 				; 			Enh'Y:                     Register A   ASCI I chat"acter"
                        	   738: 				; 			Ed t:                      Register A   EBCDIC character.
                        	   739: 				; 		Registers used: AF,DE,HL
                        	   740: 				; 		Time:            55 cycles
                        	   741: 				; 		Size:            Pr0gram 11 bytes
                        	   742: 				; 						Data    128 bytes f0r the table
                        	   743: ;*************************************************************************************************
                        	   744: 
                        	   745: 
                        	   746: ; ASC2EB:
                        	   747: ; 			LD		HL,EBCDIC			;GET BASE ADDRESS 0F EBCDIC TABLE
                        	   748: ; 			AND		011111111B			;BE SURE BIT 7 = 0
                        	   749: ; 			LD		E,A					;USE ASCII AS INDEX INT0 EBCDIC TABLE
                        	   750: ; 			LD		D,0
                        	   751: ; 			ADD		HL,DE
                        	   752: ; 			LD		A, (HL)				;GET EBCDIC
                        	   753: ; 			RET
                        	   754: ; ;ASCII T0 EBCDIC TABLE
                        	   755: ; ;   A PRINTABLE ASCII CHARACTER WITH N0 EBCDIC EQUIVALENT IS
                        	   756: ; ;   TRANSLATED T0 AN EBCDIC SPACE (040H), A N0NPRINTABLE ASCII CHARACTER
                        	   757: ; ; WITH N0 EQUIVALENT IS TRANSLATED T0 A EBCDIC NUL (000H)
                        	   758: ; EBCDIC:
                        	   759: ; 			;		 NUL  S0H  STX  ETX  E0T  ENQ  ACK  BEL			;ASCII
                        	   760: ; 			DB      000H,001H,002H,003H,037H,02DH,02EH,02FH         ;EBCDIC
                        	   761: ; 			;		 BS   HT   LF   VT   FF   CR   S0   SI			;ASCII
                        	   762: ; 			DB      016H,005H,025H,00BH,00CH,00DH,00EH,00FH         ;EBCDIC
                        	   763: ; 			;		DLE	 DC1  DC2  DC3  DC4  NAK  SYN  ETB			;ASCII
                        	   764: ; 			DB      010H,011H,012H,013H,03CH,03DH,032H,026H         ;EBCDIC
                        	   765: ; 			;		CAN  EM   SUB  ESC  IFS  IGS  IRS  IUS			;ASCII
                        	   766: ; 			DB      018H,019H,03FH,027H,01CH,01DH,01EH,01FH         ;EBCDIC
                        	   767: ; 			;		SPACE ! 	"   #	 $	  %	   & 	'			;ASCII
                        	   768: ; 			DB      040H,05AH,07FH,07BH,05BH,06CH,050H,00DH         ;EBCDIC
                        	   769: ; 			;		(     ) 	*   +    ,    _	   .   /			;ASCII
                        	   770: ; 			DB      04DH,05DH,05CH,04EH,06BH,060H,04BH,061H         ;EBCDIC
                        	   771: ; 			;		0	 1    2    3    4    5    6    7			;ASCII
                        	   772: ; 			DB		0F0H,0F1H,0F2H,0F3H,0F4H,0F5H,0F6H,0F7H         ;EBCDIC
                        	   773: ; 			;		 8    9    : 	;	 <     =   >	?			;ASCII
                        	   774: ; 			DB      0F8H,0F9H,07AH,05EH,04CH,07EH,06EH,06FH         ;EBCDIC
                        	   775: ; 			;        @    A    B    C    D    E    F    G			;ASCII
                        	   776: ; 			DB      07CH,0C1H,0C2H,0C3H,0C4H,0C5H,0C6H,0C7H         ;EBCDIC
                        	   777: ; 			;		 H    I    J    K    L    M    N    0			;ASCII
                        	   778: ; 			DB		0C8H,0C9H,0D1H,0D2H,0D3H,0D4H,0D5H,0D6H         ;EBCDIC
                        	   779: ; 			;		 P    Q    R    S    T    U    V    W			;ASCII
                        	   780: ; 			DB		0D7H,0D8H,0D9H,0E2H,0E3H,0E4H,0E5H,0E6H         ;EBCDIC
                        	   781: ; 			;	     X    Y    Z    [    \    ]    ^	-			;ASCII
                        	   782: ; 			DB		0E7H,0E8H,0E9H,040H,0E0H,040H,040H,06DH         ;EBCDIC
                        	   783: ; 			;		 '	  a	   b    c 	 d    e    f    g			;ASCII
                        	   784: ; 			DB		009H,081H,082H,083H,084H,085H,086H,087H         ;EBCDIC
                        	   785: ; 			;		 h 	  i    j    k    l	  m    n    0			;ASCII
                        	   786: ; 			DB		088H,089H,091H,092H,093H,094H,095H,096H			;EBCDIC
                        	   787: ; 			;		 p    q    r    s    t    u    v    w			;ASCII
                        	   788: ; 			DB		097H,098H,099H,0A2H,0A3H,0A4H,0A5H,0A6H         ;EBCDIC
                        	   789: ; 			;		 x    y    z    {   |     }    ~    DEL			; ASCII
                        	   790: ; 			DB		0A7H,0A8H,0A9H,0C0H,06AH,0D0H,0A1H,007H         ;EBCDIC
                        	   791: 
                        	   792: ;         ; SAMPLE EXECUTI0N:
                        	   793: 
                        	   794: ; SC4H:
                        	   795: ; 			; C0NVERT ASC I I -' A -' T0 EBCD I C
                        	   796: ; 			LD		A,'A'			; ASCI I ---A-'
                        	   797: ; 			CALL	ASC2EB			; EBCD I C -' A -'   0C 1 H
                        	   798: 
                        	   799: ; 			; C0NVERT ASC I I '1 -' T0 EBCD I C
                        	   800: ; 			LD		A,'1'			;ASCII '1'
                        	   801: ; 			CALL	ASC2EB			; EBCD I C '1 -'       0F 1 H
                        	   802: 
                        	   803: ; 			;C0NVERT ASCII 'a' T0 EBCDIC
                        	   804: ; 			LD		A, 'a'			; ASC I I -' a-'
                        	   805: ; 			CALL	ASC2EB			; EBCD I C -' a -'          081 H
                        	   806: 
                        	   807: ; 			JR	SC4H
                        	   808: 
                        	   809: ;*************************************************************************************************
                        	   810: ;*************************************************************************************************
                        	   811: 					; EBCDIC t0 ASCII C0nversi0n (EB2ASC)                                                                        41
                        	   812: 					; C0nverts an EBCDIC character t0 its ASCII
                        	   813: 					; equivalent.                                                Registers Used: AF, DE, HL
                        	   814: 					; Pr0cedure: The pr0gram uses a simple table              Executi0n Time: 48 cycles
                        	   815: 					; l00kup with the data as the index and address              Pr0gram Size: 9 bytes, plus 256 bytes f0r the c0n-
                        	   816: 					; 														versi0n table
                        	   817: 					; ASCII as the base. A printable EBCDIC charac-
                        	   818: 					; 														Data Mem0ry Required: N0ne
                        	   819: 					; ter with n0 ASCII equivalent is translated t0 an
                        	   820: 					; ASCII space (2016); a n0n-printable EBCDIC
                        	   821: 					; character with n0 ASCII equivalent is trans-
                        	   822: 					; lated t0 an ASCII NUL (00 16)'
                        	   823: 					; Entry C0nditi0ns                                      Exit C0nditi0ns
                        	   824: 					; EBCDIC character in A                                 ASCII equivalent in A
                        	   825: 					; Examples
                        	   826: 					; I.    Data:      (A) = 85'6 (EBCDIC e)                2.    Data:     (A) = 4E'6 (EBCDIC +)
                        	   827: 					; 	Result:     (A) = 65'6 (ASCII e)                      Result:    (A) = 2B'6 (ASCII +)
                        	   828: 					; 			Title                    EBCDIC t0 ASCII c0nversi0n
                        	   829: 					; 			Name:                    EB2ASC
                        	   830: 					; 			Purp0se:                 C0nvert an EBCDIC character t0 its
                        	   831: 					; 										c0rresp0nding ASCII character
                        	   832: 					; 			Entr'y:                  Register A   EBCDIC character
                        	   833: 					; 			Exit:                    Register A   ASCII character
                        	   834: 					; 			Registers used: AF ,DE, H L
                        	   835: 					; 		Time:               48 cycles
                        	   836: 					; 		Size:               Pr0gram 9 bytes
                        	   837: 					; 							Data    256 bytes f0r the table
                        	   838: ;*************************************************************************************************
                        	   839: ;*************************************************************************************************
                        	   840: 
                        	   841: 
                        	   842: ; EB2ASC:
                        	   843: ; 			LD		HL,ASCII			;0ET BASE ADDRESS 0F ASCII TABLE
                        	   844: ; 			LD		E,A					; USE EBCDIC AS INDEX
                        	   845: ; 			LD		D,0
                        	   846: ; 			ADD		HL,DE
                        	   847: ; 			LD		A,(HL)				;0ET ASC II CHARACTER
                        	   848: ; 			RET
                        	   849: ; ; EBCDIC T0 ASCII TABLE
                        	   850: ; ; A PRINTABLE EBCDIC CHARACTER WITH N0 ASCII EQUIVALENT IS
                        	   851: ; ; TRANSLATED T0 AN ASCII SPACE (020H). A N0NPRINTABLE EBCDIC CHARACTER
                        	   852: ; ; WITH N0 EQUIVALENT IS TRANSLATED T0 AN ASCII NUL (000H)
                        	   853: ; ASCII:
                        	   854: ; 			; 	    NUL   S0H  STX  ETX       HT        DEL				;EBCDIC
                        	   855: ; 			DB      000H,001H,002H,003H,000H,009H,000H,07FH				;ASCII
                        	   856: ; 			;						VT   FF   CR   S0	S1				;EBCDIC
                        	   857: ; 			DB		000H,000H,000H,00BH,00CH,00DH,00EH,00FH				;ASCII
                        	   858: ; 			;	     DLE  DCl  DC2  DC3			   BS					;EBCDIC
                        	   859: ; 			DB      010H,011H,012H,013H,000H,000H,008H,000H  			;ASCII
                        	   860: ; 			;		 CAN  EM             IFS  IGS  IRS  IUS				;EBCDIC
                        	   861: ; 			DB		018H,019H,000H,000H,01CH,01DH,01EH,01FH				;ASCII
                        	   862: ; 			;								  LF   ETB  ESC				;EBCDIC
                        	   863: ; 			DB		000H,000H,000H,000H,000H,00AH,017H,01BH				;ASCII
                        	   864: ; 			;						          ENQ  ACK  BEL				;EBCDIC	
                        	   865: ; 			DB      000H,000H,000H,000H,000H,005H,006H,007H				;ASCII
                        	   866: ; 			;                  SYN						EOT				;EBCDIC
                        	   867: ; 			DB		000H,000H,016H,000H,000H,000H,000H,004H				;ASCII
                        	   868: ; 			;                            DC4  NAK  		SUB 			;EBCDIC
                        	   869: ; 			DB		000H,000H,000H,000H,014H,015H,000H,01AH				;ASCII
                        	   870: ; 			;     SPACE													;EBCDIC
                        	   871: ; 			DB		' ' ,000H,000H,000H,000H,000H,000H,000H				;ASCII
                        	   872: ; 			;						.	 <	  (    +					;EBCDIC
                        	   873: ; 			DB      000H,000H,' ' ,'.' ,'<' ,'(' ,'+' ,' '				;ASCII
                        	   874: ; 			;	  	 &													;EBCDIC
                        	   875: ; 			DB		'&' ,000H,000H,000H,000H,000H,000H,000H				;ASCII
                        	   876: ; 			;				   !    $    *    )    ;  					;EBCDIC
                        	   877: ; 			DB      000H,000H,'!' ,'$' ,'*' ,')' ,';' ,' '				;ASCII
                        	   878: ; 			;		 _    /												;EBCDIC
                        	   879: ; 			DB      '_' ,'/' ,000H,000H,000H,000H,000H,000H				;ASCII
                        	   880: ; 			;                  |    ,    %    -    >    ?     			;EBCDIC
                        	   881: ; 			DB      000H,000H,'|' ,',' ,'%' ,'-' ,'>' ,'?'  			;ASCII
                        	   882: ; 			;															;EBCDIC
                        	   883: ; 			DB      000H,000H,000H,000H,000H,000H,000H,000H 			;ASCII
                        	   884: ; 			;             `    :    #    @    '    =    "				;EBCDIC
                        	   885: ; 			DB      000H,'`' ,':' ,'#' ,'@' ,' ' ,'=' ,'"'   			;ASCII
                        	   886: ; 			;             a    b    c    d    e    f    g				;EBCDIC
                        	   887: ; 			DB      000H,'a' ,'b' ,'c' ,'d' ,'e' ,'f' ,'g'  			;ASCII
                        	   888: ; 			;		h     i												;EBCDIC
                        	   889: ; 			DB      'h' ,'i' ,000H,000H,000H,000H,000H,000H				;ASCII
                        	   890: ; 			;			  j    k    l    m    n    o    p				;EBCDIC
                        	   891: ; 			DB      000H,'j' ,'k' ,'l' ,'m' ,'n' ,'o' ,'p'				;ASCII
                        	   892: ; 			;		q    r												;EBCDIC
                        	   893: ; 			DB      'q' ,'r' ,000H,000H,000H,000H,000H,000H  			;ASCII
                        	   894: ; 			;			 ~	   s    t    u    v    w    x				;EBCDIC
                        	   895: ; 			DB      000H,'~' ,'s' ,'t' ,'u' ,'v' ,'w' ,'x'				;ASCII
                        	   896: ; 			;	     y    z												;EBCDIC
                        	   897: ; 			DB      'y' ,'z' ,000H,000H,000H,000H,000H,000H 			;ASCII
                        	   898: ; 			;															;EBCDIC
                        	   899: ; 			DB      000H,000H,000H,000H,000H,000H,000H,000H  			;ASCII
                        	   900: ; 			;                                                     		;EBCDIC
                        	   901: ; 			DB      000H,000H,000H,000H,000H,000H,000H,000H  			;ASCII
                        	   902: ; 			;		 {    A    B    C    D    E    F    G           	;EBCDIC
                        	   903: ; 			DB      '{' ,'A' ,'B' ,'C' ,'D' ,'E' ,'F' ,'G'				;ASCII
                        	   904: ; 			;		 H    I                                     		;EBCDIC
                        	   905: ; 			DB      'H' ,'I' ,000H,000H,000H,000H,000H,000H   			;ASCII
                        	   906: ; 			;		 }    J    K    L    M    N    O    P       		;EBCDIC
                        	   907: ; 			DB      '}' ,'J' ,'K' ,'L' ,'M' ,'N' ,'O' ,'P'      		;ASCII
                        	   908: ; 			;	     Q    R                                   			;EBCDIC
                        	   909: ; 			DB      'Q' ,'R' ,000H,000H,000H,000H,000H,000H				;ASCII
                        	   910: ; 			;		 \         S    T    U    V    W    X				;EBCDIC
                        	   911: ; 			DB      '\\' ,000H,'S' ,'T' ,'U' ,'V' ,'W' ,'X'     			;ASCII
                        	   912: ; 			;		 Y    Z                                				;EBCDIC
                        	   913: ; 			DB      'Y' ,'Z' ,000H,000H,000H,000H,000H,000H				;ASCII
                        	   914: ; 			;        0    1    2    3    4    5    6    7				;EBCDIC
                        	   915: ; 			DB      '0' ,'1' ,'2' ,'3' ,'4' ,'5' ,'6' ,'7'     			;ASCII
                        	   916: ; 			;		9													;EBCDIC
                        	   917: ; 			DB      '9' ,000H,000H,000H,000H,000H,000H,000H				;ASCII
                        	   918: 
                        	   919: 
                        	   920: 
                        	   921: ;         ;  SAMPLE EXECUTI0N:
                        	   922: 
                        	   923: 
                        	   924: ; SC4I:
                        	   925: ; 			;C0NVERT EBCDIC            'A'    T0 ASCII
                        	   926: ; 			LD		A,0C1H                        ;EBCDIC           ~A~
                        	   927: ; 			CALL	EB2ASC                        ;ASCII "'A~             = 041H
                        	   928: ; 			;C0NVERT EBCDIC            ~1'"   T0 ASCII
                        	   929: ; 			LD		A,0F1H                        ;EBCDIC ~1"
                        	   930: ; 			CALL	EB2ASC                        ; ASCI I "1" = 031H
                        	   931: ; 			;C0NVERT EBCDIC            ~a"    T0 ASCII
                        	   932: ; 			LD		A,081H                        ; EBCDIC .' a'"
                        	   933: ; 			CALL	EB2ASC                        ; ASCII "'a'" = 061H
                        	   934: ; 			JR		SC4I
                        	   935: 
                        	   936: 
                        	   937: ;*************************************************************************************************
                        	   938: ;*************************************************************************************************
                        	   939: 
                        	   940: 		;*** 	write DE to sceen in hex
                        	   941: putDEtoScreen:
                        	   942: 		; Binary to HEX  BN2HEX   DE->(HL)
00:013B 210000          	   943: 		ld 		hl,T_BUFFER
00:013E 23              	   944: 		inc		hl
00:013F CD2700          	   945: 		call	Bin2Hex16			;result in T_buffer
00:0142 FD210000        	   946: 		ld 		iy,T_BUFFER
00:0146 CD0000          	   947: 		call	WriteLine
00:0149 C9              	   948: 		ret
                        	   949: 
                        	   950: ;*************************************************************************************************
                        	   951: ;*************************************************************************************************
                        	   952: 		;*** 	write DE to sceen in decimal
                        	   953: putDEtoScreenDEC:
                        	   954: 		; Binary to HEX  BN2HEX   DE->(HL)
00:014A 210000          	   955: 		ld 		hl,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
00:014D 23              	   956: 		inc		hl
00:014E CD6A00          	   957: 		CALL	BN2DEC				; C0NVERT ;result in T_buffer
00:0151 FD210000        	   958: 		ld 		iy,T_BUFFER
00:0155 CD0000          	   959: 		call	WriteLine
00:0158 C9              	   960: 		ret
                        	   961: 
                        	   962: ;*************************************************************************************************
                        	   963: ;*************************************************************************************************
                        	   964: 		;  Dump registers. Saves all registers, display to screen.
                        	   965: 		;	Dump of flag registers
                        	   966: 
                        	   967: 		GLOBAL	RegLabels1,RegLabels2,RegLabels3, display_n_8registers
                        	   968: 
                        	   969: DumpRegisters:
00:0159 ED730000        	   970: 		ld		(SP_value),sp
00:015D 220000          	   971: 		ld		(reg16_value),hl
                        	   972: 		; ex		(sp),hl
                        	   973: 		; ld		(PC_value),hl
                        	   974: 		; ex		(sp),hl
00:0160 2A0000          	   975: 		ld 		hl,(SP_value)		; get value of sp to hl
00:0163 E5              	   976: 		push 	hl				; push value of hl(=sp) to (sp)
00:0164 2A0000          	   977: 		ld		hl,(reg16_value)	
00:0167 DDE5            	   978: 		push	ix
00:0169 FDE5            	   979: 		push	iy
00:016B F5              	   980: 		push	af
00:016C C5              	   981: 		push	BC
00:016D D5              	   982: 		push	de
00:016E E5              	   983: 		push 	hl
00:016F 08              	   984: 		ex		af,af'
00:0170 D9              	   985: 		exx
00:0171 F5              	   986: 		push	af
00:0172 C5              	   987: 		push	BC
00:0173 D5              	   988: 		push	de
00:0174 E5              	   989: 		push 	hl
00:0175 08              	   990: 		ex		af,af'
00:0176 D9              	   991: 		exx
                        	   992: 
                        	   993: 
                        	   994: 
                        	   995: 
                        	   996: ; 			;	clear Textbuf
                        	   997: ; 		ld 		a,0
                        	   998: ; 		ld 		de,Textbuf
                        	   999: ; 		ld 		b,0x40
                        	  1000: ; .zeroTextBuf:
                        	  1001: ; 		ld 		(de),A
                        	  1002: ; 		djnz	.zeroTextBuf		
                        	  1003: 
                        	  1004: 		
                        	  1005: 
00:0177 DD2A0000        	  1006: 		ld		ix,(SP_value)		; ix  points to stack
                        	  1007: 
00:017B FD210000        	  1008: 		ld 		iy,RegLabels1
00:017F CD0000          	  1009: 		call 	WriteLineCRNL
                        	  1010: 
00:0182 210000          	  1011: 		ld		hl,S1x
00:0185 CDFE01          	  1012: 		call	display_4_registers
00:0188 CD0000          	  1013: 		call  	CRLF
                        	  1014: 
00:018B FD210000        	  1015: 		ld 		iy,RegLabels2
00:018F CD0000          	  1016: 		call 	WriteLineCRNL
                        	  1017: 
00:0192 210000          	  1018: 		ld		hl,S1x
00:0195 CDFE01          	  1019: 		call	display_4_registers
00:0198 CD0000          	  1020: 		call 	CRLF
                        	  1021: 
00:019B FD210000        	  1022: 		ld 		iy,RegLabels3
00:019F CD0000          	  1023: 		call	WriteLineCRNL
                        	  1024: 
00:01A2 210000          	  1025: 		ld		hl,S1x
00:01A5 CDFE01          	  1026: 		call	display_4_registers
00:01A8 CD0000          	  1027: 		call 	CRLF
                        	  1028: 
                        	  1029: 			; display status flags  	DB		38," S Z X H X P N C",0
00:01AB DD7E10          	  1030: 		ld		A,(ix+16)
00:01AE 4F              	  1031: 		ld 		c,a			; store A
00:01AF 210100          	  1032: 		ld		hl,S1x+1
00:01B2 FD210100        	  1033: 		ld		iy,RegFlags+1
                        	  1034: 
00:01B6 0605            	  1035: 		ld 		b,05
00:01B8 CD4702          	  1036: 		call	add_space		; add (b) spaces to (hl), advance hl	
                        	  1037: 
00:01BB 0608            	  1038: 		ld 		b,8
                        	  1039: all_flags:
00:01BD CB21            	  1040: 		sla		c			; shift msb bit to C flag
                        	  1041: 
00:01BF DCEE01          	  1042: 		call	C,disp_flags			; set act. flag in text.buf
                        	  1043: 
00:01C2 CDF901          	  1044: 		call	adv_iy
00:01C5 10F6            	  1045: 		djnz	all_flags
                        	  1046: 
                        	  1047: 
00:01C7 AF              	  1048: 		xor 	a					; clear A
00:01C8 77              	  1049: 		ld 		(hl),a				; set end of string
00:01C9 CD4E02          	  1050: 		call	adjust_txtbuf_length
00:01CC FD210000        	  1051: 		ld 		iy,S1x
00:01D0 CD0000          	  1052: 		call 	WriteLineCRNL
                        	  1053: 
00:01D3 CD0000          	  1054: 		call 	waitForKey
00:01D6 CD0000          	  1055: 		call 	CRLF
                        	  1056: 
                        	  1057: 
00:01D9 D9              	  1058: 		exx
00:01DA 08              	  1059: 		ex		af,af'
00:01DB E1              	  1060: 		pop	hl
00:01DC D1              	  1061: 		pop	de
00:01DD C1              	  1062: 		pop	bc
00:01DE F1              	  1063: 		pop af
00:01DF D9              	  1064: 		exx
00:01E0 08              	  1065: 		ex	af,af'
00:01E1 E1              	  1066: 		pop hl
00:01E2 D1              	  1067: 		pop	de
00:01E3 C1              	  1068: 		pop	BC
00:01E4 F1              	  1069: 		pop	af
00:01E5 FDE1            	  1070: 		pop	iy
00:01E7 DDE1            	  1071: 		pop	ix
                        	  1072: 
00:01E9 ED7B0000        	  1073: 		ld 		sp,(SP_value)		; restore value of sp
                        	  1074: 
00:01ED C9              	  1075: 		ret
                        	  1076: ;********************************************************************************************
                        	  1077: ;********************************************************************************************	
                        	  1078: 
                        	  1079: disp_flags:
00:01EE FD7E00          	  1080: 		ld 		A,(iy)
00:01F1 77              	  1081: 		ld		(hl),A
00:01F2 23              	  1082: 		inc		hl
00:01F3 FD7E01          	  1083: 		ld		a,(iy+1)
00:01F6 77              	  1084: 		ld 		(hl),a
00:01F7 23              	  1085: 		inc		hl
00:01F8 C9              	  1086: 		ret
                        	  1087: adv_iy:
00:01F9 FD23            	  1088: 		inc		iy
00:01FB FD23            	  1089: 		inc		iy
00:01FD C9              	  1090: 		ret
                        	  1091: ;********************************************************************************************
                        	  1092: ;********************************************************************************************	
                        	  1093: 
                        	  1094: 
                        	  1095: 		;	load 4 16bit values in buffer ->(HL)
                        	  1096: display_4_registers:
00:01FE 0604            	  1097: 		ld 		b,04
                        	  1098: 		
                        	  1099: display_regs:
00:0200 ED430000        	  1100: 		ld		(reg16_value),bc		; save the # regs /line
                        	  1101: 
00:0204 0605            	  1102: 		ld 		b,05
                        	  1103: 			; add (b) spaces to (hl), advance hl	
00:0206 CD4702          	  1104: 		call	add_space
                        	  1105: 
                        	  1106: 
00:0209 DD5601          	  1107: 		ld		d,(ix+1)
00:020C DD5E00          	  1108: 		ld		e,(ix)		; get value from temp.stack..to de..?
00:020F DD2B            	  1109: 		dec		ix
00:0211 DD2B            	  1110: 		dec		ix			; ix points to next rec in stack
                        	  1111: 
00:0213 CD2700          	  1112: 		call	Bin2Hex16			;result added to (HL)-> to last 0x00. hl updatd (+4)
                        	  1113: 
00:0216 ED4B0000        	  1114: 		ld		bc,(reg16_value)
00:021A 10E4            	  1115: 		djnz 	display_regs			; display (b) registers with spaces...
                        	  1116: 
                        	  1117: 		; call	adjust_txtbuf_length
00:021C AF              	  1118: 		xor 	a
00:021D 77              	  1119: 		ld 		(hl),A
                        	  1120: 
00:021E FD210000        	  1121: 		ld 		iy,S1x
00:0222 CD0000          	  1122: 		call	WriteLineCRNL
00:0225 C9              	  1123: 		ret
                        	  1124: 
                        	  1125: 
                        	  1126: ;********************************************************************************************
                        	  1127: ;********************************************************************************************	
                        	  1128: 
                        	  1129: ;********************************************************************************************
                        	  1130: ;********************************************************************************************	
                        	  1131: 
                        	  1132: 		;	load n 8bit values in buffer ->(HL); i.e. S1x
                        	  1133: 		; 	ix points to data.
                        	  1134: 		;	n = reg B
                        	  1135: display_n_8registers:
                        	  1136: 		
00:0226 ED430000        	  1137: 		ld		(reg16_value),bc		; save the # regs /line
                        	  1138: 
00:022A 0602            	  1139: 		ld 		b,02
                        	  1140: 			; add (b) spaces to (hl), advance hl	
00:022C CD4702          	  1141: 		call	add_space
                        	  1142: 
00:022F DD5E00          	  1143: 		ld		e,(ix)		; get value from (ix) to e
00:0232 DD23            	  1144: 		inc		ix
                        	  1145: 
00:0234 CD2D00          	  1146: 		call	Bin2Hex8			;result added to (HL)-> to last 0x00. hl updatd (+2)
                        	  1147: 
00:0237 ED4B0000        	  1148: 		ld		bc,(reg16_value)
00:023B 10E9            	  1149: 		djnz 	display_n_8registers			; display (b) registers with spaces...
                        	  1150: 
                        	  1151: 		; call	adjust_txtbuf_length
00:023D AF              	  1152: 		xor 	a
00:023E 77              	  1153: 		ld 		(hl),A
                        	  1154: 
00:023F FD210000        	  1155: 		ld 		iy,S1x
00:0243 CD0000          	  1156: 		call 	WriteLineCRNL
00:0246 C9              	  1157: 		ret
                        	  1158: 
                        	  1159: 
                        	  1160: ;********************************************************************************************
                        	  1161: ;********************************************************************************************	
                        	  1162: 		global 	add_space
                        	  1163: 
                        	  1164: 		; set new length in string pos 0 (HL)-> end of string
                        	  1165: 
                        	  1166: add_space:
00:0247 3E20            	  1167: 		ld 		a,' '
00:0249 77              	  1168: 		ld 		(hl),A
00:024A 23              	  1169: 		inc 	hl
00:024B 10FA            	  1170: 		djnz	add_space
00:024D C9              	  1171: 		ret
                        	  1172: 
                        	  1173: adjust_txtbuf_length:
                        	  1174: 
00:024E 110000          	  1175: 		ld		de,S1x
00:0251 ED52            	  1176: 		SBC		hl,de		; calc new length of string
00:0253 7D              	  1177: 		ld 		a,l
00:0254 12              	  1178: 		ld 		(de),a		; store in first pos
00:0255 19              	  1179: 		add		hl,de		; restore to first pos after spaces
00:0256 C9              	  1180: 		ret
                        	  1181: ;********************************************************************************************
                        	  1182: ;********************************************************************************************	
                        	  1183: 
                        	  1184: 
                        	  1185: 
                        	  1186: 
                        	  1187: 		; Array Manipulation and Indexing
                        	  1188: 		; 5A      Memory Fill    195
                        	  1189: 		; 5B      Block Move    198
                        	  1190: 
                        	  1191: ;*****************************************************************************************************
                        	  1192: ;*****************************************************************************************************
                        	  1193: 				; Memory Fill (MFILL)                                                                                             
                        	  1194: 				; Places a specified value in each byte of a mem-
                        	  1195: 				; ory area of known size, starting at a given ad-                 Registers Used: AF, BC, DE, HL
                        	  1196: 				; dress.                                                          Execution Time: Approximately 21 cycles per byte
                        	  1197: 				;         Registers used: AF.BC.DE.HL
                        	  1198: 				;         Time:                Approximately 21 cycles per byte plus
                        	  1199: 				;                                 50 cycles overhead
                        	  1200: 				;         Size:                Program 11 bytes
                        	  1201: 				;                                 Data    None
                        	  1202: ;*****************************************************************************************************
                        	  1203: ;*****************************************************************************************************
                        	  1204: 
                        	  1205: MFILL:
00:0257 77              	  1206: 			LD		(HL),A			;FILL FIRST BYTE WITH VALUE
00:0258 54              	  1207: 			LD		D,H				;DESTINATION PTR = SOURCE PTR + 1
00:0259 5D              	  1208: 			LD		E,L
00:025A 13              	  1209: 			INC		DE
00:025B 0B              	  1210: 			DEC		BC				;ELIMINATE FIRST BYTE FROM COUNT
00:025C 78              	  1211: 			LD		A,B				;ARE THERE MORE BYTES TO FILL?
00:025D B1              	  1212: 			OR		C
00:025E C8              	  1213: 			RET		Z				;NO. RETURN - SIZE WAS 1
00:025F EDB0            	  1214: 			LDIR					;YES. USE BLOCK MOVE TO FILL REST
                        	  1215: 									; BY MOVING VALUE AHEAD 1 BYTE
00:0261 C9              	  1216: 			RET
                        	  1217: 
                        	  1218: 
                        	  1219: 
                        	  1220: 			; SAMPLE EXECUTION:
                        	  1221: 
                        	  1222: 
                        	  1223: SC5A:
                        	  1224: 			;FILL BF1 THROUGH BF1+15 WITH 00
                        	  1225: ; 			LD		HL,BF1			:STARTING ADDRESS
                        	  1226: ; 			LD		BC,SIZEI		JNUMBER OF BYTES
                        	  1227: ; 			LD		A,0				;VALUE TO FILL
                        	  1228: ; 			CALL	MFILL			;FILL MEMORY
                        	  1229: ; 			;FILL BF2 THROUGH BF2+l999 WITH FF
                        	  1230: ; 			LD		HL,BF2			;STARTING ADDRESS
                        	  1231: ; 			LD		BC,SIZE2		;NUMBER OF BYTES
                        	  1232: ; 			LD		A,0FFH			;VALUE TO FILL
                        	  1233: ; 			CALL	MFILL			;FILL MEMORY
                        	  1234: ; 			JR		SC5A
                        	  1235: ; SIZEl	EQU	16					;SIZE OF BUFFER 1 (10 HEX)
                        	  1236: ; SIZE2	EQU	2000				; SIZE OF BUFFER 2 (07DO HEX)
                        	  1237: ; BF1:	DS	SIZE1
                        	  1238: ; BF2:	DS	SIZE2
                        	  1239: 
                        	  1240: 
                        	  1241: ;*****************************************************************************************************
                        	  1242: ;*****************************************************************************************************
                        	  1243: 				; Block Move (BLKMOV)                                                                                              
                        	  1244: 				; Moves a block of data from a source area to
                        	  1245: 				; a destination area.                                              Registers Used: AF, BC, DE, HL
                        	  1246: 				; 		Title               Block Move
                        	  1247: 				; 		Name:                BLKMOV
                        	  1248: 				; 		Purpose:             Move data from source to destination
                        	  1249: 				; 		Entry:               Register'H     = High byte of source address
                        	  1250: 				; 							Register L     = Low byte of sou,rce address
                        	  1251: 				; 							Register D     = High byte of destination address
                        	  1252: 				; 							Register E     = Low byte of destination address     ,
                        	  1253: 				; 							Register B     = High byte of number of bytes to move,
                        	  1254: 				; 							Register C     = Low byte of number of bytes to move
                        	  1255: 				; 		Exit:                Data moved from source to destination
                        	  1256: 				; 		Registers used:AF,BC,DE,HL
                        	  1257: 				; 		Time:                21 cycles per byte plus 97 cycles overhead
                        	  1258: 				; 							if no overlap exists, 134 cycles overhead
                        	  1259: 				; 							if overlap occurs
                        	  1260: 				; 		Size:                Program 27 bytes
                        	  1261: ;*****************************************************************************************************
                        	  1262: ;*****************************************************************************************************
                        	  1263: 
                        	  1264: 
                        	  1265: BLKMOV:
00:0262 78              	  1266: 			LD		A,B				;IS SIZE OF AREA O?
00:0263 B1              	  1267: 			OR		C
00:0264 C8              	  1268: 			RET		Z				;YES, RETURN WITH NOTHING MOVED
                        	  1269: 				; DETERMINE IF DESTINATION AREA IS ABOVE SOURCE AREA AND OVERLAPS
                        	  1270: 				; IT (OVERLAP CAN BE MOD 64K). OVERLAP OCCURS IF
                        	  1271: 				; STARTING DESTINATION ADDRESS MINUS STARTING SOURCE ADDRESS
                        	  1272: 				; (MOD 64K) IS LESS THAN NUMBER OF BYTES TO MOVE
00:0265 EB              	  1273: 			EX		DE,HL			;CALCULATE DESTINATION - SOURCE
00:0266 E5              	  1274: 			PUSH	HL				;SAVE DESTINATION
00:0267 A7              	  1275: 			AND		A				;CLEAR CARRY
00:0268 ED52            	  1276: 			SBC		HL,DE
00:026A A7              	  1277: 			AND		A				;THEN    SUBTRACT AREA SIZE
00:026B ED42            	  1278: 			SBC		HL,BC
00:026D E1              	  1279: 			POP		HL				;RESTORE    DESTINATION
00:026E EB              	  1280: 			EX		DE,HL
00:026F 3009            	  1281: 			JR		NC,DOLEFT		;JUMP    IF NO PROBLEM WITH OVERLAP
                        	  1282: 				; DESTINATION     AREA IS ABOVE SOURCE AREA AND OVERLAPS IT
                        	  1283: 				; MOVE   FROM HIGHEST ADDRESS TO AVOID DESTROYING DATA
00:0271 09              	  1284: 			ADD		HL,BC			;SOURCE = SOURCE + LENGTH - 1
00:0272 2B              	  1285: 			DEC		HL
00:0273 EB              	  1286: 			EX		DE,HL			;DEST = DEST + LENGTH - 1
00:0274 09              	  1287: 			ADD		HL,BC
00:0275 2B              	  1288: 			DEC		HL
00:0276 EB              	  1289: 			EX		DE,HL
00:0277 EDB8            	  1290: 			LDDR					;BLOCK MOVE HIGH TO LOW
00:0279 C9              	  1291: 			RET
                        	  1292: 			; ORDINARY     MOVE STARTING AT LOWEST ADDRESS
                        	  1293: DOLEFT:
00:027A EDB0            	  1294: 			LDIR					;BLOCK    MOVE LOW TO HIGH
00:027C C9              	  1295: 			RET
                        	  1296: 
                        	  1297: 
                        	  1298: 
                        	  1299: 			; SAMPLE EXECUTION:
                        	  1300: 
                        	  1301: 
                        	  1302: ; SOURCE    EQU		2000H             ;BASE    ADDRESS OF SOURCE AREA
                        	  1303: ; DEST      EQU		2010H             ;BASE    ADDRESS OF DESTINATION AREA
                        	  1304: ; LEN       EQU		11H               ;NUMBER    OF BYTES TO MOVE
                        	  1305: ;           ;MOVE   11 HEX BYTES FROM 2000-2010 HEX TO 2010-2020 HEX
                        	  1306: ; SC5B:
                        	  1307: ; 			LD		HL,SOURCE
                        	  1308: ; 			LD		DE,DEST
                        	  1309: ; 			LD		BC,LEN
                        	  1310: ; 			CALL	BLKMOV            ;MOVE    DATA FROM SOURCE TO DESTINATION
                        	  1311: ; 			JR		SC5B
                        	  1312: 
                        	  1313: 	if DOALIGN
                        	  1314: 		align 4
                        	  1315: 	endif
                        	  1316: 
                        	  1317: 
                        	  1318: 
                        	  1319: .END
                        	  1320: 
                        	  1321: 
                        	  1322: 
                        	  1323: 


Symbols by name:
A2HEX                           00:0061
A2HEX1                          00:0069
AddToT_Buf                      00:0047 EXP
BCD2BN                          00:0019 EXP
BLKMOV                          00:0262 EXP
BN2BCD                          00:0000 EXP
BN2DEC                          00:006A EXP
BN2HEX                          external EXP
BUFFER                          00:00D9
BUFPTR                          00:00D5
Bin2Hex16                       00:0027 EXP
Bin2Hex8                        00:002D EXP
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CHINS                           00:009A
CHKDIG                          00:0102
CNVERT_4E                       00:0082
CNVERT_4F                       00:0101
CRLF                            external
CURLEN                          00:00D7
D100LP                          00:0002
D10LP                           00:000B
DEC2BN                          00:00E0 EXP
DECCNT                          00:0094
DOALIGN                          E:0000
DOLEFT                          00:027A
DVL00P                          00:0087
DumpRegisters                   00:0159 EXP
EREXIT                          00:012C
EXIT                            00:00A4
EXITMR                          00:00C8
EXIT_4G                         00:013A
HEX2BN                          00:0052 EXP
INIT1                           00:00ED
INSERT                          00:00B1
LC2UC                           00:0130 EXP
MFILL                           00:0257 EXP
NGFLAG                          00:00D8
NGFLAG_4F                       00:012F
OKEXIT                          00:012A
P0S                             00:00B0
PLUS                            00:00F9
RegFlags                        external
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
S1x                             external
SC4B                            00:0027
SC4D                            00:006A
SC4G                            00:013B
SC5A                            00:0262
SIO_0_A_C                       external
SIO_0_A_D                       external
SIO_0_B_C                       external
SIO_0_B_D                       external
SIO_0_Int_Vec                    E:F400
SKIP                            00:00FD
SP_value                        external
T_BUFFER                        external
WriteLine                       external
WriteLineCRNL                   external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_0_Base                  external
add_space                       00:0247 EXP
adjust_txtbuf_length            00:024E
adv_iy                          00:01F9
all_flags                       00:01BD
cnv_byte                        00:0036
disp_flags                      00:01EE
display_4_registers             00:01FE
display_n_8registers            00:0226 EXP
display_regs                    00:0200
entr8                           00:002E
gpioB                           external
gpio_in                         external
gpio_out                        external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
putDEtoScreen                   00:013B EXP
putDEtoScreenDEC                00:014A EXP
reg16_value                     external
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
waitForKey                      external

Symbols by value:
0000 BN2BCD
0000 DOALIGN
0002 D100LP
000B D10LP
0019 BCD2BN
0027 Bin2Hex16
0027 SC4B
002D Bin2Hex8
002E entr8
0036 cnv_byte
0047 AddToT_Buf
0052 HEX2BN
0061 A2HEX
0069 A2HEX1
006A BN2DEC
006A SC4D
0082 CNVERT_4E
0087 DVL00P
0094 DECCNT
009A CHINS
00A4 EXIT
00B0 P0S
00B1 INSERT
00C8 EXITMR
00D5 BUFPTR
00D7 CURLEN
00D8 NGFLAG
00D9 BUFFER
00E0 DEC2BN
00ED INIT1
00F9 PLUS
00FD SKIP
0101 CNVERT_4F
0102 CHKDIG
012A OKEXIT
012C EREXIT
012F NGFLAG_4F
0130 LC2UC
013A EXIT_4G
013B SC4G
013B putDEtoScreen
014A putDEtoScreenDEC
0159 DumpRegisters
01BD all_flags
01EE disp_flags
01F9 adv_iy
01FE display_4_registers
0200 display_regs
0226 display_n_8registers
0247 add_space
024E adjust_txtbuf_length
0257 MFILL
0262 BLKMOV
0262 SC5A
027A DOLEFT
F400 SIO_0_Int_Vec
