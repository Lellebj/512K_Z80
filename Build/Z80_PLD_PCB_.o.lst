Sections:
00: "Monitor" (0-6C3)


Source: "temp.tmp"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: 
                        	     5: ; ;Function addresses
                        	     6: ; setcursor		= $3100
                        	     7: ; writecommand	= $3180
                        	     8: ; writedata		= $3140
                        	     9: ; testBusyFlag    = $31B0
                        	    10: ; HD44780_main_init = $3000
                        	    11: 
                        	    12: 
                        	    13: ; PIO addressess...
                        	    14: portA_Contr:	equ _Z80PIO_Base + 1
                        	    15: portB_Contr:	equ _Z80PIO_Base + 3
                        	    16: portA_Data:		equ _Z80PIO_Base + 0
                        	    17: portB_Data:		equ _Z80PIO_Base + 2
                        	    18: 
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: 				;SIO_0 CHANNEL A DATA
                        	    22: SIO_0_A_D:		equ	_Z80SIO_0_Base
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_0_A_C:		equ	_Z80SIO_0_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_0_B_D:		equ	_Z80SIO_0_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_0_B_C:		equ	_Z80SIO_0_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_0_A_C
                        	    31: sio_ad: 		equ 	SIO_0_A_D
                        	    32: sio_bc: 		equ 	SIO_0_B_C
                        	    33: sio_bd: 		equ 	SIO_0_B_D
                        	    34: 
                        	    35: 
                        	    36: SIO_0_Int_Vec		EQU     $F400					; interrupt vector 
                        	    37: SIO_0_Int_WR_Vec	EQU     SIO_0_Int_Vec+8			;sio_0 channel A write interrupt vector
                        	    38: SIO_0_Int_EXT_Vec	EQU     SIO_0_Int_Vec+10		;sio_0 channel A external/status ; interrupt vector
                        	    39: SIO_0_Int_Read_Vec	EQU     SIO_0_Int_Vec+12		;sio_0 channel A read interrupt vector
                        	    40: SIO_0_Int_Spec_Vec	EQU     SIO_0_Int_Vec+14		;sio_0 channel A special receive interrupt vector
                        	    41: 
                        	    42: 		;sio_0 channel B write interrupt vector
                        	    43: SIO_0_USB_WR_Vec	EQU     SIO_0_Int_Vec+0	
                        	    44: 		;sio_0 channel B external/status ; interrupt vector
                        	    45: SIO_0_USB_EXT_Vec	EQU     SIO_0_Int_Vec+2	
                        	    46: 		;sio_0 channel B read interrupt vector
                        	    47: SIO_0_USB_Read_Vec	EQU     SIO_0_Int_Vec+4	
                        	    48: 			;sio_0 channel B special receive interrupt vector
                        	    49: SIO_0_USB_Spec_Vec	EQU     SIO_0_Int_Vec+6
                        	    50: 
                        	    51: 
                        	    52: ;Write register 0
                        	    53: WR0 equ 0
                        	    54: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    55: _Ch_Reset		equ 3<<3			; 18
                        	    56: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    57: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    58: _Error_Reset 	equ $30				; (30)	
                        	    59: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    60: 
                        	    61: ;Write register 1
                        	    62: WR1 equ 1
                        	    63: _Ext_INT_EN			equ 1
                        	    64: _Tx_INT_EN 			equ 2
                        	    65: _Status_Vector		equ 4
                        	    66: _Rx_INT_Disable		equ 0
                        	    67: _Rx_INT_First_Char  equ $08
                        	    68: _INT_All_Rx_Char_P 	equ $10 
                        	    69: _Int_All_Rx_Char_NP	equ $18
                        	    70: _WAIT_READY_R_T 	equ $20
                        	    71: _WAIT_READY_FUNC	equ $40
                        	    72: _WAIT_READY_EN		equ $80
                        	    73: 
                        	    74: WR2 equ 2
                        	    75: 
                        	    76: ;Write register 3
                        	    77: WR3 equ 3
                        	    78: _Rx_Enable 			equ $01
                        	    79: _Rx_Disable 		equ $00
                        	    80: _Auto_Enable		equ $20
                        	    81: _RX_5_bits			equ $00
                        	    82: _RX_6_bits			equ $40
                        	    83: _RX_7_bits			equ $80
                        	    84: _RX_8_bits			equ $C0
                        	    85: 
                        	    86: ;Write register 4
                        	    87: WR4 equ 4
                        	    88: _Parity_EN			equ $01
                        	    89: _Parity_Even		equ $02
                        	    90: _Stop_1_bit			equ $04
                        	    91: _Stop_1_2_bit		equ $08
                        	    92: _Stop_2_bit			equ $0C
                        	    93: _X1_Clock_mode		equ $00
                        	    94: _X16_Clock_mode		equ $40
                        	    95: _X32_Clock_mode		equ $80
                        	    96: _X64_Clock_mode		equ $C0
                        	    97: 
                        	    98: ;Write register 5
                        	    99: WR5 equ 5
                        	   100: _RTS_Enable			equ $02
                        	   101: _Tx_Enable 			equ $08
                        	   102: _Send_Break			equ $10
                        	   103: _Tx_5bits_char		equ $00
                        	   104: _Tx_7bits_char		equ $20
                        	   105: _Tx_6bits_char		equ $40
                        	   106: _Tx_8bits_char		equ $60
                        	   107: _DTR_Enable 		equ $80
                        	   108: 
                        	   109: EOT_FOUND			equ $02
                        	   110: _err01_				equ	$08
                        	   111: _err02_				equ	$09
                        	   112: _err03_				equ	$0C
                        	   113: _err04_				equ	$0D
                        	   114: _err05_				equ	$0E
                        	   115: CTCpulse			equ $0A
                        	   116: CTCtimeout			equ $0B
                        	   117: 
                        	   118: 
                        	   119: ; CTC stuff
                        	   120: CH0		equ 	_Z80CTC_Base	
                        	   121: CH1		equ 	_Z80CTC_Base+1	
                        	   122: CH2		equ 	_Z80CTC_Base+2	
                        	   123: CH3		equ 	_Z80CTC_Base+3	
                        	   124: 
                        	   125: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   126: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   127: _Timer 		equ 	$00
                        	   128: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   129: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   130: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   131: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   132: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   133: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   134: 
                        	   135: ; Interrupt vectors for CTC
                        	   136: CTC_CH0_I_Vector	EQU     SIO_0_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   137: CTC_CH1_I_Vector	EQU     SIO_0_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   138: CTC_CH2_I_Vector	EQU     SIO_0_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   139: CTC_CH3_I_Vector	EQU     SIO_0_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   140: 
                        	   141: ; Data tables  (upper EPROM/FLASH)
                        	   142: ; Interupt_vector		= SIO_0_Int_Vec
                        	   143: ; stack  				= $FF00
                        	   144: Heap				= $F000				; space for variable storage
                        	   145: 
                        	   146: ; variables  	(upper ram)
                        	   147: PIO_B_value:		= $F1D0
                        	   148: Result_NumToHex:	= $F1F0
                        	   149: 
                        	   150: 
                        	   151: ; _RAMSTART		= $8010	
                        	   152: ; _EETESTPROG		= $100	
                        	   153: 	
                        	   154: ; _Z80PIO_Base	= $0
                        	   155: ; _Z80CTC_Base	= $10
                        	   156: ; _Z80SIO_0_Base	= $20
                        	   157: ; _Z80_BankCS  	= 0x30;		/*	 30 - 3F   */
                        	   158: ; _8Bitsout 		= $40;		/*	 40 - 4F  */
                        	   159: ; _CE_RST_BANK 	= 0x80;		/*	 40 - 4F  */
                        	   160: 
                        	   161: ;*****	ALIGN command  : 00 removes all align commands
                        	   162: DOALIGN 	EQU 	00
                        	   163: 
                        	   164: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   165: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   166: CRChar:			EQU		0DH				; carrige return
                        	   167: LFChar:			EQU		0AH				; line feed
                        	   168: NUL			EQU		00
                        	   169: SOH			EQU		01
                        	   170: STX			EQU		02
                        	   171: ETX			EQU		03
                        	   172: EOT			EQU		04
                        	   173: ENQ			EQU		05
                        	   174: ACK			EQU		06
                        	   175: BEL			EQU		07
                        	   176: BS			EQU		08h
                        	   177: HT			EQU		09h
                        	   178: LF			EQU		0AH
                        	   179: VT			EQU		0BH
                        	   180: FF			EQU		0CH
                        	   181: CR			EQU		0DH
                        	   182: SO			EQU		0Eh
                        	   183: SI			EQU		0Fh
                        	   184: DLE			EQU		10h
                        	   185: DC1			EQU		11h
                        	   186: DC2			EQU		12h
                        	   187: DC3			EQU		13h
                        	   188: DC4			EQU		14h
                        	   189: NAK			EQU		15h
                        	   190: SYN			EQU		16h
                        	   191: ETB			EQU		17h
                        	   192: CAN			EQU		18h
                        	   193: EM			EQU		19h
                        	   194: SUB			EQU		1Ah
                        	   195: ESC			EQU		1Bh
                        	   196: FS			EQU		1Ch
                        	   197: GS			EQU		1Dh
                        	   198: RS			EQU		1Eh
                        	   199: US			EQU		1Fh
                        	   200: ITEM		EQU		1Ch
                        	   201: STEND		EQU		1Dh
                        	   202: LISTEND		EQU		1Eh
                        	   203: SP			EQU		20h
                        	   204: 
                        	   205: 
                        	   206: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   207: ;DATA LOCATIONS
                        	   208: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   209: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   210: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   211: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   212: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   213: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   214: 
                        	   215: ;BUFFER CONFIGURATION
                        	   216: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   217: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   218: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   219: 
                        	   220: ;BUFFER SIZES, change to suit
                        	   221: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   222: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   223: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   224: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   225: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   226: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   227: 
                        	   228: 
                        	   229: ;INTERRUPT VECTOR TABLE SETUP
                        	   230: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   231: ;There are 4 reasons the interrupt will occur:
                        	   232: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   233: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   234: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   235: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   236: ;
                        	   237: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   238: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   239: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   240: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   241: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   242: ;
                        	   243: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   244: ; -------   --  --  --  ----  --------------
                        	   245: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   246: ;    B       0   0   1   02H  External/Status Change
                        	   247: ;    B       0   1   0   04H  Receive Character Available
                        	   248: ;    B       0   1   1   06H  Special Receive Condition
                        	   249: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   250: ;    A       1   0   1   0AH  External/Status Change
                        	   251: ;    A       1   1   0   0CH  Receive Character Available
                        	   252: ;    A       1   1   1   0EH  Special Receive Condition
                        	   253: ;
                        	   254: ; SIO_0_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   255: ; SIO_0_WriteVector:		EQU		SIO_0_IntVectors+08H ;Write Interrupt Vector
                        	   256: ; SIO_0_ExternalVector:	EQU		SIO_0_IntVectors+0AH ;External Status Interrupt Vector
                        	   257: ; SIO_0_ReadVector:		EQU		SIO_0_IntVectors+0CH ;Read Interrupt Vector
                        	   258: ; SIO_0_SpecialVector:		EQU		SIO_0_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   259: 
                        	   260: 
                        	   261: 	; SIO_0_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   262: 	; SIO_0_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   263: 	; SIO_0_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   264: 	; SIO_0_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   265: 
                        	   266: ;****************************************************************************
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	   271: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	   272: gpioB:			equ		portB_Data
                        	   273: 
                        	   274: 
                        	   275: ; Define the memory size to be used for the CP/M configuration
                        	   276: ; MEM:    equ 60
                        	   277: 
                        	   278: ; The CPM origin will be at: (MEM-7)*1024
                        	   279: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   280: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   281: 
                        	   282: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   283: 
                        	   284: stacktop: equ	0xFFF0	
                        	   285: 
                        	   286: 

Source: "temp.tmp"
                        	     4:  
                        	     5: 
                        	     6: 		
                        	     7: ;********************************************************		
                        	     8: ;		section MainSRam			; main program in sram
                        	     9: ;********************************************************		
                        	    10: 
                        	    11: 	
                        	    12: 		section	Monitor
                        	    13: 
                        	    14: 
                        	    15: 
                        	    16: 			xref	Bin2Hex8,Bin2Hex16,  HEX2BN, BN2DEC,BN2DEC_S,DEC2BN,MFILL, BLKMOV,strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR
                        	    17: 			xref	InitBuffers, ReadLine, WriteChar, ReadChar, S_head_tail
                        	    18: 			xref	Textbuf, inBufferEnd,inBuffer,cleanInBuffer,cleanOutBuffer,InitInterrupt
                        	    19: 			xref	dumpMemory
                        	    20: 
                        	    21: 			xref	st2g1,st1g2,steq,subst
                        	    22: 			xref	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	    23: 			xref	sourctext1,sourctext2,endtext,src_size, writeSTRBelow,isHex
                        	    24: 
                        	    25: 			xref 	crc16_2,CRC16
                        	    26: 		
                        	    27: 		xdef 	PLD_PCB_Start
                        	    28: 		xref 	A_RTS_OFF,A_RTS_ON
                        	    29: 
                        	    30: 
                        	    31: 	;***************************************************************
                        	    32: 	;SAMPLE EXECUTION:
                        	    33: 	;***************************************************************
                        	    34: 
                        	    35: 
                        	    36: DO_Debug:	equ	1		; Set to 1 to show debug printing, else 0 
                        	    37: 
                        	    38: PLD_PCB_Start:	
                        	    39: 		; ***	should be start address $D000
00:0000 1806            	    40: 		jr 		.initRH
                        	    41: 		; Code in $D002-D005 = '0000' - 'AAAA': copy from flash
                        	    42: 		; Code in $D002-D005 = 'CCCC': code uploaded from xmodem/or DMA. Do not copy from flash
                        	    43: 		; db 		"AAAA"
00:0002 43434343        	    44: 		db 		"CCCC"
                        	    45: 		align	3
                        	    46: 
                        	    47: .initRH:
00:0008 3E33            	    48: 		ld 		A,$33
00:000A D302            	    49: 		out 	(gpio_out),A
                        	    50: 
                        	    51: 
                        	    52: 
                        	    53: 		
                        	    54: 
                        	    55: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
00:000C 110000          	    56: 		ld		DE,SRAM_VAR_START		; defined in linker script
00:000F 217E01          	    57: 		ld		hl,zero_byte
                        	    58: 		
00:0012 010000          	    59: 		ld 		BC,HEAP_SIZE			; defined in linker script
                        	    60: 
                        	    61: .cl_vars:
00:0015 EDA0            	    62: 		ldi
00:0017 2B              	    63: 		dec 	hl
00:0018 EA1500          	    64: 		jp		PE,.cl_vars			; 		P/V is set if BC – 1 ≠ 0; otherwise, it is reset.
                        	    65: 
00:001B ED7320F1        	    66: 		ld 		($F120),SP
00:001F 3EAA            	    67: 		ld 		A,$AA
00:0021 D302            	    68: 		out 	(gpio_out),A
                        	    69: 
00:0023 CD0000          	    70: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    71: 			; initialize buffer counters and pointers.
                        	    72: 	 
00:0026 CD0000          	    73: 		call	PIO_Init
                        	    74: 		
00:0029 CD0000          	    75: 		call 	CTC_Init
00:002C 3ECC            	    76: 		ld 		A,$CC
00:002E D302            	    77: 		out 	(gpio_out),A
                        	    78: 
00:0030 CD0000          	    79: 		call 	SIO_0_Init
                        	    80: 		
00:0033 CD0000          	    81: 		call	S_head_tail			; save input heads and tails
00:0036 3E81            	    82: 		ld 		A,$81
00:0038 D302            	    83: 		out 	(gpio_out),A
                        	    84: 
                        	    85: 		; call	sh_test
                        	    86: 		;call 	Flash_WR_Test
                        	    87: 		;ld		HL,$2010
                        	    88: 		;call	Flash_SE_Erase
                        	    89: 
00:003A CD0000          	    90: 		call	CRLF
00:003D CD0000          	    91: 		call 	writeSTRBelow
00:0040 000D0A          	    92: 		defb   	"\0\r\n"
00:0043 2323232323232323	    93: 		defb	"##########################################################\r\n"
00:004B 2323232323232323
00:0053 2323232323232323
00:005B 2323232323232323
00:0063 2323232323232323
00:006B 2323232323232323
00:0073 2323232323232323
00:007B 23230D0A
00:007F 546865205A383020	    94: 		defb	"The Z80 Board Awakened 2024\r\n"
00:0087 426F617264204177
00:008F 616B656E65642032
00:0097 3032340D0A
00:009C 202020206769743A	    95: 		defb	"    git: UPdate_Jan_25-0-gf049c59\r\n"
00:00A4 205550646174655F
00:00AC 4A616E5F32352D30
00:00B4 2D67663034396335
00:00BC 390D0A
00:00BF 202020206275696C	    96: 		defb	"    build: 2026-02-06_21:45\r\n"
00:00C7 643A20323032362D
00:00CF 30322D30365F3231
00:00D7 3A34350D0A
00:00DC 20202020464C4153	    97: 		defb	"    FLASH->SRAM 0xD000.\r\n"
00:00E4 482D3E5352414D20
00:00EC 3078443030302E0D
00:00F4 0A
00:00F5 00              	    98: 		defb	"\0"
                        	    99: 
                        	   100: 
00:00F6 CD0000          	   101: 		call	CRLF
                        	   102: 
                        	   103: next_line:
                        	   104: 
00:00F9 CD2103          	   105: 		call 	initCommParseTable
                        	   106: 
                        	   107: 		; ***	indicate memory banks   F[x]  Flash memory bank x
                        	   108: 		; ***	indicate memory banks   S[y]  SRAM memory bank y
                        	   109: 				; if bit 7 (memBankID) = 1  no FLASH memory is selected
                        	   110: 				; if bit 7 (memBankID) = 0 FLASH memory is lower 32k and SRAM upper 32k
00:00FC 210100          	   111: 		ld 		HL,T_BUFFER+1 			; prepare output buffer		
00:00FF 3646            	   112: 		ld 		(HL),'F'	
00:0101 3A0000          	   113: 		ld 		A,(memBankID)
00:0104 CB7F            	   114: 		bit 	7,A					; bit 7 set -> 64kSRAM
00:0106 2802            	   115: 		jr 		Z,useFlash
00:0108 3653            	   116: 		ld 		(HL),'S'	
                        	   117: useFlash:
00:010A 23              	   118: 		inc 	HL
00:010B 365B            	   119: 		ld 		(HL),'['	
00:010D 23              	   120: 		inc 	HL
00:010E CB7F            	   121: 		bit 	7,A					; bit 7 set -> 64kSRAM
00:0110 2807            	   122: 		jr 		Z,.IDflash
                        	   123: 
                        	   124: 		; ***	show sram bank number
00:0112 E60F            	   125: 		and 	$0F					; sram bank #
00:0114 CD0000          	   126: 		call 	AddToT_Buf			; convert to 1 ascii char in (HL+)
00:0117 180D            	   127: 		jr 		.cont
                        	   128: .IDflash:
                        	   129: 		; ***	show flash bank number
00:0119 CB3F            	   130: 		srl 	A
00:011B CB3F            	   131: 		srl 	A
00:011D CB3F            	   132: 		srl 	A
00:011F CB3F            	   133: 		srl 	A
00:0121 E607            	   134: 		and 	A,$07				; flash bank #
00:0123 CD0000          	   135: 		call	AddToT_Buf			; convert to 1 ascii char in (HL+)
                        	   136: .cont:
00:0126 365D            	   137: 		ld  	(HL),']'
00:0128 23              	   138: 		inc 	HL
                        	   139: 
                        	   140: 		; 	*** Print prompt text to screen, value of PC and content in memory
00:0129 ED5B0000        	   141: 		ld 		DE,(PCvalue)
00:012D 365B            	   142: 		ld  	(HL),'['
00:012F 23              	   143: 		inc 	HL
                        	   144: 
                        	   145: 		; ***	Address in parenthesis
00:0130 CD0000          	   146: 		call 	Bin2Hex16
00:0133 365D            	   147: 		ld  	(HL),']'
00:0135 23              	   148: 		inc 	HL
00:0136 363D            	   149: 		ld  	(HL),'='
00:0138 23              	   150: 		inc 	HL
                        	   151: 
                        	   152: 		; ***	Value of the bytes in address (2 bytes) to screen
00:0139 E5              	   153: 		push 	HL
00:013A 2A0000          	   154: 		ld 		HL,(PCvalue)
00:013D 56              	   155: 		ld 		D,(HL)
00:013E 23              	   156: 		inc 	HL
00:013F 5E              	   157: 		ld 		E,(HL)
00:0140 E1              	   158: 		pop 	HL
00:0141 CD0000          	   159: 		call	Bin2Hex16
00:0144 362D            	   160: 		ld  	(HL),'-'
00:0146 23              	   161: 		inc 	HL
00:0147 363E            	   162: 		ld  	(HL),'>'
00:0149 23              	   163: 		inc 	HL
                        	   164: 
00:014A 3600            	   165: 		ld  	(HL),$00
00:014C FD210000        	   166: 		ld 		iy,T_BUFFER
00:0150 CD0000          	   167: 		call	WriteLine
                        	   168: 
00:0153 210000          	   169: 		ld 		hl,Textbuf
00:0156 CD0000          	   170: 		call 	ReadLine
                        	   171: 
00:0159 FD210000        	   172: 		ld 		iy,Textbuf
00:015D CD0000          	   173: 		call	WriteLineCRNL
                        	   174: 		; ld 		A,5
                        	   175: 		; out 	(portA_Data),A
                        	   176: 
                        	   177: 		;***  	compare input
                        	   178: 		; ld 		HL,Textbuf
                        	   179: 		; ld 		DE,command_list+2
                        	   180: 		; call	strCompare
                        	   181: 
                        	   182: 	;***************************************************************
                        	   183: 	;	Find /Identify command:
                        	   184: 	;***************************************************************
                        	   185: 
00:0160 210000          	   186: 		ld 		HL,Textbuf
00:0163 CD0000          	   187: 		call 	skipPriorDelimit			; set (HL) first char
                        	   188: 		; ld 		A,7
                        	   189: 		; out 	(portA_Data),A
                        	   190: 
00:0166 DA2E04          	   191: 		jp 		C,temp_finish 				; end encountered; no command (empty line)	
                        	   192: 
00:0169 E5              	   193: 		push 	HL
00:016A D1              	   194: 		pop  	DE							; typed command start in DE
                        	   195: 
                        	   196: 		; ***	Search command in 'command_list:'
                        	   197: 		;  		DE = typed command first char in DE (Textbuf)
00:016B 210102          	   198: 		ld 		HL,command_list+1			; first char in first command in the list
                        	   199: 		; ld 		A,9
                        	   200: 		; out 	(portA_Data),A
                        	   201: 
                        	   202: scanCommandList:
00:016E 4E              	   203: 		ld 		C,(HL)						; command # in C
00:016F 23              	   204: 		inc 	HL 							; (HL)=first char
00:0170 46              	   205: 		ld 		B,(HL)						; # chars in command in list
00:0171 23              	   206: 		inc 	HL 							; (HL)=first char
00:0172 D5              	   207: 		push 	DE 							; save start of typed string (DE) for later
                        	   208: 
                        	   209: findCommandInList:
00:0173 1A              	   210: 		ld 		a,(DE)						; next typed char
                        	   211: 		; or 		$20							; make typed char lower case
00:0174 BE              	   212: 		cp		(HL)
00:0175 2008            	   213: 		jr 		nz,findNextITEM				; different chars-> test next item in list
00:0177 13              	   214: 		inc 	DE
00:0178 23              	   215: 		inc 	HL  
00:0179 10F8            	   216: 		djnz 	findCommandInList
                        	   217: 		
                        	   218: 		; ***	test char (DE); should be a delimiter...
                        	   219: 		; ex 		DE,HL
                        	   220: 		; call 	isDelimit
                        	   221: 		; 				;delimiters found ? =>Z, else ~Z
                        	   222: 		; 				;char in (HL) is '0' ->  set C, else NC
                        	   223: 		; ex 		DE,HL
                        	   224: 
                        	   225: 		; call 	writeSTRBelow
                        	   226: 		; DB 		0,"pop 	HL.. !",CR,LF,00
                        	   227: 		; call 	DumpRegisters
                        	   228: 
                        	   229: 		; jr 		nz,findNextITEM    			; command match but is longer (more chars) cp list					
                        	   230: 
                        	   231: 		; ***	Found a matching command, All char do match...
                        	   232: 		; 		(HL) points to first after command
00:017B C33403          	   233: 		jp 		matchInList
00:017E 00              	   234: zero_byte:	db  0
                        	   235: 
                        	   236: findNextITEM:
                        	   237: 		; ***	find next ITEM or LISTEND
00:017F 7E              	   238: 		ld 		a,(HL)
00:0180 FE1C            	   239: 		cp		ITEM
00:0182 2811            	   240: 		jr 		z,nextInList
                        	   241: 
00:0184 FE1E            	   242: 		cp 		LISTEND
00:0186 200A            	   243: 		jr 		NZ,.cont
                        	   244: 
                        	   245: 		; ***	Command list did not match; check if direct address '$' or byte input
00:0188 3EFF            	   246: 		ld 		A,$FF
00:018A 320000          	   247: 		ld 		(PCinpFlag),A			; indicate ev. typed address to change PCV or bytes ...
00:018D E1              	   248: 		pop 	HL					; HL start of typed string (again)
00:018E 7E              	   249: 		ld 		A,(HL)
00:018F C37503          	   250: 		jp 		checkaddress			; No more commands to check, check if address entered , '$'
                        	   251: 										; or direct input of bytes.....
                        	   252: 
00:0192 23              	   253: .cont:	inc 	HL
00:0193 18EA            	   254: 		jr 		findNextITEM
                        	   255: 
                        	   256: nextInList:
00:0195 23              	   257: 		inc 	HL						; points to item #
00:0196 D1              	   258: 		pop 	DE 						; DE start of typed string (again)
00:0197 18D5            	   259: 		jr 		scanCommandList
                        	   260: 
                        	   261: 
                        	   262: 	;***************************************************************
                        	   263: 	;	Semantic error occurred in input :
                        	   264: 	;***************************************************************
                        	   265: 
                        	   266: inputerror:
00:0199 E5              	   267: 		push   	HL
00:019A CD0000          	   268: 		call 	writeSTRBelow
00:019D 00              	   269: 		DB 		0,"Input Semantic Error... ! code(DE):",00
00:019E 496E707574205365
00:01A6 6D616E7469632045
00:01AE 72726F722E2E2E20
00:01B6 2120636F64652844
00:01BE 45293A
00:01C1 00
00:01C2 D1              	   270: 		pop 	DE
00:01C3 CD0000          	   271: 		call 	putDEtoScreen
00:01C6 CD0000          	   272: 		call 	CRLF
00:01C9 C3F900          	   273: 		jp 		next_line
                        	   274: 
                        	   275: command_addresses:
00:01CC 0000            	   276: 		defw 	00
00:01CE 8504            	   277: 		defw 	p_load			;1
00:01D0 8604            	   278: 		defw 	p_dumpmem		;2
00:01D2 8A04            	   279: 		defw 	p_pc			;3
00:01D4 8B04            	   280: 		defw 	p_clearmem		;4
00:01D6 8C04            	   281: 		defw 	p_exe			;5
00:01D8 8D04            	   282: 		defw 	p_go			;6
00:01DA 9C04            	   283: 		defw 	p_incDecPC		;7
00:01DC 9C04            	   284: 		defw 	p_incDecPC		;8
00:01DE C104            	   285: 		defw 	p_FON			;9
00:01E0 0D05            	   286: 		defw 	p_FOFF			;10
00:01E2 3805            	   287: 		defw 	p_flwr			;11. write data to EEPROM
00:01E4 6D05            	   288: 		defw 	p_flse			;12. sector erase
00:01E6 7605            	   289: 		defw 	p_xmod			;13. transfer files via x-modem
00:01E8 7104            	   290: 		defw 	p_reset			;14. Jump to $0000
00:01EA 8B05            	   291: 		defw	p_C_Read		;15. Read from SD card   sdrd  "file"  $Addr
00:01EC DD05            	   292: 		defw	p_C_Write		;16. Write to SD card   sdrd  "file"  $Addr.l $Addr.h/Num
00:01EE 8B05            	   293: 		defw	p_C_Read		;17. Read from USB   sdrd  "file"  $Addr
00:01F0 DD05            	   294: 		defw	p_C_Write		;18. Write to USB   sdrd  "file"  $Addr.l $Addr.h/Num
00:01F2 3506            	   295: 		defw	p_C_Delete		;19. delete file on SD card   sdrd  "file"  $Addr
00:01F4 3506            	   296: 		defw	p_C_Delete		;20. delete file on USB  sdrd  "file"  $Addr.l $Addr.h/Num
00:01F6 8B05            	   297: 		defw 	p_C_Read		;21. List root level files/dirs on sd card
00:01F8 8B05            	   298: 		defw 	p_C_Read 		;22. List root level files/dirs on USB
00:01FA 6C06            	   299: 		defw	p_cptFl			;23. copy from mem to flash memory (on selected bank)
00:01FC 6C06            	   300: 		defw 	p_flbank		;24. Set flash bank #
00:01FE 7306            	   301: 		defw	p_srbank		;25. Set sram bank #
                        	   302: command_list:
                        	   303: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	   304: 
00:0200 1C              	   305: 		db		ITEM,1,4,"load",STEND,%100010,0
00:0201 01
00:0202 04
00:0203 6C6F6164
00:0207 1D
00:0208 22
00:0209 00
00:020A 1C              	   306: 		db		ITEM,2,2,"dm",	STEND,%000010,0
00:020B 02
00:020C 02
00:020D 646D
00:020F 1D
00:0210 02
00:0211 00
00:0212 1C              	   307: 		db		ITEM,3,2,"pc",	STEND,%000000,0
00:0213 03
00:0214 02
00:0215 7063
00:0217 1D
00:0218 00
00:0219 00
00:021A 1C              	   308: 		db		ITEM,4,2,"cm",	STEND,%000000,0
00:021B 04
00:021C 02
00:021D 636D
00:021F 1D
00:0220 00
00:0221 00
00:0222 1C              	   309: 		db		ITEM,5,3,"exe",	STEND,%000000,0
00:0223 05
00:0224 03
00:0225 657865
00:0228 1D
00:0229 00
00:022A 00
00:022B 1C              	   310: 		db		ITEM,6,2,"go",	STEND,%000000,0
00:022C 06
00:022D 02
00:022E 676F
00:0230 1D
00:0231 00
00:0232 00
00:0233 1C              	   311: 		db		ITEM,7,2,"++",	STEND,%000000,0
00:0234 07
00:0235 02
00:0236 2B2B
00:0238 1D
00:0239 00
00:023A 00
00:023B 1C              	   312: 		db		ITEM,8,2,"--",	STEND,%000000,0
00:023C 08
00:023D 02
00:023E 2D2D
00:0240 1D
00:0241 00
00:0242 00
00:0243 1C              	   313: 		db		ITEM,9,4,"f-on",	STEND,%000000,0
00:0244 09
00:0245 04
00:0246 662D6F6E
00:024A 1D
00:024B 00
00:024C 00
00:024D 1C              	   314: 		db		ITEM,9,8,"flash-on",	STEND,%000000,0
00:024E 09
00:024F 08
00:0250 666C6173682D6F6E
00:0258 1D
00:0259 00
00:025A 00
00:025B 1C              	   315: 		db		ITEM,10,5,"f-off",	STEND,%000000,0
00:025C 0A
00:025D 05
00:025E 662D6F6666
00:0263 1D
00:0264 00
00:0265 00
00:0266 1C              	   316: 		db		ITEM,10,9,"flash-off",	STEND,%000000,0
00:0267 0A
00:0268 09
00:0269 666C6173682D6F66
00:0271 66
00:0272 1D
00:0273 00
00:0274 00
00:0275 1C              	   317: 		db		ITEM,11,4,"flwr",	STEND,%001110,0		; write to flash: flwr  <$Addr.mem> <$Addr.flash>  <Num> (0E)
00:0276 0B
00:0277 04
00:0278 666C7772
00:027C 1D
00:027D 0E
00:027E 00
00:027F 1C              	   318: 		db		ITEM,12,4,"flse",	STEND,%000000,0
00:0280 0C
00:0281 04
00:0282 666C7365
00:0286 1D
00:0287 00
00:0288 00
00:0289 1C              	   319: 		db		ITEM,13,4,"xmod",	STEND,%001000,0		; xmodem from PC   xmod <address>
00:028A 0D
00:028B 04
00:028C 786D6F64
00:0290 1D
00:0291 08
00:0292 00
00:0293 1C              	   320: 		db		ITEM,14,3,"rst",	STEND,%000000,0
00:0294 0E
00:0295 03
00:0296 727374
00:0299 1D
00:029A 00
00:029B 00
00:029C 1C              	   321: 		db		ITEM,15,4,"sdrd",	STEND,%101000,0		; Read from SD card   sdrd  "file"  $Addr
00:029D 0F
00:029E 04
00:029F 73647264
00:02A3 1D
00:02A4 28
00:02A5 00
00:02A6 1C              	   322: 		db		ITEM,16,4,"sdwr",	STEND,%101010,0 	; Write to SD card   sdwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
00:02A7 10
00:02A8 04
00:02A9 73647772
00:02AD 1D
00:02AE 2A
00:02AF 00
00:02B0 1C              	   323: 		db		ITEM,17,5,"usbrd",	STEND,%101000,0		; Read from USB      usbrd  "file"  $Addr
00:02B1 11
00:02B2 05
00:02B3 7573627264
00:02B8 1D
00:02B9 28
00:02BA 00
00:02BB 1C              	   324: 		db		ITEM,18,5,"usbwr",	STEND,%101010,0 	; Write to USB        usbwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
00:02BC 12
00:02BD 05
00:02BE 7573627772
00:02C3 1D
00:02C4 2A
00:02C5 00
00:02C6 1C              	   325: 		db		ITEM,19,5,"sddel",	STEND,%100000,0 	; Delete file on SD card   sddel  "file"  
00:02C7 13
00:02C8 05
00:02C9 736464656C
00:02CE 1D
00:02CF 20
00:02D0 00
00:02D1 1C              	   326: 		db		ITEM,20,6,"usbdel",	STEND,%100000,0 	; Delete file on USB   usbdel  "file"  
00:02D2 14
00:02D3 06
00:02D4 75736264656C
00:02DA 1D
00:02DB 20
00:02DC 00
00:02DD 1C              	   327: 		db		ITEM,21,5,"sddir",	STEND,%100000,0 	; List root level files/dirs on sd card
00:02DE 15
00:02DF 05
00:02E0 7364646972
00:02E5 1D
00:02E6 20
00:02E7 00
00:02E8 1C              	   328: 		db		ITEM,22,6,"usbdir",	STEND,%100000,0 	; List root level files/dirs on USB
00:02E9 16
00:02EA 06
00:02EB 757362646972
00:02F1 1D
00:02F2 20
00:02F3 00
00:02F4 1C              	   329: 		db 		ITEM,23,5,"cptfl",	STEND,%001100,0		; copy from adress range to flash   cptfl  $Addr   $Addr
00:02F5 17
00:02F6 05
00:02F7 637074666C
00:02FC 1D
00:02FD 0C
00:02FE 00
00:02FF 1C              	   330: 		db 		ITEM,24,6,"flbank",	STEND,%000010,0		; set flash bank #	
00:0300 18
00:0301 06
00:0302 666C62616E6B
00:0308 1D
00:0309 02
00:030A 00
00:030B 1C              	   331: 		db 		ITEM,25,6,"srbank",	STEND,%000010,0		; set sram bank #	
00:030C 19
00:030D 06
00:030E 737262616E6B
00:0314 1D
00:0315 02
00:0316 00
00:0317 1C              	   332: 		db		ITEM,26,3,"nop",	STEND,%000000,0
00:0318 1A
00:0319 03
00:031A 6E6F70
00:031D 1D
00:031E 00
00:031F 00
00:0320 1E              	   333: 		db		LISTEND
                        	   334: commListLen  equ   27
                        	   335: 
                        	   336: 		; ld		HL,$6000
                        	   337: 		; ld		(packetBaseAddress),HL			; store the address for target code (for error correction)
                        	   338: 		; ld		A,01
                        	   339: 		; ld		(prevPacketByte01),A 				; store of packet numbers
                        	   340: 
                        	   341: 		; call 	SetupXMODEM_TXandRX					 
                        	   342: 	
                        	   343: 
                        	   344: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   345: ;---------------------------------------------------------------------------------
                        	   346: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   347: 
                        	   348: ;		skipPriorDelimit 		; increase A0 until non delimiter (NZ) or #0 (Z) 
                        	   349: ;		***		store string value in textarea and reference in table
                        	   350: ;		skipCharsUntilDelim		; increase A0 until blank (NZ) or #0 (Z) 
                        	   351: ;		***		read/store either address or lvalue and store in table
                        	   352: ; 		isDelimit(S)  is char in (A0) any of the delimiters specified in (A1) ? =>Z, else ~Z
                        	   353: ; 		Parameters returned; A0 - Address of char
                        	   354: 
                        	   355: ;		commParseTable
                        	   356: ;		***************************************************
                        	   357: ;		***	decode input line;
                        	   358: ;		*** <cmd>    "TEXT"  	$xxyyzz  xxyyzz
                        	   359: ;		*** command textstring 	address	 lvalue
                        	   360: ;		************************************************************
                        	   361: ;		*** commParseTable:
                        	   362: ;		*** 00 : W : offset in jumptable  (F080)
                        	   363: ;		*** 04 : L : address 1  (F084-F087)
                        	   364: ;		*** 08 : L : address 2  (F088-F08B)
                        	   365: ;		*** 10 : L : lvalue1  (F090-F09F)
                        	   366: ;		*** 20 : L : lvalue2  (F0A0-F0AF)
                        	   367: ;		*** 57 : L : text1   (F0B0-F0D7)
                        	   368: ;		*** 58 : L : text2 	 (F0D8-F0FF)	
                        	   369: ;		***
                        	   370: ;		***--------------------------------------
                        	   371: 
                        	   372: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   373: ;---------------------------------------------------------------------------------
                        	   374: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   375: 
                        	   376: 		; call	skipCharsUntilDelim			; set (HL) to first delimiter
                        	   377: 		; push 	HL
                        	   378: 		; pop  	BC							; typed command end+1 in BC
                        	   379: 
                        	   380: 		; ***	Prepares the commParseTable. Consumes HL,B,A
                        	   381: initCommParseTable:
00:0321 3E00            	   382: 		ld 		A,0
00:0323 320000          	   383: 		ld 		(PCinpFlag),A
00:0326 320100          	   384: 		ld 		(PCinpFlag+1),A
00:0329 210000          	   385: 		ld 		HL,commParseTable
                        	   386: 
00:032C 0680            	   387: 		ld 		B,$80
00:032E 97              	   388: 		sub 	A 					; clear A.
                        	   389: .icpt:
00:032F 77              	   390: 		ld 		(HL),A
00:0330 23              	   391: 		inc 	HL
00:0331 10FC            	   392: 		djnz 	.icpt
                        	   393: 
00:0333 C9              	   394: 		ret
                        	   395: 
                        	   396: ;---------------------------------------------------------------------------------
                        	   397: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   398: 
                        	   399: 	;***************************************************************
                        	   400: 	;	Command identified -> now search for stringh :
                        	   401: 	;***************************************************************
                        	   402: 
                        	   403: matchInList:
                        	   404: 		; ***	Command found. Then, check for string input "<string>"
                        	   405: 		; ***	DE points to first delimiter after command 
                        	   406: 						;delimiters found ? =>Z, else ~Z
                        	   407: 						;char in (HL) is '0' ->  set C, else NC
                        	   408: 
00:0334 33              	   409: 		inc 	sp
00:0335 33              	   410: 		inc 	sp						; restore PC from PUSH in <scanCommandList>
00:0336 23              	   411: 		inc 	HL 						; HL point to first after <STEND>  ->req arguments
00:0337 7E              	   412: 		ld 		A,(HL) 					; A= required arguments
00:0338 210000          	   413:  		ld 		HL,commParseTable
00:033B 71              	   414: 		ld 		(HL),C 					; store the command number in (commParseTable, F080)
00:033C 23              	   415: 		inc 	HL
00:033D 77              	   416: 		ld 		(HL),A					; store required arguments  in (commParseTable+1, F081)
                        	   417: 		; call 	writeSTRBelow_CRLF
                        	   418: 		; DB 		0,"Found a valid command  see (C).. !",CR,LF,00
00:033E 62              	   419: 		ld 		H,D
00:033F 6B              	   420: 		ld		L,E		
00:0340 2B              	   421: 		dec 	HL							; DE -> HL -> last char before delimiter
                        	   422: paramLoopEntry:	
                        	   423: 
00:0341 CD0000          	   424: 		call 	skipPriorDelimit 			; look for next char (  '"' ?)
00:0344 DA1D04          	   425: 		jp 		C,executeCommand			; C set from 'skipPriorDelimit', no command parameters
                        	   426: 
00:0347 7E              	   427: 		ld 		A,(HL)
                        	   428: 
00:0348 FE22            	   429: 		cp 		'"'							; beginning of string ?̣
00:034A 2029            	   430: 		jr 		NZ,checkaddress				;  NZ -> (HL) points to non delimiter
                        	   431: 		; ***	extract string 
00:034C 23              	   432: 		inc 	HL 							; skip '"' (HL)-> first char
                        	   433: 
00:034D 54              	   434: 		ld 		D,H
00:034E 5D              	   435: 		ld		E,L							; DE -> first char after '"' <source>
00:034F CD0000          	   436: 		call 	skipCharsUntilDelim			; find second '"'
00:0352 2B              	   437: 		dec 	HL 							; skip first delimiter (ev. CR)
00:0353 7E              	   438: 		ld 		A,(HL)
00:0354 FE22            	   439: 		cp 		'"' 						; found second '"' ??
00:0356 C29901          	   440: 		jp 		NZ,inputerror
00:0359 2B              	   441: 		dec 	HL 							; skip second '"'
                        	   442: 	;***************************************************************
                        	   443: 	;	copy string to  'commParseTable'
                        	   444: 	;***************************************************************
                        	   445: 
00:035A A7              	   446: 		and 	A
00:035B ED52            	   447: 		sbc 	HL,DE 						; amount of chars...
00:035D 44              	   448: 		ld 		B,H							; amount of chars...
00:035E 4D              	   449: 		ld 		C,L							; amount of chars...
00:035F 03              	   450: 		inc 	BC
                        	   451: 
00:0360 210000          	   452: 		ld 		HL,commStr1				; address for first string
00:0363 7E              	   453: 		ld 		A,(HL)
00:0364 B7              	   454: 		or 		A 						; =0?
00:0365 2808            	   455: 		jr 		Z, .strone
00:0367 210000          	   456: 		ld 		HL,commStr2				; address for second string
00:036A 7E              	   457: 		ld 		A,(HL)
00:036B B7              	   458: 		or  	A						; =0 ?
00:036C C29901          	   459: 		jp 		NZ,inputerror			; too many strings
                        	   460: .strone:
00:036F EB              	   461: 		ex 		DE,HL 					; HL = <source>, DE = <dest>, size = BC
00:0370 EDB0            	   462: 		ldir 							; make the copy
                        	   463: 		; ex		DE,HL
00:0372 23              	   464: 		inc 	HL 						; (HL) past the second '"'
                        	   465: 
00:0373 18CC            	   466: 		jr 		paramLoopEntry
                        	   467: 
                        	   468: 
                        	   469: 	;***************************************************************
                        	   470: 	;	Check if address is specified in input 
                        	   471: 	;***************************************************************
                        	   472: 
                        	   473: 
                        	   474: checkaddress:
                        	   475: 		; ***	A = (HL), first char after delimiter
                        	   476: 
00:0375 320100          	   477: 		ld 		(PCinpFlag+1),A			; if value '(PCinpFlag+1)' == '$' -> address input
00:0378 FE24            	   478: 		cp 		'$'						; identified address id
00:037A 3E00            	   479: 		ld 		A,0
00:037C 2023            	   480: 		jr 		NZ,getLvalue			; first value of A (PCinpFlag+1) is '$' ??
00:037E 23              	   481: 		inc 	HL 						; skip past '$'
                        	   482: 
                        	   483: chkADR1:
                        	   484: 	; ***		Check where to store address...
                        	   485: 
00:037F DD210000        	   486: 		ld 		IX,commAdr1
                        	   487: 		; ld 		A,0
00:0383 DDBE00          	   488: 		cp 		(IX)			; check if zero ? (already stored)
00:0386 2007            	   489: 		jr 		NZ,chkADR2
00:0388 DDBE01          	   490: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
00:038B 2002            	   491: 		jr 		NZ,chkADR2
00:038D 1832            	   492: 		jr 		makeASCIItoHEX
                        	   493: chkADR2:
                        	   494: 
00:038F DD210000        	   495: 		ld 		IX,commAdr2
                        	   496: 		; ld 		A,0
00:0393 DDBE00          	   497: 		cp 		(IX)			; check if zero ? (already stored)
00:0396 C29901          	   498: 		jp 		NZ,inputerror	; error : No more addresses to store
00:0399 DDBE01          	   499: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
00:039C C29901          	   500: 		jp 		NZ,inputerror	; error : No more addresses to store
00:039F 1820            	   501: 		jr 		makeASCIItoHEX
                        	   502: 
                        	   503: getLvalue:
00:03A1 DD210000        	   504: 		ld 		IX,commLvl1
00:03A5 DDBE00          	   505: 		cp 		(IX)			; check if zero ? (already stored)
00:03A8 2007            	   506: 		jr 		NZ,chkLVL2
00:03AA DDBE01          	   507: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
00:03AD 2002            	   508: 		jr 		NZ,chkLVL2
00:03AF 1810            	   509: 		jr 		makeASCIItoHEX
                        	   510: 
                        	   511: chkLVL2:
00:03B1 DD210000        	   512: 		ld 		IX,commLvl2
00:03B5 DDBE00          	   513: 		cp 		(IX)			; check if zero ? (already stored)
00:03B8 C29901          	   514: 		jp 		NZ,inputerror	; error : No more addresses to store
00:03BB DDBE01          	   515: 		cp 		(IX+1)			; check if zero (byte 2) ? (already stored)
00:03BE C29901          	   516: 		jp 		NZ,inputerror	; error : No more addresses to store
                        	   517: 
                        	   518: 
                        	   519: makeASCIItoHEX:
                        	   520: 		; ***	copy from command line to adr or lvalue in table
                        	   521: 		; ***	only two bytes (four chars)....
                        	   522: 		; 		IX point to destination...
00:03C1 54              	   523: 		ld 		D,H
00:03C2 5D              	   524: 		ld		E,L						; DE -> first char after '$' <source>
00:03C3 CD0000          	   525: 		call 	skipCharsUntilDelim			; find next delimiter or CR ; adr in HL
00:03C6 7E              	   526: 		ld 		A,(HL)
                        	   527: 
                        	   528: 	;***************************************************************
                        	   529: 	;	copy string to  'commParseTable', IX points to dest address.
                        	   530: 	;***************************************************************
                        	   531: 
00:03C7 A7              	   532: 		and 	A						; clear C
00:03C8 ED52            	   533: 		sbc 	HL,DE 					; amount of chars...->HL ( H=0); DE -> first char after '$' <source>
                        	   534: 
                        	   535: 		; ***	Do not check even or odd...
                        	   536: 		; bit 	0,L 					; even or odd (=1)?
                        	   537: 		; jp 		NZ,inputerror
                        	   538: 
00:03CA 45              	   539: 		ld 		B,L 					; char counter
00:03CB 210000          	   540: 		ld 		HL,00					;  
                        	   541: 
00:03CE EB              	   542: 		ex 		DE,HL					; HL -> first char after '$' <source>	
                        	   543: 
                        	   544: nextHalfByte:
                        	   545: 
00:03CF CD0000          	   546: 		call 	isHex					; return with Carry, value in A is NOT HEX
00:03D2 DA9901          	   547: 		jp 		C,inputerror			; 		; return with Carry, value in A is NOT HEX
                        	   548: 
00:03D5 CB23            	   549: 		sla 	E						; shift left E-> Carry
00:03D7 CB12            	   550: 		rl 		D 						; Carry -> rotate left D
00:03D9 CB23            	   551: 		sla 	E						; shift left E-> Carry
00:03DB CB12            	   552: 		rl 		D 						; Carry -> rotate left D
00:03DD CB23            	   553: 		sla 	E						; shift left E-> Carry
00:03DF CB12            	   554: 		rl 		D 						; Carry -> rotate left D
00:03E1 CB23            	   555: 		sla 	E						; shift left E-> Carry
00:03E3 CB12            	   556: 		rl 		D 						; Carry -> rotate left D
00:03E5 B3              	   557: 		or      E  						; A OR E(0..3) are zero
00:03E6 5F              	   558: 		ld 		E,A
                        	   559: 
00:03E7 DD7300          	   560: 		ld 		(IX),E					; store E value [big endian]
00:03EA DD7201          	   561: 		ld 		(IX+1),D				; store D value [big endian]
                        	   562: 
00:03ED 23              	   563: 		inc 	HL
                        	   564: 		; inc 	IX
00:03EE 10DF            	   565: 		djnz 	nextHalfByte
                        	   566: 		;***	HL should point to first delimiter...
                        	   567: 
                        	   568: byteEnd:
                        	   569: 
00:03F0 3A0000          	   570: 		ld  	A,(PCinpFlag)
00:03F3 B7              	   571: 		or  	A 						; check Z; =0 -> normal parameter save
00:03F4 CA4103          	   572: 		jp 	   	Z,paramLoopEntry
                        	   573: 
00:03F7 3A0100          	   574: 		ld  	A,(PCinpFlag+1) 		; address input for PCValue ?
00:03FA FE24            	   575: 		cp 		'$' 					; adress flag ?
00:03FC 2814            	   576: 		jr 		Z,changePCVal
                        	   577: 		; ***	Store Bytes from LVL1 to (PCval) this is not finished...
                        	   578: 
00:03FE E5              	   579: 		push 	HL
00:03FF 2A0000          	   580: 		ld 		HL,(PCvalue)	
00:0402 110000          	   581: 		ld 		DE,commLvl1
00:0405 1A              	   582: 		ld 		A,(DE)
00:0406 77              	   583: 		ld 		(HL),A
00:0407 23              	   584: 		inc 	HL
00:0408 13              	   585: 		inc 	DE
00:0409 1A              	   586: 		ld 		A,(DE)
00:040A B7              	   587: 		or 		A
00:040B 2801            	   588: 		jr 		Z,noHighNib
00:040D 77              	   589: 		ld 		(HL),A
                        	   590: noHighNib:
00:040E E1              	   591: 		pop 	HL		
                        	   592: 		; ***	reset flag
                        	   593: 		; ld 		A,0
                        	   594: 		; ld 		(PCinpFlag),A
                        	   595: 		; ld 		(PCinpFlag+1),A
00:040F C34103          	   596: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   597: 
                        	   598: changePCVal:
                        	   599: 		; ***	Change PCvalue from 'commAdr1'
00:0412 E5              	   600: 		push 	HL
00:0413 2A0000          	   601: 		ld 		HL,(commAdr1)
00:0416 220000          	   602: 		ld 		(PCvalue),HL
00:0419 E1              	   603: 		pop 	HL 						; restore value of first delimiter
00:041A C34103          	   604: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   605: 
                        	   606: executeCommand:	
                        	   607: 		; ***	execute commands (and arguments)
                        	   608: 		; call 	writeSTRBelow
                        	   609: 		; DB 		0,"Finish parsing !",CR,LF,00
                        	   610: 		; call 	DumpRegisters			; checkpoint for list of arguments
                        	   611: 
00:041D 3A0000          	   612: 		ld 		A,(PCinpFlag)
00:0420 B7              	   613: 		or 		A   					; check if zero  
00:0421 2003            	   614: 		jr 		NZ,.noJump
                        	   615: 
00:0423 CD3104          	   616: 		call 	JPTable01
                        	   617: .noJump:
                        	   618: 		; ***	reset flag
00:0426 3E00            	   619: 		ld 		A,0
00:0428 320000          	   620: 		ld 		(PCinpFlag),A
00:042B 320100          	   621: 		ld 		(PCinpFlag+1),A
                        	   622: 
                        	   623: 		
                        	   624: 		; jp 		paramLoopEntry 				; loop and check for more parameters
                        	   625: 
                        	   626: temp_finish:
                        	   627: 		; call 	DumpRegisters
00:042E C3F900          	   628: 		jp 		next_line
                        	   629: 
                        	   630: 	;***************************************************************
                        	   631: 	;	Check if LVALUE is specified in input 
                        	   632: 	;***************************************************************
                        	   633: 
                        	   634: JPTable01:
00:0431 3A0000          	   635: 		ld 		A,(commParseTable) 			; retrieve command number
00:0434 B7              	   636: 		or 	  	A 							; error if 0
00:0435 CA9901          	   637: 		jp 		Z,inputerror
00:0438 FE1B            	   638: 		cp 		commListLen
00:043A 3F              	   639: 		ccf 						;complement carry for error indicator
                        	   640: 
00:043B DA9901          	   641: 		jp      C,inputerror
                        	   642: 
00:043E E5              	   643: 		push  	HL
00:043F CB27            	   644: 		sla 	A 							; multiply *2
00:0441 21CC01          	   645: 		ld 		HL,command_addresses
                        	   646: 
00:0444 85              	   647: 		add		A, L						; addition to avoid disturbing
00:0445 6F              	   648: 		ld 		L,A							; another register pair
00:0446 3E00            	   649: 		ld		A,0
00:0448 8C              	   650: 		adc		A,H
00:0449 67              	   651: 		ld		H, A						; access routine address
                        	   652: 
                        	   653: 										;obtain routine address from table and transfer 
                        	   654: 										;control to it, leaving all register pairs unchanged
                        	   655: 		
00:044A 7E              	   656: 		ld 		A,(HL)
                        	   657: 
00:044B 23              	   658: 		inc 	HL
00:044C 66              	   659: 		ld 		H,(HL)
00:044D 6F              	   660: 		ld 		L,A
                        	   661: 
00:044E E3              	   662: 		ex 		(SP),HL					;restore old HL, push routine address
00:044F C9              	   663: 		ret 							; jump to routine
                        	   664: 
                        	   665: 		; exx
                        	   666: 		; ld		HL,$0077
                        	   667: 		; exx	
                        	   668: 		; call DumpRegisters
                        	   669: argumentsError:
00:0450 CD0000          	   670: 		call 	writeSTRBelow
00:0453 00              	   671: 		DB 		0,"Some arguments mismatch !",CR,LF,00
00:0454 536F6D6520617267
00:045C 756D656E7473206D
00:0464 69736D6174636820
00:046C 21
00:046D 0D
00:046E 0A
00:046F 00
00:0470 C9              	   672: 		ret
                        	   673: 
                        	   674: 
                        	   675: p_reset:
00:0471 AF              	   676: 		xor 	A
00:0472 320000          	   677: 		ld 		(memBankID),A			; set memory banks #0
00:0475 CD0000          	   678: 		call 	setFLASHBank			; FLASH bank #0
00:0478 AF              	   679: 		xor 	A
00:0479 CD0000          	   680: 		call 	setSRAMBank				; ram bank #0
                        	   681: 
00:047C CD0000          	   682: 		call 	enableFLASH			; start from FLASH
                        	   683: 
00:047F CD0000          	   684: 		call 	enableIC620_OE 			; enable the outputs.
                        	   685: 
00:0482 C30000          	   686: 		jp $0000
                        	   687: 
                        	   688: p_load:
00:0485 C9              	   689: 		ret
                        	   690: p_dumpmem:
00:0486 CD0000          	   691: 		call 	dumpMemory
                        	   692: 
00:0489 C9              	   693: 		ret
                        	   694: p_pc:
00:048A C9              	   695: 		ret
                        	   696: p_clearmem:
00:048B C9              	   697: 		ret
                        	   698: p_exe:
00:048C C9              	   699: 		ret
                        	   700: p_go:
                        	   701: 
00:048D 3A0000          	   702: 		ld 		A,(TempVar1)
00:0490 3C              	   703: 		inc 	A
00:0491 320000          	   704: 		ld 		(TempVar1),A
00:0494 FE0F            	   705: 		cp 		15
00:0496 CD0000          	   706: 		call 	DumpRegisters
                        	   707: 		
00:0499 F0              	   708: 		ret 	P
00:049A 18F1            	   709: 		jr 		p_go
                        	   710: p_incDecPC:
00:049C 210000          	   711: 		ld 		HL,commLvl1
00:049F 3E00            	   712: 		ld 		A,0
00:04A1 5E              	   713: 		ld 		E,(HL)
00:04A2 23              	   714: 		inc 	HL
00:04A3 56              	   715: 		ld 		D,(hl) 				; DE = (commLvl1)
                        	   716: 		; ***	if both D and E is 0 -> DE = 1 		; no param -> A=1
00:04A4 BB              	   717: 		cp 		E
00:04A5 2006            	   718: 		jr 		NZ,.justOne
00:04A7 BA              	   719: 		cp 		D
00:04A8 2003            	   720: 		jr 		NZ,.justOne
00:04AA 110100          	   721: 		ld 		DE,1
                        	   722: .justOne:
00:04AD 3A0000          	   723: 		ld 		A,(commParseTable)
00:04B0 2A0000          	   724: 		ld 		HL,(PCvalue)
00:04B3 FE07            	   725: 		cp 		7 					; ++ (increase) ??
00:04B5 2003            	   726: 		jr  	nz,.sub
00:04B7 19              	   727: 		add 	HL,DE 				; increase HL (PCvalue) with DE
00:04B8 1803            	   728: 		jr 		.common
                        	   729: .sub:
00:04BA A7              	   730: 		and 	A					; clear C
00:04BB ED52            	   731: 		sbc 	HL,DE 				; decrease HL (PCvalue) with DE
                        	   732: .common:
00:04BD 220000          	   733: 		ld 		(PCvalue),HL
00:04C0 C9              	   734: 		ret
                        	   735: 
                        	   736: p_FON:
                        	   737: 		; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0)
                        	   738: 
00:04C1 CD0000          	   739: 		call 	enableFLASH
                        	   740: 
                        	   741: 
00:04C4 CD0000          	   742: 		call 	writeSTRBelow
00:04C7 00              	   743: 		DB 		0," Use 256k FLASH (7 banks),lower 32k and SRAM (bank16),upper 32k !",CR,LF,00
00:04C8 2055736520323536
00:04D0 6B20464C41534820
00:04D8 28372062616E6B73
00:04E0 292C6C6F77657220
00:04E8 33326B20616E6420
00:04F0 5352414D20286261
00:04F8 6E6B3136292C7570
00:0500 7065722033326B20
00:0508 21
00:0509 0D
00:050A 0A
00:050B 00
00:050C C9              	   744: 		ret
                        	   745: 
                        	   746: p_FOFF:
                        	   747: 		; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1)
00:050D CD0000          	   748: 		call 	disableFLASH
                        	   749: 
00:0510 CD0000          	   750: 		call 	writeSTRBelow
00:0513 00              	   751: 		DB 		0," Use only 512k (16 banks) SRAM !",CR,LF,00
00:0514 20557365206F6E6C
00:051C 79203531326B2028
00:0524 31362062616E6B73
00:052C 29205352414D2021
00:0534 0D
00:0535 0A
00:0536 00
                        	   752: 
00:0537 C9              	   753: 		ret
                        	   754: 
                        	   755: p_flwr:
                        	   756: 		; *** 	testwrite to EEPROM
                        	   757: 		
                        	   758: 		; call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
                        	   759: 		; jp		NZ,argumentsError			; show argument error and return
                        	   760: 		; 	*** Check if flashmem is enabled
00:0538 3A0000          	   761: 		ld 		A,(memBankID)
00:053B CB7F            	   762: 		bit 	7,A
00:053D 2004            	   763: 		jr 		NZ,errNoFlash
                        	   764: 
00:053F CD0000          	   765: 		call 	Flash_WR_Test
00:0542 C9              	   766: 		ret
                        	   767: errNoFlash:
00:0543 CD0000          	   768: 		call 	writeSTRBelow
00:0546 00              	   769: 		DB 		0," Can't write to deselected FLASH !",CR,LF,00
00:0547 2043616E27742077
00:054F 7269746520746F20
00:0557 646573656C656374
00:055F 656420464C415348
00:0567 2021
00:0569 0D
00:056A 0A
00:056B 00
                        	   770: 
00:056C C9              	   771: 		ret
                        	   772: 
                        	   773: 
                        	   774: p_flse:
                        	   775: 		; *** 	erase the sector that contain the address of HL
                        	   776: 
00:056D E5              	   777: 		push	HL
00:056E 211020          	   778: 		ld 		HL,$2010
00:0571 CD0000          	   779: 		call 	Flash_SE_Erase
00:0574 E1              	   780: 		pop 	HL
00:0575 C9              	   781: 		ret
                        	   782: 
                        	   783: p_xmod:
                        	   784: 		; ***	Transfer files via x-modem
                        	   785: 		; ***	Check commParseTable+1 if required parameters
                        	   786: 
00:0576 3A0100          	   787: 		ld 		A,(commParseTable+1)
00:0579 CB47            	   788: 		bit 	0,A 			; should be a <2-textstring 	1-address	 0-lvalue>
00:057B 2804            	   789: 		jr 		Z,.nxta
                        	   790: 		; ***	check the commLvl1 if zero
00:057D ED5B0000        	   791: 		ld 		DE,(commLvl1)
                        	   792: .nxta:		
                        	   793: 
                        	   794: 
00:0581 CD0000          	   795: 		call 	doImportXMODEM
                        	   796: 
00:0584 CD0000          	   797: 		call 	SIO_0_A_TXRX_INTon
00:0587 CD0000          	   798: 		call 	CTC1_INT_OFF
                        	   799: 	
00:058A C9              	   800: 		ret
                        	   801: 
                        	   802: p_C_Read:
                        	   803: 
00:058B CD7A06          	   804: 		call 	checkArgsTAL				; check necessary args
00:058E C25004          	   805: 		jp		NZ,argumentsError			; show argument error and return
                        	   806: 
00:0591 110000          	   807: 		ld 		DE,CTC_delay_INT_handler
00:0594 ED5312F4        	   808: 		ld 		(CTC_CH1_I_Vector),DE
                        	   809: 
00:0598 CD0000          	   810: 		call 	purgeRXB
00:059B CD0000          	   811: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
00:059E CD0000          	   812: 		call 	HC376S_ResetAll
00:05A1 CD0000          	   813: 		call 	HC376S_CheckConnection
00:05A4 3A0000          	   814: 		ld 		A,(commParseTable)
00:05A7 FE0F            	   815: 		cp 		15							; 15 read SD; 17-read USB
00:05A9 280C            	   816: 		jr 		Z,.doSD
00:05AB FE15            	   817: 		cp 		21							; 21 read SD enumerate, 22 read USB enumerate
00:05AD 2808            	   818: 		jr 		Z,.doSD
00:05AF CD0000          	   819: 		call 	HC376S_setUSBMode
00:05B2 CD0000          	   820: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
00:05B5 1803            	   821: 		jr 		.cont
                        	   822: .doSD:
00:05B7 CD0000          	   823: 		call 	HC376S_setSDMode
                        	   824: 		
                        	   825: .cont:
00:05BA CD0000          	   826: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:05BD 2011            	   827: 		jr 		NZ,abort
00:05BF CD0000          	   828: 		call 	HC376S_setFileName
00:05C2 CD0000          	   829: 		call 	HC376S_fileOpen
00:05C5 2009            	   830: 		jr 		NZ,abort
                        	   831: 
00:05C7 CD0000          	   832: 		call 	HC376S_getFileSize
00:05CA CD0000          	   833: 		call 	HC376S_fileRead
00:05CD CD0000          	   834: 		call 	HC376S_fileClose
                        	   835: abort:
                        	   836: 
                        	   837: 		; ***	reset the interrupt handler for CTC
00:05D0 CD0000          	   838: 		call 	HC376S_ResetAll
00:05D3 CD0000          	   839: 		call 	CTC1_INT_OFF
00:05D6 210000          	   840: 		ld		HL,CTC_CH1_Interrupt_Handler
00:05D9 2212F4          	   841: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:05DC C9              	   842: 		ret
                        	   843: 
                        	   844: 		
                        	   845: p_C_Write:
00:05DD CD7A06          	   846: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
00:05E0 2816            	   847: 		jr 		Z,.contWR
                        	   848: 		; ***	check alternative (2 adresses)
00:05E2 3E2C            	   849: 		ld 		A,%101100					; alt. with "string" $Adr1 < $Adr2
00:05E4 77              	   850: 		ld 		(HL),A						; HL-> (commParseTable+1);
00:05E5 23              	   851: 		inc 	HL			; HL-> (commParseTable+2); get the resulting arguments counted
00:05E6 BE              	   852: 		cp 		(HL) 						; compare resulting arguments with req arguments
                        	   853: 
00:05E7 C25004          	   854: 		jp		NZ,argumentsError			; show argument error and return
                        	   855: 		
                        	   856: 		; ***	calculate size from addresses $Adr2 - $Adr1
00:05EA 37              	   857: 		scf
00:05EB 3F              	   858: 		ccf
00:05EC 2A0000          	   859: 		ld 		HL,(commAdr2)
00:05EF ED5B0000        	   860: 		ld		DE,(commAdr1)
00:05F3 ED52            	   861: 		sbc		HL,DE
00:05F5 220000          	   862: 		ld 		(commLvl1),HL				; resulting size in commLvl1
                        	   863: 
                        	   864: 
                        	   865: .contWR:
00:05F8 110000          	   866: 		ld 		DE,CTC_delay_INT_handler
00:05FB ED5312F4        	   867: 		ld 		(CTC_CH1_I_Vector),DE
                        	   868: 
00:05FF CD0000          	   869: 		call 	purgeRXB
00:0602 CD0000          	   870: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
00:0605 CD0000          	   871: 		call 	HC376S_ResetAll
00:0608 CD0000          	   872: 		call 	HC376S_CheckConnection
00:060B 3A0000          	   873: 		ld 		A,(commParseTable)
00:060E FE10            	   874: 		cp 		16							; 16 read SD; 18-read USB
00:0610 2808            	   875: 		jr 		Z,.doSD
00:0612 CD0000          	   876: 		call 	HC376S_setUSBMode
00:0615 CD0000          	   877: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
00:0618 1803            	   878: 		jr 		.cont
                        	   879: .doSD:
00:061A CD0000          	   880: 		call 	HC376S_setSDMode
                        	   881: .cont:
00:061D CD0000          	   882: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:0620 20AE            	   883: 		jr 		NZ,abort
00:0622 CD0000          	   884: 		call 	HC376S_setFileName
00:0625 CD0000          	   885: 		call 	HC376S_fileCreate
00:0628 20A6            	   886: 		jr		NZ,abort
00:062A CD0000          	   887: 		call 	HC376S_fileWrite
                        	   888: 		
00:062D CD0000          	   889: 		call 	HC376S_fileClose
00:0630 CD0000          	   890: 		call 	HC376S_ResetAll
00:0633 189B            	   891: 		jr 		abort
                        	   892: 
                        	   893: p_C_Delete:
00:0635 CD7A06          	   894: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1  )
00:0638 C25004          	   895: 		jP 		NZ,argumentsError
00:063B 110000          	   896: 		ld 		DE,CTC_delay_INT_handler
00:063E ED5312F4        	   897: 		ld 		(CTC_CH1_I_Vector),DE
                        	   898: 
00:0642 CD0000          	   899: 		call 	purgeRXB
00:0645 CD0000          	   900: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
                        	   901: 
00:0648 CD0000          	   902: 		call 	HC376S_ResetAll
00:064B CD0000          	   903: 		call 	HC376S_CheckConnection
00:064E 3A0000          	   904: 		ld 		A,(commParseTable)
00:0651 FE13            	   905: 		cp 		19							; 19 delete file SD; 20-delete file USB
00:0653 2808            	   906: 		jr 		Z,.doSD
00:0655 CD0000          	   907: 		call 	HC376S_setUSBMode
00:0658 CD0000          	   908: 		call 	HC376S_diskConnectionStatus
00:065B 1803            	   909: 		jr 		.cont
                        	   910: .doSD:
00:065D CD0000          	   911: 		call 	HC376S_setSDMode
                        	   912: .cont:
00:0660 CD0000          	   913: 		call 	HC376S_USBdiskMount
                        	   914: 		 
                        	   915: 		; call 	HC376S_fileOpen
                        	   916: 		; call 	HC376S_getFileSize
                        	   917: 		; call 	HC376S_fileRead
                        	   918: 
00:0663 CD0000          	   919: 		call 	HC376S_fileDelete
00:0666 CD0000          	   920: 		call 	HC376S_ResetAll
                        	   921: 
00:0669 C3D005          	   922: 		jp 		abort
                        	   923: 
                        	   924: p_cptFl:
                        	   925: p_flbank:
                        	   926: 		; ***	set flash bank #
00:066C 3A0000          	   927: 		ld 		A,(commLvl1) 			; load param into A
00:066F CD0000          	   928: 		call 	setFLASHBank				; change to bank
00:0672 C9              	   929: 		ret
                        	   930: p_srbank:
                        	   931: 		; ***	set sram bank #
00:0673 3A0000          	   932: 		ld 		A,(commLvl1) 			; load param into A
00:0676 CD0000          	   933: 		call 	setSRAMBank 			; change to bank
00:0679 C9              	   934: 		ret
                        	   935: 
                        	   936: 
                        	   937: ;********************************************************************************************     
                        	   938: ;********************************************************************************************     
                        	   939: 
                        	   940: 		; ***	Check commParseTable+1 if required parameters
                        	   941: checkArgsTAL:		
                        	   942: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	   943: 
                        	   944: 		; ***	try to connect to USB
00:067A 210200          	   945: 		ld 		HL,commParseTable+2				; resulting typed arguments
00:067D 3E00            	   946: 		ld 		A,0
00:067F 77              	   947: 		ld 		(HL),A
                        	   948: 
00:0680 DD210000        	   949: 		ld 		IX,commStr1			; commStr1 =			0xB0
00:0684 CDAE06          	   950: 		call 	shift_0_1:
00:0687 DD210000        	   951: 		ld 		IX,commStr2			; commStr2 =			0xD8
00:068B CDAE06          	   952: 		call 	shift_0_1:
00:068E DD210000        	   953: 		ld 		IX,commAdr1			; commAdr1 =			0x84
00:0692 CDAE06          	   954: 		call 	shift_0_1:
00:0695 DD210000        	   955: 		ld 		IX,commAdr2			; commAdr2 =			0x88
00:0699 CDAE06          	   956: 		call 	shift_0_1:
00:069C DD210000        	   957: 		ld 		IX,commLvl1			; commLvl1 =			0x90
00:06A0 CDAE06          	   958: 		call 	shift_0_1:
00:06A3 DD210000        	   959: 		ld 		IX,commLvl2			; commLvl2 =			0xA0
00:06A7 CDAE06          	   960: 		call 	shift_0_1:
                        	   961: 
00:06AA 7E              	   962: 		ld 		A,(HL)						; get the resulting arguments counted
00:06AB 2B              	   963: 		dec 	HL
00:06AC BE              	   964: 		cp 		(HL) 						; compare resulting arguments with req arguments
00:06AD C9              	   965: 		ret 	 					; return with Z or NZ  arguments
                        	   966: 
                        	   967: shift_0_1:
00:06AE DDBE00          	   968: 		cp 		(IX)
00:06B1 2008            	   969: 		jr 		NZ,shiftIn1
00:06B3 DDBE01          	   970: 		cp 		(IX+1)
00:06B6 2003            	   971: 		jr 		NZ,shiftIn1
                        	   972: 		; ***	both =0 shift in '0'
00:06B8 CB26            	   973: 		sla		(HL)
00:06BA C9              	   974: 		ret
                        	   975: shiftIn1:
                        	   976: 		; ***	least one not '0' shift in '1'
00:06BB 37              	   977: 		scf		
00:06BC CB16            	   978: 		rl 		(HL)
00:06BE C9              	   979: 		ret
                        	   980: 
                        	   981: 
                        	   982: ;********************************************************************************************     
                        	   983: ;********************************************************************************************     
                        	   984: 
                        	   985: bit_test9:
00:06BF 01              	   986: 	db	0x01,0x02,0x80,0x40
00:06C0 02
00:06C1 80
00:06C2 40
                        	   987: 
                        	   988: 
                        	   989: ; debug:		equ	0		; Set to 1 to show debug printing, else 0 
                        	   990: 
                        	   991: 
                        	   992: 	; Spin loop here because there is nothing else to do
                        	   993: ; halt_loop:
                        	   994: ; 	halt
                        	   995: ; 	jp	halt_loop
                        	   996: 
                        	   997: 
                        	   998: 
                        	   999: 
                        	  1000: 
                        	  1001: ;*******************************************************************************     
                        	  1002: ;*******************************************************************************     
                        	  1003: 
                        	  1004: 
                        	  1005: 
                        	  1006: 		; ld 		hl,Textbuf
                        	  1007: 		; ; call	ReadLine 			;to textbuf  (A=length of input string)
                        	  1008: 
                        	  1009: 		; ld		HL,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	  1010: 		; ld		DE,Textbuf			;DE = 32767
                        	  1011: 		; call	BN2DEC				; C0NVERT
                        	  1012: 		; jp		textloop
                        	  1013: 
                        	  1014: 
                        	  1015: 		; ld 		hl,Textbuf
                        	  1016: 		; call	DEC2BN			; result in HL
                        	  1017: 
                        	  1018: 		; ld 		E,L
                        	  1019: 		; 	; Binary to HEX  BN2HEX   E->(HL)
                        	  1020: 		; ld 		hl,T_BUFFER
                        	  1021: 		; inc		hl
                        	  1022: 		; call	Bin2Hex8			;result in T_buffer
                        	  1023: 
                        	  1024: 		; ld 		iy,T_BUFFER
                        	  1025: 		; call 	WriteLineCRNL
                        	  1026: 
                        	  1027: 		; ld 		iy,Textbuf
                        	  1028: 		; call	WriteLineCRNL
                        	  1029: 
                        	  1030: 		; jp 		next_line
                        	  1031: 
                        	  1032: 
                        	  1033: 
                        	  1034: textloop:
                        	  1035: 		; LD		HL,sourctext1
                        	  1036: 		; LD		DE,S1x
                        	  1037: 		; LD		BC,src_size
                        	  1038: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1039: 
                        	  1040: 
                        	  1041: 		; LD		HL,sourctext2
                        	  1042: 		; LD		DE,S2x
                        	  1043: 		; LD		BC,14
                        	  1044: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1045: 
                        	  1046: 		; test of string concat
                        	  1047: 		; LD		HL,S1_8B		;HL = BASE ADDRESS OF S1
                        	  1048: 		; LD		DE,S2_8B		;DE = BASE ADDRESS OF S2
                        	  1049: 		; LD		B,40			;B = MAXIMUM LENGTH OF STRING 1
                        	  1050: 		; CALL 	CONCAT 			;CONCATENATE STRINGS to S1_8B
                        	  1051: 
                        	  1052: 
                        	  1053: 		; test of POS
                        	  1054: 		; LD		HL,Str2			;HL = BASE ADDRESS OF STRING
                        	  1055: 		; LD		DE,subst		;DE = BASE ADDRESS OF SUBSTRING	
                        	  1056: 		; CALL	POS				;FIND POSITION OF SUBSTRING
                        	  1057: 								; RESULTS IN REGISTER A = 8
                        	  1058: 
                        	  1059: 
                        	  1060: 		; test copy
                        	  1061: 		; LD		HL,Str4			; SOURCE STRING
                        	  1062: 		; LD		DE,COPY_BUFFER	;	DESTINATION STRING
                        	  1063: 		
                        	  1064: 		; LD		C,4				; STARTING INDEX FOR COPYING
                        	  1065: 
                        	  1066: 		; LD		B,6				; NUMBER OF BYTES TO COPY
                        	  1067: 		; LD		A, 25			; MAXIMUM LENGTH OF SUBSTRING
                        	  1068: 		; CALL 	COPY			; COPY SUBSTRING
                        	  1069: 
                        	  1070: 		; ld 		iy,COPY_BUFFER
                        	  1071: 		; call 		WriteLineCRNL ; print the copy string
                        	  1072: 
                        	  1073: 
                        	  1074: 		; ; test DELETE
                        	  1075: 		; LD		HL,Str0		;HL	= BASE 	ADDRESS OF STRING
                        	  1076: 		; LD		A,8			
                        	  1077: 		; LD		C,8				;	C= STARTING INDEX FOR DELETION
                        	  1078: 		; LD		A,4			
                        	  1079: 		; LD		B,4			; B = NUMBER OF CHARACTERS TO DELETE
                        	  1080: 		; CALL 	DELETE 			; DELETE CHARACTERS
                        	  1081: 									; DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	  1082: 		; ld 		iy,Str0
                        	  1083: 		; call 		WriteLineCRNL ; print the copy string
                        	  1084: 
                        	  1085: 
                        	  1086: ; 		;test INSERT
                        	  1087: 
                        	  1088: ; 		LD		HL,Str3				; HL = BASE ADDRESS OF STRING
                        	  1089: ; 		LD		DE,subst			; DE = BASE ADDRESS OF SUBSTRING
                        	  1090: 
                        	  1091: ; 		LD		C,7					; C = STARTING INDEX FOR INSERTION
                        	  1092: 
                        	  1093: ; 		LD		B,0x40				; B = MAXIMUM LENGTH OF STRING
                        	  1094: ; 		CALL 	INSERT_STR			; INSERT SUBSTRING
                        	  1095: ; 		ld 		iy,Str3
                        	  1096: ; 		; call	WriteLineCRNL 		; print the modified string
                        	  1097: 
                        	  1098: 
                        	  1099: ; 		jp		next_line
                        	  1100: 
                        	  1101: ; 		;TEST DATA. CHANGE FOR OTHER VALUES
                        	  1102: ; S1_8B:	DB		8H				; LENGTH OF SI
                        	  1103: ; 		DB      "LASTNAME                        "	; 32 BYTE MAX LENGTH
                        	  1104: ; S2_8B:	DB		0BH				;LENGTH OF S2
                        	  1105: ; 		DB		". FIRSTNAME                     "	; 32 BYTE MAX LENGTH
                        	  1106: 
                        	  1107: ;********************************************************************************************
                        	  1108: ;********************************************************************************************	
                        	  1109: ; sh_test:
                        	  1110: ; 		; turn shadow off then halt
                        	  1111: ; 		xor A
                        	  1112: ; 		out (_CE_RST_BANK),A 		;// clear '64K_SRAM' signal
                        	  1113: 
                        	  1114: ; 		halt
                        	  1115: 
                        	  1116: ; 		ld	A,$80
                        	  1117: ; 		out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	  1118: ; 		ld 	A,1
                        	  1119: ; 		out (_CE_RST_BANK),A 		; engage 3-state on bank#
                        	  1120: ; 		ret
                        	  1121: 
                        	  1122: 
                        	  1123: ;********************************************************************************************
                        	  1124: ;********************************************************************************************	
                        	  1125: 			;9H JUMP TABLE (JTAB)   353
                        	  1126:         ; Title               Jump table
                        	  1127:         ; Name:               JTAB
                        	  1128:         ; Purpose:            Given an index, jump to the subroutine with
                        	  1129:         ;                     that index in a table.
                        	  1130:         ; Entry:              Register A is the subroutine number (0 to
                        	  1131:         ;                                LENSUB-l, the number of subroutines)
                        	  1132:         ;                                LENSUB must be less than or equal to
                        	  1133:         ;                                128.
                        	  1134:         ; Exit:               If the routine number is valid then
                        	  1135:         ;                       execute the routine
                        	  1136:         ;                     else
                        	  1137:         ;                       Carry flag = 1
                        	  1138:         ; Registers used: AF
                        	  1139:         ; Time:               117 cycles plus execution time of subroutine
                        	  1140:         ; Size:               Program 21 bytes plus size of table (2*LENSUB)
                        	  1141: 
                        	  1142:         ;EXIT WITH CARRY SET IF ROUTINE NUMBER IS INVALID
                        	  1143:         ; THAT IS, IF IT IS TOO LARGE FOR TABLE OLENSUB -     1)
                        	  1144: 
                        	  1145: 
                        	  1146: ; JTAB:
                        	  1147: ; 		CP		LENSUB			;COMPARE ROUTINE NUMBER, TABLE SIZE
                        	  1148: ; 		CCF						;COMPLEMENT CARRY FOR ERROR INDICATOR
                        	  1149: ; 		RET		C				;RETURN IF ROUTINE NUMBER TOO LARGE
                        	  1150: ; 									; WITH CARRY SET
                        	  1151: ; 		; INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
                        	  1152: ; 		; LEAVE REGISTER PAIRS UNCHANGED SO THEY CAN BE USED FOR PASSING PARAMETERS
                        	  1153: 
                        	  1154: ; 		PUSH	HL				;SAVE HL
                        	  1155: ; 		ADD		A,A				;DOUBLE INDEX FOR WORD-LENGTH ENTRIES
                        	  1156: ; 		LD		HL,JMPTAB		;INDEX INTO TABLE USING 8-BIT
                        	  1157: ; 		ADD		A,L			; ADDITION TO AVOID DISTURBING
                        	  1158: ; 		LD		L,A				; ANOTHER REGISTER PAIR
                        	  1159: ; 		LD		A,0
                        	  1160: ; 		ADC		A,H
                        	  1161: ; 		LD		H,A			; ACCESS ROUTINE ADDRESS
                        	  1162: ; 			;OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
                        	  1163: ; 			;CONTROL TO IT, LEAVING ALL REGISTER PAIRS UNCHANGED
                        	  1164: 
                        	  1165: ; 		LD		A, (HL)			;MOVE ROUTINE ADDRESS TO HL
                        	  1166: ; 		INC		HL
                        	  1167: ; 		LD		H, (HL)
                        	  1168: ; 		LD		L,A
                        	  1169: ; 		EX		(SP),HL				;RESTORE OLD HL, PUSH ROUTINE ADDRESS
                        	  1170: ; 		RET						; JUMP TO ROUTI NE
                        	  1171: 
                        	  1172: ; LENSUB		EQU		3				;NUMBER OF SUBROUTINES IN TABLE
                        	  1173: ; JMPTAB:                            ;JUMP TABLE
                        	  1174: ; 		DW		SUB0			;ROUTINE 0
                        	  1175: ; 		DW		SUB1			;ROUTINE 1
                        	  1176: ; 		DW		SUB2			;ROUTINE 2
                        	  1177: ;            ;THREE TEST SUBROUTINES FOR JUMP TABLE
                        	  1178: ; SUB0:
                        	  1179: ; 		LD		A,1				; TEST ROUTI NE 0 SETS (A)    1
                        	  1180: ; 		RET
                        	  1181: ; SUB1:
                        	  1182: ; 		LD		A,2				; TEST ROUTI NE 1 SETS (A) = 2
                        	  1183: ; 		RET
                        	  1184: ; SUB2:
                        	  1185: ; 		LD		A,3				;TEST ROUTINE 2 SETS (A)      3
                        	  1186: ; 		RET
                        	  1187: 
                        	  1188: 
                        	  1189: 
                        	  1190: ; 			;SAMPLE EXECUTION:
                        	  1191: 
                        	  1192: 
                        	  1193: ; SC9H:
                        	  1194: ; 		SUB		A				;EXECUTE ROUTINE 0
                        	  1195: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   =1
                        	  1196: 
                        	  1197: ; 		LD		A,1				;EXECUTE ROUTINE 1
                        	  1198: ; 		CALL	JTAB			; AFTER EXECUTION, (A) = 2
                        	  1199: ; 		LD		A,2				;EXECUTE ROUTINE 2
                        	  1200: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   3
                        	  1201: ; 		LD		A,3				;EXECUTE ROUTINE 3
                        	  1202: ; 		CALL	JTAB			; AFTER EXECUTION, CARRY   1
                        	  1203: ; 		JR		SC9H			;LOOP FOR MORE TESTS
                        	  1204: 
                        	  1205: 
                        	  1206: ;********************************************************************************************
                        	  1207: ;********************************************************************************************	
                        	  1208: ; 		xref  	RDATA,RDATA_END,TB_length
                        	  1209: 
                        	  1210: ; 		;--------------------------------------------------
                        	  1211: ; 		; ld A,5
                        	  1212: ; 		; ld 	A,$00	
                        	  1213: ; 		; out (_Z80_BankCS),A		;// set bank register number 	
                        	  1214: ; 		ld 	A,$01
                        	  1215: ; 		out (_CE_RST_BANK),A 		;// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	  1216: 
                        	  1217: ; 		out (_8Bitsout),A
                        	  1218: 
                        	  1219: ; 		ld A, $0F                 ;mode 1 out
                        	  1220: ; 		out (portA_Contr), A         ; set port A as output
                        	  1221: ; 		ld A,$EB
                        	  1222: 
                        	  1223: ; Rtll:	
                        	  1224: 
                        	  1225: ; 		ld (40000),A
                        	  1226: ; 		ld A,0
                        	  1227: ; 		ld A,(40000)
                        	  1228: 
                        	  1229: ; 		out (portA_Data),A		; Data to PIO port A
                        	  1230: ; 		out (_8Bitsout),A
                        	  1231: ; 		;--------------------------------------------------
                        	  1232: ; 		ld	DE,$8200
                        	  1233: ; 		ld	HL,RDATA
                        	  1234: ; 		ld	BC,TB_length
                        	  1235: ; 		; ld	BC,RDATA_END-RDATA
                        	  1236: ; 		ldir
                        	  1237: 
                        	  1238: 
                        	  1239: ; SIO_0_A_RESET:
                        	  1240: ; 		ld	a,00110000b
                        	  1241: ; 		out	(SIO_0_A_C),A		;write into WR0: error reset, select WR0
                        	  1242: 
                        	  1243: ; 		ld	a,018h				;write into WR0: channel reset
                        	  1244: ; 		out (SIO_0_A_C),A 
                        	  1245: 
                        	  1246: ; 		ld	a,004h				;write into WR0: select WR4
                        	  1247: ; 		out	(SIO_0_A_C),A
                        	  1248: ; 		ld	a,44h				;44h write into WR4: clkx16,1 stop bit, no parity
                        	  1249: ; 		out (SIO_0_A_C),A
                        	  1250: 
                        	  1251: ; 		ld	a,005h				;write into WR0: select WR5
                        	  1252: ; 		out (SIO_0_A_C),A
                        	  1253: ; 		ld	a,01101000b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS inactive (bit 2)
                        	  1254: ; 		ld	a,01101010b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS active (bit 2)
                        	  1255: ; 		out (SIO_0_A_C),A
                        	  1256: ; SIO_0_A_EI:
                        	  1257: ; 			;enable SIO channel A RX
                        	  1258: ; 		ld	a,003h				;write into WR0: select WR3
                        	  1259: ; 		out (SIO_0_A_C),A
                        	  1260: ; 		ld	a,11000001b				;RX 8bit, auto enable off 8(bit 5), RX on (bit 0)
                        	  1261: ; 		ld	a,11100001b				;RX 8bit, auto enable on 8(bit 5), RX on (bit 0)
                        	  1262: ; 		out (SIO_0_A_C),A
                        	  1263: ; 		;Channel A RX active
                        	  1264: 
                        	  1265: 
                        	  1266: ; 		ld 	HL,Str0
                        	  1267: ; tstout:
                        	  1268: ; 		ld 	A,(HL)
                        	  1269: ; 		out (SIO_0_A_D),A
                        	  1270: ; 		inc HL
                        	  1271: ; 		ld D,A
                        	  1272: ; chkTX:
                        	  1273: ; 		in	A,(SIO_0_A_C)		; read status
                        	  1274: ; 		bit	2,A					; all sent ?
                        	  1275: ; 		jr z,chkTX				; not all sent..
                        	  1276: 
                        	  1277: ; 		ld 	A,(HL)
                        	  1278: ; 		cp	0
                        	  1279: ; 		jr 	z,endmsg
                        	  1280: 
                        	  1281: ; 		ld	A,D
                        	  1282: ; 		djnz	tstout
                        	  1283: 
                        	  1284: ; endmsg:
                        	  1285: ; chkRX:
                        	  1286: ; 		in	A,(SIO_0_A_C)		; read status
                        	  1287: ; 		bit	0,A					; char present ??
                        	  1288: ; 		jr z,chkRX				; check again
                        	  1289: 
                        	  1290: ; 		in 	A,(SIO_0_A_D)		; read the char.
                        	  1291: 
                        	  1292: ; 		out (SIO_0_A_D),A
                        	  1293: ; chkTX2:
                        	  1294: ; 		in	A,(SIO_0_A_C)		; read status
                        	  1295: ; 		bit	2,A					; all sent ?
                        	  1296: ; 		jr z,chkTX2
                        	  1297: 		
                        	  1298: ; 		jr	endmsg				; not all sent..
                        	  1299: 
                        	  1300: 
                        	  1301: 
                        	  1302: 
                        	  1303: ; 		halt
                        	  1304: ; 		halt
                        	  1305: ; 		halt
                        	  1306: ; 		inc A
                        	  1307: ; 		jr Rtll			
                        	  1308: 
                        	  1309: ; 	if DOALIGN
                        	  1310: ; 		align 4
                        	  1311: ; 	endif
                        	  1312: 
                        	  1313: 
                        	  1314: .end
                        	  1315: 


Symbols by name:
A_RTS_OFF                       external EXP
A_RTS_ON                        external EXP
AddToT_Buf                      external
BLKMOV                          external EXP
BN2DEC                          external EXP
BN2DEC_S                        external EXP
Bin2Hex16                       external EXP
Bin2Hex8                        external EXP
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CONCAT                          external EXP
COPY                            external EXP
CR                               E:000D
CRC16                           external EXP
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       external
CTC_Init                        external
CTC_delay_INT_handler           external
DEC2BN                          external EXP
DELETE                          external EXP
DumpRegisters                   external
Flash_SE_Erase                  external
Flash_WR_Test                   external
HC376S_CheckConnection          external
HC376S_ResetAll                 external
HC376S_USBdiskMount             external
HC376S_diskConnectionStatus     external
HC376S_fileClose                external
HC376S_fileCreate               external
HC376S_fileDelete               external
HC376S_fileOpen                 external
HC376S_fileRead                 external
HC376S_fileWrite                external
HC376S_getFileSize              external
HC376S_setFileName              external
HC376S_setSDMode                external
HC376S_setUSBMode               external
HEAP_SIZE                       external
HEX2BN                          external EXP
INSERT_STR                      external EXP
ITEM                             E:001C
InitBuffers                     external EXP
InitInterrupt                   external EXP
JPTable01                       00:0431
LF                               E:000A
LISTEND                          E:001E
MFILL                           external EXP
PCinpFlag                       external
PCvalue                         external
PIO_Init                        external
PLD_PCB_Start                   00:0000 EXP
POS                             external EXP
ReadChar                        external EXP
ReadLine                        external EXP
RegFlags                        external EXP
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
SIO_0_A_C                       external
SIO_0_A_D                       external
SIO_0_A_TXRX_INTon              external
SIO_0_B_C                       external
SIO_0_B_D                       external
SIO_0_Init                      external
SIO_0_Int_Vec                    E:F400
SRAM_VAR_START                  external
STEND                            E:001D
S_head_tail                     external EXP
T_BUFFER                        external
TempVar1                        external
Textbuf                         external EXP
WriteChar                       external EXP
WriteLine                       external
WriteLineCRNL                   external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_0_Base                  external
abort                           00:05D0
argumentsError                  00:0450
bit_test9                       00:06BF
byteEnd                         00:03F0
changePCVal                     00:0412
checkArgsTAL                    00:067A
checkaddress                    00:0375
chkADR1                         00:037F
chkADR2                         00:038F
chkLVL2                         00:03B1
cleanInBuffer                   external EXP
cleanOutBuffer                  external EXP
commAdr1                        external
commAdr2                        external
commListLen                      E:001B
commLvl1                        external
commLvl2                        external
commParseTable                  external
commStr1                        external
commStr2                        external
command_addresses               00:01CC
command_list                    00:0200
crc16_2                         external EXP
disableFLASH                    external
doImportXMODEM                  external
dumpMemory                      external EXP
enableFLASH                     external
enableIC620_OE                  external
endtext                         external EXP
errNoFlash                      00:0543
executeCommand                  00:041D
findCommandInList               00:0173
findNextITEM                    00:017F
getLvalue                       00:03A1
gpioB                           external
gpio_in                         external
gpio_out                        external
inBuffer                        external EXP
inBufferEnd                     external EXP
initCommParseTable              00:0321
initSIOBInterrupt               external
inputerror                      00:0199
isHex                           external EXP
makeASCIItoHEX                  00:03C1
matchInList                     00:0334
memBankID                       external
nextHalfByte                    00:03CF
nextInList                      00:0195
next_line                       00:00F9
noHighNib                       00:040E
p_C_Delete                      00:0635
p_C_Read                        00:058B
p_C_Write                       00:05DD
p_FOFF                          00:050D
p_FON                           00:04C1
p_clearmem                      00:048B
p_cptFl                         00:066C
p_dumpmem                       00:0486
p_exe                           00:048C
p_flbank                        00:066C
p_flse                          00:056D
p_flwr                          00:0538
p_go                            00:048D
p_incDecPC                      00:049C
p_load                          00:0485
p_pc                            00:048A
p_reset                         00:0471
p_srbank                        00:0673
p_xmod                          00:0576
paramLoopEntry                  00:0341
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external
putDEtoScreen                   external
scanCommandList                 00:016E
setFLASHBank                    external
setSRAMBank                     external
shiftIn1                        00:06BB
shift_0_1                       00:06AE
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             external
skipPriorDelimit                external
sourctext1                      external EXP
sourctext2                      external EXP
src_size                        external EXP
st1g2                           external EXP
st2g1                           external EXP
steq                            external EXP
strCompare                      external EXP
subst                           external EXP
temp_finish                     00:042E
textloop                        00:06C3
useFlash                        00:010A
writeSTRBelow                   external EXP
zero_byte                       00:017E

Symbols by value:
0000 PLD_PCB_Start
000A LF
000D CR
001B commListLen
001C ITEM
001D STEND
001E LISTEND
00F9 next_line
010A useFlash
016E scanCommandList
0173 findCommandInList
017E zero_byte
017F findNextITEM
0195 nextInList
0199 inputerror
01CC command_addresses
0200 command_list
0321 initCommParseTable
0334 matchInList
0341 paramLoopEntry
0375 checkaddress
037F chkADR1
038F chkADR2
03A1 getLvalue
03B1 chkLVL2
03C1 makeASCIItoHEX
03CF nextHalfByte
03F0 byteEnd
040E noHighNib
0412 changePCVal
041D executeCommand
042E temp_finish
0431 JPTable01
0450 argumentsError
0471 p_reset
0485 p_load
0486 p_dumpmem
048A p_pc
048B p_clearmem
048C p_exe
048D p_go
049C p_incDecPC
04C1 p_FON
050D p_FOFF
0538 p_flwr
0543 errNoFlash
056D p_flse
0576 p_xmod
058B p_C_Read
05D0 abort
05DD p_C_Write
0635 p_C_Delete
066C p_cptFl
066C p_flbank
0673 p_srbank
067A checkArgsTAL
06AE shift_0_1
06BB shiftIn1
06BF bit_test9
06C3 textloop
F400 SIO_0_Int_Vec
F412 CTC_CH1_I_Vector
