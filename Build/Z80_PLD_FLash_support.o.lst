Sections:
00: "Functions" (0-B4)


Source: "temp.tmp"
                        	     1: 		include "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: 
                        	     5: ; ;Function addresses
                        	     6: ; setcursor		= $3100
                        	     7: ; writecommand	= $3180
                        	     8: ; writedata		= $3140
                        	     9: ; testBusyFlag    = $31B0
                        	    10: ; HD44780_main_init = $3000
                        	    11: 
                        	    12: 
                        	    13: ; PIO addressess...
                        	    14: portA_Contr:	equ _Z80PIO_Base + 1
                        	    15: portB_Contr:	equ _Z80PIO_Base + 3
                        	    16: portA_Data:		equ _Z80PIO_Base + 0
                        	    17: portB_Data:		equ _Z80PIO_Base + 2
                        	    18: 
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: 				;SIO_0 CHANNEL A DATA
                        	    22: SIO_0_A_D:		equ	_Z80SIO_0_Base
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_0_A_C:		equ	_Z80SIO_0_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_0_B_D:		equ	_Z80SIO_0_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_0_B_C:		equ	_Z80SIO_0_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_0_A_C
                        	    31: sio_ad: 		equ 	SIO_0_A_D
                        	    32: sio_bc: 		equ 	SIO_0_B_C
                        	    33: sio_bd: 		equ 	SIO_0_B_D
                        	    34: 
                        	    35: 
                        	    36: SIO_0_Int_Vec		EQU     $F400					; interrupt vector 
                        	    37: SIO_0_Int_WR_Vec	EQU     SIO_0_Int_Vec+8			;sio_0 channel A write interrupt vector
                        	    38: SIO_0_Int_EXT_Vec	EQU     SIO_0_Int_Vec+10		;sio_0 channel A external/status ; interrupt vector
                        	    39: SIO_0_Int_Read_Vec	EQU     SIO_0_Int_Vec+12		;sio_0 channel A read interrupt vector
                        	    40: SIO_0_Int_Spec_Vec	EQU     SIO_0_Int_Vec+14		;sio_0 channel A special receive interrupt vector
                        	    41: 
                        	    42: 		;sio_0 channel B write interrupt vector
                        	    43: SIO_0_USB_WR_Vec	EQU     SIO_0_Int_Vec+0	
                        	    44: 		;sio_0 channel B external/status ; interrupt vector
                        	    45: SIO_0_USB_EXT_Vec	EQU     SIO_0_Int_Vec+2	
                        	    46: 		;sio_0 channel B read interrupt vector
                        	    47: SIO_0_USB_Read_Vec	EQU     SIO_0_Int_Vec+4	
                        	    48: 			;sio_0 channel B special receive interrupt vector
                        	    49: SIO_0_USB_Spec_Vec	EQU     SIO_0_Int_Vec+6
                        	    50: 
                        	    51: 
                        	    52: ;Write register 0
                        	    53: WR0 equ 0
                        	    54: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    55: _Ch_Reset		equ 3<<3			; 18
                        	    56: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    57: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    58: _Error_Reset 	equ $30				; (30)	
                        	    59: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    60: 
                        	    61: ;Write register 1
                        	    62: WR1 equ 1
                        	    63: _Ext_INT_EN			equ 1
                        	    64: _Tx_INT_EN 			equ 2
                        	    65: _Status_Vector		equ 4
                        	    66: _Rx_INT_Disable		equ 0
                        	    67: _Rx_INT_First_Char  equ $08
                        	    68: _INT_All_Rx_Char_P 	equ $10 
                        	    69: _Int_All_Rx_Char_NP	equ $18
                        	    70: _WAIT_READY_R_T 	equ $20
                        	    71: _WAIT_READY_FUNC	equ $40
                        	    72: _WAIT_READY_EN		equ $80
                        	    73: 
                        	    74: WR2 equ 2
                        	    75: 
                        	    76: ;Write register 3
                        	    77: WR3 equ 3
                        	    78: _Rx_Enable 			equ $01
                        	    79: _Rx_Disable 		equ $00
                        	    80: _Auto_Enable		equ $20
                        	    81: _RX_5_bits			equ $00
                        	    82: _RX_6_bits			equ $40
                        	    83: _RX_7_bits			equ $80
                        	    84: _RX_8_bits			equ $C0
                        	    85: 
                        	    86: ;Write register 4
                        	    87: WR4 equ 4
                        	    88: _Parity_EN			equ $01
                        	    89: _Parity_Even		equ $02
                        	    90: _Stop_1_bit			equ $04
                        	    91: _Stop_1_2_bit		equ $08
                        	    92: _Stop_2_bit			equ $0C
                        	    93: _X1_Clock_mode		equ $00
                        	    94: _X16_Clock_mode		equ $40
                        	    95: _X32_Clock_mode		equ $80
                        	    96: _X64_Clock_mode		equ $C0
                        	    97: 
                        	    98: ;Write register 5
                        	    99: WR5 equ 5
                        	   100: _RTS_Enable			equ $02
                        	   101: _Tx_Enable 			equ $08
                        	   102: _Send_Break			equ $10
                        	   103: _Tx_5bits_char		equ $00
                        	   104: _Tx_7bits_char		equ $20
                        	   105: _Tx_6bits_char		equ $40
                        	   106: _Tx_8bits_char		equ $60
                        	   107: _DTR_Enable 		equ $80
                        	   108: 
                        	   109: EOT_FOUND			equ $02
                        	   110: _err01_				equ	$08
                        	   111: _err02_				equ	$09
                        	   112: _err03_				equ	$0C
                        	   113: _err04_				equ	$0D
                        	   114: _err05_				equ	$0E
                        	   115: CTCpulse			equ $0A
                        	   116: CTCtimeout			equ $0B
                        	   117: 
                        	   118: 
                        	   119: ; CTC stuff
                        	   120: CH0		equ 	_Z80CTC_Base	
                        	   121: CH1		equ 	_Z80CTC_Base+1	
                        	   122: CH2		equ 	_Z80CTC_Base+2	
                        	   123: CH3		equ 	_Z80CTC_Base+3	
                        	   124: 
                        	   125: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   126: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   127: _Timer 		equ 	$00
                        	   128: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   129: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   130: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   131: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   132: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   133: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   134: 
                        	   135: ; Interrupt vectors for CTC
                        	   136: CTC_CH0_I_Vector	EQU     SIO_0_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   137: CTC_CH1_I_Vector	EQU     SIO_0_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   138: CTC_CH2_I_Vector	EQU     SIO_0_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   139: CTC_CH3_I_Vector	EQU     SIO_0_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   140: 
                        	   141: ; Data tables  (upper EPROM/FLASH)
                        	   142: ; Interupt_vector		= SIO_0_Int_Vec
                        	   143: ; stack  				= $FF00
                        	   144: Heap				= $F000				; space for variable storage
                        	   145: 
                        	   146: ; variables  	(upper ram)
                        	   147: PIO_B_value:		= $F1D0
                        	   148: Result_NumToHex:	= $F1F0
                        	   149: 
                        	   150: 
                        	   151: ; _RAMSTART		= $8010	
                        	   152: ; _EETESTPROG		= $100	
                        	   153: 	
                        	   154: ; _Z80PIO_Base	= $0
                        	   155: ; _Z80CTC_Base	= $10
                        	   156: ; _Z80SIO_0_Base	= $20
                        	   157: ; _Z80_BankCS  	= 0x30;		/*	 30 - 3F   */
                        	   158: ; _8Bitsout 		= $40;		/*	 40 - 4F  */
                        	   159: ; _CE_RST_BANK 	= 0x80;		/*	 40 - 4F  */
                        	   160: 
                        	   161: ;*****	ALIGN command  : 00 removes all align commands
                        	   162: DOALIGN 	EQU 	00
                        	   163: 
                        	   164: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   165: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   166: CRChar:			EQU		0DH				; carrige return
                        	   167: LFChar:			EQU		0AH				; line feed
                        	   168: NUL			EQU		00
                        	   169: SOH			EQU		01
                        	   170: STX			EQU		02
                        	   171: ETX			EQU		03
                        	   172: EOT			EQU		04
                        	   173: ENQ			EQU		05
                        	   174: ACK			EQU		06
                        	   175: BEL			EQU		07
                        	   176: BS			EQU		08h
                        	   177: HT			EQU		09h
                        	   178: LF			EQU		0AH
                        	   179: VT			EQU		0BH
                        	   180: FF			EQU		0CH
                        	   181: CR			EQU		0DH
                        	   182: SO			EQU		0Eh
                        	   183: SI			EQU		0Fh
                        	   184: DLE			EQU		10h
                        	   185: DC1			EQU		11h
                        	   186: DC2			EQU		12h
                        	   187: DC3			EQU		13h
                        	   188: DC4			EQU		14h
                        	   189: NAK			EQU		15h
                        	   190: SYN			EQU		16h
                        	   191: ETB			EQU		17h
                        	   192: CAN			EQU		18h
                        	   193: EM			EQU		19h
                        	   194: SUB			EQU		1Ah
                        	   195: ESC			EQU		1Bh
                        	   196: FS			EQU		1Ch
                        	   197: GS			EQU		1Dh
                        	   198: RS			EQU		1Eh
                        	   199: US			EQU		1Fh
                        	   200: ITEM		EQU		1Ch
                        	   201: STEND		EQU		1Dh
                        	   202: LISTEND		EQU		1Eh
                        	   203: SP			EQU		20h
                        	   204: 
                        	   205: 
                        	   206: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   207: ;DATA LOCATIONS
                        	   208: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   209: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   210: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   211: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   212: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   213: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   214: 
                        	   215: ;BUFFER CONFIGURATION
                        	   216: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   217: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   218: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   219: 
                        	   220: ;BUFFER SIZES, change to suit
                        	   221: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   222: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   223: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   224: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   225: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   226: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   227: 
                        	   228: 
                        	   229: ;INTERRUPT VECTOR TABLE SETUP
                        	   230: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   231: ;There are 4 reasons the interrupt will occur:
                        	   232: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   233: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   234: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   235: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   236: ;
                        	   237: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   238: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   239: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   240: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   241: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   242: ;
                        	   243: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   244: ; -------   --  --  --  ----  --------------
                        	   245: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   246: ;    B       0   0   1   02H  External/Status Change
                        	   247: ;    B       0   1   0   04H  Receive Character Available
                        	   248: ;    B       0   1   1   06H  Special Receive Condition
                        	   249: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   250: ;    A       1   0   1   0AH  External/Status Change
                        	   251: ;    A       1   1   0   0CH  Receive Character Available
                        	   252: ;    A       1   1   1   0EH  Special Receive Condition
                        	   253: ;
                        	   254: ; SIO_0_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   255: ; SIO_0_WriteVector:		EQU		SIO_0_IntVectors+08H ;Write Interrupt Vector
                        	   256: ; SIO_0_ExternalVector:	EQU		SIO_0_IntVectors+0AH ;External Status Interrupt Vector
                        	   257: ; SIO_0_ReadVector:		EQU		SIO_0_IntVectors+0CH ;Read Interrupt Vector
                        	   258: ; SIO_0_SpecialVector:		EQU		SIO_0_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   259: 
                        	   260: 
                        	   261: 	; SIO_0_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   262: 	; SIO_0_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   263: 	; SIO_0_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   264: 	; SIO_0_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   265: 
                        	   266: ;****************************************************************************
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	   271: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	   272: gpioB:			equ		portB_Data
                        	   273: 
                        	   274: 
                        	   275: ; Define the memory size to be used for the CP/M configuration
                        	   276: ; MEM:    equ 60
                        	   277: 
                        	   278: ; The CPM origin will be at: (MEM-7)*1024
                        	   279: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   280: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   281: 
                        	   282: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   283: 
                        	   284: stacktop: equ	0xFFF0	
                        	   285: 
                        	   286: 

Source: "temp.tmp"
                        	     2: 
                        	     3: 	ifndef ONESECTION
                        	     4: 		section Functions
                        	     5: 	else
                        	     6: 		section singleAssembly
                        	     7: 	endif
                        	     8: 
                        	     9: 
                        	    10:         GLOBAL  Flash_WR_Test,Flash_SE_Erase
                        	    11: 		GLOBAL 	enableFLASH,enableIC620_OE,setFLASHBank,setSRAMBank,disableFLASH,disableIC620_OE
                        	    12: 
                        	    13: ;********************************************************************************************
                        	    14: ;********************************************************************************************	
                        	    15: Flash_WR_Test:
                        	    16: 
                        	    17: 		; ***	size in commLvl1
                        	    18: 		; ***	memory address in commAdr1
                        	    19: 		; ***	flash address in commAdr2
                        	    20: 		; ***	erase sectors
                        	    21: 
                        	    22: 
                        	    23: 
                        	    24: 		; erase present flash section
00:0000 ED4B0000        	    25: 		ld 		BC,(commLvl1)		; size of block
                        	    26: 
00:0004 2A0000          	    27: 		ld 		HL,(commAdr2)		; first adress in flash sector
00:0007 ED5B0000        	    28: 		ld 		DE,(commAdr1)		; first adress in memory
                        	    29: nextSector:
00:000B 7C              	    30: 		ld 		A,H
00:000C E6F0            	    31: 		and 	A,$F0 				; select high nibble
00:000E 320000          	    32: 		ld 		(TempVar4),A		; save flash adr (highest nibble)
00:0011 CD3700          	    33: 		call	Flash_SE_Erase
                        	    34: wrOneByte:
                        	    35: 		; ***	Write one byte
00:0014 CD5700          	    36: 		call	WR_sequence
00:0017 1A              	    37: 		ld 		A,(DE)				; get byte from memory
00:0018 77              	    38: 		ld		(HL),A				; set FLASH byte/address to be programmed
00:0019 CD6700          	    39: 		call	WR_toggle			; wait for toggle
00:001C 13              	    40: 		inc 	DE
00:001D 23              	    41: 		inc 	HL
                        	    42:  	; call DumpRegisters
                        	    43: 
00:001E 0B              	    44: 		dec 	BC
00:001F AF              	    45: 		xor  	A 					; A=0
00:0020 B8              	    46: 		cp 		A,B
00:0021 2005            	    47: 		jr 		NZ,checkSector
00:0023 B9              	    48: 		cp 		A,C
00:0024 2002            	    49: 		jr 		NZ,checkSector
00:0026 180E            	    50: 		jr 		finishWrite
                        	    51: checkSector:
                        	    52: 		; ***	compare highest nibblbe to detect sector change
00:0028 D5              	    53: 		push 	DE
00:0029 7C              	    54: 			ld 		A,H
00:002A E6F0            	    55: 			and 	A,$F0 				; select high nibble
00:002C 57              	    56: 			ld 		D,A 		 		; high byte of stored flash address
00:002D 3A0000          	    57: 			ld 		A,(TempVar4)
00:0030 AA              	    58: 			xor 	A,D					; check if same sector
00:0031 D1              	    59: 		pop 	DE
00:0032 20D7            	    60: 		jr 		NZ,nextSector
00:0034 18DE            	    61: 		jr 		wrOneByte
                        	    62: 
                        	    63: 
                        	    64: 
                        	    65: 		; call	enableFLASH 	;// clear '64K_SRAM' signal
                        	    66: 
                        	    67: 
                        	    68: 		; call	WR_sequence
                        	    69: 		; ld 	A,$A0
                        	    70: 		; ld	hl,$2012
                        	    71: 		; ld	(hl),A
                        	    72: 		; call	WR_toggle
                        	    73: 
                        	    74: 		; ld	A,$80
                        	    75: 		; out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	    76: finishWrite:
00:0036 C9              	    77: 		ret
                        	    78: ;********************************************************************************************
                        	    79: ;********************************************************************************************	
                        	    80: 		; ***	erase the sector that contain the address of HL
                        	    81: Flash_SE_Erase:
                        	    82: 
00:0037 3EAA            	    83: 		ld 		A,$AA
00:0039 325555          	    84: 		ld		($5555),A
00:003C 3E55            	    85: 		ld 		A,$55
00:003E 32AA2A          	    86: 		ld		($2AAA),A
00:0041 3E80            	    87: 		ld 		A,$80
00:0043 325555          	    88: 		ld		($5555),A
00:0046 3EAA            	    89: 		ld 		A,$AA
00:0048 325555          	    90: 		ld		($5555),A
00:004B 3E55            	    91: 		ld 		A,$55
00:004D 32AA2A          	    92: 		ld		($2AAA),A
00:0050 3E30            	    93: 		ld 		A,$30
00:0052 77              	    94: 		ld		(HL),A
00:0053 CD6700          	    95: 		call	WR_toggle	; indicate end of sector erase cycle.
                        	    96: 
                        	    97: 		; ld	A,$80
                        	    98: 		; out (_Z80_BankCS),A			;// set '64K_SRAM' signal
00:0056 C9              	    99: 		ret
                        	   100: 
                        	   101: 
                        	   102: WR_sequence:
00:0057 3EAA            	   103: 		ld 		A,$AA
00:0059 325555          	   104: 		ld		($5555),A
00:005C 3E55            	   105: 		ld 		A,$55
00:005E 32AA2A          	   106: 		ld		($2AAA),A
00:0061 3EA0            	   107: 		ld 		A,$A0
00:0063 325555          	   108: 		ld		($5555),a
00:0066 C9              	   109: 		ret
                        	   110: 
                        	   111: WR_toggle:
                        	   112: 
00:0067 7E              	   113: 		ld 		A,(HL)
00:0068 C5              	   114: 		push 	BC
                        	   115: new_toggle:
00:0069 46              	   116: 			ld		B,(HL)
00:006A A8              	   117: 			xor		A,B			; A = A xor B  
00:006B E640            	   118: 			and 	A,$40		; keep bit 6 final result 0 or not
00:006D 78              	   119: 			ld 		A,B			; move (HL) to A
00:006E 20F9            	   120: 			jr		NZ,new_toggle
00:0070 C1              	   121: 		pop 	BC		
00:0071 C9              	   122: 		ret					; return if toggl finished
                        	   123: 
                        	   124: 
                        	   125: ;********************************************************************************************
                        	   126: ;********************************************************************************************	
                        	   127: setSRAMBank:
                        	   128: 		; ***	set the SRAM bank ID; Bank ID in A
00:0072 E5              	   129: 		push 	HL
00:0073 C5              	   130: 		push 	BC
00:0074 210000          	   131: 		ld 		HL,memBankID
00:0077 E60F            	   132: 		and 	$0F 				; clear all bits but 0-3
                        	   133: 
00:0079 47              	   134: 		ld 		B,A
00:007A 7E              	   135: 		ld 		A,(HL)				; get the actl. mem Bank ID
00:007B E6F0            	   136: 		and 	$F0  				; zero bits 0-3
00:007D B0              	   137: 		or 		B					; put new SRAM bank ID in A...
00:007E 77              	   138: 		ld 		(HL),A				; store new value
00:007F 1811            	   139: 		jr 		putBank
                        	   140: 
                        	   141: ;********************************************************************************************
                        	   142: ;********************************************************************************************	
                        	   143: 
                        	   144: setFLASHBank:
                        	   145: 		; ***	set the EEPROM bank ID; Bank ID in A
00:0081 E5              	   146: 		push 	HL
00:0082 C5              	   147: 		push 	BC
00:0083 210000          	   148: 		ld 		HL,memBankID
00:0086 E607            	   149: 		and 	$07 				; clear all bits but 0-2
00:0088 07              	   150: 		rlca
00:0089 07              	   151: 		rlca
00:008A 07              	   152: 		rlca
00:008B 07              	   153: 		rlca						; bank ID = bits 4-6
                        	   154: 
00:008C 47              	   155: 		ld 		B,A
00:008D 7E              	   156: 		ld 		A,(HL)				; get the actl. mem Bank ID
00:008E E68F            	   157: 		and 	$8F  				; zero bits 4-6
00:0090 B0              	   158: 		or 		B					; put new EEP bank ID in A...
00:0091 77              	   159: 		ld 		(HL),A				; store new value
                        	   160: putBank:
00:0092 7E              	   161: 		ld 		A,(HL)	
00:0093 D300            	   162: 		out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
00:0095 C1              	   163: 		pop 	BC
00:0096 E1              	   164: 		pop 	HL
00:0097 C9              	   165: 		ret 
                        	   166: 
                        	   167: ;********************************************************************************************
                        	   168: ;********************************************************************************************	
                        	   169: enableFLASH:
                        	   170: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	   171: 				; if '64K_SRAM' 1  ($80) no FLASH memory is selected
                        	   172: 				; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
00:0098 E5              	   173: 		push 	HL
00:0099 C5              	   174: 		push 	BC
00:009A 210000          	   175: 		ld 		HL,memBankID
00:009D CBBE            	   176: 		res 	7,(HL)
00:009F 18F1            	   177: 		jr 		putBank
                        	   178: 		
                        	   179: ;********************************************************************************************
                        	   180: ;********************************************************************************************	
                        	   181: disableFLASH:
                        	   182: 		; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	   183: 				; if '64K_SRAM' 1  ($80) no FLASH memory is selected
                        	   184: 				; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
00:00A1 E5              	   185: 		push 	HL
00:00A2 C5              	   186: 		push 	BC
00:00A3 210000          	   187: 		ld 		HL,memBankID
00:00A6 CBFE            	   188: 		set 	7,(HL)
00:00A8 18E8            	   189: 		jr 		putBank
                        	   190: 
                        	   191: ;********************************************************************************************
                        	   192: ;********************************************************************************************	
                        	   193: 
                        	   194: 
                        	   195: disableIC620_OE:
                        	   196: 		; ***	Set IC620 pin 1 high
00:00AA 3E00            	   197: 		ld A,0
00:00AC D300            	   198: 		out (_CE_RST_BANK),A			;IC620 (HC374) goes to high impedance.. all signals = GND
                        	   199: 		; ld 	A,$00					; FLASH memory is lower 32k and SRAM upper 32k
                        	   200: 		; out (_Z80_BankCS),A			; set bank register number 0 and 64K_SRAM=0	
                        	   201: 		; ld 	A,$01
                        	   202: 		; out (_CE_RST_BANK),A		; set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
00:00AE C9              	   203: 		ret
                        	   204: 
                        	   205: 
                        	   206: ;********************************************************************************************
                        	   207: ;********************************************************************************************	
                        	   208: 
                        	   209: enableIC620_OE: 
                        	   210: 		; ***	Set IC620 pin 1 low
00:00AF 3E01            	   211: 		ld A,1
00:00B1 D300            	   212: 		out (_CE_RST_BANK),A			;IC620 (HC374) goes to high impedance.. all signals = GND
                        	   213: 		; ld 	A,$00					; FLASH memory is lower 32k and SRAM upper 32k
                        	   214: 		; out (_Z80_BankCS),A			; set bank register number 0 and 64K_SRAM=0	
                        	   215: 		; ld 	A,$01
                        	   216: 		; out (_CE_RST_BANK),A		; set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
00:00B3 C9              	   217: 		ret
                        	   218: 
                        	   219: 
                        	   220: ;********************************************************************************************
                        	   221: ;********************************************************************************************	
                        	   222: 
                        	   223: 
                        	   224: 
                        	   225: .end
                        	   226: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
Flash_SE_Erase                  00:0037 EXP
Flash_WR_Test                   00:0000 EXP
SIO_0_A_C                       external
SIO_0_A_D                       external
SIO_0_B_C                       external
SIO_0_B_D                       external
SIO_0_Int_Vec                    E:F400
TempVar4                        external
WR_sequence                     00:0057
WR_toggle                       00:0067
_CE_RST_BANK                    external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_0_Base                  external
_Z80_BankCS                     external
checkSector                     00:0028
commAdr1                        external
commAdr2                        external
commLvl1                        external
disableFLASH                    00:00A1 EXP
disableIC620_OE                 00:00AA EXP
enableFLASH                     00:0098 EXP
enableIC620_OE                  00:00AF EXP
finishWrite                     00:0036
gpioB                           external
gpio_in                         external
gpio_out                        external
memBankID                       external
new_toggle                      00:0069
nextSector                      00:000B
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
putBank                         00:0092
setFLASHBank                    00:0081 EXP
setSRAMBank                     00:0072 EXP
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
wrOneByte                       00:0014

Symbols by value:
0000 Flash_WR_Test
000B nextSector
0014 wrOneByte
0028 checkSector
0036 finishWrite
0037 Flash_SE_Erase
0057 WR_sequence
0067 WR_toggle
0069 new_toggle
0072 setSRAMBank
0081 setFLASHBank
0092 putBank
0098 enableFLASH
00A1 disableFLASH
00AA disableIC620_OE
00AF enableIC620_OE
F400 SIO_0_Int_Vec
