Sections:
00: "SD_USB_Start" (0-231)
01: "Monitor" (0-78C)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     4: 		include 	"Salea_Logic.inc"

Source: "Salea_Logic.inc"
                        	     1: 
                        	     2: ;       *** 
                        	     3: 
                        	     4:     macro make_pulse 
                        	     5: 
                        	     6:     xor     A
                        	     7:     set     \1,A    
                        	     8:     out (gpio_out),A
                        	     9:     out (gpio_out),A
                        	    10:     out (gpio_out),A
                        	    11:     out (gpio_out),A
                        	    12:     xor     A
                        	    13:     out (gpio_out),A
                        	    14:     
                        	    15: 
                        	    16:     endm

Source: "stdin"
                        	     5: 	
                        	     6: 
                        	     7: 
                        	     8: 
                        	     9: 
                        	    10: 			xref	Bin2Hex8,Bin2Hex16,  HEX2BN, BN2DEC,BN2DEC_S,DEC2BN,MFILL, BLKMOV,strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR
                        	    11: 			xref	InitBuffers, ReadLine, WriteChar, ReadChar, S_head_tail
                        	    12: 			xref	Textbuf, inBufferEnd,inBuffer,cleanInBuffer,cleanOutBuffer,InitInterrupt
                        	    13: 			xref	dumpMemory
                        	    14: 
                        	    15: 			xref	st2g1,st1g2,steq,subst
                        	    16: 			xref	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	    17: 			xref	sourctext1,sourctext2,endtext,src_size, writeSTRBelow,isHex
                        	    18: 
                        	    19: 			xref 	crc16_2,CRC16
                        	    20: 		
                        	    21: 		xref 	SIO_A_RTS_OFF,SIO_A_RTS_ON
                        	    22: 
                        	    23: 	;***************************************************************
                        	    24: 	;SAMPLE EXECUTION:
                        	    25: 	;***************************************************************
                        	    26: GPIODEBUG EQU 0
                        	    27: 
                        	    28: DO_Debug:	equ	0		; Set to 1 to show debug printing, else 0 
                        	    29: 
                        	    30: 	GLOBAL  MONITOR_Start, SD_USB_startup
                        	    31: ;************************************************************************************************
                        	    32: ;************************************************************************************************
                        	    33: ;***		SDcard/USB startup sequence
                        	    34: ;************************************************************************************************
                        	    35: ;************************************************************************************************
                        	    36: 		section SD_USB_Start
                        	    37: 
                        	    38: 
00:0000 C30000          	    39: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	    40: 
                        	    41: SD_USB_startup:
                        	    42: 
                        	    43: 	if  	GPIODEBUG = 1
                        	    44: 		ld 		A,$33
                        	    45: 		out 	(gpio_out),A
                        	    46: 
                        	    47: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	    48: 
                        	    49: 		ld 		(SP_value),SP
                        	    50: 
                        	    51: 		ld 		A,$AA
                        	    52: 		out 	(gpio_out),A
                        	    53: 		
                        	    54: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    55: 				; initialize buffer counters and pointers.
                        	    56: 		ld 		A,$BB
                        	    57: 		out 	(gpio_out),A
                        	    58: 
                        	    59: 			call	PIO_Init
                        	    60: 		ld 		A,$CC
                        	    61: 		out 	(gpio_out),A
                        	    62: 			call 	CTC_Init
                        	    63: 		ld 		A,$DD
                        	    64: 		out 	(gpio_out),A
                        	    65: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	    66: 		ld 		A,$DF
                        	    67: 		out 	(gpio_out),A
                        	    68: 			call	S_head_tail			; save input heads and tails
                        	    69: 		ld 		A,$81
                        	    70: 		out 	(gpio_out),A
                        	    71: 	
                        	    72: 	else
                        	    73: 	
00:0003 CD0000          	    74: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    75: 			; initialize buffer counters and pointers.
00:0006 CD0000          	    76: 		call	PIO_Init
00:0009 CD0000          	    77: 		call 	CTC_Init
00:000C CD0000          	    78: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
00:000F CD0000          	    79: 		call	S_head_tail			; save input heads and tails
                        	    80: 	endif
                        	    81: 
                        	    82: 
                        	    83: 		; call	sh_test
                        	    84: 		; call 	Flash_WR_Test
                        	    85: 		; ld	HL,$2010
                        	    86: 		; call	Flash_SE_Erase
                        	    87: 
                        	    88: 		; check  $D008-$D00B for $33333333 -> Startup code is preloaded from Arduino 
                        	    89: 		; check  $D008-$D00B for $CCCCCCCC -> start from Flash 
                        	    90: 
00:0012 210000          	    91: 		ld 		HL,BootCodeAdr
00:0015 0604            	    92: 		ld 		B,04
00:0017 3E33            	    93: 		ld 		A,'3'
                        	    94: .checkBootCode:
00:0019 BE              	    95: 		cp 		(HL)	
00:001A 23              	    96: 		inc 	HL
00:001B C2F400          	    97: 		jp 		NZ,.SDstart
00:001E 10F9            	    98: 		djnz 	.checkBootCode
                        	    99: 
                        	   100: 
00:0020 CD0000          	   101: 		call	CRLF
00:0023 CD0000          	   102: 		call 	writeSTRBelow
00:0026 0D0A            	   103: 		defb   	"\r\n"
00:0028 2B2D3D2D2B2D3D2D	   104: 		defb	"+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-\r\n"
00:0030 2B2D3D2D2B2D3D2D
00:0038 2B2D3D2D2B2D3D2D
00:0040 2B2D3D2D2B2D3D2D
00:0048 2B2D3D2D2B2D3D2D
00:0050 0D0A
00:0052 205374617274204D	   105: 		defb	" Start Monitor from Arduino preloaded monitor\r\n"
00:005A 6F6E69746F722066
00:0062 726F6D2041726475
00:006A 696E6F207072656C
00:0072 6F61646564206D6F
00:007A 6E69746F720D0A
00:0081 20464C4153482042	   106: 		defb	" FLASH Boot version git: Working-TAG-27/2-0-g338630f-dirty: 2026-02-28_14:19\r\n"
00:0089 6F6F742076657273
00:0091 696F6E206769743A
00:0099 20576F726B696E67
00:00A1 2D5441472D32372F
00:00A9 322D302D67333338
00:00B1 363330662D646972
00:00B9 74793A2032303236
00:00C1 2D30322D32385F31
00:00C9 343A31390D0A
00:00CF 204D6F6E69746F72	   107: 		defb	" Monitor res in SRAM 0xD000.\r\n"
00:00D7 2072657320696E20
00:00DF 5352414D20307844
00:00E7 3030302E0D0A
00:00ED 00              	   108: 		defb	"\0"
                        	   109: 
00:00EE CD0000          	   110: 		call 	waitForFinishedPrintout
00:00F1 C30000          	   111: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   112: 		
                        	   113: 
                        	   114: .SDstart:
                        	   115: 		
00:00F4 CD0000          	   116: 		call	CRLF
00:00F7 CD0000          	   117: 		call 	writeSTRBelow
00:00FA 0D0A            	   118: 		defb   	"\r\n"
00:00FC 3D2D3D2D3D2D3D2D	   119: 		defb	"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\r\n"
00:0104 3D2D3D2D3D2D3D2D
00:010C 3D2D3D2D3D2D3D2D
00:0114 3D2D3D2D3D2D3D2D
00:011C 3D2D3D2D3D2D3D2D
00:0124 0D0A
00:0126 5374617274206672	   120: 		defb	"Start from SD/USB\r\n"
00:012E 6F6D2053442F5553
00:0136 420D0A
                        	   121: 		; defb	"    git: Working-TAG-27/2-0-g338630f-dirty\r\n"
                        	   122: 		; defb	"    build: 2026-02-28_14:19\r\n"
                        	   123: 		; defb	"    FLASH->SRAM 0xD000.\r\n"
00:0139 00              	   124: 		defb	"\0"
                        	   125: 
00:013A CD0000          	   126: 		call 	waitForFinishedPrintout
                        	   127: 
                        	   128: 	if 	GPIODEBUG =1
                        	   129: 		ld 		A,$83
                        	   130: 		out 	(gpio_out),A
                        	   131: 	endif
00:013D CD0000          	   132: 		call	CRLF
                        	   133: 
                        	   134: ;*****	Setup Boot load from SD card.
                        	   135: ;***************************************
00:0140 110000          	   136: 		ld 		DE,commStr1					; save filename in commStr1
00:0143 21E401          	   137: 		ld 		HL,rfile_name
                        	   138: .nxtchr:
00:0146 EDA0            	   139: 		ldi									; (DE) <- (HL) 
00:0148 7E              	   140: 		ld 		A,(HL)
00:0149 B7              	   141: 		or 		A 							; = 0 ?
00:014A 20FA            	   142: 		jr  	NZ,.nxtchr
00:014C 12              	   143: 		ld 		(DE),A						; save '0'
00:014D 210000          	   144: 		ld 		HL,S1x						; result in S1x
00:0150 220000          	   145: 		ld 		(commAdr1),HL
                        	   146: 
00:0153 CDF401          	   147: 		call 	p_C_Read_SD
                        	   148: 
                        	   149: 
                        	   150: ;***	correct $0A to $00 $00 in S1x (check for ascii lower than $20)
00:0156 210000          	   151: 		ld 		HL,S1x
00:0159 3E20            	   152: 		ld 		A,$20
00:015B 110000          	   153: 		ld 		DE,commStr1
                        	   154: 
                        	   155: .find0A:
00:015E EDA0            	   156: 		ldi						; (DE) <- (HL) 
00:0160 BE              	   157: 		cp 		(HL)			; char lower than ' '  $20 - (HL)
00:0161 FA5E01          	   158: 		jp 		M,.find0A		; char > ' '...
                        	   159: 
00:0164 3E00            	   160: 		ld 		A,00
00:0166 12              	   161: 		ld 		(de),A
00:0167 13              	   162: 		inc 	de
00:0168 12              	   163: 		ld 		(de),A			; strip eventually $0A, $0D, ...
00:0169 13              	   164: 		inc 	de
00:016A 12              	   165: 		ld 		(de),A			; Boot file name present in commStr1
00:016B 210000          	   166: 		ld 		HL,_RAMSTART
00:016E 220000          	   167: 		ld 		(commAdr1),HL 	; place adress for boot file...
00:0171 CDF401          	   168: 		call 	p_C_Read_SD		; read and place boot file.
                        	   169: 
                        	   170: 
00:0174 CD0000          	   171: 		call 	writeSTRBelow
00:0177 0D0A555345205241	   172: 		defb   "\r\nUSE RAM bank #0, Copy FLASH Boot seq\r\n"
00:017F 4D2062616E6B2023
00:0187 302C20436F707920
00:018F 464C41534820426F
00:0197 6F74207365710D0A
00:019F 546F2052414D2062	   173: 		defb   "To RAM bank #1 ($0-$2000) \r\n"
00:01A7 616E6B2023312028
00:01AF 24302D2432303030
00:01B7 29200D0A
00:01BB 4A756D7020746F20	   174: 		defb	"Jump to MONITOR_Start! ($D000)\r\n",0,0,0
00:01C3 4D4F4E49544F525F
00:01CB 5374617274212028
00:01D3 2444303030290D0A
00:01DB 00
00:01DC 00
00:01DD 00
00:01DE CD0000          	   175: 		call 	waitForFinishedPrintout
                        	   176: 
00:01E1 C30000          	   177: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   178: 
                        	   179: rfile_name:
00:01E4 424F4F5446494C45	   180: 	 db "BOOTFILE.TXT",0,0,0,0
00:01EC 2E545854
00:01F0 00
00:01F1 00
00:01F2 00
00:01F3 00
                        	   181: 	; db "PROVIDE.txt",0,0,0,0
                        	   182: 
                        	   183: 	
                        	   184: ;************************************************************************************************
                        	   185: p_C_Read_SD:
                        	   186: 
                        	   187: 		;call 	checkArgsTAL				; check necessary args
                        	   188: 		;jp		NZ,argumentsError			; show argument error and return
                        	   189: 	
00:01F4 110000          	   190: 		ld 		DE,CTC_delay_INT_handler
00:01F7 ED5312F4        	   191: 		ld 		(CTC_CH1_I_Vector),DE
                        	   192: 	if 	GPIODEBUG =1
                        	   193: 		xor A
                        	   194: 		out (gpio_out),A
                        	   195: 	endif
                        	   196: 		; call  	SIO_A_DI					; disable text output
                        	   197: 	if 	GPIODEBUG =1
                        	   198: 		ld a,4
                        	   199: 		out (gpio_out),A
                        	   200: 		ld a,0
                        	   201: 		out (gpio_out),A
                        	   202: 	endif
                        	   203: 
00:01FB 7B              	   204: 		ld a,e	
                        	   205: 
00:01FC CD0000          	   206: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
00:01FF CD0000          	   207: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
00:0202 CD0000          	   208: 		call 	HC376S_ResetAll
00:0205 CD0000          	   209: 		call 	HC376S_CheckConnection
                        	   210: 		; ld 		A,(commParseTable)
                        	   211: 		; cp 		15							; 15 read SD; 17-read USB
                        	   212: 		; jr 		Z,.doSD
                        	   213: 		; cp 		21							; 21 read SD enumerate, 22 read USB enumerate
                        	   214: 		; jr 		Z,.doSD
                        	   215: 		; call 	HC376S_setUSBMode
                        	   216: 		; call 	HC376S_diskConnectionStatus		; dont use with SD card
                        	   217: 		; jr 		.cont
                        	   218: .doSD:
00:0208 CD0000          	   219: 		call 	HC376S_setSDMode
                        	   220: 		
                        	   221: .cont:
00:020B CD0000          	   222: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:020E 2014            	   223: 		jr 		NZ,SDabort
                        	   224: 
                        	   225: 
00:0210 CD0000          	   226: 		call 	HC376S_setFileName
00:0213 CD0000          	   227: 		call 	HC376S_fileOpen
00:0216 200C            	   228: 		jr 		NZ,SDabort
00:0218 CD0000          	   229: 		call 	waitForFinishedPrintout
                        	   230: 
00:021B CD0000          	   231: 		call 	HC376S_getFileSize
00:021E CD0000          	   232: 		call 	HC376S_fileRead
00:0221 CD0000          	   233: 		call 	HC376S_fileClose
                        	   234: SDabort:
                        	   235: 
                        	   236: 		; ***	reset the interrupt handler for CTC
                        	   237: 		; call 	SIO_A_EI					; enable text output
00:0224 CD0000          	   238: 		call 	HC376S_ResetAll
00:0227 CD0000          	   239: 		call 	CTC1_INT_OFF
00:022A 210000          	   240: 		ld		HL,CTC_CH1_Interrupt_Handler
00:022D 2212F4          	   241: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:0230 C9              	   242: 		ret
                        	   243: 
                        	   244: 
                        	   245: ;*****************************************************************************************************
                        	   246: ;*****************************************************************************************************
                        	   247: 
                        	   248: 		section	Monitor			; enter point for monitor
                        	   249: 
                        	   250: ;***	MONITOR_Start:  entry point for monitor, should be at $D000.
                        	   251: ;*****************************************************************************************************
                        	   252: ;*****************************************************************************************************
                        	   253: 
                        	   254: MONITOR_Start:		
                        	   255: 
                        	   256: 		; ***	should be start address $D000
                        	   257: 		;jr 		.makeShadowRAM
                        	   258: 
                        	   259: 
01:0000 1838            	   260: 		jr 		.skipBlockCopy		; use Flash mem and SRAM normally
                        	   261: 	align 3
                        	   262: 		; Ref. vlink_Z80_.ld
                        	   263: 		; BootCode in $D008-D00B = $00000000 - $AAAAAAAA': copy from flash
                        	   264: 		; BootCode in $D008-D00B = $CCCCCCCC: code uploaded from xmodem/or DMA. Do not copy from flash
                        	   265: 		; BootCode in $D008-D00B = $33333333: code uploaded from Arduino. Do not copy from flash, 
                        	   266: 		;defl 	    $01010101
01:0008 00000000        	   267: 		defl 		BootCode
                        	   268: 		align	3
                        	   269: 
                        	   270: 
                        	   271: 	;call 	waitForFinishedPrintout
                        	   272: 	
                        	   273: .makeShadowRAM:
                        	   274: 
                        	   275: 	if 	GPIODEBUG =1
                        	   276: 	ld 		A,$33
                        	   277: 	out 	(gpio_out),A
                        	   278: 	endif
                        	   279: ;		***  	NOFLASH - Don not use the FLASH mem -> 64kRAM
                        	   280: ; 		*** 	Copy Flash boot sequence to RAM bank #1
                        	   281: ; 		*** 	first to temp storage area.
                        	   282: 
                        	   283: ;		***	 	Copy 128 blocks of 256 bytes from flash to RAM bank #0, then copy to RAM bank #1
                        	   284: 
01:0010 0680            	   285: 		ld  	B,128		; count 128 blocks of 256 bytes
                        	   286: .loopBlocks:
01:0012 C5              	   287: 		push  	BC 			; save BC as block counter
01:0013 018000          	   288: 		ld     	BC,128		; byte counter
                        	   289: 
01:0016 21FF7F          	   290: 		ld 		HL,$7FFF		; end of flash memory area
01:0019 11FFCF          	   291: 		ld 		DE,$CFFF		; temp storage area 0xCF00-CFFF		
01:001C E5              	   292: 		push 	HL
01:001D D5              	   293: 		push 	DE
01:001E EDB8            	   294: 		lddr					; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0		
                        	   295: 
                        	   296: ; 		*** 	secondly: to Rambank #1 storage area. deselect FLASH mem
                        	   297: ; 		***		Swithch to RAM bank #1
01:0020 CD3807          	   298: 		call  	p_FOFF_No_Print	; ***		Disable Flash memory 
01:0023 3E01            	   299: 		ld 		A,1
01:0025 CD8706          	   300: 		call 	p_srbank0; 		***		Swithch to RAM bank #1
                        	   301: 
                        	   302: 				; from old area (HL), $7FFF  to new area ram area (DE), 0x7FFF
01:0028 E1              	   303: 		pop 	HL			; HL point to temp storage area 0xCFFF (old DE value)
01:0029 D1              	   304: 		pop 	DE 			; DE point to new area in ram bank #1 0xCFFF (old HL value)
01:002A 018000          	   305: 		ld     	BC,128
01:002D EDB8            	   306: 		lddr				; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0
                        	   307: 
                        	   308: ;		***		Enable Flash again and set ram bank #0	
01:002F CD3807          	   309: 		call  	p_FOFF_No_Print
01:0032 3E00            	   310: 		ld 		A,0
01:0034 CD9A06          	   311: 		call 	p_flbank0; 		***		Swithch to FLASH bank #0
                        	   312: 
                        	   313: 
01:0037 C1              	   314: 		pop 	BC			; restore BC as block counter
01:0038 10D8            	   315: 		djnz	.loopBlocks
                        	   316: 			
                        	   317: 
                        	   318: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	   319: 
                        	   320: .skipBlockCopy:
                        	   321: 
01:003A ED730000        	   322: 		ld 		(SP_value),SP
                        	   323: 
                        	   324: 		if 	GPIODEBUG =1
                        	   325: 			ld 		A,$AA
                        	   326: 			out 	(gpio_out),A
                        	   327: 			
                        	   328: 
                        	   329: 			CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   330: 					; initialize buffer counters and pointers.
                        	   331: 			ld 		A,$BB
                        	   332: 			out 	(gpio_out),A
                        	   333: 
                        	   334: 			call	PIO_Init
                        	   335: 			ld 		A,$CC
                        	   336: 			out 	(gpio_out),A
                        	   337: 
                        	   338: 			call 	CTC_Init
                        	   339: 			ld 		A,$DD
                        	   340: 			out 	(gpio_out),A
                        	   341: 
                        	   342: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	   343: 			ld 		A,$DF
                        	   344: 			out 	(gpio_out),A
                        	   345: 
                        	   346: 			call	S_head_tail			; save input heads and tails
                        	   347: 			ld 		A,$81
                        	   348: 			out 	(gpio_out),A
                        	   349: 		else 
                        	   350: 
01:003E CD0000          	   351: 			CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   352: 					; initialize buffer counters and pointers.
01:0041 CD0000          	   353: 			call	PIO_Init
01:0044 CD0000          	   354: 			call 	CTC_Init
01:0047 CD0000          	   355: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
01:004A CD0000          	   356: 			call	S_head_tail			; save input heads and tails
                        	   357: 		endif
                        	   358: 
                        	   359: 		; call	sh_test
                        	   360: 		; call 	Flash_WR_Test
                        	   361: 		; ld	HL,$2010
                        	   362: 		; call	Flash_SE_Erase
                        	   363: 
                        	   364: 
01:004D CD0000          	   365: 		call	CRLF
01:0050 CD0000          	   366: 		call 	writeSTRBelow
01:0053 0D0A            	   367: 		defb   	"\r\n"
01:0055 205A383443303032	   368: 		defb	" Z84C0020/Z84C4010/Z84C3010/512K SRAM/256K FLASH Board\r\n"
01:005D 302F5A3834433430
01:0065 31302F5A38344333
01:006D 3031302F3531324B
01:0075 205352414D2F3235
01:007D 364B20464C415348
01:0085 20426F6172640D0A
01:008D 204D6F6E69746F72	   369: 		defb	" Monitor: git Working-TAG-27/2-0-g338630f-dirty: 2026-02-28_14:19\r\n"
01:0095 3A2067697420576F
01:009D 726B696E672D5441
01:00A5 472D32372F322D30
01:00AD 2D67333338363330
01:00B5 662D64697274793A
01:00BD 20323032362D3032
01:00C5 2D32385F31343A31
01:00CD 390D0A
01:00D0 00              	   370: 		defb	"\0"
01:00D1 CD0000          	   371: 		call 	waitForFinishedPrintout
                        	   372: 
                        	   373: 
                        	   374: 	if 	GPIODEBUG=1
                        	   375: 		ld 		A,$83
                        	   376: 		out 	(gpio_out),A
                        	   377: 	endif
01:00D4 CD0000          	   378: 		call	CRLF
01:00D7 1800            	   379: 		jr  next_line
                        	   380: 
                        	   381: 
                        	   382: next_line:
                        	   383: 
01:00D9 CD6903          	   384: 		call 	initCommParseTable			; Put zeros.....
                        	   385: 	if 	GPIODEBUG =1
                        	   386: 		ld 		A,$85
                        	   387: 		out 	(gpio_out),A
                        	   388: 	endif
                        	   389: 
                        	   390: 		; ***	indicate memory banks   F[x]  Flash memory bank x
                        	   391: 		; ***	indicate memory banks   S[y]  SRAM memory bank y
                        	   392: 				; if bit 3 (rstBankID) = 1  no FLASH memory is selected
                        	   393: 				; if bit 3 (rstBankID) = 0 FLASH memory is lower 32k and SRAM upper 32k
01:00DC 210100          	   394: 		ld 		HL,T_BUFFER+1 			; prepare output buffer		
01:00DF 3646            	   395: 		ld 		(HL),'F'	
01:00E1 3A0000          	   396: 		ld 		A,(rstBankID)
01:00E4 CB5F            	   397: 		bit 	3,A					; bit 3 set -> 64kSRAM
01:00E6 2802            	   398: 		jr 		Z,useFlash
01:00E8 3653            	   399: 		ld 		(HL),'S'	
                        	   400: useFlash:
01:00EA 23              	   401: 		inc 	HL
01:00EB 365B            	   402: 		ld 		(HL),'['	
01:00ED 23              	   403: 		inc 	HL
01:00EE CB5F            	   404: 		bit 	3,A					; bit 7 set -> 64kSRAM
01:00F0 3A0000          	   405: 		ld  	A,(memBankID)
01:00F3 2807            	   406: 		jr 		Z,.IDflash
                        	   407: 
                        	   408: 		; ***	show sram bank number
01:00F5 E60F            	   409: 		and 	$0F					; sram bank #
01:00F7 CD0000          	   410: 		call 	AddToT_Buf			; convert to 1 ascii char in (HL+)
01:00FA 180D            	   411: 		jr 		.cont
                        	   412: .IDflash:
                        	   413: 		; ***	show flash bank number
01:00FC CB3F            	   414: 		srl 	A
01:00FE CB3F            	   415: 		srl 	A
01:0100 CB3F            	   416: 		srl 	A
01:0102 CB3F            	   417: 		srl 	A
01:0104 E607            	   418: 		and 	A,$07				; flash bank #
01:0106 CD0000          	   419: 		call	AddToT_Buf			; convert to 1 ascii char in (HL+)
                        	   420: .cont:
01:0109 365D            	   421: 		ld  	(HL),']'
01:010B 23              	   422: 		inc 	HL
                        	   423: 
                        	   424: 	if 	GPIODEBUG=1
                        	   425: 		ld 		A,$87
                        	   426: 		out 	(gpio_out),A
                        	   427: 	endif
                        	   428: 
                        	   429: 	; 	*** Print prompt text to screen, value of PC and content in memory
01:010C ED5B0000        	   430: 		ld 		DE,(PCvalue)
01:0110 365B            	   431: 		ld  	(HL),'['
01:0112 23              	   432: 		inc 	HL
                        	   433: 
                        	   434: 		; ***	Address in parenthesis
01:0113 CD0000          	   435: 		call 	Bin2Hex16
01:0116 365D            	   436: 		ld  	(HL),']'
01:0118 23              	   437: 		inc 	HL
01:0119 363D            	   438: 		ld  	(HL),'='
01:011B 23              	   439: 		inc 	HL
                        	   440: 
                        	   441: 		; ***	Value of the bytes in address (2 bytes) to screen
01:011C E5              	   442: 		push 	HL
01:011D 2A0000          	   443: 		ld 		HL,(PCvalue)
01:0120 56              	   444: 		ld 		D,(HL)
01:0121 23              	   445: 		inc 	HL
01:0122 5E              	   446: 		ld 		E,(HL)
01:0123 E1              	   447: 		pop 	HL
01:0124 CD0000          	   448: 		call	Bin2Hex16
01:0127 362D            	   449: 		ld  	(HL),'-'
01:0129 23              	   450: 		inc 	HL
01:012A 363E            	   451: 		ld  	(HL),'>'
01:012C 23              	   452: 		inc 	HL
                        	   453: 
01:012D 3600            	   454: 		ld  	(HL),$00
01:012F FD210000        	   455: 		ld 		iy,T_BUFFER
01:0133 CD0000          	   456: 		call	WriteLine
                        	   457: 
01:0136 210000          	   458: 		ld 		hl,Textbuf
01:0139 CD0000          	   459: 		call 	ReadLine				; Läs in kommandorad !
                        	   460: 
01:013C FD210000        	   461: 		ld 		iy,Textbuf
01:0140 CD0000          	   462: 		call	WriteLineCRNL
                        	   463: 		; ld 		A,5
                        	   464: 		; out 	(portA_Data),A
                        	   465: 
                        	   466: 		;***  	compare input
                        	   467: 		; ld 		HL,Textbuf
                        	   468: 		; ld 		DE,command_list+2
                        	   469: 		; call	strCompare
                        	   470: 
                        	   471: 	;***************************************************************
                        	   472: 	;	Find /Identify command:
                        	   473: 	;***************************************************************
                        	   474: 
01:0143 210000          	   475: 		ld 		HL,Textbuf
01:0146 CD0000          	   476: 		call 	skipPriorDelimit			; hoppa (HL) till första giltiga bokstav i kommandot, eller till nollbyte (tom rad)
                        	   477: 
01:0149 DA9204          	   478: 		jp 		C,temp_finish 				; inga mer kommandon
                        	   479: 
01:014C E5              	   480: 		push 	HL
01:014D D1              	   481: 		pop  	DE							;  DE pekar på första char i det inmatade kommandot (Textbuf) som ska jämföras med kommandolistan 
                        	   482: 
                        	   483: 		; ***	sök kommando i  'command_list:'
                        	   484: 		;  		DE = DE pekar på första char i det inmatade kommandot (Textbuf) 
01:014E 21BA01          	   485: 		ld 		HL,command_list+1			; HL pekar på första byte i command_list (löpnummer)
                        	   486: 		
                        	   487: scanCommandList:							;ITEM,1,4,"load",STEND,%100010,0,CDEL
01:0151 4E              	   488: 		ld 		C,(HL)						; löpnummer i reg C
01:0152 23              	   489: 		inc 	HL 							; 
01:0153 46              	   490: 		ld 		B,(HL)						; antal tecken i aktuell kommando i listan
01:0154 23              	   491: 		inc 	HL 							; HL-> första bokstav i aktuell kommando i listan
01:0155 D5              	   492: 		push 	DE 							; spara inmatat kommnde (DE)(Textbuf)  
                        	   493: 
                        	   494: findCommandInList:
01:0156 1A              	   495: 		ld 		a,(DE)						; reg A = tecken i inmatat kommando
                        	   496: 		; or 		$20							; make typed char lower case
01:0157 BE              	   497: 		cp		(HL)				; jämför tecken i inmatat kommando (DE) med tecken i aktuellt kommando i listan (HL)
01:0158 2008            	   498: 		jr 		nz,findNextITEM		; om inte, hoppa till findNextITEM
01:015A 13              	   499: 		inc 	DE
01:015B 23              	   500: 		inc 	HL  
01:015C 10F8            	   501: 		djnz 	findCommandInList
                        	   502: 		
                        	   503: 		; ***	test char (DE); should be a delimiter...
                        	   504: 		; ex 		DE,HL
                        	   505: 		; call 	isDelimit
                        	   506: 		; 				;delimiters found ? =>Z, else ~Z
                        	   507: 		; 				;char in (HL) is '0' ->  set C, else NC
                        	   508: 		; ex 		DE,HL
                        	   509: 
                        	   510: 		; call 	writeSTRBelow
                        	   511: 		; DB 		0,"pop 	HL.. !",CR,LF,00
                        	   512: 		; call 	DumpRegisters
                        	   513: 
                        	   514: 		; jr 		nz,findNextITEM    			; command match but is longer (more chars) cp list					
                        	   515: 
                        	   516: 		; ***	Found a matching command, All char do match...
                        	   517: 		; 		(HL) points to first after command
                        	   518: 		;----------------------------------------------------------------------------
01:015E C37C03          	   519: 		jp 		matchInList		; ***	Hittat kommande i listan, HL pekar p (STEND)...
                        	   520: 		;----------------------------------------------------------------------------
01:0161 00              	   521: zero_byte:	db  0
                        	   522: 
                        	   523: findNextITEM:
                        	   524: 		; ***	Fortsätt leta i nästa kommando i listan ITEM or LISTEND
01:0162 7E              	   525: 		ld 		a,(HL)
01:0163 FEEE            	   526: 		cp		CDEL					; hitta CDEL och hopp till skipPastCommAdr
01:0165 2812            	   527: 		jr 		z,.skipPastCommAdr
                        	   528: 	
01:0167 FE1C            	   529: 		cp		ITEM					; avgränsare ? -> nextInList
01:0169 2817            	   530: 		jr 		z,nextInList
                        	   531: 	
01:016B FE1E            	   532: 		cp 		LISTEND
01:016D 2010            	   533: 		jr 		NZ,.cont				; fortsätter listan ? -> .cont
                        	   534: 
                        	   535: 		; ***	Command list did not match; check if direct address '$' or byte input
01:016F 3EFF            	   536: 		ld 		A,$FF
01:0171 320000          	   537: 		ld 		(PCinpFlag),A			; reg A=FF : kod för angiven adress eller värde
01:0174 E1              	   538: 		pop 	HL						; återställ HL pekar på adress eller värde
01:0175 7E              	   539: 		ld 		A,(HL)
01:0176 C3C703          	   540: 		jp 		checkaddress			; om reg A =  $, angivet värde är adress
                        	   541: 										; eller relative adress '@'
                        	   542: 										; eller direkt input av bytes.....
                        	   543: .skipPastCommAdr:
01:0179 23              	   544: 		inc  	HL		;hög adr.
01:017A 23              	   545: 		inc  	HL		; låg adr.
01:017B 23              	   546: 		inc  	HL		;  '0'
01:017C 23              	   547: 		inc  	HL		;  nästa rad i kommando listan
01:017D 18E3            	   548: 		jr 		findNextITEM
                        	   549: 
01:017F 23              	   550: .cont:	inc 	HL				; HL pekar på första char i nästa textsträng i listan	
01:0180 18E0            	   551: 		jr 		findNextITEM
                        	   552: 
                        	   553: nextInList:
01:0182 23              	   554: 		inc 	HL						; HL = löpnummer på nästa kommando i listan
01:0183 D1              	   555: 		pop 	DE 						; återställ DE till start av inmatad kommando
01:0184 18CB            	   556: 		jr 		scanCommandList
                        	   557: 
                        	   558: 
                        	   559: 	;***************************************************************
                        	   560: 	;	Semantic error occurred in input :
                        	   561: 	;***************************************************************
                        	   562: 
                        	   563: inputerror:
01:0186 E5              	   564: 		push   	HL
01:0187 CD0000          	   565: 		call 	writeSTRBelow
01:018A 00              	   566: 		DB 		0,"Input Semantic Error... ! code(DE):",00
01:018B 496E707574205365
01:0193 6D616E7469632045
01:019B 72726F722E2E2E20
01:01A3 2120636F64652844
01:01AB 45293A
01:01AE 00
01:01AF D1              	   567: 		pop 	DE
01:01B0 CD0000          	   568: 		call 	putDEtoScreen
01:01B3 CD0000          	   569: 		call 	CRLF
01:01B6 C3D900          	   570: 		jp 		next_line
                        	   571: 
                        	   572: ; command_addresses:
                        	   573: ; 		defw 	00
                        	   574: ; 		defw 	p_load			;1
                        	   575: ; 		defw 	p_dumpmem		;2
                        	   576: ; 		defw 	p_pc			;3
                        	   577: ; 		defw 	p_eep			;4
                        	   578: ; 		defw 	p_clearmem		;5
                        	   579: ; 		defw 	p_exe			;6
                        	   580: ; 		defw 	p_go			;7
                        	   581: ; 		defw 	p_incDecPC		;8
                        	   582: ; 		defw 	p_incDecPC		;9
                        	   583: ; 		defw 	p_FON			;10
                        	   584: ; 		defw 	p_FOFF			;11
                        	   585: ; 		defw 	p_flwr			;12. write data to FLASH
                        	   586: ; 		defw 	p_flse			;13. sector erase
                        	   587: ; 		defw 	p_xmod			;14. transfer files via x-modem
                        	   588: ; 		defw 	p_reset			;16. Jump to $0000
                        	   589: ; 		defw	p_C_Read		;16. Read from SD card   sdrd  "file"  $Addr
                        	   590: ; 		defw	p_C_Write		;17. Write to SD card   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   591: ; 		defw	p_C_Read		;18. Read from USB   sdrd  "file"  $Addr
                        	   592: ; 		defw	p_C_Write		;19. Write to USB   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   593: ; 		defw	p_C_Delete		;20. delete file on SD card   sdrd  "file"  $Addr
                        	   594: ; 		defw	p_C_Delete		;21. delete file on USB  sdrd  "file"  $Addr.l $Addr.h/Num
                        	   595: ; 		defw 	p_C_Read		;22. List root level files/dirs on sd card
                        	   596: ; 		defw 	p_C_Read 		;23. List root level files/dirs on USB
                        	   597: ; 		defw	p_cptFl			;24. copy from mem to flash memory (on selected bank)
                        	   598: ; 		defw 	p_flbank		;25. Set flash bank #
                        	   599: ; 		defw	p_srbank		;26. Set sram bank #
                        	   600: 
                        	   601: command_list:
                        	   602: ;		*** command <STEND> textstring1/2 	address1/2	 lvalue1/2
                        	   603: 
01:01B9 1C              	   604: 		db		ITEM,1,4,"load",STEND,%100010,0,CDEL
01:01BA 01
01:01BB 04
01:01BC 6C6F6164
01:01C0 1D
01:01C1 22
01:01C2 00
01:01C3 EE
01:01C4 E404            	   605: 		dw 		p_load,0
01:01C6 0000
01:01C8 1C              	   606: 		db		ITEM,2,2,"dm",	STEND,%000010,0,CDEL
01:01C9 02
01:01CA 02
01:01CB 646D
01:01CD 1D
01:01CE 02
01:01CF 00
01:01D0 EE
01:01D1 E504            	   607: 		dw  	p_dumpmem,0
01:01D3 0000
01:01D5 1C              	   608: 		db		ITEM,3,2,"pc",	STEND,%000000,0,CDEL
01:01D6 03
01:01D7 02
01:01D8 7063
01:01DA 1D
01:01DB 00
01:01DC 00
01:01DD EE
01:01DE E904            	   609: 		dw 		p_pc,0
01:01E0 0000
01:01E2 1C              	   610: 		db		ITEM,4,3,"eep",	STEND,%000000,0,CDEL
01:01E3 04
01:01E4 03
01:01E5 656570
01:01E8 1D
01:01E9 00
01:01EA 00
01:01EB EE
01:01EC EA04            	   611: 		dw 		p_eep,0
01:01EE 0000
01:01F0 1C              	   612: 		db		ITEM,5,2,"cm",	STEND,%000000,0,CDEL
01:01F1 05
01:01F2 02
01:01F3 636D
01:01F5 1D
01:01F6 00
01:01F7 00
01:01F8 EE
01:01F9 F104            	   613: 		dw  	p_clearmem,0
01:01FB 0000
01:01FD 1C              	   614: 		db		ITEM,6,3,"exe",	STEND,%000000,0,CDEL
01:01FE 06
01:01FF 03
01:0200 657865
01:0203 1D
01:0204 00
01:0205 00
01:0206 EE
01:0207 0405            	   615: 		dw 		p_exe,0
01:0209 0000
01:020B 1C              	   616: 		db		ITEM,7,2,"go",	STEND,%000000,0,CDEL
01:020C 07
01:020D 02
01:020E 676F
01:0210 1D
01:0211 00
01:0212 00
01:0213 EE
01:0214 0505            	   617: 		dw 		p_go,0
01:0216 0000
01:0218 1C              	   618: 		db		ITEM,8,2,"++",	STEND,%000000,0,CDEL
01:0219 08
01:021A 02
01:021B 2B2B
01:021D 1D
01:021E 00
01:021F 00
01:0220 EE
01:0221 1605            	   619: 		dw 		p_incDecPC,0
01:0223 0000
01:0225 1C              	   620: 		db		ITEM,9,2,"--",	STEND,%000000,0,CDEL
01:0226 09
01:0227 02
01:0228 2D2D
01:022A 1D
01:022B 00
01:022C 00
01:022D EE
01:022E 1605            	   621: 		dw 		p_incDecPC,0
01:0230 0000
01:0232 1C              	   622: 		db		ITEM,10,3,"fl1",		STEND,%000000,0,CDEL; flash on, bank 1
01:0233 0A
01:0234 03
01:0235 666C31
01:0238 1D
01:0239 00
01:023A 00
01:023B EE
01:023C B006            	   623: 		dw		p_FON,0
01:023E 0000
01:0240 1C              	   624: 		db		ITEM,10,8,"flash-on",	STEND,%000000,0,CDEL; flash on, bank 1
01:0241 0A
01:0242 08
01:0243 666C6173682D6F6E
01:024B 1D
01:024C 00
01:024D 00
01:024E EE
01:024F B006            	   625: 		dw 		p_FON,0
01:0251 0000
01:0253 1C              	   626: 		db		ITEM,11,3,"fl0",		STEND,%000000,0,CDEL; flash off
01:0254 0B
01:0255 03
01:0256 666C30
01:0259 1D
01:025A 00
01:025B 00
01:025C EE
01:025D 0A07            	   627: 		dw 		p_FOFF,0
01:025F 0000
01:0261 1C              	   628: 		db		ITEM,11,9,"flash-off",	STEND,%000000,0,CDEL; flash off
01:0262 0B
01:0263 09
01:0264 666C6173682D6F66
01:026C 66
01:026D 1D
01:026E 00
01:026F 00
01:0270 EE
01:0271 0A07            	   629: 		dw 		p_FOFF,0
01:0273 0000
01:0275 1C              	   630: 		db		ITEM,12,4,"flwr",	STEND,%001110,0,CDEL
01:0276 0C
01:0277 04
01:0278 666C7772
01:027C 1D
01:027D 0E
01:027E 00
01:027F EE
01:0280 3B05            	   631: 		dw 		p_flwr,0									; write to flash: flwr  <$Addr.mem> <$Addr.flash>  <Num> (0E)
01:0282 0000
01:0284 1C              	   632: 		db		ITEM,13,4,"flse",	STEND,%000000,0,CDEL
01:0285 0D
01:0286 04
01:0287 666C7365
01:028B 1D
01:028C 00
01:028D 00
01:028E EE
01:028F 7005            	   633: 		dw 		p_flse,0
01:0291 0000
01:0293 1C              	   634: 		db		ITEM,14,4,"xmod",	STEND,%001000,0,CDEL
01:0294 0E
01:0295 04
01:0296 786D6F64
01:029A 1D
01:029B 08
01:029C 00
01:029D EE
01:029E 7905            	   635: 		dw 		p_xmod,0									; xmodem from PC   xmod <address>
01:02A0 0000
01:02A2 1C              	   636: 		db		ITEM,15,3,"rst",	STEND,%000000,0,CDEL
01:02A3 0F
01:02A4 03
01:02A5 727374
01:02A8 1D
01:02A9 00
01:02AA 00
01:02AB EE
01:02AC D004            	   637: 		dw 		p_reset,0
01:02AE 0000
01:02B0 1C              	   638: 		db		ITEM,16,4,"sdrd",	STEND,%101000,0,CDEL
01:02B1 10
01:02B2 04
01:02B3 73647264
01:02B7 1D
01:02B8 28
01:02B9 00
01:02BA EE
01:02BB 9105            	   639: 		dw		p_C_Read,0									; Read from SD card   sdrd  "file"  $Addr
01:02BD 0000
01:02BF 1C              	   640: 		db		ITEM,17,4,"sdwr",	STEND,%101010,0,CDEL
01:02C0 11
01:02C1 04
01:02C2 73647772
01:02C6 1D
01:02C7 2A
01:02C8 00
01:02C9 EE
01:02CA EA05            	   641: 		dw 		p_C_Write,0									; Write to SD card   sdwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:02CC 0000
01:02CE 1C              	   642: 		db		ITEM,18,5,"usbrd",	STEND,%101000,0,CDEL
01:02CF 12
01:02D0 05
01:02D1 7573627264
01:02D6 1D
01:02D7 28
01:02D8 00
01:02D9 EE
01:02DA 9105            	   643: 		dw 		p_C_Read,0									; Read from USB      usbrd  "file"  $Addr
01:02DC 0000
01:02DE 1C              	   644: 		db		ITEM,19,5,"usbwr",	STEND,%101010,0,CDEL
01:02DF 13
01:02E0 05
01:02E1 7573627772
01:02E6 1D
01:02E7 2A
01:02E8 00
01:02E9 EE
01:02EA EA05            	   645: 		dw 		p_C_Write,0									; Write to USB        usbwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:02EC 0000
01:02EE 1C              	   646: 		db		ITEM,20,5,"sddel",	STEND,%100000,0,CDEL
01:02EF 14
01:02F0 05
01:02F1 736464656C
01:02F6 1D
01:02F7 20
01:02F8 00
01:02F9 EE
01:02FA 4206            	   647: 		dw 		p_C_Delete,0 								; Delete file on SD card   sddel  "file"  
01:02FC 0000
01:02FE 1C              	   648: 		db		ITEM,21,6,"usbdel",	STEND,%100000,0,CDEL
01:02FF 15
01:0300 06
01:0301 75736264656C
01:0307 1D
01:0308 20
01:0309 00
01:030A EE
01:030B 4206            	   649: 		dw 		p_C_Delete,0 								; Delete file on USB   usbdel  "file"  
01:030D 0000
01:030F 1C              	   650: 		db		ITEM,22,5,"sddir",	STEND,%100000,0,CDEL
01:0310 16
01:0311 05
01:0312 7364646972
01:0317 1D
01:0318 20
01:0319 00
01:031A EE
01:031B 9105            	   651: 		dw 		p_C_Read,0 									; List root level files/dirs on sd card
01:031D 0000
01:031F 1C              	   652: 		db		ITEM,23,6,"usbdir",	STEND,%100000,0,CDEL
01:0320 17
01:0321 06
01:0322 757362646972
01:0328 1D
01:0329 20
01:032A 00
01:032B EE
01:032C 9105            	   653: 		dw 		p_C_Read,0 									; List root level files/dirs on USB
01:032E 0000
01:0330 1C              	   654: 		db 		ITEM,24,5,"cptfl",	STEND,%001100,0,CDEL
01:0331 18
01:0332 05
01:0333 637074666C
01:0338 1D
01:0339 0C
01:033A 00
01:033B EE
01:033C 7906            	   655: 		dw 		p_cptFl,0									; copy from adress range to flash   cptfl  $Addr   $Addr
01:033E 0000
01:0340 1C              	   656: 		db 		ITEM,25,2,"fb",		STEND,%000010,0,CDEL
01:0341 19
01:0342 02
01:0343 6662
01:0345 1D
01:0346 02
01:0347 00
01:0348 EE
01:0349 9406            	   657: 		dw 		p_flbank,0									; set flash bank #	
01:034B 0000
01:034D 1C              	   658: 		db 		ITEM,26,2,"sb",		STEND,%000010,0,CDEL
01:034E 1A
01:034F 02
01:0350 7362
01:0352 1D
01:0353 02
01:0354 00
01:0355 EE
01:0356 8106            	   659: 		dw		p_srbank,0									; set sram bank #	
01:0358 0000
01:035A 1C              	   660: 		db		ITEM,27,3,"nop",	STEND,%000000,0,CDEL
01:035B 1B
01:035C 03
01:035D 6E6F70
01:0360 1D
01:0361 00
01:0362 00
01:0363 EE
01:0364 0000            	   661: 		dw 		0,0
01:0366 0000
01:0368 1E              	   662: 		db		LISTEND
                        	   663: commListLen  equ   27
                        	   664: 
                        	   665: 		; ld		HL,$6000
                        	   666: 		; ld		(packetBaseAddress),HL			; store the address for target code (for error correction)
                        	   667: 		; ld		A,01
                        	   668: 		; ld		(prevPacketByte01),A 				; store of packet numbers
                        	   669: 
                        	   670: 		; call 	SetupXMODEM_TXandRX					 
                        	   671: 	
                        	   672: 
                        	   673: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   674: ;---------------------------------------------------------------------------------
                        	   675: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   676: 
                        	   677: ;		skipPriorDelimit 		; increase A0 until non delimiter (NZ) or #0 (Z) 
                        	   678: ;		***		store string value in textarea and reference in table
                        	   679: ;		skipCharsUntilDelim		; increase A0 until blank (NZ) or #0 (Z) 
                        	   680: ;		***		read/store either address or lvalue and store in table
                        	   681: ; 		isDelimit(S)  is char in (A0) any of the delimiters specified in (A1) ? =>Z, else ~Z
                        	   682: ; 		Parameters returned; A0 - Address of char
                        	   683: 
                        	   684: ;		commParseTable
                        	   685: ;		***************************************************
                        	   686: ;		***	decode input line;
                        	   687: ;		*** <cmd>    "TEXT"  	$xxyy  xxyy
                        	   688: ;		*** command textstring 	address	 lvalue
                        	   689: ;		************************************************************
                        	   690: ;		*** commParseTable:
                        	   691: ;		*** 00 : W : offset in jumptable  (F080)
                        	   692: ;		*** 04 : L : address 1  (F084-F087)
                        	   693: ;		*** 08 : L : address 2  (F088-F08B)
                        	   694: ;		*** 10 : L : lvalue1  (F090-F09F)
                        	   695: ;		*** 20 : L : lvalue2  (F0A0-F0AF)
                        	   696: ;		*** 57 : L : text1   (F0B0-F0D7)
                        	   697: ;		*** 58 : L : text2 	 (F0D8-F0FF)	
                        	   698: ;		***
                        	   699: ;		***--------------------------------------
                        	   700: 
                        	   701: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   702: ;---------------------------------------------------------------------------------
                        	   703: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   704: 
                        	   705: 		; call	skipCharsUntilDelim			; set (HL) to first delimiter
                        	   706: 		; push 	HL
                        	   707: 		; pop  	BC							; typed command end+1 in BC
                        	   708: 
                        	   709: 		; ***	Prepares the commParseTable. Consumes HL,B,A
                        	   710: initCommParseTable:
01:0369 3E00            	   711: 		ld 		A,0
01:036B 320000          	   712: 		ld 		(PCinpFlag),A
01:036E 320100          	   713: 		ld 		(PCinpFlag+1),A
01:0371 210000          	   714: 		ld 		HL,commParseTable
                        	   715: 
01:0374 0680            	   716: 		ld 		B,$80
01:0376 97              	   717: 		sub 	A 					; clear A.
                        	   718: .icpt:
01:0377 77              	   719: 		ld 		(HL),A
01:0378 23              	   720: 		inc 	HL
01:0379 10FC            	   721: 		djnz 	.icpt
                        	   722: 
01:037B C9              	   723: 		ret
                        	   724: 
                        	   725: ;---------------------------------------------------------------------------------
                        	   726: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   727: 
                        	   728: 	;***************************************************************
                        	   729: 	;	Command identified -> now search for string :
                        	   730: 	;***************************************************************
                        	   731: 
                        	   732: matchInList:
                        	   733: 		; ***	Kommandeo hittat i listan. Kolla sedan om inmatad sträng finns "<string>"
                        	   734: 		; ***	DE pekar på första avgränsare efter kommandot i listan 
                        	   735: 						;Hittade avgränsare ? =>Z, annars ~Z
                        	   736: 						;tecken i (HL) är '0' ->  sätt C, annars NC
                        	   737: 
01:037C 33              	   738: 		inc 	sp
01:037D 33              	   739: 		inc 	sp						; flytta SP en adress upp i stacken <scanCommandList>
01:037E 23              	   740: 		inc 	HL 						; HL pekar på första efter <STEND>  ->spec vilka argument som krävs (STEND,%100010,0,CDEL,p_load,0)
                        	   741: 										; command <STEND> textstring1/2 	address1/2	 lvalue1/2
                        	   742: 
01:037F 7E              	   743: 		ld 		A,(HL) 					; reg A= specifikation av vilka argument som krävs i kommandot (STEND,%100010,0,CDEL,p_load,0)
01:0380 FD210000        	   744: 		ld 		IY,commParseTable		; IY = commParseTable =	0x80 + _String_HEAP
01:0384 FD7502          	   745: 		ld   	(IY+2),L 
01:0387 FD7403          	   746: 		ld   	(IY+3),H				; spara (IY,2,3) som är  kommando adress.
                        	   747: 		
01:038A FD7100          	   748: 		ld 		(IY),C 					; spara kommando löpnummer i (commParseTable, 0x80)
01:038D FD7701          	   749: 		ld 		(IY+1),A				; spara  pecifikation av vilka argument som krävs i (commParseTable+1, 0x81)
                        	   750: 		; call 	writeSTRBelow_CRLF
                        	   751: 		; DB 		0,"Found a valid command  see (C).. !",CR,LF,00
01:0390 D5              	   752: 		push 	DE
01:0391 E1              	   753: 		pop 	HL						; HL=DE = första avgränsare efter angiven kommndotext
01:0392 2B              	   754: 		dec 	HL							; DE -> HL -> sista tecken innan avgränsare
                        	   755: paramLoopEntry:	
                        	   756: 
01:0393 CD0000          	   757: 		call 	skipPriorDelimit 			; hitta nästa avgränsare (  '"' ?)  		db   ' _&/#,=',CR,0,0	
01:0396 DA8104          	   758: 		jp 		C,executeCommand			; C flagga från 'skipPriorDelimit', inga kommando argument kvar, hoppa till executeCommand
                        	   759: 
01:0399 7E              	   760: 		ld 		A,(HL)
                        	   761: 
01:039A FE22            	   762: 		cp 		'"'							; början på sträng ?̣
01:039C 2029            	   763: 		jr 		NZ,checkaddress				;  NZ -> (HL) pekar på något annat än '"', kolla om det är adress eller lvalue input
                        	   764: 										;  Z -> (HL) pekar på '"', fortsätt att extrahera sträng
                        	   765: 
                        	   766: 		; ***	hämta sträng i inmatning, som är avgränsad av två '"' tecken, och spara i commParseTable
01:039E 23              	   767: 		inc 	HL 							; skip '"' (HL)-> första bokstav i sträng
                        	   768: 
01:039F E5              	   769: 		push  	HL
01:03A0 D1              	   770: 		pop  	DE							; DE -> första bokstav i sträng
01:03A1 CD0000          	   771: 		call 	skipCharsUntilDelim			; hitta sista avgränsare (  '"' ?)
01:03A4 2B              	   772: 		dec 	HL 							; hoppa förbi första '"' (ev. CR)
01:03A5 7E              	   773: 		ld 		A,(HL)
01:03A6 FE22            	   774: 		cp 		'"' 						; hittade andra (=Z) '"' ??
01:03A8 C28601          	   775: 		jp 		NZ,inputerror
01:03AB 2B              	   776: 		dec 	HL 							; hoppa föri andra '"'
                        	   777: 	;***************************************************************
                        	   778: 	;	kopiera sträng till  'commParseTable'
                        	   779: 	;***************************************************************
                        	   780: 
01:03AC A7              	   781: 		and 	A
01:03AD ED52            	   782: 		sbc 	HL,DE 						; beräkna antalet tecken...
01:03AF 44              	   783: 		ld 		B,H							; amount of chars...
01:03B0 4D              	   784: 		ld 		C,L							; beräkna antalet tecken -> BC
01:03B1 03              	   785: 		inc 	BC
                        	   786: 
01:03B2 210000          	   787: 		ld 		HL,commStr1				;  HL = address för första strängen i commParseTable
01:03B5 7E              	   788: 		ld 		A,(HL)
01:03B6 B7              	   789: 		or 		A 						; = värde i commStr1 = reg A = 0? isåfall, .strone
01:03B7 2808            	   790: 		jr 		Z, .strone
01:03B9 210000          	   791: 		ld 		HL,commStr2				; address för andra stängen
01:03BC 7E              	   792: 		ld 		A,(HL)
01:03BD B7              	   793: 		or  	A						; = värde i commStr2 = reg A = 0? ominte isåfall, visa input error (för många strängar)
01:03BE C28601          	   794: 		jp 		NZ,inputerror	
                        	   795: .strone:
01:03C1 EB              	   796: 		ex 		DE,HL 					;kopiera (HL) till (DE) (BC st. HL = <source>, DE = <dest>, size = BC
01:03C2 EDB0            	   797: 		ldir 							; kopiera värdet av strängen till commParseTable
                        	   798: 		; ex		DE,HL
01:03C4 23              	   799: 		inc 	HL 						; (HL) förbi den andra '"'
                        	   800: 
01:03C5 18CC            	   801: 		jr 		paramLoopEntry
                        	   802: 
                        	   803: 
                        	   804: 	;***************************************************************
                        	   805: 	;	Kontrollera om en adress är angiven, 
                        	   806: 	;***************************************************************
                        	   807: 
                        	   808: 
                        	   809: checkaddress:
                        	   810: 		; ***	A = (HL), första tecken efter avgränsare
                        	   811: 
01:03C7 320100          	   812: 		ld 		(PCinpFlag+1),A			; if tecken är $ '(PCinpFlag+1)' == '$' -> angive n address
                        	   813: 										; if tecken är '(PCinpFlag+1)' == '@' -> relativ adress till (PCval) angiven
01:03CA FE24            	   814: 		cp 		'$'						; jämför address id $
01:03CC 3E00            	   815: 		ld 		A,0
01:03CE 2802            	   816: 		jr 		Z,chkADR				; Tecknet är $ (adress) (PCinpFlag+1) is '$' ??
                        	   817: 		; cp 		'@'						; jämför address id @
                        	   818: 		; jr 		Z,chkADR			; Tecknet är $ (relativ adress PCval)  (PCinpFlag+1) is '@' ??
                        	   819: 
01:03D0 1823            	   820: 		jr 		getLvalue				; kontrollera om bytes är angivna,
                        	   821: 
01:03D2 23              	   822: chkADR:	inc 	HL 						; HL: hoppa förbi '$' eller '@'
                        	   823: 
                        	   824: chkADR1:
                        	   825: 	; ***		Var ska adress lagras ...
                        	   826: 
01:03D3 DD210000        	   827: 		ld 		IX,commAdr1		; IX = address för första address i commParseTable
                        	   828: 		; ld 		A,0
01:03D7 DDBE00          	   829: 		cp 		(IX)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> kolla adress 2
01:03DA 2007            	   830: 		jr 		NZ,chkADR2
01:03DC DDBE01          	   831: 		cp 		(IX+1)			; ckontrollera adress lsb  inte 0 ? (ascii värde redan lagrat)-> kolla adress 2
01:03DF 2002            	   832: 		jr 		NZ,chkADR2
01:03E1 1832            	   833: 		jr 		makeASCIItoHEX	; konvertera (HL)till hex. (IX)	ska få adressen i hex 
                        	   834: chkADR2:
                        	   835: 
01:03E3 DD210000        	   836: 		ld 		IX,commAdr2
                        	   837: 		; ld 		A,0
01:03E7 DDBE00          	   838: 		cp 		(IX)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> visa error (för många adresser)
01:03EA C28601          	   839: 		jp 		NZ,inputerror	; error : för många adresser angivna
01:03ED DDBE01          	   840: 		cp 		(IX+1)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> visa error (för många adresser)
01:03F0 C28601          	   841: 		jp 		NZ,inputerror	; error : No more addresses to store
01:03F3 1820            	   842: 		jr 		makeASCIItoHEX	; konvertera till hex. (IX)	ska få adressen i hex
                        	   843: 
                        	   844: getLvalue:
01:03F5 DD210000        	   845: 		ld 		IX,commLvl1
01:03F9 DDBE00          	   846: 		cp 		(IX)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> kolla bytevärde 2
01:03FC 2007            	   847: 		jr 		NZ,chkLVL2
01:03FE DDBE01          	   848: 		cp 		(IX+1)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> kolla bytevärde 2
01:0401 2002            	   849: 		jr 		NZ,chkLVL2
01:0403 1810            	   850: 		jr 		makeASCIItoHEX	 konvertera till hex. (IX)	ska få adressen i hex
                        	   851: 
                        	   852: chkLVL2:
01:0405 DD210000        	   853: 		ld 		IX,commLvl2
01:0409 DDBE00          	   854: 		cp 		(IX)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> visa error (för många värden)
01:040C C28601          	   855: 		jp 		NZ,inputerror	; error : för många värden angivna
01:040F DDBE01          	   856: 		cp 		(IX+1)			; kontrollera msb inte 0 ? (ascii värde redan lagrat) -> visa error (för många värden)
01:0412 C28601          	   857: 		jp 		NZ,inputerror	; error : inga mer värden att lagra
                        	   858: 
                        	   859: 
                        	   860: makeASCIItoHEX:
                        	   861: 		; ***	kopiera från angivet kommando till adress eller värde i tabell
                        	   862: 		; ***	två bytes (four chars)....
                        	   863: 		; 		IX pekar på destination...
01:0415 54              	   864: 		ld 		D,H
01:0416 5D              	   865: 		ld		E,L						; DE -> första tecken efter '$' | '@' 
01:0417 CD0000          	   866: 		call 	skipCharsUntilDelim		; Hitta nästa avgränsare eller CR ; adress i HL
01:041A 7E              	   867: 		ld 		A,(HL)
                        	   868: 
                        	   869: 	;************************************************************************
                        	   870: 	;	kopiera sträng till  'commParseTable', IX pekar på destination adress
                        	   871: 	;************************************************************************
                        	   872: 
01:041B A7              	   873: 		and 	A						; nollställ Carry
01:041C ED52            	   874: 		sbc 	HL,DE 					; antal tecken i...->HL ( H=0); DE -> första tecken efter '$' <source>
                        	   875: 
                        	   876: 		; ***	kolla inte jämn /udda...
                        	   877: 		; bit 	0,L 					; even or odd (=1)?
                        	   878: 		; jp 		NZ,inputerror
                        	   879: 
01:041E 45              	   880: 		ld 		B,L 					; tecken räknare i B
01:041F 210000          	   881: 		ld 		HL,00					;  
                        	   882: 
01:0422 EB              	   883: 		ex 		DE,HL					; HL,DE byter plats. HL -> första tecken efter '$' <ascii source>	
                        	   884: 
                        	   885: nextHalfByte:
                        	   886: 
01:0423 CD0000          	   887: 		call 	isHex					; kolla tecken i (HL) retur med Carry satt, värde i regA inte HEX-värde
01:0426 DA8601          	   888: 		jp 		C,inputerror			; retur med Carry satt, värde i regA är inte HEX-värde
                        	   889: 
01:0429 CB23            	   890: 		sla 	E						; skift vänster E-> Carry
01:042B CB12            	   891: 		rl 		D 						; Carry -> rotera vänster D
01:042D CB23            	   892: 		sla 	E						; skift vänster E-> Carry
01:042F CB12            	   893: 		rl 		D 						; Carry -> rotera vänster D
01:0431 CB23            	   894: 		sla 	E						; skift vänster E-> Carry
01:0433 CB12            	   895: 		rl 		D 						; Carry -> rotera vänster D
01:0435 CB23            	   896: 		sla 	E						; skift vänster E-> Carry
01:0437 CB12            	   897: 		rl 		D 						; Carry -> rotera vänster D
01:0439 B3              	   898: 		or      E  						; regA eller regE(bit 0..3) är 0
01:043A 5F              	   899: 		ld 		E,A
                        	   900: 
01:043B DD7300          	   901: 		ld 		(IX),E					; lagra E värde [big endian]
01:043E DD7201          	   902: 		ld 		(IX+1),D				; lagra D värde [big endian]
                        	   903: 
01:0441 23              	   904: 		inc 	HL
                        	   905: 
01:0442 10DF            	   906: 		djnz 	nextHalfByte
                        	   907: 		;***	HL spekar på första avgränsare...
                        	   908: 
                        	   909: byteEnd:
                        	   910: 
01:0444 3A0000          	   911: 		ld  	A,(PCinpFlag)
01:0447 B7              	   912: 		or  	A 						; om flagga Z; =0 -> spara parameter normalt
01:0448 CA9303          	   913: 		jp 	   	Z,paramLoopEntry
                        	   914: 
01:044B 3A0100          	   915: 		ld  	A,(PCinpFlag+1) 		; är angiven parameter address för PCValue ?
01:044E FE24            	   916: 		cp 		'$' 					; kolla för adress flag ?
                        	   917: 		; jr 		Z,changePCVal		; hoppa till ändring av PCvalue
                        	   918: 		; cp 		'@' 					; @ = relativ adress flagga ?
01:0450 2813            	   919: 		jr 		Z,changePCVal			; hoppa till ändring av PCvalue
                        	   920: 
                        	   921: 		; ***	lagra bytes värden från LVL1 till (PCval)
01:0452 E5              	   922: 		push 	HL
01:0453 ED5B0000        	   923: 		ld 		DE,(PCvalue)			; DE = (PCvalue), destination för bytevärden
01:0457 210000          	   924: 		ld 		HL,commLvl1				; HL pekar på första bytevärde i commParseTable
                        	   925: 		; ld 		A,(DE)
                        	   926: 		; ld 		(HL),A
                        	   927: 		; inc 	HL
                        	   928: 		; inc 	DE
01:045A EDA0            	   929: 		ldi  							; (DE)<-(HL), inc HL,DE, dec BC
01:045C 7E              	   930: 		ld 		A,(HL)
01:045D B7              	   931: 		or 		A
01:045E 2801            	   932: 		jr 		Z,noHighNib
01:0460 12              	   933: 		ld 		(DE),A
                        	   934: noHighNib:
01:0461 E1              	   935: 		pop 	HL		
                        	   936: 		; ***	reset flag
                        	   937: 		; ld 		A,0
                        	   938: 		; ld 		(PCinpFlag),A
                        	   939: 		; ld 		(PCinpFlag+1),A
01:0462 C39303          	   940: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   941: 
                        	   942: 		
                        	   943: changePCVal:
                        	   944: 		; ***	Ändra relativa värdet på PCval från 'commAdr1' eller
                        	   945: 		; ***	ändra PCvalue från 'commAdr1'
                        	   946: 		; ***	regA är '$' or '@'
01:0465 E5              	   947: 		push 	HL
01:0466 D5              	   948: 		push  	DE
01:0467 FE40            	   949: 		cp   	'@' 					; relativ adress ?
01:0469 2806            	   950: 		jr 		Z,.reladr				; flagga Z = '@'  -> relativ adress, annars absolut adress
                        	   951: ; 		***		absolute adr !		
01:046B 210000          	   952: 		ld 		HL,00
01:046E 220000          	   953: 		ld 		(PCvalue),HL				; nollställ PCvalue och addera från commAdr1
                        	   954: 
                        	   955: .reladr:		
01:0471 2A0000          	   956: 		ld 		HL,(commAdr1)			; HL pekar på commAdr1, som är första adressen i commParseTable
01:0474 ED5B0000        	   957: 		ld  	DE,(PCvalue)			; DE = (PCvalue), destination för bytevärden	
01:0478 19              	   958: 		add 	HL,DE
01:0479 220000          	   959: 		ld 		(PCvalue),HL			; resulterande värde för PCvalue
01:047C D1              	   960: 		pop 	DE						; återställ DE
01:047D E1              	   961: 		pop 	HL 						; restore value of first delimiter
01:047E C39303          	   962: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   963: 
                        	   964: executeCommand:	
                        	   965: 		; ***	execute commands (and arguments)
                        	   966: 		; call 	writeSTRBelow
                        	   967: 		; DB 		0,"Finish parsing !",CR,LF,00
                        	   968: 		; call 	DumpRegisters			; checkpoint for list of arguments
                        	   969: 		; ***	IY+2 point to command address. IY=commParseTable
                        	   970: 
01:0481 3A0000          	   971: 		ld 		A,(PCinpFlag)
01:0484 B7              	   972: 		or 		A   					; check if zero  
01:0485 2003            	   973: 		jr 		NZ,.noJump
                        	   974: 
01:0487 CD9504          	   975: 		call 	JPTable01
                        	   976: .noJump:
                        	   977: 		; ***	reset flag
01:048A 3E00            	   978: 		ld 		A,0
01:048C 320000          	   979: 		ld 		(PCinpFlag),A
01:048F 320100          	   980: 		ld 		(PCinpFlag+1),A
                        	   981: 
                        	   982: 		
                        	   983: 		; jp 		paramLoopEntry 				; loop and check for more parameters
                        	   984: 
                        	   985: temp_finish:
                        	   986: 		; call 	DumpRegisters
01:0492 C3D900          	   987: 		jp 		next_line
                        	   988: 
                        	   989: 	;***************************************************************
                        	   990: 	;	Check if LVALUE is specified in input 
                        	   991: 	;***************************************************************
                        	   992: 
                        	   993: JPTable01:
01:0495 3A0000          	   994: 		ld 		A,(commParseTable) 			; retrieve command number
01:0498 B7              	   995: 		or 	  	A 							; error if 0
01:0499 CA8601          	   996: 		jp 		Z,inputerror
01:049C FE1B            	   997: 		cp 		commListLen
01:049E 3F              	   998: 		ccf 						;complement carry for error indicator
                        	   999: 
01:049F DA8601          	  1000: 		jp      C,inputerror
                        	  1001: 
01:04A2 E5              	  1002: 		push  	HL					; make space in stack for 'return' address
                        	  1003: 
                        	  1004: 		; 								;obtain routine address from table and transfer 
                        	  1005: 		; 								;control to it, leaving all register pairs unchanged
                        	  1006: 		
01:04A3 FD2A0200        	  1007: 		ld   	IY,(commParseTable+2)	; get address $F080+2
01:04A7 FD6E03          	  1008: 		ld   	L,(IY+3)				; load address in HL, move pointer 3 pos forward
01:04AA FD6604          	  1009: 		ld   	H,(IY+4)
                        	  1010: 
01:04AD E3              	  1011: 		ex 		(SP),HL					;restore old HL, push routine address
01:04AE C9              	  1012: 		ret 							; jump to routine
                        	  1013: 
                        	  1014: argumentsError:
01:04AF CD0000          	  1015: 		call 	writeSTRBelow
01:04B2 00              	  1016: 		DB 		0,"Some arguments mismatch !",CR,LF,00
01:04B3 536F6D6520617267
01:04BB 756D656E7473206D
01:04C3 69736D6174636820
01:04CB 21
01:04CC 0D
01:04CD 0A
01:04CE 00
01:04CF C9              	  1017: 		ret
                        	  1018: 
                        	  1019: 
                        	  1020: p_reset:
01:04D0 AF              	  1021: 		xor 	A
01:04D1 320000          	  1022: 		ld 		(memBankID),A			; set memory banks #0
01:04D4 CD0000          	  1023: 		call 	setFLASHBank			; FLASH bank #0
01:04D7 AF              	  1024: 		xor 	A
01:04D8 CD0000          	  1025: 		call 	setSRAMBank				; ram bank #0
                        	  1026: 
01:04DB CD0000          	  1027: 		call 	enableFLASH			; start from FLASH
                        	  1028: 
01:04DE CD0000          	  1029: 		call 	enableIC620_OE 			; enable the outputs.
                        	  1030: 
01:04E1 C30000          	  1031: 		jp $0000
                        	  1032: 
                        	  1033: p_load:
01:04E4 C9              	  1034: 		ret
                        	  1035: p_dumpmem:
01:04E5 CD0000          	  1036: 		call 	dumpMemory
                        	  1037: 
01:04E8 C9              	  1038: 		ret
                        	  1039: p_pc:
01:04E9 C9              	  1040: 		ret
                        	  1041: 
                        	  1042: p_eep:
                        	  1043: 
01:04EA 210000          	  1044: 		ld 		HL,000
01:04ED 220000          	  1045: 		ld 		(PCvalue),hl
01:04F0 C9              	  1046: 		ret
                        	  1047: 
                        	  1048: p_clearmem:
                        	  1049: ;		***		clear memory from PC/Adr n bytes from ram memory
                        	  1050: 
01:04F1 ED4B0000        	  1051: 		ld 		BC,(commLvl1)    	;amount of bytes
01:04F5 ED5B0000        	  1052: 		ld   	DE,(PCvalue)		 
01:04F9 210305          	  1053: 		ld		hl,.zero_byte
                        	  1054: 		
                        	  1055: .cl_vars:
01:04FC EDA0            	  1056: 		ldi							; (DE)<-(HL)
01:04FE 2B              	  1057: 		dec 	hl
01:04FF EAFC04          	  1058: 		jp		PE,.cl_vars			; 		P/V is set if BC – 1 ≠ 0; otherwise, it is reset.
                        	  1059: 
01:0502 C9              	  1060: 		ret
01:0503 00              	  1061: .zero_byte:	db  0
                        	  1062: 
                        	  1063: p_exe:
                        	  1064: 
                        	  1065: 		; call 	LCD_Test
                        	  1066: 
01:0504 C9              	  1067: 		ret
                        	  1068: p_go:
                        	  1069: 
01:0505 18FD            	  1070: 		jr 	p_exe
                        	  1071: 
                        	  1072: 
01:0507 3A0000          	  1073: 		ld 		A,(TempVar1)
01:050A 3C              	  1074: 		inc 	A
01:050B 320000          	  1075: 		ld 		(TempVar1),A
01:050E FE0F            	  1076: 		cp 		15
01:0510 CD0000          	  1077: 		call 	DumpRegisters
                        	  1078: 		
01:0513 F0              	  1079: 		ret 	P
01:0514 18EF            	  1080: 		jr 		p_go
                        	  1081: p_incDecPC:
01:0516 210000          	  1082: 		ld 		HL,commLvl1
01:0519 3E00            	  1083: 		ld 		A,0
01:051B 5E              	  1084: 		ld 		E,(HL)
01:051C 23              	  1085: 		inc 	HL
01:051D 56              	  1086: 		ld 		D,(hl) 				; DE = (commLvl1)
                        	  1087: 		; ***	if both D and E is 0 -> DE = 1 		; no param -> A=1
01:051E BB              	  1088: 		cp 		E
01:051F 2006            	  1089: 		jr 		NZ,.justOne
01:0521 BA              	  1090: 		cp 		D
01:0522 2003            	  1091: 		jr 		NZ,.justOne
01:0524 110100          	  1092: 		ld 		DE,1
                        	  1093: .justOne:
01:0527 3A0000          	  1094: 		ld 		A,(commParseTable)	; command number in commParseTable
01:052A 2A0000          	  1095: 		ld 		HL,(PCvalue)
01:052D FE08            	  1096: 		cp 		8 					; ++ (increase) ??
01:052F 2003            	  1097: 		jr  	nz,.sub
01:0531 19              	  1098: 		add 	HL,DE 				; increase HL (PCvalue) with DE
01:0532 1803            	  1099: 		jr 		.common
                        	  1100: .sub:
01:0534 A7              	  1101: 		and 	A					; clear C
01:0535 ED52            	  1102: 		sbc 	HL,DE 				; decrease HL (PCvalue) with DE
                        	  1103: .common:
01:0537 220000          	  1104: 		ld 		(PCvalue),HL
01:053A C9              	  1105: 		ret
                        	  1106: p_flwr:
                        	  1107: 		; *** 	testwrite to FLASH
                        	  1108: 		
                        	  1109: 		; call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
                        	  1110: 		; jp		NZ,argumentsError			; show argument error and return
                        	  1111: 		; 	*** Check if flashmem is enabled
01:053B 3A0000          	  1112: 		ld 		A,(memBankID)
01:053E CB7F            	  1113: 		bit 	7,A
01:0540 2004            	  1114: 		jr 		NZ,errNoFlash
                        	  1115: 
01:0542 CD0000          	  1116: 		call 	Flash_WR_Test
01:0545 C9              	  1117: 		ret
                        	  1118: errNoFlash:
01:0546 CD0000          	  1119: 		call 	writeSTRBelow
01:0549 00              	  1120: 		DB 		0," Can't write to deselected FLASH !",CR,LF,00
01:054A 2043616E27742077
01:0552 7269746520746F20
01:055A 646573656C656374
01:0562 656420464C415348
01:056A 2021
01:056C 0D
01:056D 0A
01:056E 00
                        	  1121: 
01:056F C9              	  1122: 		ret
                        	  1123: 
                        	  1124: 
                        	  1125: p_flse:
                        	  1126: 		; *** 	erase the sector that contain the address of HL
                        	  1127: 
01:0570 E5              	  1128: 		push	HL
01:0571 211020          	  1129: 		ld 		HL,$2010
01:0574 CD0000          	  1130: 		call 	Flash_SE_Erase
01:0577 E1              	  1131: 		pop 	HL
01:0578 C9              	  1132: 		ret
                        	  1133: 
                        	  1134: p_xmod:
                        	  1135: 		; ***	Transfer files via x-modem
                        	  1136: 		; ***	Check commParseTable+1 if required parameters
                        	  1137: 
01:0579 3A0100          	  1138: 		ld 		A,(commParseTable+1)
01:057C CD0000          	  1139: 		call    DumpRegisters
01:057F CB47            	  1140: 		bit 	0,A 			; should be a <2-textstring 	1-address	 0-lvalue>
01:0581 2804            	  1141: 		jr 		Z,.nxta
                        	  1142: 		; ***	check the commLvl1 if zero
01:0583 ED5B0000        	  1143: 		ld 		DE,(commLvl1)
                        	  1144: .nxta:		
                        	  1145: 
                        	  1146: 		ifndef 	BOOTLOAD				; don not use during BOOT
01:0587 CD0000          	  1147: 		call 	doImportXMODEM
                        	  1148: 
01:058A CD0000          	  1149: 		call 	SIO_A_TXRX_INTon
01:058D CD0000          	  1150: 		call 	CTC1_INT_OFF
                        	  1151: 		endif	
01:0590 C9              	  1152: 		ret
                        	  1153: 
                        	  1154: p_C_Read:
                        	  1155: 
01:0591 CD4307          	  1156: 		call 	checkArgsTAL				; check necessary args
01:0594 C2AF04          	  1157: 		jp		NZ,argumentsError			; show argument error and return
                        	  1158: 	
01:0597 110000          	  1159: 		ld 		DE,CTC_delay_INT_handler
01:059A ED5312F4        	  1160: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1161: 
                        	  1162: 	if 	GPIODEBUG=1
                        	  1163: 		xor A
                        	  1164: 		out (gpio_out),A
                        	  1165: 	endif
                        	  1166: 
01:059E CD0000          	  1167: 		call  	SIO_A_DI					; disable text output
                        	  1168: 	if 	GPIODEBUG=1
                        	  1169: 		ld a,4
                        	  1170: 		out (gpio_out),A
                        	  1171: 		ld a,0
                        	  1172: 		out (gpio_out),A
                        	  1173: 	endif
                        	  1174: 	
01:05A1 7B              	  1175: 		ld a,e
01:05A2 CD0000          	  1176: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
01:05A5 CD0000          	  1177: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
01:05A8 CD0000          	  1178: 		call 	HC376S_ResetAll
01:05AB CD0000          	  1179: 		call 	HC376S_CheckConnection
01:05AE 3A0000          	  1180: 		ld 		A,(commParseTable)
01:05B1 FE0F            	  1181: 		cp 		15							; 15 read SD; 17-read USB
01:05B3 280C            	  1182: 		jr 		Z,.doSD
01:05B5 FE15            	  1183: 		cp 		21							; 21 read SD enumerate, 22 read USB enumerate
01:05B7 2808            	  1184: 		jr 		Z,.doSD
01:05B9 CD0000          	  1185: 		call 	HC376S_setUSBMode
01:05BC CD0000          	  1186: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:05BF 1803            	  1187: 		jr 		.cont
                        	  1188: .doSD:
01:05C1 CD0000          	  1189: 		call 	HC376S_setSDMode
                        	  1190: 		
                        	  1191: .cont:
01:05C4 CD0000          	  1192: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:05C7 2011            	  1193: 		jr 		NZ,abort
                        	  1194: 
01:05C9 CD0000          	  1195: 		call 	HC376S_setFileName
01:05CC CD0000          	  1196: 		call 	HC376S_fileOpen
01:05CF 2009            	  1197: 		jr 		NZ,abort
                        	  1198: 
01:05D1 CD0000          	  1199: 		call 	HC376S_getFileSize
01:05D4 CD0000          	  1200: 		call 	HC376S_fileRead
01:05D7 CD0000          	  1201: 		call 	HC376S_fileClose
                        	  1202: abort:
                        	  1203: 
                        	  1204: 		; ***	reset the interrupt handler for CTC
01:05DA CD0000          	  1205: 		call 	SIO_A_EI					; enable text output
01:05DD CD0000          	  1206: 		call 	HC376S_ResetAll
01:05E0 CD0000          	  1207: 		call 	CTC1_INT_OFF
01:05E3 210000          	  1208: 		ld		HL,CTC_CH1_Interrupt_Handler
01:05E6 2212F4          	  1209: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
01:05E9 C9              	  1210: 		ret
                        	  1211: 
                        	  1212: 		
                        	  1213: p_C_Write:
01:05EA CD4307          	  1214: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
01:05ED 2816            	  1215: 		jr 		Z,.contWR
                        	  1216: 		; ***	check alternative (2 adresses)
01:05EF 3E2C            	  1217: 		ld 		A,%101100					; alt. with "string" $Adr1 < $Adr2
01:05F1 77              	  1218: 		ld 		(HL),A						; HL-> (commParseTable+1);
01:05F2 23              	  1219: 		inc 	HL			; HL-> (commParseTable+2); get the resulting arguments counted
01:05F3 BE              	  1220: 		cp 		(HL) 						; compare resulting arguments with req arguments
                        	  1221: 
01:05F4 C2AF04          	  1222: 		jp		NZ,argumentsError			; show argument error and return
                        	  1223: 		
                        	  1224: 		; ***	calculate size from addresses $Adr2 - $Adr1
01:05F7 37              	  1225: 		scf
01:05F8 3F              	  1226: 		ccf
01:05F9 2A0000          	  1227: 		ld 		HL,(commAdr2)
01:05FC ED5B0000        	  1228: 		ld		DE,(commAdr1)
01:0600 ED52            	  1229: 		sbc		HL,DE
01:0602 220000          	  1230: 		ld 		(commLvl1),HL				; resulting size in commLvl1
                        	  1231: 
                        	  1232: 
                        	  1233: .contWR:
01:0605 110000          	  1234: 		ld 		DE,CTC_delay_INT_handler
01:0608 ED5312F4        	  1235: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1236: 
01:060C CD0000          	  1237: 		call 	purgeRXB
01:060F CD0000          	  1238: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
01:0612 CD0000          	  1239: 		call 	HC376S_ResetAll
01:0615 CD0000          	  1240: 		call 	HC376S_CheckConnection
01:0618 3A0000          	  1241: 		ld 		A,(commParseTable)
01:061B FE10            	  1242: 		cp 		16							; 16 read SD; 18-read USB
01:061D 2808            	  1243: 		jr 		Z,.doSD
01:061F CD0000          	  1244: 		call 	HC376S_setUSBMode
01:0622 CD0000          	  1245: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:0625 1803            	  1246: 		jr 		.cont
                        	  1247: .doSD:
01:0627 CD0000          	  1248: 		call 	HC376S_setSDMode
                        	  1249: .cont:
01:062A CD0000          	  1250: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:062D 20AB            	  1251: 		jr 		NZ,abort
01:062F CD0000          	  1252: 		call 	HC376S_setFileName
01:0632 CD0000          	  1253: 		call 	HC376S_fileCreate
01:0635 20A3            	  1254: 		jr		NZ,abort
01:0637 CD0000          	  1255: 		call 	HC376S_fileWrite
                        	  1256: 		
01:063A CD0000          	  1257: 		call 	HC376S_fileClose
01:063D CD0000          	  1258: 		call 	HC376S_ResetAll
01:0640 1898            	  1259: 		jr 		abort
                        	  1260: 
                        	  1261: p_C_Delete:
01:0642 CD4307          	  1262: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1  )
01:0645 C2AF04          	  1263: 		jP 		NZ,argumentsError
01:0648 110000          	  1264: 		ld 		DE,CTC_delay_INT_handler
01:064B ED5312F4        	  1265: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1266: 
01:064F CD0000          	  1267: 		call 	purgeRXB
01:0652 CD0000          	  1268: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
                        	  1269: 
01:0655 CD0000          	  1270: 		call 	HC376S_ResetAll
01:0658 CD0000          	  1271: 		call 	HC376S_CheckConnection
01:065B 3A0000          	  1272: 		ld 		A,(commParseTable)
01:065E FE13            	  1273: 		cp 		19							; 19 delete file SD; 20-delete file USB
01:0660 2808            	  1274: 		jr 		Z,.doSD
01:0662 CD0000          	  1275: 		call 	HC376S_setUSBMode
01:0665 CD0000          	  1276: 		call 	HC376S_diskConnectionStatus
01:0668 1803            	  1277: 		jr 		.cont
                        	  1278: .doSD:
01:066A CD0000          	  1279: 		call 	HC376S_setSDMode
                        	  1280: .cont:
01:066D CD0000          	  1281: 		call 	HC376S_USBdiskMount
                        	  1282: 		 
                        	  1283: 		; call 	HC376S_fileOpen
                        	  1284: 		; call 	HC376S_getFileSize
                        	  1285: 		; call 	HC376S_fileRead
                        	  1286: 
01:0670 CD0000          	  1287: 		call 	HC376S_fileDelete
01:0673 CD0000          	  1288: 		call 	HC376S_ResetAll
                        	  1289: 
01:0676 C3DA05          	  1290: 		jp 		abort
                        	  1291: 
                        	  1292: p_cptFl:
01:0679 CD0000          	  1293: 		call 	setFLASHBank				; change to bank
01:067C C9              	  1294: 		ret
01:067D CD0000          	  1295: 		call 	setSRAMBank 			; change to bank
01:0680 C9              	  1296: 		ret
                        	  1297: ;********************************************************************************************
                        	  1298: ;********************************************************************************************	
                        	  1299: p_srbank:
                        	  1300: 	; ***	set sram bank #
01:0681 CD0A07          	  1301: 	call 	p_FOFF				; disable the flash memory
01:0684 3A0000          	  1302: 	ld 		A,(commLvl1) 			; load param into A
                        	  1303: ; ***	set the SRAM bank ID; Bank ID in A
                        	  1304: p_srbank0:
                        	  1305: 
01:0687 E5              	  1306: 	push 	HL
01:0688 C5              	  1307: 	push 	BC
01:0689 210000          	  1308: 	ld 		HL,memBankID
01:068C E60F            	  1309: 	and 	$0F 				; clear all bits but 0-3 in A
                        	  1310: 
01:068E 47              	  1311: 	ld 		B,A
01:068F 7E              	  1312: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:0690 E6F0            	  1313: 	and 	$F0  				; zero bits 0-3
01:0692 1815            	  1314: 	jr 		putBank
                        	  1315: 
                        	  1316: ;********************************************************************************************
                        	  1317: ;********************************************************************************************	
                        	  1318: 
                        	  1319: p_flbank:
                        	  1320: 	; ***	set flash bank #
                        	  1321: 
01:0694 CDB006          	  1322: 	call 	p_FON				; enable  the  flash memory
01:0697 3A0000          	  1323: 	ld 		A,(commLvl1) 			; load param into A
                        	  1324: ; ***	set the FLASH bank ID; Bank ID in A
                        	  1325: p_flbank0:
                        	  1326: 
01:069A E5              	  1327: 	push 	HL
01:069B C5              	  1328: 	push 	BC
01:069C 210000          	  1329: 	ld 		HL,memBankID
01:069F E607            	  1330: 	and 	$07 				; clear all bits but 0-2
01:06A1 07              	  1331: 	rlca
01:06A2 07              	  1332: 	rlca
01:06A3 07              	  1333: 	rlca
01:06A4 07              	  1334: 	rlca						; bank ID = bits 4-6
                        	  1335: 
01:06A5 47              	  1336: 	ld 		B,A
01:06A6 7E              	  1337: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:06A7 E68F            	  1338: 	and 	$8F  				; zero bits 4-6
                        	  1339: putBank:
01:06A9 B0              	  1340: 	or 		B					; put new EEP bank ID in A...
01:06AA 77              	  1341: 	ld 		(HL),A				; store new value
01:06AB D300            	  1342: 	out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
01:06AD C1              	  1343: 	pop  	BC
01:06AE E1              	  1344: 	pop 	HL
01:06AF C9              	  1345: 	ret
                        	  1346: 
                        	  1347: ;********************************************************************************************
                        	  1348: ;********************************************************************************************	
                        	  1349: 
                        	  1350: p_FON:
                        	  1351: 		; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0)
                        	  1352: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	  1353: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1354: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:06B0 CD0000          	  1355: 	call 	writeSTRBelow
01:06B3 00              	  1356: 	DB 		0," Use 256k FLASH (7 banks),lower 32k and SRAM (16 banks),upper 32k !",CR,LF,00
01:06B4 2055736520323536
01:06BC 6B20464C41534820
01:06C4 28372062616E6B73
01:06CC 292C6C6F77657220
01:06D4 33326B20616E6420
01:06DC 5352414D20283136
01:06E4 2062616E6B73292C
01:06EC 7570706572203332
01:06F4 6B2021
01:06F7 0D
01:06F8 0A
01:06F9 00
01:06FA CD0000          	  1357: 	call 	waitForFinishedPrintout
                        	  1358: p_FON_No_Print: 		;; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0) without printout		
01:06FD E5              	  1359: 	push 	HL
01:06FE 210000          	  1360: 	ld 		HL,rstBankID
01:0701 CB9E            	  1361: 	res 	3,(HL)				; clear bit 3 -> enable FLASH
01:0703 CB96            	  1362: 	res 	2,(HL)				; temp enable reset of IC622
                        	  1363: putBankF:
01:0705 7E              	  1364: 	ld 		A,(HL)
01:0706 D300            	  1365: 	out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
01:0708 E1              	  1366: 	pop 	HL
01:0709 C9              	  1367: 	ret 
                        	  1368: 	
                        	  1369: ;********************************************************************************************
                        	  1370: ;********************************************************************************************	
                        	  1371: p_FOFF:
                        	  1372: 	; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1)
                        	  1373: 	; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	  1374: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1375: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:070A CD0000          	  1376: 	call 	writeSTRBelow
01:070D 20557365206F6E6C	  1377: 	DB 		" Use only SRAM (16 banks),upper 32k !",CR,LF,00
01:0715 79205352414D2028
01:071D 31362062616E6B73
01:0725 292C757070657220
01:072D 33326B2021
01:0732 0D
01:0733 0A
01:0734 00
01:0735 CD0000          	  1378: 	call 	waitForFinishedPrintout
                        	  1379: 
                        	  1380: p_FOFF_No_Print:		; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1) without printout
01:0738 E5              	  1381: 	push 	HL
01:0739 210000          	  1382: 	ld 		HL,rstBankID
01:073C CBD6            	  1383: 	set 	2,(HL) 			; temp disable reset of IC622
01:073E CBDE            	  1384: 	set 	3,(HL)			; set bit 3 -> disable FLASH
01:0740 18C3            	  1385: 	jr 		putBankF
                        	  1386: 	; ld 		A,(HL)
                        	  1387: 	; out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
                        	  1388: 	; pop 	HL
                        	  1389: 	; call 	writeSTRBelow
                        	  1390: 	; DB 		0," Use only 512k (16 banks) SRAM !",CR,LF,00
01:0742 C9              	  1391: 	ret 
                        	  1392: 
                        	  1393: ;********************************************************************************************     
                        	  1394: ;********************************************************************************************     
                        	  1395: 
                        	  1396: 		; ***	Check commParseTable+1 if required parameters
                        	  1397: checkArgsTAL:		
                        	  1398: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	  1399: 
                        	  1400: 		; ***	try to connect to USB
01:0743 210200          	  1401: 		ld 		HL,commParseTable+2				; resulting typed arguments
01:0746 3E00            	  1402: 		ld 		A,0
01:0748 77              	  1403: 		ld 		(HL),A
                        	  1404: 
01:0749 DD210000        	  1405: 		ld 		IX,commStr1			; commStr1 =			0xB0
01:074D CD7707          	  1406: 		call 	shift_0_1:
01:0750 DD210000        	  1407: 		ld 		IX,commStr2			; commStr2 =			0xD8
01:0754 CD7707          	  1408: 		call 	shift_0_1:
01:0757 DD210000        	  1409: 		ld 		IX,commAdr1			; commAdr1 =			0x84
01:075B CD7707          	  1410: 		call 	shift_0_1:
01:075E DD210000        	  1411: 		ld 		IX,commAdr2			; commAdr2 =			0x88
01:0762 CD7707          	  1412: 		call 	shift_0_1:
01:0765 DD210000        	  1413: 		ld 		IX,commLvl1			; commLvl1 =			0x90
01:0769 CD7707          	  1414: 		call 	shift_0_1:
01:076C DD210000        	  1415: 		ld 		IX,commLvl2			; commLvl2 =			0xA0
01:0770 CD7707          	  1416: 		call 	shift_0_1:
                        	  1417: 
01:0773 7E              	  1418: 		ld 		A,(HL)						; get the resulting arguments counted
01:0774 2B              	  1419: 		dec 	HL
01:0775 BE              	  1420: 		cp 		(HL) 						; compare resulting arguments with req arguments
01:0776 C9              	  1421: 		ret 	 					; return with Z or NZ  arguments
                        	  1422: 
                        	  1423: shift_0_1:
01:0777 DDBE00          	  1424: 		cp 		(IX)
01:077A 2008            	  1425: 		jr 		NZ,shiftIn1
01:077C DDBE01          	  1426: 		cp 		(IX+1)
01:077F 2003            	  1427: 		jr 		NZ,shiftIn1
                        	  1428: 		; ***	both =0 shift in '0'
01:0781 CB26            	  1429: 		sla		(HL)
01:0783 C9              	  1430: 		ret
                        	  1431: shiftIn1:
                        	  1432: 		; ***	least one not '0' shift in '1'
01:0784 37              	  1433: 		scf		
01:0785 CB16            	  1434: 		rl 		(HL)
01:0787 C9              	  1435: 		ret
                        	  1436: 
                        	  1437: 
                        	  1438: ;********************************************************************************************     
                        	  1439: ;********************************************************************************************     
                        	  1440: 
                        	  1441: bit_test9:
01:0788 01              	  1442: 	db	0x01,0x02,0x80,0x40
01:0789 02
01:078A 80
01:078B 40
                        	  1443: 
                        	  1444: 
                        	  1445: ; debug:		equ	0		; Set to 1 to show debug printing, else 0 
                        	  1446: 
                        	  1447: 
                        	  1448: 	; Spin loop here because there is nothing else to do
                        	  1449: ; halt_loop:
                        	  1450: ; 	halt
                        	  1451: ; 	jp	halt_loop
                        	  1452: 
                        	  1453: 
                        	  1454: 
                        	  1455: 
                        	  1456: 
                        	  1457: ;*******************************************************************************     
                        	  1458: ;*******************************************************************************     
                        	  1459: 
                        	  1460: 
                        	  1461: 
                        	  1462: 		; ld 		hl,Textbuf
                        	  1463: 		; ; call	ReadLine 			;to textbuf  (A=length of input string)
                        	  1464: 
                        	  1465: 		; ld		HL,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	  1466: 		; ld		DE,Textbuf			;DE = 32767
                        	  1467: 		; call	BN2DEC				; C0NVERT
                        	  1468: 		; jp		textloop
                        	  1469: 
                        	  1470: 
                        	  1471: 		; ld 		hl,Textbuf
                        	  1472: 		; call	DEC2BN			; result in HL
                        	  1473: 
                        	  1474: 		; ld 		E,L
                        	  1475: 		; 	; Binary to HEX  BN2HEX   E->(HL)
                        	  1476: 		; ld 		hl,T_BUFFER
                        	  1477: 		; inc		hl
                        	  1478: 		; call	Bin2Hex8			;result in T_buffer
                        	  1479: 
                        	  1480: 		; ld 		iy,T_BUFFER
                        	  1481: 		; call 	WriteLineCRNL
                        	  1482: 
                        	  1483: 		; ld 		iy,Textbuf
                        	  1484: 		; call	WriteLineCRNL
                        	  1485: 
                        	  1486: 		; jp 		next_line
                        	  1487: 
                        	  1488: 
                        	  1489: 
                        	  1490: textloop:
                        	  1491: 		; LD		HL,sourctext1
                        	  1492: 		; LD		DE,S1x
                        	  1493: 		; LD		BC,src_size
                        	  1494: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1495: 
                        	  1496: 
                        	  1497: 		; LD		HL,sourctext2
                        	  1498: 		; LD		DE,S2x
                        	  1499: 		; LD		BC,14
                        	  1500: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1501: 
                        	  1502: 		; test of string concat
                        	  1503: 		; LD		HL,S1_8B		;HL = BASE ADDRESS OF S1
                        	  1504: 		; LD		DE,S2_8B		;DE = BASE ADDRESS OF S2
                        	  1505: 		; LD		B,40			;B = MAXIMUM LENGTH OF STRING 1
                        	  1506: 		; CALL 	CONCAT 			;CONCATENATE STRINGS to S1_8B
                        	  1507: 
                        	  1508: 
                        	  1509: 		; test of POS
                        	  1510: 		; LD		HL,Str2			;HL = BASE ADDRESS OF STRING
                        	  1511: 		; LD		DE,subst		;DE = BASE ADDRESS OF SUBSTRING	
                        	  1512: 		; CALL	POS				;FIND POSITION OF SUBSTRING
                        	  1513: 								; RESULTS IN REGISTER A = 8
                        	  1514: 
                        	  1515: 
                        	  1516: 		; test copy
                        	  1517: 		; LD		HL,Str4			; SOURCE STRING
                        	  1518: 		; LD		DE,COPY_BUFFER	;	DESTINATION STRING
                        	  1519: 		
                        	  1520: 		; LD		C,4				; STARTING INDEX FOR COPYING
                        	  1521: 
                        	  1522: 		; LD		B,6				; NUMBER OF BYTES TO COPY
                        	  1523: 		; LD		A, 25			; MAXIMUM LENGTH OF SUBSTRING
                        	  1524: 		; CALL 	COPY			; COPY SUBSTRING
                        	  1525: 
                        	  1526: 		; ld 		iy,COPY_BUFFER
                        	  1527: 		; call 		WriteLineCRNL ; print the copy string
                        	  1528: 
                        	  1529: 
                        	  1530: 		; ; test DELETE
                        	  1531: 		; LD		HL,Str0		;HL	= BASE 	ADDRESS OF STRING
                        	  1532: 		; LD		A,8			
                        	  1533: 		; LD		C,8				;	C= STARTING INDEX FOR DELETION
                        	  1534: 		; LD		A,4			
                        	  1535: 		; LD		B,4			; B = NUMBER OF CHARACTERS TO DELETE
                        	  1536: 		; CALL 	DELETE 			; DELETE CHARACTERS
                        	  1537: 									; DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	  1538: 		; ld 		iy,Str0
                        	  1539: 		; call 		WriteLineCRNL ; print the copy string
                        	  1540: 
                        	  1541: 
                        	  1542: ; 		;test INSERT
                        	  1543: 
                        	  1544: ; 		LD		HL,Str3				; HL = BASE ADDRESS OF STRING
                        	  1545: ; 		LD		DE,subst			; DE = BASE ADDRESS OF SUBSTRING
                        	  1546: 
                        	  1547: ; 		LD		C,7					; C = STARTING INDEX FOR INSERTION
                        	  1548: 
                        	  1549: ; 		LD		B,0x40				; B = MAXIMUM LENGTH OF STRING
                        	  1550: ; 		CALL 	INSERT_STR			; INSERT SUBSTRING
                        	  1551: ; 		ld 		iy,Str3
                        	  1552: ; 		; call	WriteLineCRNL 		; print the modified string
                        	  1553: 
                        	  1554: 
                        	  1555: ; 		jp		next_line
                        	  1556: 
                        	  1557: ; 		;TEST DATA. CHANGE FOR OTHER VALUES
                        	  1558: ; S1_8B:	DB		8H				; LENGTH OF SI
                        	  1559: ; 		DB      "LASTNAME                        "	; 32 BYTE MAX LENGTH
                        	  1560: ; S2_8B:	DB		0BH				;LENGTH OF S2
                        	  1561: ; 		DB		". FIRSTNAME                     "	; 32 BYTE MAX LENGTH
                        	  1562: 
                        	  1563: ;********************************************************************************************
                        	  1564: ;********************************************************************************************	
                        	  1565: ; sh_test:
                        	  1566: ; 		; turn shadow off then halt
                        	  1567: ; 		xor A
                        	  1568: ; 		out (_CE_RST_BANK),A 		;// clear '64K_SRAM' signal
                        	  1569: 
                        	  1570: ; 		halt
                        	  1571: 
                        	  1572: ; 		ld	A,$80
                        	  1573: ; 		out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	  1574: ; 		ld 	A,1
                        	  1575: ; 		out (_CE_RST_BANK),A 		; engage 3-state on bank#
                        	  1576: ; 		ret
                        	  1577: 
                        	  1578: 
                        	  1579: ;********************************************************************************************
                        	  1580: ;********************************************************************************************	
                        	  1581: 			;9H JUMP TABLE (JTAB)   353
                        	  1582:         ; Title               Jump table
                        	  1583:         ; Name:               JTAB
                        	  1584:         ; Purpose:            Given an index, jump to the subroutine with
                        	  1585:         ;                     that index in a table.
                        	  1586:         ; Entry:              Register A is the subroutine number (0 to
                        	  1587:         ;                                LENSUB-l, the number of subroutines)
                        	  1588:         ;                                LENSUB must be less than or equal to
                        	  1589:         ;                                128.
                        	  1590:         ; Exit:               If the routine number is valid then
                        	  1591:         ;                       execute the routine
                        	  1592:         ;                     else
                        	  1593:         ;                       Carry flag = 1
                        	  1594:         ; Registers used: AF
                        	  1595:         ; Time:               117 cycles plus execution time of subroutine
                        	  1596:         ; Size:               Program 21 bytes plus size of table (2*LENSUB)
                        	  1597: 
                        	  1598:         ;EXIT WITH CARRY SET IF ROUTINE NUMBER IS INVALID
                        	  1599:         ; THAT IS, IF IT IS TOO LARGE FOR TABLE OLENSUB -     1)
                        	  1600: 
                        	  1601: 
                        	  1602: ; JTAB:
                        	  1603: ; 		CP		LENSUB			;COMPARE ROUTINE NUMBER, TABLE SIZE
                        	  1604: ; 		CCF						;COMPLEMENT CARRY FOR ERROR INDICATOR
                        	  1605: ; 		RET		C				;RETURN IF ROUTINE NUMBER TOO LARGE
                        	  1606: ; 									; WITH CARRY SET
                        	  1607: ; 		; INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
                        	  1608: ; 		; LEAVE REGISTER PAIRS UNCHANGED SO THEY CAN BE USED FOR PASSING PARAMETERS
                        	  1609: 
                        	  1610: ; 		PUSH	HL				;SAVE HL
                        	  1611: ; 		ADD		A,A				;DOUBLE INDEX FOR WORD-LENGTH ENTRIES
                        	  1612: ; 		LD		HL,JMPTAB		;INDEX INTO TABLE USING 8-BIT
                        	  1613: ; 		ADD		A,L			; ADDITION TO AVOID DISTURBING
                        	  1614: ; 		LD		L,A				; ANOTHER REGISTER PAIR
                        	  1615: ; 		LD		A,0
                        	  1616: ; 		ADC		A,H
                        	  1617: ; 		LD		H,A			; ACCESS ROUTINE ADDRESS
                        	  1618: ; 			;OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
                        	  1619: ; 			;CONTROL TO IT, LEAVING ALL REGISTER PAIRS UNCHANGED
                        	  1620: 
                        	  1621: ; 		LD		A, (HL)			;MOVE ROUTINE ADDRESS TO HL
                        	  1622: ; 		INC		HL
                        	  1623: ; 		LD		H, (HL)
                        	  1624: ; 		LD		L,A
                        	  1625: ; 		EX		(SP),HL				;RESTORE OLD HL, PUSH ROUTINE ADDRESS
                        	  1626: ; 		RET						; JUMP TO ROUTI NE
                        	  1627: 
                        	  1628: ; LENSUB		EQU		3				;NUMBER OF SUBROUTINES IN TABLE
                        	  1629: ; JMPTAB:                            ;JUMP TABLE
                        	  1630: ; 		DW		SUB0			;ROUTINE 0
                        	  1631: ; 		DW		SUB1			;ROUTINE 1
                        	  1632: ; 		DW		SUB2			;ROUTINE 2
                        	  1633: ;            ;THREE TEST SUBROUTINES FOR JUMP TABLE
                        	  1634: ; SUB0:
                        	  1635: ; 		LD		A,1				; TEST ROUTI NE 0 SETS (A)    1
                        	  1636: ; 		RET
                        	  1637: ; SUB1:
                        	  1638: ; 		LD		A,2				; TEST ROUTI NE 1 SETS (A) = 2
                        	  1639: ; 		RET
                        	  1640: ; SUB2:
                        	  1641: ; 		LD		A,3				;TEST ROUTINE 2 SETS (A)      3
                        	  1642: ; 		RET
                        	  1643: 
                        	  1644: 
                        	  1645: 
                        	  1646: ; 			;SAMPLE EXECUTION:
                        	  1647: 
                        	  1648: 
                        	  1649: ; SC9H:
                        	  1650: ; 		SUB		A				;EXECUTE ROUTINE 0
                        	  1651: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   =1
                        	  1652: 
                        	  1653: ; 		LD		A,1				;EXECUTE ROUTINE 1
                        	  1654: ; 		CALL	JTAB			; AFTER EXECUTION, (A) = 2
                        	  1655: ; 		LD		A,2				;EXECUTE ROUTINE 2
                        	  1656: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   3
                        	  1657: ; 		LD		A,3				;EXECUTE ROUTINE 3
                        	  1658: ; 		CALL	JTAB			; AFTER EXECUTION, CARRY   1
                        	  1659: ; 		JR		SC9H			;LOOP FOR MORE TESTS
                        	  1660: 
                        	  1661: 
                        	  1662: ;********************************************************************************************
                        	  1663: ;********************************************************************************************	
                        	  1664: ; 		xref  	RDATA,RDATA_END,TB_length
                        	  1665: 
                        	  1666: ; 		;--------------------------------------------------
                        	  1667: ; 		; ld A,5
                        	  1668: ; 		; ld 	A,$00	
                        	  1669: ; 		; out (_Z80_BankCS),A		;// set bank register number 	
                        	  1670: ; 		ld 	A,$01
                        	  1671: ; 		out (_CE_RST_BANK),A 		;// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	  1672: 
                        	  1673: ; 		out (_8Bitsout),A
                        	  1674: 
                        	  1675: ; 		ld A, $0F                 ;mode 1 out
                        	  1676: ; 		out (portA_Contr), A         ; set port A as output
                        	  1677: ; 		ld A,$EB
                        	  1678: 
                        	  1679: ; Rtll:	
                        	  1680: 
                        	  1681: ; 		ld (40000),A
                        	  1682: ; 		ld A,0
                        	  1683: ; 		ld A,(40000)
                        	  1684: 
                        	  1685: ; 		out (portA_Data),A		; Data to PIO port A
                        	  1686: ; 		out (_8Bitsout),A
                        	  1687: ; 		;--------------------------------------------------
                        	  1688: ; 		ld	DE,$8200
                        	  1689: ; 		ld	HL,RDATA
                        	  1690: ; 		ld	BC,TB_length
                        	  1691: ; 		; ld	BC,RDATA_END-RDATA
                        	  1692: ; 		ldir
                        	  1693: 
                        	  1694: 
                        	  1695: ; SIO_A_RESET:
                        	  1696: ; 		ld	a,00110000b
                        	  1697: ; 		out	(SIO_A_C),A		;write into WR0: error reset, select WR0
                        	  1698: 
                        	  1699: ; 		ld	a,018h				;write into WR0: channel reset
                        	  1700: ; 		out (SIO_A_C),A 
                        	  1701: 
                        	  1702: ; 		ld	a,004h				;write into WR0: select WR4
                        	  1703: ; 		out	(SIO_A_C),A
                        	  1704: ; 		ld	a,44h				;44h write into WR4: clkx16,1 stop bit, no parity
                        	  1705: ; 		out (SIO_A_C),A
                        	  1706: 
                        	  1707: ; 		ld	a,005h				;write into WR0: select WR5
                        	  1708: ; 		out (SIO_A_C),A
                        	  1709: ; 		ld	a,01101000b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS inactive (bit 2)
                        	  1710: ; 		ld	a,01101010b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS active (bit 2)
                        	  1711: ; 		out (SIO_A_C),A
                        	  1712: ; SIO_A_EI:
                        	  1713: ; 			;enable SIO channel A RX
                        	  1714: ; 		ld	a,003h				;write into WR0: select WR3
                        	  1715: ; 		out (SIO_A_C),A
                        	  1716: ; 		ld	a,11000001b				;RX 8bit, auto enable off 8(bit 5), RX on (bit 0)
                        	  1717: ; 		ld	a,11100001b				;RX 8bit, auto enable on 8(bit 5), RX on (bit 0)
                        	  1718: ; 		out (SIO_A_C),A
                        	  1719: ; 		;Channel A RX active
                        	  1720: 
                        	  1721: 
                        	  1722: ; 		ld 	HL,Str0
                        	  1723: ; tstout:
                        	  1724: ; 		ld 	A,(HL)
                        	  1725: ; 		out (SIO_A_D),A
                        	  1726: ; 		inc HL
                        	  1727: ; 		ld D,A
                        	  1728: ; chkTX:
                        	  1729: ; 		in	A,(SIO_A_C)		; read status
                        	  1730: ; 		bit	2,A					; all sent ?
                        	  1731: ; 		jr z,chkTX				; not all sent..
                        	  1732: 
                        	  1733: ; 		ld 	A,(HL)
                        	  1734: ; 		cp	0
                        	  1735: ; 		jr 	z,endmsg
                        	  1736: 
                        	  1737: ; 		ld	A,D
                        	  1738: ; 		djnz	tstout
                        	  1739: 
                        	  1740: ; endmsg:
                        	  1741: ; chkRX:
                        	  1742: ; 		in	A,(SIO_A_C)		; read status
                        	  1743: ; 		bit	0,A					; char present ??
                        	  1744: ; 		jr z,chkRX				; check again
                        	  1745: 
                        	  1746: ; 		in 	A,(SIO_A_D)		; read the char.
                        	  1747: 
                        	  1748: ; 		out (SIO_A_D),A
                        	  1749: ; chkTX2:
                        	  1750: ; 		in	A,(SIO_A_C)		; read status
                        	  1751: ; 		bit	2,A					; all sent ?
                        	  1752: ; 		jr z,chkTX2
                        	  1753: 		
                        	  1754: ; 		jr	endmsg				; not all sent..
                        	  1755: 
                        	  1756: 
                        	  1757: 
                        	  1758: 
                        	  1759: ; 		halt
                        	  1760: ; 		halt
                        	  1761: ; 		halt
                        	  1762: ; 		inc A
                        	  1763: ; 		jr Rtll			
                        	  1764: 
                        	  1765: ; 	if DOALIGN
                        	  1766: ; 		align 4
                        	  1767: ; 	endif
                        	  1768: 
                        	  1769: 
                        	  1770: .end
                        	  1771: 


Symbols by name:
AddToT_Buf                      external
BLKMOV                          external EXP
BN2DEC                          external EXP
BN2DEC_S                        external EXP
Bin2Hex16                       external EXP
Bin2Hex8                        external EXP
BootCode                        external
BootCodeAdr                     external
CDEL                             E:00EE
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CONCAT                          external EXP
COPY                            external EXP
CR                               E:000D
CRC16                           external EXP
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       external
CTC_Init                        external
CTC_delay_INT_handler           external
DEC2BN                          external EXP
DELETE                          external EXP
DumpRegisters                   external
Flash_SE_Erase                  external
Flash_WR_Test                   external
GPIODEBUG                        E:0000
HC376S_CheckConnection          external
HC376S_ResetAll                 external
HC376S_USBdiskMount             external
HC376S_diskConnectionStatus     external
HC376S_fileClose                external
HC376S_fileCreate               external
HC376S_fileDelete               external
HC376S_fileOpen                 external
HC376S_fileRead                 external
HC376S_fileWrite                external
HC376S_getFileSize              external
HC376S_setFileName              external
HC376S_setSDMode                external
HC376S_setUSBMode               external
HEX2BN                          external EXP
INSERT_STR                      external EXP
ITEM                             E:001C
InitBuffers                     external EXP
InitInterrupt                   external EXP
JPTable01                       01:0495
LF                               E:000A
LISTEND                          E:001E
MFILL                           external EXP
MONITOR_Start                   01:0000 EXP
PCinpFlag                       external
PCvalue                         external
PIO_Init                        external
POS                             external EXP
ReadChar                        external EXP
ReadLine                        external EXP
RegFlags                        external EXP
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
S1x                             external
SD_USB_startup                  00:0003 EXP
SDabort                         00:0224
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        external
SIO_A_EI                        external
SIO_A_RTS_OFF                   external EXP
SIO_A_RTS_ON                    external EXP
SIO_A_TXRX_INTon                external
SIO_B_C                         external
SIO_B_D                         external
SIO_Init                        external
SIO_Int_Vec                      E:F400
SP_value                        external
STEND                            E:001D
S_head_tail                     external EXP
T_BUFFER                        external
TempVar1                        external
Textbuf                         external EXP
WriteChar                       external EXP
WriteLine                       external
WriteLineCRNL                   external
_CE_RST_BANK                    external
_RAMSTART                       external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
abort                           01:05DA
argumentsError                  01:04AF
bit_test9                       01:0788
byteEnd                         01:0444
changePCVal                     01:0465
checkArgsTAL                    01:0743
checkaddress                    01:03C7
chkADR                          01:03D2
chkADR1                         01:03D3
chkADR2                         01:03E3
chkLVL2                         01:0405
cleanInBuffer                   external EXP
cleanOutBuffer                  external EXP
commAdr1                        external
commAdr2                        external
commListLen                      E:001B
commLvl1                        external
commLvl2                        external
commParseTable                  external
commStr1                        external
commStr2                        external
command_list                    01:01B9
crc16_2                         external EXP
doImportXMODEM                  external
dumpMemory                      external EXP
enableFLASH                     external
enableIC620_OE                  external
endtext                         external EXP
errNoFlash                      01:0546
executeCommand                  01:0481
findCommandInList               01:0156
findNextITEM                    01:0162
getLvalue                       01:03F5
gpioB                           external
gpio_in                         external
gpio_out                        external
inBuffer                        external EXP
inBufferEnd                     external EXP
initCommParseTable              01:0369
initSIOBInterrupt               external
inputerror                      01:0186
isHex                           external EXP
makeASCIItoHEX                  01:0415
matchInList                     01:037C
memBankID                       external
nextHalfByte                    01:0423
nextInList                      01:0182
next_line                       01:00D9
noHighNib                       01:0461
p_C_Delete                      01:0642
p_C_Read                        01:0591
p_C_Read_SD                     00:01F4
p_C_Write                       01:05EA
p_FOFF                          01:070A
p_FOFF_No_Print                 01:0738
p_FON                           01:06B0
p_FON_No_Print                  01:06FD
p_clearmem                      01:04F1
p_cptFl                         01:0679
p_dumpmem                       01:04E5
p_eep                           01:04EA
p_exe                           01:0504
p_flbank                        01:0694
p_flbank0                       01:069A
p_flse                          01:0570
p_flwr                          01:053B
p_go                            01:0505
p_incDecPC                      01:0516
p_load                          01:04E4
p_pc                            01:04E9
p_reset                         01:04D0
p_srbank                        01:0681
p_srbank0                       01:0687
p_xmod                          01:0579
paramLoopEntry                  01:0393
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external
putBank                         01:06A9
putBankF                        01:0705
putDEtoScreen                   external
rfile_name                      00:01E4
rstBankID                       external
scanCommandList                 01:0151
setFLASHBank                    external
setSRAMBank                     external
shiftIn1                        01:0784
shift_0_1                       01:0777
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             external
skipPriorDelimit                external
sourctext1                      external EXP
sourctext2                      external EXP
src_size                        external EXP
st1g2                           external EXP
st2g1                           external EXP
steq                            external EXP
strCompare                      external EXP
subst                           external EXP
temp_finish                     01:0492
textloop                        01:078C
useFlash                        01:00EA
waitForFinishedPrintout         external
writeSTRBelow                   external EXP
zero_byte                       01:0161

Symbols by value:
0000 GPIODEBUG
0000 MONITOR_Start
0003 SD_USB_startup
000A LF
000D CR
001B commListLen
001C ITEM
001D STEND
001E LISTEND
00D9 next_line
00EA useFlash
00EE CDEL
0151 scanCommandList
0156 findCommandInList
0161 zero_byte
0162 findNextITEM
0182 nextInList
0186 inputerror
01B9 command_list
01E4 rfile_name
01F4 p_C_Read_SD
0224 SDabort
0369 initCommParseTable
037C matchInList
0393 paramLoopEntry
03C7 checkaddress
03D2 chkADR
03D3 chkADR1
03E3 chkADR2
03F5 getLvalue
0405 chkLVL2
0415 makeASCIItoHEX
0423 nextHalfByte
0444 byteEnd
0461 noHighNib
0465 changePCVal
0481 executeCommand
0492 temp_finish
0495 JPTable01
04AF argumentsError
04D0 p_reset
04E4 p_load
04E5 p_dumpmem
04E9 p_pc
04EA p_eep
04F1 p_clearmem
0504 p_exe
0505 p_go
0516 p_incDecPC
053B p_flwr
0546 errNoFlash
0570 p_flse
0579 p_xmod
0591 p_C_Read
05DA abort
05EA p_C_Write
0642 p_C_Delete
0679 p_cptFl
0681 p_srbank
0687 p_srbank0
0694 p_flbank
069A p_flbank0
06A9 putBank
06B0 p_FON
06FD p_FON_No_Print
0705 putBankF
070A p_FOFF
0738 p_FOFF_No_Print
0743 checkArgsTAL
0777 shift_0_1
0784 shiftIn1
0788 bit_test9
078C textloop
F400 SIO_Int_Vec
F412 CTC_CH1_I_Vector
