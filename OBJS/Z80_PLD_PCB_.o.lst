Sections:
00: "SD_USB_Start" (0-148)
01: "Monitor" (0-7A8)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     4: 		include 	"Salea_Logic.inc"

Source: "Salea_Logic.inc"
                        	     1: 
                        	     2: ;       *** 
                        	     3: 
                        	     4:     macro make_pulse 
                        	     5: 
                        	     6:     xor     A
                        	     7:     set     \1,A    
                        	     8:     out (gpio_out),A
                        	     9:     out (gpio_out),A
                        	    10:     out (gpio_out),A
                        	    11:     out (gpio_out),A
                        	    12:     xor     A
                        	    13:     out (gpio_out),A
                        	    14:     
                        	    15: 
                        	    16:     endm

Source: "stdin"
                        	     5: 	
                        	     6: 
                        	     7: ; ;***********************************************************************
                        	     8: ; 		section	Monitor
                        	     9: ; ;***********************************************************************
                        	    10: 
                        	    11: 
                        	    12: 
                        	    13: 
                        	    14: 			xref	Bin2Hex8,Bin2Hex16,  HEX2BN, BN2DEC,BN2DEC_S,DEC2BN,MFILL, BLKMOV,strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR
                        	    15: 			xref	InitBuffers, ReadLine, WriteChar, ReadChar, S_head_tail
                        	    16: 			xref	Textbuf, inBufferEnd,inBuffer,cleanInBuffer,cleanOutBuffer,InitInterrupt
                        	    17: 			xref	dumpMemory
                        	    18: 
                        	    19: 			xref	st2g1,st1g2,steq,subst
                        	    20: 			xref	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	    21: 			xref	sourctext1,sourctext2,endtext,src_size, writeSTRBelow,isHex
                        	    22: 
                        	    23: 			xref 	crc16_2,CRC16
                        	    24: 		
                        	    25: 		xref 	SIO_A_RTS_OFF,SIO_A_RTS_ON
                        	    26: 
                        	    27: 
                        	    28: 	;***************************************************************
                        	    29: 	;SAMPLE EXECUTION:
                        	    30: 	;***************************************************************
                        	    31: 
                        	    32: DO_Debug:	equ	0		; Set to 1 to show debug printing, else 0 
                        	    33: 
                        	    34: 	GLOBAL SD_USB_startup,MONITOR_Start
                        	    35: 
                        	    36: ;************************************************************************************************
                        	    37: ;************************************************************************************************
                        	    38: ;***		SDcard/USB startup sequence
                        	    39: ;************************************************************************************************
                        	    40: ;************************************************************************************************
                        	    41: 		section SD_USB_Start
                        	    42: 
                        	    43: 
00:0000 C34801          	    44: 		jp 		MONITOR_Start0 		; jump to MONITOR_Start if hard call to $8000
                        	    45: 
                        	    46: SD_USB_startup:
                        	    47: 
                        	    48: 	ifd 	GPIODEBUG
                        	    49: 	ld 		A,$33
                        	    50: 	out 	(gpio_out),A
                        	    51: 	endif
                        	    52: 
                        	    53: 
                        	    54: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	    55: 
                        	    56: 
00:0003 ED730000        	    57: 		ld 		(SP_value),SP
                        	    58: 	
                        	    59: 	ifd 	GPIODEBUG
                        	    60: 	ld 		A,$AA
                        	    61: 	out 	(gpio_out),A
                        	    62: 	endif
                        	    63: 	
00:0007 CD0000          	    64: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    65: 			; initialize buffer counters and pointers.
                        	    66: 	ifd 	GPIODEBUG
                        	    67: 	ld 		A,$BB
                        	    68: 	out 	(gpio_out),A
                        	    69: 	endif
                        	    70: 
00:000A CD0000          	    71: 		call	PIO_Init
                        	    72: 	ifd 	GPIODEBUG
                        	    73: 	ld 		A,$CC
                        	    74: 	out 	(gpio_out),A
                        	    75: 	endif
00:000D CD0000          	    76: 		call 	CTC_Init
                        	    77: 	ifd 	GPIODEBUG
                        	    78: 	ld 		A,$DD
                        	    79: 	out 	(gpio_out),A
                        	    80: 	endif
00:0010 CD0000          	    81: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	    82: 	ifd 	GPIODEBUG
                        	    83: 	ld 		A,$DF
                        	    84: 	out 	(gpio_out),A
                        	    85: 	endif
00:0013 CD0000          	    86: 		call	S_head_tail			; save input heads and tails
                        	    87: 	ifd 	GPIODEBUG
                        	    88: 	ld 		A,$81
                        	    89: 	out 	(gpio_out),A
                        	    90: 	endif
                        	    91: 
                        	    92: 		; call	sh_test
                        	    93: 		; call 	Flash_WR_Test
                        	    94: 		; ld	HL,$2010
                        	    95: 		; call	Flash_SE_Erase
                        	    96: 
00:0016 CD0000          	    97: 		call	CRLF
00:0019 CD0000          	    98: 		call 	writeSTRBelow
00:001C 0D0A            	    99: 		defb   	"\r\n"
00:001E 3D2D3D2D3D2D3D2D	   100: 		defb	"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\r\n"
00:0026 3D2D3D2D3D2D3D2D
00:002E 3D2D3D2D3D2D3D2D
00:0036 3D2D3D2D3D2D3D2D
00:003E 3D2D3D2D3D2D3D2D
00:0046 0D0A
00:0048 5374617274206672	   101: 		defb	"Start from SD/USB\r\n"
00:0050 6F6D2053442F5553
00:0058 420D0A
                        	   102: 		; defb	"    git: UPdate_Jan_25-3-ge24e08d-dirty\r\n"
                        	   103: 		; defb	"    build: 2026-02-06_21:29\r\n"
                        	   104: 		; defb	"    FLASH->SRAM 0xD000.\r\n"
00:005B 00              	   105: 		defb	"\0"
                        	   106: 
00:005C CD0000          	   107: 		 call 	waitForFinishedPrintout
                        	   108: 
                        	   109: 	ifd 	GPIODEBUG
                        	   110: 	ld 		A,$83
                        	   111: 	out 	(gpio_out),A
                        	   112: 	endif
00:005F CD0000          	   113: 		call	CRLF
                        	   114: 
                        	   115: ;*****	Setup Boot load from SD card.
                        	   116: ;***************************************
00:0062 110000          	   117: 		ld 		DE,commStr1					; save filename in commStr1
00:0065 21FB00          	   118: 		ld 		HL,rfile_name
                        	   119: .nxtchr:
00:0068 EDA0            	   120: 		ldi									; (DE) <- (HL) 
00:006A 7E              	   121: 		ld 		A,(HL)
00:006B B7              	   122: 		or 		A 							; = 0 ?
00:006C 20FA            	   123: 		jr  	NZ,.nxtchr
00:006E 12              	   124: 		ld 		(DE),A						; save '0'
00:006F 210000          	   125: 		ld 		HL,S1x						; result in S1x
00:0072 220000          	   126: 		ld 		(commAdr1),HL
                        	   127: 
00:0075 CD0B01          	   128: 		call 	p_C_Read_SD
                        	   129: 
                        	   130: 
                        	   131: ;***	correct $0A to $00 $00 in S1x (check for ascii lower than $20)
00:0078 210000          	   132: 		ld 		HL,S1x
00:007B 3E20            	   133: 		ld 		A,$20
00:007D 110000          	   134: 		ld 		DE,commStr1
                        	   135: 
                        	   136: .find0A:
00:0080 EDA0            	   137: 		ldi						; (DE) <- (HL) 
00:0082 BE              	   138: 		cp 		(HL)			; char lower than ' '  $20 - (HL)
00:0083 FA8000          	   139: 		jp 		M,.find0A		; char > ' '...
                        	   140: 
00:0086 3E00            	   141: 		ld 		A,00
00:0088 12              	   142: 		ld 		(de),A
00:0089 13              	   143: 		inc 	de
00:008A 12              	   144: 		ld 		(de),A			; strip eventually $0A, $0D, ...
00:008B 13              	   145: 		inc 	de
00:008C 12              	   146: 		ld 		(de),A			; Boot file name present in commStr1
00:008D 210000          	   147: 		ld 		HL,_RAMSTART
00:0090 220000          	   148: 		ld 		(commAdr1),HL 	; place adress for boot file...
00:0093 CD0B01          	   149: 		call 	p_C_Read_SD		; read and place boot file.
                        	   150: 
                        	   151: 
00:0096 CD0000          	   152: 		call 	writeSTRBelow
00:0099 0D0A555345205241	   153: 		defb   "\r\nUSE RAM bank #0, Copy FLASH Boot seq\r\n"
00:00A1 4D2062616E6B2023
00:00A9 302C20436F707920
00:00B1 464C41534820426F
00:00B9 6F74207365710D0A
00:00C1 546F2052414D2062	   154: 		defb   "To RAM bank #1 ($0-$2000) \r\n"
00:00C9 616E6B2023312028
00:00D1 24302D2432303030
00:00D9 29200D0A
00:00DD 4A756D7020746F20	   155: 		defb	"Jump to _RAMSTART! \r\n",0,0,0
00:00E5 5F52414D53544152
00:00ED 5421200D0A
00:00F2 00
00:00F3 00
00:00F4 00
                        	   156: 
00:00F5 C30000          	   157: 		jp 		_RAMSTART 		; monitor start $D000
                        	   158: 
                        	   159: .loopINF:
00:00F8 76              	   160: 		halt
                        	   161: 	ifd 	GPIODEBUG	
                        	   162: 	ld 		A,$99
                        	   163: 	out 	(gpio_out),A
                        	   164: 	endif
00:00F9 18FD            	   165: 		jr 		.loopINF
                        	   166: rfile_name:
00:00FB 424F4F5446494C45	   167: 	 db "BOOTFILE.TXT",0,0,0,0
00:0103 2E545854
00:0107 00
00:0108 00
00:0109 00
00:010A 00
                        	   168: 	; db "PROVIDE.txt",0,0,0,0
                        	   169: 
                        	   170: 	
                        	   171: ;************************************************************************************************
                        	   172: ;************************************************************************************************
                        	   173: p_C_Read_SD:
                        	   174: 
                        	   175: 		;call 	checkArgsTAL				; check necessary args
                        	   176: 		;jp		NZ,argumentsError			; show argument error and return
                        	   177: 	
00:010B 110000          	   178: 		ld 		DE,CTC_delay_INT_handler
00:010E ED5312F4        	   179: 		ld 		(CTC_CH1_I_Vector),DE
                        	   180: 	ifd 	GPIODEBUG
                        	   181: 	xor A
                        	   182: 	out (gpio_out),A
                        	   183: 	endif
                        	   184: 		; call  	SIO_A_DI					; disable text output
                        	   185: 	ifd 	GPIODEBUG
                        	   186: 	ld a,4
                        	   187: 	out (gpio_out),A
                        	   188: 	ld a,0
                        	   189: 	out (gpio_out),A
                        	   190: 	endif
                        	   191: 
00:0112 7B              	   192: 		ld a,e	
                        	   193: 
00:0113 CD0000          	   194: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
00:0116 CD0000          	   195: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
00:0119 CD0000          	   196: 		call 	HC376S_ResetAll
00:011C CD0000          	   197: 		call 	HC376S_CheckConnection
                        	   198: 		; ld 		A,(commParseTable)
                        	   199: 		; cp 		15							; 15 read SD; 17-read USB
                        	   200: 		; jr 		Z,.doSD
                        	   201: 		; cp 		21							; 21 read SD enumerate, 22 read USB enumerate
                        	   202: 		; jr 		Z,.doSD
                        	   203: 		; call 	HC376S_setUSBMode
                        	   204: 		; call 	HC376S_diskConnectionStatus		; dont use with SD card
                        	   205: 		; jr 		.cont
                        	   206: .doSD:
00:011F CD0000          	   207: 		call 	HC376S_setSDMode
                        	   208: 		
                        	   209: .cont:
00:0122 CD0000          	   210: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:0125 2014            	   211: 		jr 		NZ,SDabort
                        	   212: 
                        	   213: 
00:0127 CD0000          	   214: 		call 	HC376S_setFileName
00:012A CD0000          	   215: 		call 	HC376S_fileOpen
00:012D 200C            	   216: 		jr 		NZ,SDabort
00:012F CD0000          	   217: 		call 	waitForFinishedPrintout
                        	   218: 
00:0132 CD0000          	   219: 		call 	HC376S_getFileSize
00:0135 CD0000          	   220: 		call 	HC376S_fileRead
00:0138 CD0000          	   221: 		call 	HC376S_fileClose
                        	   222: SDabort:
                        	   223: 
                        	   224: 		; ***	reset the interrupt handler for CTC
                        	   225: 		; call 	SIO_A_EI					; enable text output
00:013B CD0000          	   226: 		call 	HC376S_ResetAll
00:013E CD0000          	   227: 		call 	CTC1_INT_OFF
00:0141 210000          	   228: 		ld		HL,CTC_CH1_Interrupt_Handler
00:0144 2212F4          	   229: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:0147 C9              	   230: 		ret
                        	   231: 
                        	   232: MONITOR_Start0:	
                        	   233: 
                        	   234: ;***********************************************************************
                        	   235: 		section	Monitor			; enter point for monitor
                        	   236: ;***********************************************************************
                        	   237: 
                        	   238: MONITOR_Start:	
                        	   239: 
                        	   240: 		; ***	should be start address $D000
01:0000 1806            	   241: 		jr 		.initRH
                        	   242: 		; Code in $D002-D005 = '0000' - 'AAAA': copy from flash
                        	   243: 		; Code in $D002-D005 = 'CCCC': code uploaded from xmodem/or DMA. Do not copy from flash
                        	   244: 		; db 		"AAAA"
01:0002 43434343        	   245: 		db 		"CCCC"
                        	   246: 		align	3
                        	   247: 
                        	   248: .initRH:
01:0008 CD0000          	   249: 	call 	waitForFinishedPrintout
                        	   250: 	
                        	   251: 
                        	   252: 	ifd 	GPIODEBUG
                        	   253: 	ld 		A,$33
                        	   254: 	out 	(gpio_out),A
                        	   255: 	endif
                        	   256: ;		***  	NOFLASH - Don not use the FLASH mem -> 64kRAM
                        	   257: ; 		*** 	Copy Flash boot sequence to RAM bank #0 $0-$1800
                        	   258: ; 		*** 	first to temp storage area.
01:000B 1100B0          	   259: 		ld		DE,$B000		; temp storage area 0xB000
01:000E 210000          	   260: 		ld		hl,0000
                        	   261: 
01:0011 010018          	   262: 		ld 		BC,$1800			;Boot seq size ~6kb
01:0014 EDB0            	   263: 		ldir							; (DE)<-(HL)
                        	   264: ; 		*** 	secondly: to Rambank #1 storage area.
                        	   265: 
                        	   266: ;		***		deselect FLASH mem
                        	   267: ; 		***		Swithch to RAM bank #1
                        	   268: 
01:0016 CD5407          	   269: 		call  	p_FOFF_No_Print
01:0019 3E01            	   270: 		ld 		A,1
01:001B CDA306          	   271: 		call 	p_srbank0
01:001E 110000          	   272: 		ld		DE,0000		; temp storage area 0xB000
01:0021 2100B0          	   273: 		ld		hl,$B000
                        	   274: 
01:0024 010018          	   275: 		ld 		BC,$1800			;Boot seq size ~6kb
01:0027 EDB0            	   276: 		ldir							; (DE)<-(HL)
                        	   277: 
                        	   278: 
                        	   279: 
                        	   280: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	   281: 
                        	   282: 
01:0029 ED730000        	   283: 		ld 		(SP_value),SP
                        	   284: 
                        	   285: 	ifd 	GPIODEBUG
                        	   286: 	ld 		A,$AA
                        	   287: 	out 	(gpio_out),A
                        	   288: 	endif
                        	   289: 
01:002D CD0000          	   290: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   291: 			; initialize buffer counters and pointers.
                        	   292: 	ifd		PIODEBUG
                        	   293: 	ld 		A,$BB
                        	   294: 	out 	(gpio_out),A
                        	   295: 	endif
                        	   296: 
01:0030 CD0000          	   297: 		call	PIO_Init
                        	   298: 	ifd 	GPIODEBUG
                        	   299: 	ld 		A,$CC
                        	   300: 	out 	(gpio_out),A
                        	   301: 	endif
                        	   302: 
01:0033 CD0000          	   303: 		call 	CTC_Init
                        	   304: 	ifd 	GPIODEBUG
                        	   305: 	ld 		A,$DD
                        	   306: 	out 	(gpio_out),A
                        	   307: 	endif
                        	   308: 
01:0036 CD0000          	   309: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	   310: 	ifd 	GPIODEBUG
                        	   311: 	ld 		A,$DF
                        	   312: 	out 	(gpio_out),A
                        	   313: 	endif
                        	   314: 
01:0039 CD0000          	   315: 		call	S_head_tail			; save input heads and tails
                        	   316: 	ifd 	GPIODEBUG
                        	   317: 	ld 		A,$81
                        	   318: 	out 	(gpio_out),A
                        	   319: 	endif
                        	   320: 
                        	   321: 		; call	sh_test
                        	   322: 		; call 	Flash_WR_Test
                        	   323: 		; ld	HL,$2010
                        	   324: 		; call	Flash_SE_Erase
                        	   325: 
01:003C CD0000          	   326: 		call	CRLF
01:003F CD0000          	   327: 		call 	writeSTRBelow
01:0042 000D0A          	   328: 		defb   	"\0\r\n"
01:0045 2323232323232323	   329: 		defb	"##########################################################\r\n"
01:004D 2323232323232323
01:0055 2323232323232323
01:005D 2323232323232323
01:0065 2323232323232323
01:006D 2323232323232323
01:0075 2323232323232323
01:007D 23230D0A
01:0081 546865205A383020	   330: 		defb	"The Z80 Board Awakened 2025\r\n"
01:0089 426F617264204177
01:0091 616B656E65642032
01:0099 3032350D0A
01:009E 202020206769743A	   331: 		defb	"    git: UPdate_Jan_25-3-ge24e08d-dirty\r\n"
01:00A6 205550646174655F
01:00AE 4A616E5F32352D33
01:00B6 2D67653234653038
01:00BE 642D64697274790D
01:00C6 0A
01:00C7 202020206275696C	   332: 		defb	"    build: 2026-02-06_21:29\r\n"
01:00CF 643A20323032362D
01:00D7 30322D30365F3231
01:00DF 3A32390D0A
01:00E4 20202020464C4153	   333: 		defb	"    FLASH->SRAM 0xD000.\r\n"
01:00EC 482D3E5352414D20
01:00F4 3078443030302E0D
01:00FC 0A
01:00FD 00              	   334: 		defb	"\0"
                        	   335: 
                        	   336: 	ifd 	GPIODEBUG
                        	   337: 	ld 		A,$83
                        	   338: 	out 	(gpio_out),A
                        	   339: 	endif
01:00FE CD0000          	   340: 		call	CRLF
                        	   341: 
                        	   342: next_line:
                        	   343: 
01:0101 CD9103          	   344: 		call 	initCommParseTable			; Put zeros.....
                        	   345: 	ifd 	GPIODEBUG
                        	   346: 	ld 		A,$85
                        	   347: 	out 	(gpio_out),A
                        	   348: 	endif
                        	   349: 
                        	   350: 		; ***	indicate memory banks   F[x]  Flash memory bank x
                        	   351: 		; ***	indicate memory banks   S[y]  SRAM memory bank y
                        	   352: 				; if bit 3 (rstBankID) = 1  no FLASH memory is selected
                        	   353: 				; if bit 3 (rstBankID) = 0 FLASH memory is lower 32k and SRAM upper 32k
01:0104 210100          	   354: 		ld 		HL,T_BUFFER+1 			; prepare output buffer		
01:0107 3646            	   355: 		ld 		(HL),'F'	
01:0109 3A0000          	   356: 		ld 		A,(rstBankID)
01:010C CB5F            	   357: 		bit 	3,A					; bit 3 set -> 64kSRAM
01:010E 2802            	   358: 		jr 		Z,useFlash
01:0110 3653            	   359: 		ld 		(HL),'S'	
                        	   360: useFlash:
01:0112 23              	   361: 		inc 	HL
01:0113 365B            	   362: 		ld 		(HL),'['	
01:0115 23              	   363: 		inc 	HL
01:0116 CB5F            	   364: 		bit 	3,A					; bit 7 set -> 64kSRAM
01:0118 3A0000          	   365: 		ld  	A,(memBankID)
01:011B 2807            	   366: 		jr 		Z,.IDflash
                        	   367: 
                        	   368: 		; ***	show sram bank number
01:011D E60F            	   369: 		and 	$0F					; sram bank #
01:011F CD0000          	   370: 		call 	AddToT_Buf			; convert to 1 ascii char in (HL+)
01:0122 180D            	   371: 		jr 		.cont
                        	   372: .IDflash:
                        	   373: 		; ***	show flash bank number
01:0124 CB3F            	   374: 		srl 	A
01:0126 CB3F            	   375: 		srl 	A
01:0128 CB3F            	   376: 		srl 	A
01:012A CB3F            	   377: 		srl 	A
01:012C E607            	   378: 		and 	A,$07				; flash bank #
01:012E CD0000          	   379: 		call	AddToT_Buf			; convert to 1 ascii char in (HL+)
                        	   380: .cont:
01:0131 365D            	   381: 		ld  	(HL),']'
01:0133 23              	   382: 		inc 	HL
                        	   383: 
                        	   384: 	ifd 	GPIODEBUG	
                        	   385: 	ld 		A,$87
                        	   386: 	out 	(gpio_out),A
                        	   387: 	endif
                        	   388: 
                        	   389: 	; 	*** Print prompt text to screen, value of PC and content in memory
01:0134 ED5B0000        	   390: 		ld 		DE,(PCvalue)
01:0138 365B            	   391: 		ld  	(HL),'['
01:013A 23              	   392: 		inc 	HL
                        	   393: 
                        	   394: 		; ***	Address in parenthesis
01:013B CD0000          	   395: 		call 	Bin2Hex16
01:013E 365D            	   396: 		ld  	(HL),']'
01:0140 23              	   397: 		inc 	HL
01:0141 363D            	   398: 		ld  	(HL),'='
01:0143 23              	   399: 		inc 	HL
                        	   400: 
                        	   401: 		; ***	Value of the bytes in address (2 bytes) to screen
01:0144 E5              	   402: 		push 	HL
01:0145 2A0000          	   403: 		ld 		HL,(PCvalue)
01:0148 56              	   404: 		ld 		D,(HL)
01:0149 23              	   405: 		inc 	HL
01:014A 5E              	   406: 		ld 		E,(HL)
01:014B E1              	   407: 		pop 	HL
01:014C CD0000          	   408: 		call	Bin2Hex16
01:014F 362D            	   409: 		ld  	(HL),'-'
01:0151 23              	   410: 		inc 	HL
01:0152 363E            	   411: 		ld  	(HL),'>'
01:0154 23              	   412: 		inc 	HL
                        	   413: 
01:0155 3600            	   414: 		ld  	(HL),$00
01:0157 FD210000        	   415: 		ld 		iy,T_BUFFER
01:015B CD0000          	   416: 		call	WriteLine
                        	   417: 
01:015E 210000          	   418: 		ld 		hl,Textbuf
01:0161 CD0000          	   419: 		call 	ReadLine
                        	   420: 
01:0164 FD210000        	   421: 		ld 		iy,Textbuf
01:0168 CD0000          	   422: 		call	WriteLineCRNL
                        	   423: 		; ld 		A,5
                        	   424: 		; out 	(portA_Data),A
                        	   425: 
                        	   426: 		;***  	compare input
                        	   427: 		; ld 		HL,Textbuf
                        	   428: 		; ld 		DE,command_list+2
                        	   429: 		; call	strCompare
                        	   430: 
                        	   431: 	;***************************************************************
                        	   432: 	;	Find /Identify command:
                        	   433: 	;***************************************************************
                        	   434: 
01:016B 210000          	   435: 		ld 		HL,Textbuf
01:016E CD0000          	   436: 		call 	skipPriorDelimit			; set (HL) first char
                        	   437: 
01:0171 DABA04          	   438: 		jp 		C,temp_finish 				; end encountered; no command (empty line)	
                        	   439: 
01:0174 E5              	   440: 		push 	HL
01:0175 D1              	   441: 		pop  	DE							; typed command start in DE
                        	   442: 
                        	   443: 		; ***	Search command in 'command_list:'
                        	   444: 		;  		DE = typed command first char in DE (Textbuf)
01:0176 21E201          	   445: 		ld 		HL,command_list+1			; first char in first command in the list
                        	   446: 		
                        	   447: scanCommandList:
01:0179 4E              	   448: 		ld 		C,(HL)						; command # in C
01:017A 23              	   449: 		inc 	HL 							; (HL)=first char
01:017B 46              	   450: 		ld 		B,(HL)						; # chars in command in list
01:017C 23              	   451: 		inc 	HL 							; (HL)=first char
01:017D D5              	   452: 		push 	DE 							; save start of typed string (DE) for later
                        	   453: 
                        	   454: findCommandInList:
01:017E 1A              	   455: 		ld 		a,(DE)						; next typed char
                        	   456: 		; or 		$20							; make typed char lower case
01:017F BE              	   457: 		cp		(HL)
01:0180 2008            	   458: 		jr 		nz,findNextITEM				; different chars-> test next item in list
01:0182 13              	   459: 		inc 	DE
01:0183 23              	   460: 		inc 	HL  
01:0184 10F8            	   461: 		djnz 	findCommandInList
                        	   462: 		
                        	   463: 		; ***	test char (DE); should be a delimiter...
                        	   464: 		; ex 		DE,HL
                        	   465: 		; call 	isDelimit
                        	   466: 		; 				;delimiters found ? =>Z, else ~Z
                        	   467: 		; 				;char in (HL) is '0' ->  set C, else NC
                        	   468: 		; ex 		DE,HL
                        	   469: 
                        	   470: 		; call 	writeSTRBelow
                        	   471: 		; DB 		0,"pop 	HL.. !",CR,LF,00
                        	   472: 		; call 	DumpRegisters
                        	   473: 
                        	   474: 		; jr 		nz,findNextITEM    			; command match but is longer (more chars) cp list					
                        	   475: 
                        	   476: 		; ***	Found a matching command, All char do match...
                        	   477: 		; 		(HL) points to first after command
01:0186 C3A403          	   478: 		jp 		matchInList
01:0189 00              	   479: zero_byte:	db  0
                        	   480: 
                        	   481: findNextITEM:
                        	   482: 		; ***	find next ITEM or LISTEND
01:018A 7E              	   483: 		ld 		a,(HL)
01:018B FEEE            	   484: 		cp		CDEL					; command adress delimiter
01:018D 2812            	   485: 		jr 		z,.skipPastCommAdr
                        	   486: 	
01:018F FE1C            	   487: 		cp		ITEM					; command adress delimiter
01:0191 2817            	   488: 		jr 		z,nextInList
                        	   489: 	
01:0193 FE1E            	   490: 		cp 		LISTEND
01:0195 2010            	   491: 		jr 		NZ,.cont
                        	   492: 
                        	   493: 		; ***	Command list did not match; check if direct address '$' or byte input
01:0197 3EFF            	   494: 		ld 		A,$FF
01:0199 320000          	   495: 		ld 		(PCinpFlag),A			; indicate ev. typed ($)address to change PCV or input bytes ...
01:019C E1              	   496: 		pop 	HL						; HL start of typed string (again)
01:019D 7E              	   497: 		ld 		A,(HL)
01:019E C3EF03          	   498: 		jp 		checkaddress			; No more commands to check, check if address entered , '$'
                        	   499: 										; or relative adress '@'
                        	   500: 										; or direct input of bytes.....
                        	   501: .skipPastCommAdr:
01:01A1 23              	   502: 		inc  	HL		;hig adr.
01:01A2 23              	   503: 		inc  	HL		; low adr.
01:01A3 23              	   504: 		inc  	HL		;  '0'
01:01A4 23              	   505: 		inc  	HL		;  next row
01:01A5 18E3            	   506: 		jr 		findNextITEM
                        	   507: 
01:01A7 23              	   508: .cont:	inc 	HL
01:01A8 18E0            	   509: 		jr 		findNextITEM
                        	   510: 
                        	   511: nextInList:
01:01AA 23              	   512: 		inc 	HL						; points to item #
01:01AB D1              	   513: 		pop 	DE 						; DE start of typed string (again)
01:01AC 18CB            	   514: 		jr 		scanCommandList
                        	   515: 
                        	   516: 
                        	   517: 	;***************************************************************
                        	   518: 	;	Semantic error occurred in input :
                        	   519: 	;***************************************************************
                        	   520: 
                        	   521: inputerror:
01:01AE E5              	   522: 		push   	HL
01:01AF CD0000          	   523: 		call 	writeSTRBelow
01:01B2 00              	   524: 		DB 		0,"Input Semantic Error... ! code(DE):",00
01:01B3 496E707574205365
01:01BB 6D616E7469632045
01:01C3 72726F722E2E2E20
01:01CB 2120636F64652844
01:01D3 45293A
01:01D6 00
01:01D7 D1              	   525: 		pop 	DE
01:01D8 CD0000          	   526: 		call 	putDEtoScreen
01:01DB CD0000          	   527: 		call 	CRLF
01:01DE C30101          	   528: 		jp 		next_line
                        	   529: 
                        	   530: ; command_addresses:
                        	   531: ; 		defw 	00
                        	   532: ; 		defw 	p_load			;1
                        	   533: ; 		defw 	p_dumpmem		;2
                        	   534: ; 		defw 	p_pc			;3
                        	   535: ; 		defw 	p_eep			;4
                        	   536: ; 		defw 	p_clearmem		;5
                        	   537: ; 		defw 	p_exe			;6
                        	   538: ; 		defw 	p_go			;7
                        	   539: ; 		defw 	p_incDecPC		;8
                        	   540: ; 		defw 	p_incDecPC		;9
                        	   541: ; 		defw 	p_FON			;10
                        	   542: ; 		defw 	p_FOFF			;11
                        	   543: ; 		defw 	p_flwr			;12. write data to FLASH
                        	   544: ; 		defw 	p_flse			;13. sector erase
                        	   545: ; 		defw 	p_xmod			;14. transfer files via x-modem
                        	   546: ; 		defw 	p_reset			;16. Jump to $0000
                        	   547: ; 		defw	p_C_Read		;16. Read from SD card   sdrd  "file"  $Addr
                        	   548: ; 		defw	p_C_Write		;17. Write to SD card   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   549: ; 		defw	p_C_Read		;18. Read from USB   sdrd  "file"  $Addr
                        	   550: ; 		defw	p_C_Write		;19. Write to USB   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   551: ; 		defw	p_C_Delete		;20. delete file on SD card   sdrd  "file"  $Addr
                        	   552: ; 		defw	p_C_Delete		;21. delete file on USB  sdrd  "file"  $Addr.l $Addr.h/Num
                        	   553: ; 		defw 	p_C_Read		;22. List root level files/dirs on sd card
                        	   554: ; 		defw 	p_C_Read 		;23. List root level files/dirs on USB
                        	   555: ; 		defw	p_cptFl			;24. copy from mem to flash memory (on selected bank)
                        	   556: ; 		defw 	p_flbank		;25. Set flash bank #
                        	   557: ; 		defw	p_srbank		;26. Set sram bank #
                        	   558: 
                        	   559: command_list:
                        	   560: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	   561: 
01:01E1 1C              	   562: 		db		ITEM,1,4,"load",STEND,%100010,0,CDEL
01:01E2 01
01:01E3 04
01:01E4 6C6F6164
01:01E8 1D
01:01E9 22
01:01EA 00
01:01EB EE
01:01EC 0C05            	   563: 		dw 		p_load,0
01:01EE 0000
01:01F0 1C              	   564: 		db		ITEM,2,2,"dm",	STEND,%000010,0,CDEL
01:01F1 02
01:01F2 02
01:01F3 646D
01:01F5 1D
01:01F6 02
01:01F7 00
01:01F8 EE
01:01F9 0D05            	   565: 		dw  	p_dumpmem,0
01:01FB 0000
01:01FD 1C              	   566: 		db		ITEM,3,2,"pc",	STEND,%000000,0,CDEL
01:01FE 03
01:01FF 02
01:0200 7063
01:0202 1D
01:0203 00
01:0204 00
01:0205 EE
01:0206 1105            	   567: 		dw 		p_pc,0
01:0208 0000
01:020A 1C              	   568: 		db		ITEM,4,3,"eep",	STEND,%000000,0,CDEL
01:020B 04
01:020C 03
01:020D 656570
01:0210 1D
01:0211 00
01:0212 00
01:0213 EE
01:0214 1205            	   569: 		dw 		p_eep,0
01:0216 0000
01:0218 1C              	   570: 		db		ITEM,5,2,"cm",	STEND,%000000,0,CDEL
01:0219 05
01:021A 02
01:021B 636D
01:021D 1D
01:021E 00
01:021F 00
01:0220 EE
01:0221 1905            	   571: 		dw  	p_clearmem,0
01:0223 0000
01:0225 1C              	   572: 		db		ITEM,6,3,"exe",	STEND,%000000,0,CDEL
01:0226 06
01:0227 03
01:0228 657865
01:022B 1D
01:022C 00
01:022D 00
01:022E EE
01:022F 2C05            	   573: 		dw 		p_exe,0
01:0231 0000
01:0233 1C              	   574: 		db		ITEM,7,2,"go",	STEND,%000000,0,CDEL
01:0234 07
01:0235 02
01:0236 676F
01:0238 1D
01:0239 00
01:023A 00
01:023B EE
01:023C 2D05            	   575: 		dw 		p_go,0
01:023E 0000
01:0240 1C              	   576: 		db		ITEM,8,2,"++",	STEND,%000000,0,CDEL
01:0241 08
01:0242 02
01:0243 2B2B
01:0245 1D
01:0246 00
01:0247 00
01:0248 EE
01:0249 3E05            	   577: 		dw 		p_incDecPC,0
01:024B 0000
01:024D 1C              	   578: 		db		ITEM,9,2,"--",	STEND,%000000,0,CDEL
01:024E 09
01:024F 02
01:0250 2D2D
01:0252 1D
01:0253 00
01:0254 00
01:0255 EE
01:0256 3E05            	   579: 		dw 		p_incDecPC,0
01:0258 0000
01:025A 1C              	   580: 		db		ITEM,10,3,"fl1",		STEND,%000000,0,CDEL
01:025B 0A
01:025C 03
01:025D 666C31
01:0260 1D
01:0261 00
01:0262 00
01:0263 EE
01:0264 CC06            	   581: 		dw		p_FON,0
01:0266 0000
01:0268 1C              	   582: 		db		ITEM,10,8,"flash-on",	STEND,%000000,0,CDEL
01:0269 0A
01:026A 08
01:026B 666C6173682D6F6E
01:0273 1D
01:0274 00
01:0275 00
01:0276 EE
01:0277 CC06            	   583: 		dw 		p_FON,0
01:0279 0000
01:027B 1C              	   584: 		db		ITEM,11,3,"fl0",		STEND,%000000,0,CDEL
01:027C 0B
01:027D 03
01:027E 666C30
01:0281 1D
01:0282 00
01:0283 00
01:0284 EE
01:0285 2607            	   585: 		dw 		p_FOFF,0
01:0287 0000
01:0289 1C              	   586: 		db		ITEM,11,9,"flash-off",	STEND,%000000,0,CDEL
01:028A 0B
01:028B 09
01:028C 666C6173682D6F66
01:0294 66
01:0295 1D
01:0296 00
01:0297 00
01:0298 EE
01:0299 2607            	   587: 		dw 		p_FOFF,0
01:029B 0000
01:029D 1C              	   588: 		db		ITEM,12,4,"flwr",	STEND,%001110,0,CDEL
01:029E 0C
01:029F 04
01:02A0 666C7772
01:02A4 1D
01:02A5 0E
01:02A6 00
01:02A7 EE
01:02A8 6305            	   589: 		dw 		p_flwr,0									; write to flash: flwr  <$Addr.mem> <$Addr.flash>  <Num> (0E)
01:02AA 0000
01:02AC 1C              	   590: 		db		ITEM,13,4,"flse",	STEND,%000000,0,CDEL
01:02AD 0D
01:02AE 04
01:02AF 666C7365
01:02B3 1D
01:02B4 00
01:02B5 00
01:02B6 EE
01:02B7 9805            	   591: 		dw 		p_flse,0
01:02B9 0000
01:02BB 1C              	   592: 		db		ITEM,14,4,"xmod",	STEND,%001000,0,CDEL
01:02BC 0E
01:02BD 04
01:02BE 786D6F64
01:02C2 1D
01:02C3 08
01:02C4 00
01:02C5 EE
01:02C6 A105            	   593: 		dw 		p_xmod,0									; xmodem from PC   xmod <address>
01:02C8 0000
01:02CA 1C              	   594: 		db		ITEM,15,3,"rst",	STEND,%000000,0,CDEL
01:02CB 0F
01:02CC 03
01:02CD 727374
01:02D0 1D
01:02D1 00
01:02D2 00
01:02D3 EE
01:02D4 F804            	   595: 		dw 		p_reset,0
01:02D6 0000
01:02D8 1C              	   596: 		db		ITEM,16,4,"sdrd",	STEND,%101000,0,CDEL
01:02D9 10
01:02DA 04
01:02DB 73647264
01:02DF 1D
01:02E0 28
01:02E1 00
01:02E2 EE
01:02E3 AD05            	   597: 		dw		p_C_Read,0									; Read from SD card   sdrd  "file"  $Addr
01:02E5 0000
01:02E7 1C              	   598: 		db		ITEM,17,4,"sdwr",	STEND,%101010,0,CDEL
01:02E8 11
01:02E9 04
01:02EA 73647772
01:02EE 1D
01:02EF 2A
01:02F0 00
01:02F1 EE
01:02F2 0606            	   599: 		dw 		p_C_Write,0									; Write to SD card   sdwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:02F4 0000
01:02F6 1C              	   600: 		db		ITEM,18,5,"usbrd",	STEND,%101000,0,CDEL
01:02F7 12
01:02F8 05
01:02F9 7573627264
01:02FE 1D
01:02FF 28
01:0300 00
01:0301 EE
01:0302 AD05            	   601: 		dw 		p_C_Read,0									; Read from USB      usbrd  "file"  $Addr
01:0304 0000
01:0306 1C              	   602: 		db		ITEM,19,5,"usbwr",	STEND,%101010,0,CDEL
01:0307 13
01:0308 05
01:0309 7573627772
01:030E 1D
01:030F 2A
01:0310 00
01:0311 EE
01:0312 0606            	   603: 		dw 		p_C_Write,0									; Write to USB        usbwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0314 0000
01:0316 1C              	   604: 		db		ITEM,20,5,"sddel",	STEND,%100000,0,CDEL
01:0317 14
01:0318 05
01:0319 736464656C
01:031E 1D
01:031F 20
01:0320 00
01:0321 EE
01:0322 5E06            	   605: 		dw 		p_C_Delete,0 								; Delete file on SD card   sddel  "file"  
01:0324 0000
01:0326 1C              	   606: 		db		ITEM,21,6,"usbdel",	STEND,%100000,0,CDEL
01:0327 15
01:0328 06
01:0329 75736264656C
01:032F 1D
01:0330 20
01:0331 00
01:0332 EE
01:0333 5E06            	   607: 		dw 		p_C_Delete,0 								; Delete file on USB   usbdel  "file"  
01:0335 0000
01:0337 1C              	   608: 		db		ITEM,22,5,"sddir",	STEND,%100000,0,CDEL
01:0338 16
01:0339 05
01:033A 7364646972
01:033F 1D
01:0340 20
01:0341 00
01:0342 EE
01:0343 AD05            	   609: 		dw 		p_C_Read,0 									; List root level files/dirs on sd card
01:0345 0000
01:0347 1C              	   610: 		db		ITEM,23,6,"usbdir",	STEND,%100000,0,CDEL
01:0348 17
01:0349 06
01:034A 757362646972
01:0350 1D
01:0351 20
01:0352 00
01:0353 EE
01:0354 AD05            	   611: 		dw 		p_C_Read,0 									; List root level files/dirs on USB
01:0356 0000
01:0358 1C              	   612: 		db 		ITEM,24,5,"cptfl",	STEND,%001100,0,CDEL
01:0359 18
01:035A 05
01:035B 637074666C
01:0360 1D
01:0361 0C
01:0362 00
01:0363 EE
01:0364 9506            	   613: 		dw 		p_cptFl,0									; copy from adress range to flash   cptfl  $Addr   $Addr
01:0366 0000
01:0368 1C              	   614: 		db 		ITEM,25,2,"fb",		STEND,%000010,0,CDEL
01:0369 19
01:036A 02
01:036B 6662
01:036D 1D
01:036E 02
01:036F 00
01:0370 EE
01:0371 B006            	   615: 		dw 		p_flbank,0									; set flash bank #	
01:0373 0000
01:0375 1C              	   616: 		db 		ITEM,26,2,"sb",		STEND,%000010,0,CDEL
01:0376 1A
01:0377 02
01:0378 7362
01:037A 1D
01:037B 02
01:037C 00
01:037D EE
01:037E 9D06            	   617: 		dw		p_srbank,0									; set sram bank #	
01:0380 0000
01:0382 1C              	   618: 		db		ITEM,27,3,"nop",	STEND,%000000,0,CDEL
01:0383 1B
01:0384 03
01:0385 6E6F70
01:0388 1D
01:0389 00
01:038A 00
01:038B EE
01:038C 0000            	   619: 		dw 		0,0
01:038E 0000
01:0390 1E              	   620: 		db		LISTEND
                        	   621: commListLen  equ   27
                        	   622: 
                        	   623: 		; ld		HL,$6000
                        	   624: 		; ld		(packetBaseAddress),HL			; store the address for target code (for error correction)
                        	   625: 		; ld		A,01
                        	   626: 		; ld		(prevPacketByte01),A 				; store of packet numbers
                        	   627: 
                        	   628: 		; call 	SetupXMODEM_TXandRX					 
                        	   629: 	
                        	   630: 
                        	   631: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   632: ;---------------------------------------------------------------------------------
                        	   633: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   634: 
                        	   635: ;		skipPriorDelimit 		; increase A0 until non delimiter (NZ) or #0 (Z) 
                        	   636: ;		***		store string value in textarea and reference in table
                        	   637: ;		skipCharsUntilDelim		; increase A0 until blank (NZ) or #0 (Z) 
                        	   638: ;		***		read/store either address or lvalue and store in table
                        	   639: ; 		isDelimit(S)  is char in (A0) any of the delimiters specified in (A1) ? =>Z, else ~Z
                        	   640: ; 		Parameters returned; A0 - Address of char
                        	   641: 
                        	   642: ;		commParseTable
                        	   643: ;		***************************************************
                        	   644: ;		***	decode input line;
                        	   645: ;		*** <cmd>    "TEXT"  	$xxyy  xxyy
                        	   646: ;		*** command textstring 	address	 lvalue
                        	   647: ;		************************************************************
                        	   648: ;		*** commParseTable:
                        	   649: ;		*** 00 : W : offset in jumptable  (F080)
                        	   650: ;		*** 04 : L : address 1  (F084-F087)
                        	   651: ;		*** 08 : L : address 2  (F088-F08B)
                        	   652: ;		*** 10 : L : lvalue1  (F090-F09F)
                        	   653: ;		*** 20 : L : lvalue2  (F0A0-F0AF)
                        	   654: ;		*** 57 : L : text1   (F0B0-F0D7)
                        	   655: ;		*** 58 : L : text2 	 (F0D8-F0FF)	
                        	   656: ;		***
                        	   657: ;		***--------------------------------------
                        	   658: 
                        	   659: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   660: ;---------------------------------------------------------------------------------
                        	   661: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   662: 
                        	   663: 		; call	skipCharsUntilDelim			; set (HL) to first delimiter
                        	   664: 		; push 	HL
                        	   665: 		; pop  	BC							; typed command end+1 in BC
                        	   666: 
                        	   667: 		; ***	Prepares the commParseTable. Consumes HL,B,A
                        	   668: initCommParseTable:
01:0391 3E00            	   669: 		ld 		A,0
01:0393 320000          	   670: 		ld 		(PCinpFlag),A
01:0396 320100          	   671: 		ld 		(PCinpFlag+1),A
01:0399 210000          	   672: 		ld 		HL,commParseTable
                        	   673: 
01:039C 0680            	   674: 		ld 		B,$80
01:039E 97              	   675: 		sub 	A 					; clear A.
                        	   676: .icpt:
01:039F 77              	   677: 		ld 		(HL),A
01:03A0 23              	   678: 		inc 	HL
01:03A1 10FC            	   679: 		djnz 	.icpt
                        	   680: 
01:03A3 C9              	   681: 		ret
                        	   682: 
                        	   683: ;---------------------------------------------------------------------------------
                        	   684: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   685: 
                        	   686: 	;***************************************************************
                        	   687: 	;	Command identified -> now search for string :
                        	   688: 	;***************************************************************
                        	   689: 
                        	   690: matchInList:
                        	   691: 		; ***	Command found. Then, check for string input "<string>"
                        	   692: 		; ***	DE points to first delimiter after command 
                        	   693: 						;delimiters found ? =>Z, else ~Z
                        	   694: 						;char in (HL) is '0' ->  set C, else NC
                        	   695: 
01:03A4 33              	   696: 		inc 	sp
01:03A5 33              	   697: 		inc 	sp						; restore PC from PUSH in <scanCommandList>
01:03A6 23              	   698: 		inc 	HL 						; HL point to first after <STEND>  ->req arguments  (STEND,%100010,0,CDEL,p_load,0)
01:03A7 7E              	   699: 		ld 		A,(HL) 					; A= required arguments from table
01:03A8 FD210000        	   700: 		ld 		IY,commParseTable		; IY =commParseTable =	0x80 + _String_HEAP
01:03AC FD7502          	   701: 		ld   	(IY+2),L 
01:03AF FD7403          	   702: 		ld   	(IY+3),H				; save the command adress.
                        	   703: 		
01:03B2 FD7100          	   704: 		ld 		(IY),C 					; store the command number in (commParseTable, 0x80)
01:03B5 FD7701          	   705: 		ld 		(IY+1),A				; store required arguments  in (commParseTable+1, 0x81)
                        	   706: 		; call 	writeSTRBelow_CRLF
                        	   707: 		; DB 		0,"Found a valid command  see (C).. !",CR,LF,00
01:03B8 D5              	   708: 		push 	DE
01:03B9 E1              	   709: 		pop 	HL						; HL=DE = first delimiter after command
01:03BA 2B              	   710: 		dec 	HL							; DE -> HL -> last char before delimiter
                        	   711: paramLoopEntry:	
                        	   712: 
01:03BB CD0000          	   713: 		call 	skipPriorDelimit 			; look for next char (  '"' ?)
01:03BE DAA904          	   714: 		jp 		C,executeCommand			; C set from 'skipPriorDelimit', no command parameters
                        	   715: 
01:03C1 7E              	   716: 		ld 		A,(HL)
                        	   717: 
01:03C2 FE22            	   718: 		cp 		'"'							; beginning of string ?
01:03C4 2029            	   719: 		jr 		NZ,checkaddress				;  NZ -> (HL) points to non delimiter
                        	   720: 
                        	   721: 		; ***	extract string 
01:03C6 23              	   722: 		inc 	HL 							; skip '"' (HL)-> first char
                        	   723: 
01:03C7 E5              	   724: 		push  	HL
01:03C8 D1              	   725: 		pop  	DE							; DE -> first char after '"' <source>
01:03C9 CD0000          	   726: 		call 	skipCharsUntilDelim			; find second '"'
01:03CC 2B              	   727: 		dec 	HL 							; skip first delimiter (ev. CR)
01:03CD 7E              	   728: 		ld 		A,(HL)
01:03CE FE22            	   729: 		cp 		'"' 						; found second '"' ??
01:03D0 C2AE01          	   730: 		jp 		NZ,inputerror
01:03D3 2B              	   731: 		dec 	HL 							; skip second '"'
                        	   732: 	;***************************************************************
                        	   733: 	;	copy string to  'commParseTable'
                        	   734: 	;***************************************************************
                        	   735: 
01:03D4 A7              	   736: 		and 	A
01:03D5 ED52            	   737: 		sbc 	HL,DE 						; amount of chars...
01:03D7 44              	   738: 		ld 		B,H							; amount of chars...
01:03D8 4D              	   739: 		ld 		C,L							; amount of chars...
01:03D9 03              	   740: 		inc 	BC
                        	   741: 
01:03DA 210000          	   742: 		ld 		HL,commStr1				; address for first string
01:03DD 7E              	   743: 		ld 		A,(HL)
01:03DE B7              	   744: 		or 		A 						; =0?
01:03DF 2808            	   745: 		jr 		Z, .strone
01:03E1 210000          	   746: 		ld 		HL,commStr2				; address for second string
01:03E4 7E              	   747: 		ld 		A,(HL)
01:03E5 B7              	   748: 		or  	A						; =0 ?
01:03E6 C2AE01          	   749: 		jp 		NZ,inputerror			; too many strings
                        	   750: .strone:
01:03E9 EB              	   751: 		ex 		DE,HL 					; HL = <source>, DE = <dest>, size = BC
01:03EA EDB0            	   752: 		ldir 							; make the copy
                        	   753: 		; ex		DE,HL
01:03EC 23              	   754: 		inc 	HL 						; (HL) past the second '"'
                        	   755: 
01:03ED 18CC            	   756: 		jr 		paramLoopEntry
                        	   757: 
                        	   758: 
                        	   759: 	;***************************************************************
                        	   760: 	;	Check if address is specified in input 
                        	   761: 	;***************************************************************
                        	   762: 
                        	   763: 
                        	   764: checkaddress:
                        	   765: 		; ***	A = (HL), first char after delimiter
                        	   766: 
01:03EF 320100          	   767: 		ld 		(PCinpFlag+1),A			; if value '(PCinpFlag+1)' == '$' -> address input
                        	   768: 										; if value '(PCinpFlag+1)' == '@' -> relative (PCval) address input
01:03F2 FE24            	   769: 		cp 		'$'						; identified address id
01:03F4 3E00            	   770: 		ld 		A,0
01:03F6 2802            	   771: 		jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   772: 		; cp 		'@'						; identified address id
                        	   773: 		; jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   774: 
01:03F8 1823            	   775: 		jr 		getLvalue				
                        	   776: 
01:03FA 23              	   777: chkADR:		inc 	HL 						; skip past '$' or '@'
                        	   778: 
                        	   779: chkADR1:
                        	   780: 	; ***		Check where to store address...
                        	   781: 
01:03FB DD210000        	   782: 		ld 		IX,commAdr1
                        	   783: 		; ld 		A,0
01:03FF DDBE00          	   784: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0402 2007            	   785: 		jr 		NZ,chkADR2
01:0404 DDBE01          	   786: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:0407 2002            	   787: 		jr 		NZ,chkADR2
01:0409 1832            	   788: 		jr 		makeASCIItoHEX
                        	   789: chkADR2:
                        	   790: 
01:040B DD210000        	   791: 		ld 		IX,commAdr2
                        	   792: 		; ld 		A,0
01:040F DDBE00          	   793: 		cp 		(IX)			; check if zero ? (already stored)
01:0412 C2AE01          	   794: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0415 DDBE01          	   795: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
01:0418 C2AE01          	   796: 		jp 		NZ,inputerror	; error : No more addresses to store
01:041B 1820            	   797: 		jr 		makeASCIItoHEX
                        	   798: 
                        	   799: getLvalue:
01:041D DD210000        	   800: 		ld 		IX,commLvl1
01:0421 DDBE00          	   801: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0424 2007            	   802: 		jr 		NZ,chkLVL2
01:0426 DDBE01          	   803: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:0429 2002            	   804: 		jr 		NZ,chkLVL2
01:042B 1810            	   805: 		jr 		makeASCIItoHEX
                        	   806: 
                        	   807: chkLVL2:
01:042D DD210000        	   808: 		ld 		IX,commLvl2
01:0431 DDBE00          	   809: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0434 C2AE01          	   810: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0437 DDBE01          	   811: 		cp 		(IX+1)			; check if zero (byte 2) ? (ascii value already stored)
01:043A C2AE01          	   812: 		jp 		NZ,inputerror	; error : No more addresses to store
                        	   813: 
                        	   814: 
                        	   815: makeASCIItoHEX:
                        	   816: 		; ***	copy from command line to adr or lvalue in table
                        	   817: 		; ***	only two bytes (four chars)....
                        	   818: 		; 		IX point to destination...
01:043D 54              	   819: 		ld 		D,H
01:043E 5D              	   820: 		ld		E,L						; DE -> first char after '$' | '@' <source>
01:043F CD0000          	   821: 		call 	skipCharsUntilDelim		; find next delimiter or CR ; adr in HL
01:0442 7E              	   822: 		ld 		A,(HL)
                        	   823: 
                        	   824: 	;***************************************************************
                        	   825: 	;	copy string to  'commParseTable', IX points to dest address.
                        	   826: 	;***************************************************************
                        	   827: 
01:0443 A7              	   828: 		and 	A						; clear Carry
01:0444 ED52            	   829: 		sbc 	HL,DE 					; amount of chars...->HL ( H=0); DE -> first char after '$' <source>
                        	   830: 
                        	   831: 		; ***	Do not check even or odd...
                        	   832: 		; bit 	0,L 					; even or odd (=1)?
                        	   833: 		; jp 		NZ,inputerror
                        	   834: 
01:0446 45              	   835: 		ld 		B,L 					; char counter
01:0447 210000          	   836: 		ld 		HL,00					;  
                        	   837: 
01:044A EB              	   838: 		ex 		DE,HL					; HL -> first char after '$' <ascii source>	
                        	   839: 
                        	   840: nextHalfByte:
                        	   841: 
01:044B CD0000          	   842: 		call 	isHex					; check char in (HL) return with Carry, value in A is NOT HEX
01:044E DAAE01          	   843: 		jp 		C,inputerror			; return with Carry, value in A is NOT HEX
                        	   844: 
01:0451 CB23            	   845: 		sla 	E						; shift left E-> Carry
01:0453 CB12            	   846: 		rl 		D 						; Carry -> rotate left D
01:0455 CB23            	   847: 		sla 	E						; shift left E-> Carry
01:0457 CB12            	   848: 		rl 		D 						; Carry -> rotate left D
01:0459 CB23            	   849: 		sla 	E						; shift left E-> Carry
01:045B CB12            	   850: 		rl 		D 						; Carry -> rotate left D
01:045D CB23            	   851: 		sla 	E						; shift left E-> Carry
01:045F CB12            	   852: 		rl 		D 						; Carry -> rotate left D
01:0461 B3              	   853: 		or      E  						; A OR E(0..3) are zero
01:0462 5F              	   854: 		ld 		E,A
                        	   855: 
01:0463 DD7300          	   856: 		ld 		(IX),E					; store E value [big endian]
01:0466 DD7201          	   857: 		ld 		(IX+1),D				; store D value [big endian]
                        	   858: 
01:0469 23              	   859: 		inc 	HL
                        	   860: 
01:046A 10DF            	   861: 		djnz 	nextHalfByte
                        	   862: 		;***	HL should point to first delimiter...
                        	   863: 
                        	   864: byteEnd:
                        	   865: 
01:046C 3A0000          	   866: 		ld  	A,(PCinpFlag)
01:046F B7              	   867: 		or  	A 						; check Z; =0 -> normal parameter save
01:0470 CABB03          	   868: 		jp 	   	Z,paramLoopEntry
                        	   869: 
01:0473 3A0100          	   870: 		ld  	A,(PCinpFlag+1) 		; address input for PCValue ?
01:0476 FE24            	   871: 		cp 		'$' 					; adress flag ?
                        	   872: 		; jr 		Z,changePCVal
                        	   873: 		; cp 		'@' 					; relative adress flag ?
01:0478 2813            	   874: 		jr 		Z,changePCVal
                        	   875: 
                        	   876: 		; ***	Store  bytes from LVL1 to (PCval)
01:047A E5              	   877: 		push 	HL
01:047B ED5B0000        	   878: 		ld 		DE,(PCvalue)	
01:047F 210000          	   879: 		ld 		HL,commLvl1
                        	   880: 		; ld 		A,(DE)
                        	   881: 		; ld 		(HL),A
                        	   882: 		; inc 	HL
                        	   883: 		; inc 	DE
01:0482 EDA0            	   884: 		ldi  							; (DE)<-(HL), inc HL,DE, dec BC
01:0484 7E              	   885: 		ld 		A,(HL)
01:0485 B7              	   886: 		or 		A
01:0486 2801            	   887: 		jr 		Z,noHighNib
01:0488 12              	   888: 		ld 		(DE),A
                        	   889: noHighNib:
01:0489 E1              	   890: 		pop 	HL		
                        	   891: 		; ***	reset flag
                        	   892: 		; ld 		A,0
                        	   893: 		; ld 		(PCinpFlag),A
                        	   894: 		; ld 		(PCinpFlag+1),A
01:048A C3BB03          	   895: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   896: 
                        	   897: 		
                        	   898: changePCVal:
                        	   899: 		; ***	Change relative PCvalue from 'commAdr1' or
                        	   900: 		; ***	change PCvalue from 'commAdr1'
                        	   901: 		; ***	A contains '$' or '@'
01:048D E5              	   902: 		push 	HL
01:048E D5              	   903: 		push  	DE
01:048F FE40            	   904: 		cp   	'@' 					; relative adress ?
01:0491 2806            	   905: 		jr 		Z,.reladr
                        	   906: ; 		***		absolute adr !		
01:0493 210000          	   907: 		ld 		HL,00
01:0496 220000          	   908: 		ld 		(PCvalue),HL				; clear and then add value from commAdr1
                        	   909: 
                        	   910: .reladr:		
01:0499 2A0000          	   911: 		ld 		HL,(commAdr1)
01:049C ED5B0000        	   912: 		ld  	DE,(PCvalue)
01:04A0 19              	   913: 		add 	HL,DE
01:04A1 220000          	   914: 		ld 		(PCvalue),HL
01:04A4 D1              	   915: 		pop 	DE
01:04A5 E1              	   916: 		pop 	HL 						; restore value of first delimiter
01:04A6 C3BB03          	   917: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   918: 
                        	   919: executeCommand:	
                        	   920: 		; ***	execute commands (and arguments)
                        	   921: 		; call 	writeSTRBelow
                        	   922: 		; DB 		0,"Finish parsing !",CR,LF,00
                        	   923: 		; call 	DumpRegisters			; checkpoint for list of arguments
                        	   924: 		; ***	IY+2 point to command address. IY=commParseTable
                        	   925: 
01:04A9 3A0000          	   926: 		ld 		A,(PCinpFlag)
01:04AC B7              	   927: 		or 		A   					; check if zero  
01:04AD 2003            	   928: 		jr 		NZ,.noJump
                        	   929: 
01:04AF CDBD04          	   930: 		call 	JPTable01
                        	   931: .noJump:
                        	   932: 		; ***	reset flag
01:04B2 3E00            	   933: 		ld 		A,0
01:04B4 320000          	   934: 		ld 		(PCinpFlag),A
01:04B7 320100          	   935: 		ld 		(PCinpFlag+1),A
                        	   936: 
                        	   937: 		
                        	   938: 		; jp 		paramLoopEntry 				; loop and check for more parameters
                        	   939: 
                        	   940: temp_finish:
                        	   941: 		; call 	DumpRegisters
01:04BA C30101          	   942: 		jp 		next_line
                        	   943: 
                        	   944: 	;***************************************************************
                        	   945: 	;	Check if LVALUE is specified in input 
                        	   946: 	;***************************************************************
                        	   947: 
                        	   948: JPTable01:
01:04BD 3A0000          	   949: 		ld 		A,(commParseTable) 			; retrieve command number
01:04C0 B7              	   950: 		or 	  	A 							; error if 0
01:04C1 CAAE01          	   951: 		jp 		Z,inputerror
01:04C4 FE1B            	   952: 		cp 		commListLen
01:04C6 3F              	   953: 		ccf 						;complement carry for error indicator
                        	   954: 
01:04C7 DAAE01          	   955: 		jp      C,inputerror
                        	   956: 
01:04CA E5              	   957: 		push  	HL					; make space in stack for 'return' address
                        	   958: 
                        	   959: 		; 								;obtain routine address from table and transfer 
                        	   960: 		; 								;control to it, leaving all register pairs unchanged
                        	   961: 		
01:04CB FD2A0200        	   962: 		ld   	IY,(commParseTable+2)	; get address $F080+2
01:04CF FD6E03          	   963: 		ld   	L,(IY+3)				; load address in HL, move pointer 3 pos forward
01:04D2 FD6604          	   964: 		ld   	H,(IY+4)
                        	   965: 
01:04D5 E3              	   966: 		ex 		(SP),HL					;restore old HL, push routine address
01:04D6 C9              	   967: 		ret 							; jump to routine
                        	   968: 
                        	   969: argumentsError:
01:04D7 CD0000          	   970: 		call 	writeSTRBelow
01:04DA 00              	   971: 		DB 		0,"Some arguments mismatch !",CR,LF,00
01:04DB 536F6D6520617267
01:04E3 756D656E7473206D
01:04EB 69736D6174636820
01:04F3 21
01:04F4 0D
01:04F5 0A
01:04F6 00
01:04F7 C9              	   972: 		ret
                        	   973: 
                        	   974: 
                        	   975: p_reset:
01:04F8 AF              	   976: 		xor 	A
01:04F9 320000          	   977: 		ld 		(memBankID),A			; set memory banks #0
01:04FC CD0000          	   978: 		call 	setFLASHBank			; FLASH bank #0
01:04FF AF              	   979: 		xor 	A
01:0500 CD0000          	   980: 		call 	setSRAMBank				; ram bank #0
                        	   981: 
01:0503 CD0000          	   982: 		call 	enableFLASH			; start from FLASH
                        	   983: 
01:0506 CD0000          	   984: 		call 	enableIC620_OE 			; enable the outputs.
                        	   985: 
01:0509 C30000          	   986: 		jp $0000
                        	   987: 
                        	   988: p_load:
01:050C C9              	   989: 		ret
                        	   990: p_dumpmem:
01:050D CD0000          	   991: 		call 	dumpMemory
                        	   992: 
01:0510 C9              	   993: 		ret
                        	   994: p_pc:
01:0511 C9              	   995: 		ret
                        	   996: 
                        	   997: p_eep:
                        	   998: 
01:0512 210000          	   999: 		ld 		HL,000
01:0515 220000          	  1000: 		ld 		(PCvalue),hl
01:0518 C9              	  1001: 		ret
                        	  1002: 
                        	  1003: p_clearmem:
                        	  1004: ;		***		clear memory from PC/Adr n bytes from ram memory
                        	  1005: 
01:0519 ED4B0000        	  1006: 		ld 		BC,(commLvl1)    	;amount of bytes
01:051D ED5B0000        	  1007: 		ld   	DE,(PCvalue)		 
01:0521 212B05          	  1008: 		ld		hl,.zero_byte
                        	  1009: 		
                        	  1010: .cl_vars:
01:0524 EDA0            	  1011: 		ldi							; (DE)<-(HL)
01:0526 2B              	  1012: 		dec 	hl
01:0527 EA2405          	  1013: 		jp		PE,.cl_vars			; 		P/V is set if BC  1  0; otherwise, it is reset.
                        	  1014: 
01:052A C9              	  1015: 		ret
01:052B 00              	  1016: .zero_byte:	db  0
                        	  1017: 
                        	  1018: p_exe:
                        	  1019: 
                        	  1020: 		; call 	LCD_Test
                        	  1021: 
01:052C C9              	  1022: 		ret
                        	  1023: p_go:
                        	  1024: 
01:052D 18FD            	  1025: 		jr 	p_exe
                        	  1026: 
                        	  1027: 
01:052F 3A0000          	  1028: 		ld 		A,(TempVar1)
01:0532 3C              	  1029: 		inc 	A
01:0533 320000          	  1030: 		ld 		(TempVar1),A
01:0536 FE0F            	  1031: 		cp 		15
01:0538 CD0000          	  1032: 		call 	DumpRegisters
                        	  1033: 		
01:053B F0              	  1034: 		ret 	P
01:053C 18EF            	  1035: 		jr 		p_go
                        	  1036: p_incDecPC:
01:053E 210000          	  1037: 		ld 		HL,commLvl1
01:0541 3E00            	  1038: 		ld 		A,0
01:0543 5E              	  1039: 		ld 		E,(HL)
01:0544 23              	  1040: 		inc 	HL
01:0545 56              	  1041: 		ld 		D,(hl) 				; DE = (commLvl1)
                        	  1042: 		; ***	if both D and E is 0 -> DE = 1 		; no param -> A=1
01:0546 BB              	  1043: 		cp 		E
01:0547 2006            	  1044: 		jr 		NZ,.justOne
01:0549 BA              	  1045: 		cp 		D
01:054A 2003            	  1046: 		jr 		NZ,.justOne
01:054C 110100          	  1047: 		ld 		DE,1
                        	  1048: .justOne:
01:054F 3A0000          	  1049: 		ld 		A,(commParseTable)	; command number in commParseTable
01:0552 2A0000          	  1050: 		ld 		HL,(PCvalue)
01:0555 FE08            	  1051: 		cp 		8 					; ++ (increase) ??
01:0557 2003            	  1052: 		jr  	nz,.sub
01:0559 19              	  1053: 		add 	HL,DE 				; increase HL (PCvalue) with DE
01:055A 1803            	  1054: 		jr 		.common
                        	  1055: .sub:
01:055C A7              	  1056: 		and 	A					; clear C
01:055D ED52            	  1057: 		sbc 	HL,DE 				; decrease HL (PCvalue) with DE
                        	  1058: .common:
01:055F 220000          	  1059: 		ld 		(PCvalue),HL
01:0562 C9              	  1060: 		ret
                        	  1061: p_flwr:
                        	  1062: 		; *** 	testwrite to FLASH
                        	  1063: 		
                        	  1064: 		; call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
                        	  1065: 		; jp		NZ,argumentsError			; show argument error and return
                        	  1066: 		; 	*** Check if flashmem is enabled
01:0563 3A0000          	  1067: 		ld 		A,(memBankID)
01:0566 CB7F            	  1068: 		bit 	7,A
01:0568 2004            	  1069: 		jr 		NZ,errNoFlash
                        	  1070: 
01:056A CD0000          	  1071: 		call 	Flash_WR_Test
01:056D C9              	  1072: 		ret
                        	  1073: errNoFlash:
01:056E CD0000          	  1074: 		call 	writeSTRBelow
01:0571 00              	  1075: 		DB 		0," Can't write to deselected FLASH !",CR,LF,00
01:0572 2043616E27742077
01:057A 7269746520746F20
01:0582 646573656C656374
01:058A 656420464C415348
01:0592 2021
01:0594 0D
01:0595 0A
01:0596 00
                        	  1076: 
01:0597 C9              	  1077: 		ret
                        	  1078: 
                        	  1079: 
                        	  1080: p_flse:
                        	  1081: 		; *** 	erase the sector that contain the address of HL
                        	  1082: 
01:0598 E5              	  1083: 		push	HL
01:0599 211020          	  1084: 		ld 		HL,$2010
01:059C CD0000          	  1085: 		call 	Flash_SE_Erase
01:059F E1              	  1086: 		pop 	HL
01:05A0 C9              	  1087: 		ret
                        	  1088: 
                        	  1089: p_xmod:
                        	  1090: 		; ***	Transfer files via x-modem
                        	  1091: 		; ***	Check commParseTable+1 if required parameters
                        	  1092: 
01:05A1 3A0100          	  1093: 		ld 		A,(commParseTable+1)
01:05A4 CB47            	  1094: 		bit 	0,A 			; should be a <2-textstring 	1-address	 0-lvalue>
01:05A6 2804            	  1095: 		jr 		Z,.nxta
                        	  1096: 		; ***	check the commLvl1 if zero
01:05A8 ED5B0000        	  1097: 		ld 		DE,(commLvl1)
                        	  1098: .nxta:		
                        	  1099: 
                        	  1100: 		ifndef 	BOOTLOAD				; don not use during BOOT
                        	  1101: 		call 	doImportXMODEM
                        	  1102: 
                        	  1103: 		call 	SIO_A_TXRX_INTon
                        	  1104: 		call 	CTC1_INT_OFF
                        	  1105: 		endif	
01:05AC C9              	  1106: 		ret
                        	  1107: 
                        	  1108: p_C_Read:
                        	  1109: 
01:05AD CD5F07          	  1110: 		call 	checkArgsTAL				; check necessary args
01:05B0 C2D704          	  1111: 		jp		NZ,argumentsError			; show argument error and return
                        	  1112: 	
01:05B3 110000          	  1113: 		ld 		DE,CTC_delay_INT_handler
01:05B6 ED5312F4        	  1114: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1115: 
                        	  1116: 	ifd 	GPIODEBUG
                        	  1117: 	xor A
                        	  1118: 	out (gpio_out),A
                        	  1119: 	endif
                        	  1120: 
01:05BA CD0000          	  1121: 		call  	SIO_A_DI					; disable text output
                        	  1122: 	ifd 	GPIODEBUG
                        	  1123: 	ld a,4
                        	  1124: 	out (gpio_out),A
                        	  1125: 	ld a,0
                        	  1126: 	out (gpio_out),A
                        	  1127: 	endif
                        	  1128: 	
01:05BD 7B              	  1129: 		ld a,e
01:05BE CD0000          	  1130: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
01:05C1 CD0000          	  1131: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
01:05C4 CD0000          	  1132: 		call 	HC376S_ResetAll
01:05C7 CD0000          	  1133: 		call 	HC376S_CheckConnection
01:05CA 3A0000          	  1134: 		ld 		A,(commParseTable)
01:05CD FE0F            	  1135: 		cp 		15							; 15 read SD; 17-read USB
01:05CF 280C            	  1136: 		jr 		Z,.doSD
01:05D1 FE15            	  1137: 		cp 		21							; 21 read SD enumerate, 22 read USB enumerate
01:05D3 2808            	  1138: 		jr 		Z,.doSD
01:05D5 CD0000          	  1139: 		call 	HC376S_setUSBMode
01:05D8 CD0000          	  1140: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:05DB 1803            	  1141: 		jr 		.cont
                        	  1142: .doSD:
01:05DD CD0000          	  1143: 		call 	HC376S_setSDMode
                        	  1144: 		
                        	  1145: .cont:
01:05E0 CD0000          	  1146: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:05E3 2011            	  1147: 		jr 		NZ,abort
                        	  1148: 
01:05E5 CD0000          	  1149: 		call 	HC376S_setFileName
01:05E8 CD0000          	  1150: 		call 	HC376S_fileOpen
01:05EB 2009            	  1151: 		jr 		NZ,abort
                        	  1152: 
01:05ED CD0000          	  1153: 		call 	HC376S_getFileSize
01:05F0 CD0000          	  1154: 		call 	HC376S_fileRead
01:05F3 CD0000          	  1155: 		call 	HC376S_fileClose
                        	  1156: abort:
                        	  1157: 
                        	  1158: 		; ***	reset the interrupt handler for CTC
01:05F6 CD0000          	  1159: 		call 	SIO_A_EI					; enable text output
01:05F9 CD0000          	  1160: 		call 	HC376S_ResetAll
01:05FC CD0000          	  1161: 		call 	CTC1_INT_OFF
01:05FF 210000          	  1162: 		ld		HL,CTC_CH1_Interrupt_Handler
01:0602 2212F4          	  1163: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
01:0605 C9              	  1164: 		ret
                        	  1165: 
                        	  1166: 		
                        	  1167: p_C_Write:
01:0606 CD5F07          	  1168: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
01:0609 2816            	  1169: 		jr 		Z,.contWR
                        	  1170: 		; ***	check alternative (2 adresses)
01:060B 3E2C            	  1171: 		ld 		A,%101100					; alt. with "string" $Adr1 < $Adr2
01:060D 77              	  1172: 		ld 		(HL),A						; HL-> (commParseTable+1);
01:060E 23              	  1173: 		inc 	HL			; HL-> (commParseTable+2); get the resulting arguments counted
01:060F BE              	  1174: 		cp 		(HL) 						; compare resulting arguments with req arguments
                        	  1175: 
01:0610 C2D704          	  1176: 		jp		NZ,argumentsError			; show argument error and return
                        	  1177: 		
                        	  1178: 		; ***	calculate size from addresses $Adr2 - $Adr1
01:0613 37              	  1179: 		scf
01:0614 3F              	  1180: 		ccf
01:0615 2A0000          	  1181: 		ld 		HL,(commAdr2)
01:0618 ED5B0000        	  1182: 		ld		DE,(commAdr1)
01:061C ED52            	  1183: 		sbc		HL,DE
01:061E 220000          	  1184: 		ld 		(commLvl1),HL				; resulting size in commLvl1
                        	  1185: 
                        	  1186: 
                        	  1187: .contWR:
01:0621 110000          	  1188: 		ld 		DE,CTC_delay_INT_handler
01:0624 ED5312F4        	  1189: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1190: 
01:0628 CD0000          	  1191: 		call 	purgeRXB
01:062B CD0000          	  1192: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
01:062E CD0000          	  1193: 		call 	HC376S_ResetAll
01:0631 CD0000          	  1194: 		call 	HC376S_CheckConnection
01:0634 3A0000          	  1195: 		ld 		A,(commParseTable)
01:0637 FE10            	  1196: 		cp 		16							; 16 read SD; 18-read USB
01:0639 2808            	  1197: 		jr 		Z,.doSD
01:063B CD0000          	  1198: 		call 	HC376S_setUSBMode
01:063E CD0000          	  1199: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:0641 1803            	  1200: 		jr 		.cont
                        	  1201: .doSD:
01:0643 CD0000          	  1202: 		call 	HC376S_setSDMode
                        	  1203: .cont:
01:0646 CD0000          	  1204: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:0649 20AB            	  1205: 		jr 		NZ,abort
01:064B CD0000          	  1206: 		call 	HC376S_setFileName
01:064E CD0000          	  1207: 		call 	HC376S_fileCreate
01:0651 20A3            	  1208: 		jr		NZ,abort
01:0653 CD0000          	  1209: 		call 	HC376S_fileWrite
                        	  1210: 		
01:0656 CD0000          	  1211: 		call 	HC376S_fileClose
01:0659 CD0000          	  1212: 		call 	HC376S_ResetAll
01:065C 1898            	  1213: 		jr 		abort
                        	  1214: 
                        	  1215: p_C_Delete:
01:065E CD5F07          	  1216: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1  )
01:0661 C2D704          	  1217: 		jP 		NZ,argumentsError
01:0664 110000          	  1218: 		ld 		DE,CTC_delay_INT_handler
01:0667 ED5312F4        	  1219: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1220: 
01:066B CD0000          	  1221: 		call 	purgeRXB
01:066E CD0000          	  1222: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
                        	  1223: 
01:0671 CD0000          	  1224: 		call 	HC376S_ResetAll
01:0674 CD0000          	  1225: 		call 	HC376S_CheckConnection
01:0677 3A0000          	  1226: 		ld 		A,(commParseTable)
01:067A FE13            	  1227: 		cp 		19							; 19 delete file SD; 20-delete file USB
01:067C 2808            	  1228: 		jr 		Z,.doSD
01:067E CD0000          	  1229: 		call 	HC376S_setUSBMode
01:0681 CD0000          	  1230: 		call 	HC376S_diskConnectionStatus
01:0684 1803            	  1231: 		jr 		.cont
                        	  1232: .doSD:
01:0686 CD0000          	  1233: 		call 	HC376S_setSDMode
                        	  1234: .cont:
01:0689 CD0000          	  1235: 		call 	HC376S_USBdiskMount
                        	  1236: 		 
                        	  1237: 		; call 	HC376S_fileOpen
                        	  1238: 		; call 	HC376S_getFileSize
                        	  1239: 		; call 	HC376S_fileRead
                        	  1240: 
01:068C CD0000          	  1241: 		call 	HC376S_fileDelete
01:068F CD0000          	  1242: 		call 	HC376S_ResetAll
                        	  1243: 
01:0692 C3F605          	  1244: 		jp 		abort
                        	  1245: 
                        	  1246: p_cptFl:
01:0695 CD0000          	  1247: 		call 	setFLASHBank				; change to bank
01:0698 C9              	  1248: 		ret
01:0699 CD0000          	  1249: 		call 	setSRAMBank 			; change to bank
01:069C C9              	  1250: 		ret
                        	  1251: ;********************************************************************************************
                        	  1252: ;********************************************************************************************	
                        	  1253: p_srbank:
                        	  1254: 	; ***	set sram bank #
01:069D CD2607          	  1255: 	call 	p_FOFF				; disable the flash memory
01:06A0 3A0000          	  1256: 	ld 		A,(commLvl1) 			; load param into A
                        	  1257: ; ***	set the SRAM bank ID; Bank ID in A
                        	  1258: p_srbank0:
                        	  1259: 
01:06A3 E5              	  1260: 	push 	HL
01:06A4 C5              	  1261: 	push 	BC
01:06A5 210000          	  1262: 	ld 		HL,memBankID
01:06A8 E60F            	  1263: 	and 	$0F 				; clear all bits but 0-3 in A
                        	  1264: 
01:06AA 47              	  1265: 	ld 		B,A
01:06AB 7E              	  1266: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:06AC E6F0            	  1267: 	and 	$F0  				; zero bits 0-3
01:06AE 1815            	  1268: 	jr 		putBank
                        	  1269: 
                        	  1270: ;********************************************************************************************
                        	  1271: ;********************************************************************************************	
                        	  1272: 
                        	  1273: p_flbank:
                        	  1274: 	; ***	set flash bank #
                        	  1275: 
01:06B0 CDCC06          	  1276: 	call 	p_FON				; enable  the  flash memory
01:06B3 3A0000          	  1277: 	ld 		A,(commLvl1) 			; load param into A
                        	  1278: ; ***	set the FLASH bank ID; Bank ID in A
                        	  1279: 
01:06B6 E5              	  1280: 	push 	HL
01:06B7 C5              	  1281: 	push 	BC
01:06B8 210000          	  1282: 	ld 		HL,memBankID
01:06BB E607            	  1283: 	and 	$07 				; clear all bits but 0-2
01:06BD 07              	  1284: 	rlca
01:06BE 07              	  1285: 	rlca
01:06BF 07              	  1286: 	rlca
01:06C0 07              	  1287: 	rlca						; bank ID = bits 4-6
                        	  1288: 
01:06C1 47              	  1289: 	ld 		B,A
01:06C2 7E              	  1290: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:06C3 E68F            	  1291: 	and 	$8F  				; zero bits 4-6
                        	  1292: putBank:
01:06C5 B0              	  1293: 	or 		B					; put new EEP bank ID in A...
01:06C6 77              	  1294: 	ld 		(HL),A				; store new value
01:06C7 D300            	  1295: 	out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
01:06C9 C1              	  1296: 	pop  	BC
01:06CA E1              	  1297: 	pop 	HL
01:06CB C9              	  1298: 	ret
                        	  1299: 
                        	  1300: ;********************************************************************************************
                        	  1301: ;********************************************************************************************	
                        	  1302: 
                        	  1303: p_FON:
                        	  1304: 		; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0)
                        	  1305: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	  1306: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1307: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:06CC CD0000          	  1308: 	call 	writeSTRBelow
01:06CF 00              	  1309: 	DB 		0," Use 256k FLASH (7 banks),lower 32k and SRAM (16 banks),upper 32k !",CR,LF,00
01:06D0 2055736520323536
01:06D8 6B20464C41534820
01:06E0 28372062616E6B73
01:06E8 292C6C6F77657220
01:06F0 33326B20616E6420
01:06F8 5352414D20283136
01:0700 2062616E6B73292C
01:0708 7570706572203332
01:0710 6B2021
01:0713 0D
01:0714 0A
01:0715 00
01:0716 CD0000          	  1310: 	call 	waitForFinishedPrintout
01:0719 E5              	  1311: 	push 	HL
01:071A 210000          	  1312: 	ld 		HL,rstBankID
01:071D CB9E            	  1313: 	res 	3,(HL)				; clear bit 3 -> enable FLASH
01:071F CB96            	  1314: 	res 	2,(HL)				; temp enable reset of IC622
                        	  1315: putBankF:
01:0721 7E              	  1316: 	ld 		A,(HL)
01:0722 D300            	  1317: 	out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
01:0724 E1              	  1318: 	pop 	HL
01:0725 C9              	  1319: 	ret 
                        	  1320: 	
                        	  1321: ;********************************************************************************************
                        	  1322: ;********************************************************************************************	
                        	  1323: p_FOFF:
                        	  1324: 	; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1)
                        	  1325: 	; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	  1326: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1327: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:0726 CD0000          	  1328: 	call 	writeSTRBelow
01:0729 20557365206F6E6C	  1329: 	DB 		" Use only SRAM (16 banks),upper 32k !",CR,LF,00
01:0731 79205352414D2028
01:0739 31362062616E6B73
01:0741 292C757070657220
01:0749 33326B2021
01:074E 0D
01:074F 0A
01:0750 00
01:0751 CD0000          	  1330: 	call 	waitForFinishedPrintout
                        	  1331: 
                        	  1332: p_FOFF_No_Print:
01:0754 E5              	  1333: 	push 	HL
01:0755 210000          	  1334: 	ld 		HL,rstBankID
01:0758 CBD6            	  1335: 	set 	2,(HL) 			; temp disable reset of IC622
01:075A CBDE            	  1336: 	set 	3,(HL)			; set bit 3 -> disable FLASH
01:075C 18C3            	  1337: 	jr 		putBankF
                        	  1338: 	; ld 		A,(HL)
                        	  1339: 	; out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
                        	  1340: 	; pop 	HL
                        	  1341: 	; call 	writeSTRBelow
                        	  1342: 	; DB 		0," Use only 512k (16 banks) SRAM !",CR,LF,00
01:075E C9              	  1343: 	ret 
                        	  1344: 
                        	  1345: ;********************************************************************************************     
                        	  1346: ;********************************************************************************************     
                        	  1347: 
                        	  1348: 		; ***	Check commParseTable+1 if required parameters
                        	  1349: checkArgsTAL:		
                        	  1350: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	  1351: 
                        	  1352: 		; ***	try to connect to USB
01:075F 210200          	  1353: 		ld 		HL,commParseTable+2				; resulting typed arguments
01:0762 3E00            	  1354: 		ld 		A,0
01:0764 77              	  1355: 		ld 		(HL),A
                        	  1356: 
01:0765 DD210000        	  1357: 		ld 		IX,commStr1			; commStr1 =			0xB0
01:0769 CD9307          	  1358: 		call 	shift_0_1:
01:076C DD210000        	  1359: 		ld 		IX,commStr2			; commStr2 =			0xD8
01:0770 CD9307          	  1360: 		call 	shift_0_1:
01:0773 DD210000        	  1361: 		ld 		IX,commAdr1			; commAdr1 =			0x84
01:0777 CD9307          	  1362: 		call 	shift_0_1:
01:077A DD210000        	  1363: 		ld 		IX,commAdr2			; commAdr2 =			0x88
01:077E CD9307          	  1364: 		call 	shift_0_1:
01:0781 DD210000        	  1365: 		ld 		IX,commLvl1			; commLvl1 =			0x90
01:0785 CD9307          	  1366: 		call 	shift_0_1:
01:0788 DD210000        	  1367: 		ld 		IX,commLvl2			; commLvl2 =			0xA0
01:078C CD9307          	  1368: 		call 	shift_0_1:
                        	  1369: 
01:078F 7E              	  1370: 		ld 		A,(HL)						; get the resulting arguments counted
01:0790 2B              	  1371: 		dec 	HL
01:0791 BE              	  1372: 		cp 		(HL) 						; compare resulting arguments with req arguments
01:0792 C9              	  1373: 		ret 	 					; return with Z or NZ  arguments
                        	  1374: 
                        	  1375: shift_0_1:
01:0793 DDBE00          	  1376: 		cp 		(IX)
01:0796 2008            	  1377: 		jr 		NZ,shiftIn1
01:0798 DDBE01          	  1378: 		cp 		(IX+1)
01:079B 2003            	  1379: 		jr 		NZ,shiftIn1
                        	  1380: 		; ***	both =0 shift in '0'
01:079D CB26            	  1381: 		sla		(HL)
01:079F C9              	  1382: 		ret
                        	  1383: shiftIn1:
                        	  1384: 		; ***	least one not '0' shift in '1'
01:07A0 37              	  1385: 		scf		
01:07A1 CB16            	  1386: 		rl 		(HL)
01:07A3 C9              	  1387: 		ret
                        	  1388: 
                        	  1389: 
                        	  1390: ;********************************************************************************************     
                        	  1391: ;********************************************************************************************     
                        	  1392: 
                        	  1393: bit_test9:
01:07A4 01              	  1394: 	db	0x01,0x02,0x80,0x40
01:07A5 02
01:07A6 80
01:07A7 40
                        	  1395: 
                        	  1396: 
                        	  1397: ; debug:		equ	0		; Set to 1 to show debug printing, else 0 
                        	  1398: 
                        	  1399: 
                        	  1400: 	; Spin loop here because there is nothing else to do
                        	  1401: ; halt_loop:
                        	  1402: ; 	halt
                        	  1403: ; 	jp	halt_loop
                        	  1404: 
                        	  1405: 
                        	  1406: 
                        	  1407: 
                        	  1408: 
                        	  1409: ;*******************************************************************************     
                        	  1410: ;*******************************************************************************     
                        	  1411: 
                        	  1412: 
                        	  1413: 
                        	  1414: 		; ld 		hl,Textbuf
                        	  1415: 		; ; call	ReadLine 			;to textbuf  (A=length of input string)
                        	  1416: 
                        	  1417: 		; ld		HL,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	  1418: 		; ld		DE,Textbuf			;DE = 32767
                        	  1419: 		; call	BN2DEC				; C0NVERT
                        	  1420: 		; jp		textloop
                        	  1421: 
                        	  1422: 
                        	  1423: 		; ld 		hl,Textbuf
                        	  1424: 		; call	DEC2BN			; result in HL
                        	  1425: 
                        	  1426: 		; ld 		E,L
                        	  1427: 		; 	; Binary to HEX  BN2HEX   E->(HL)
                        	  1428: 		; ld 		hl,T_BUFFER
                        	  1429: 		; inc		hl
                        	  1430: 		; call	Bin2Hex8			;result in T_buffer
                        	  1431: 
                        	  1432: 		; ld 		iy,T_BUFFER
                        	  1433: 		; call 	WriteLineCRNL
                        	  1434: 
                        	  1435: 		; ld 		iy,Textbuf
                        	  1436: 		; call	WriteLineCRNL
                        	  1437: 
                        	  1438: 		; jp 		next_line
                        	  1439: 
                        	  1440: 
                        	  1441: 
                        	  1442: textloop:
                        	  1443: 		; LD		HL,sourctext1
                        	  1444: 		; LD		DE,S1x
                        	  1445: 		; LD		BC,src_size
                        	  1446: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1447: 
                        	  1448: 
                        	  1449: 		; LD		HL,sourctext2
                        	  1450: 		; LD		DE,S2x
                        	  1451: 		; LD		BC,14
                        	  1452: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1453: 
                        	  1454: 		; test of string concat
                        	  1455: 		; LD		HL,S1_8B		;HL = BASE ADDRESS OF S1
                        	  1456: 		; LD		DE,S2_8B		;DE = BASE ADDRESS OF S2
                        	  1457: 		; LD		B,40			;B = MAXIMUM LENGTH OF STRING 1
                        	  1458: 		; CALL 	CONCAT 			;CONCATENATE STRINGS to S1_8B
                        	  1459: 
                        	  1460: 
                        	  1461: 		; test of POS
                        	  1462: 		; LD		HL,Str2			;HL = BASE ADDRESS OF STRING
                        	  1463: 		; LD		DE,subst		;DE = BASE ADDRESS OF SUBSTRING	
                        	  1464: 		; CALL	POS				;FIND POSITION OF SUBSTRING
                        	  1465: 								; RESULTS IN REGISTER A = 8
                        	  1466: 
                        	  1467: 
                        	  1468: 		; test copy
                        	  1469: 		; LD		HL,Str4			; SOURCE STRING
                        	  1470: 		; LD		DE,COPY_BUFFER	;	DESTINATION STRING
                        	  1471: 		
                        	  1472: 		; LD		C,4				; STARTING INDEX FOR COPYING
                        	  1473: 
                        	  1474: 		; LD		B,6				; NUMBER OF BYTES TO COPY
                        	  1475: 		; LD		A, 25			; MAXIMUM LENGTH OF SUBSTRING
                        	  1476: 		; CALL 	COPY			; COPY SUBSTRING
                        	  1477: 
                        	  1478: 		; ld 		iy,COPY_BUFFER
                        	  1479: 		; call 		WriteLineCRNL ; print the copy string
                        	  1480: 
                        	  1481: 
                        	  1482: 		; ; test DELETE
                        	  1483: 		; LD		HL,Str0		;HL	= BASE 	ADDRESS OF STRING
                        	  1484: 		; LD		A,8			
                        	  1485: 		; LD		C,8				;	C= STARTING INDEX FOR DELETION
                        	  1486: 		; LD		A,4			
                        	  1487: 		; LD		B,4			; B = NUMBER OF CHARACTERS TO DELETE
                        	  1488: 		; CALL 	DELETE 			; DELETE CHARACTERS
                        	  1489: 									; DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	  1490: 		; ld 		iy,Str0
                        	  1491: 		; call 		WriteLineCRNL ; print the copy string
                        	  1492: 
                        	  1493: 
                        	  1494: ; 		;test INSERT
                        	  1495: 
                        	  1496: ; 		LD		HL,Str3				; HL = BASE ADDRESS OF STRING
                        	  1497: ; 		LD		DE,subst			; DE = BASE ADDRESS OF SUBSTRING
                        	  1498: 
                        	  1499: ; 		LD		C,7					; C = STARTING INDEX FOR INSERTION
                        	  1500: 
                        	  1501: ; 		LD		B,0x40				; B = MAXIMUM LENGTH OF STRING
                        	  1502: ; 		CALL 	INSERT_STR			; INSERT SUBSTRING
                        	  1503: ; 		ld 		iy,Str3
                        	  1504: ; 		; call	WriteLineCRNL 		; print the modified string
                        	  1505: 
                        	  1506: 
                        	  1507: ; 		jp		next_line
                        	  1508: 
                        	  1509: ; 		;TEST DATA. CHANGE FOR OTHER VALUES
                        	  1510: ; S1_8B:	DB		8H				; LENGTH OF SI
                        	  1511: ; 		DB      "LASTNAME                        "	; 32 BYTE MAX LENGTH
                        	  1512: ; S2_8B:	DB		0BH				;LENGTH OF S2
                        	  1513: ; 		DB		". FIRSTNAME                     "	; 32 BYTE MAX LENGTH
                        	  1514: 
                        	  1515: ;********************************************************************************************
                        	  1516: ;********************************************************************************************	
                        	  1517: ; sh_test:
                        	  1518: ; 		; turn shadow off then halt
                        	  1519: ; 		xor A
                        	  1520: ; 		out (_CE_RST_BANK),A 		;// clear '64K_SRAM' signal
                        	  1521: 
                        	  1522: ; 		halt
                        	  1523: 
                        	  1524: ; 		ld	A,$80
                        	  1525: ; 		out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	  1526: ; 		ld 	A,1
                        	  1527: ; 		out (_CE_RST_BANK),A 		; engage 3-state on bank#
                        	  1528: ; 		ret
                        	  1529: 
                        	  1530: 
                        	  1531: ;********************************************************************************************
                        	  1532: ;********************************************************************************************	
                        	  1533: 			;9H JUMP TABLE (JTAB)   353
                        	  1534:         ; Title               Jump table
                        	  1535:         ; Name:               JTAB
                        	  1536:         ; Purpose:            Given an index, jump to the subroutine with
                        	  1537:         ;                     that index in a table.
                        	  1538:         ; Entry:              Register A is the subroutine number (0 to
                        	  1539:         ;                                LENSUB-l, the number of subroutines)
                        	  1540:         ;                                LENSUB must be less than or equal to
                        	  1541:         ;                                128.
                        	  1542:         ; Exit:               If the routine number is valid then
                        	  1543:         ;                       execute the routine
                        	  1544:         ;                     else
                        	  1545:         ;                       Carry flag = 1
                        	  1546:         ; Registers used: AF
                        	  1547:         ; Time:               117 cycles plus execution time of subroutine
                        	  1548:         ; Size:               Program 21 bytes plus size of table (2*LENSUB)
                        	  1549: 
                        	  1550:         ;EXIT WITH CARRY SET IF ROUTINE NUMBER IS INVALID
                        	  1551:         ; THAT IS, IF IT IS TOO LARGE FOR TABLE OLENSUB -     1)
                        	  1552: 
                        	  1553: 
                        	  1554: ; JTAB:
                        	  1555: ; 		CP		LENSUB			;COMPARE ROUTINE NUMBER, TABLE SIZE
                        	  1556: ; 		CCF						;COMPLEMENT CARRY FOR ERROR INDICATOR
                        	  1557: ; 		RET		C				;RETURN IF ROUTINE NUMBER TOO LARGE
                        	  1558: ; 									; WITH CARRY SET
                        	  1559: ; 		; INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
                        	  1560: ; 		; LEAVE REGISTER PAIRS UNCHANGED SO THEY CAN BE USED FOR PASSING PARAMETERS
                        	  1561: 
                        	  1562: ; 		PUSH	HL				;SAVE HL
                        	  1563: ; 		ADD		A,A				;DOUBLE INDEX FOR WORD-LENGTH ENTRIES
                        	  1564: ; 		LD		HL,JMPTAB		;INDEX INTO TABLE USING 8-BIT
                        	  1565: ; 		ADD		A,L			; ADDITION TO AVOID DISTURBING
                        	  1566: ; 		LD		L,A				; ANOTHER REGISTER PAIR
                        	  1567: ; 		LD		A,0
                        	  1568: ; 		ADC		A,H
                        	  1569: ; 		LD		H,A			; ACCESS ROUTINE ADDRESS
                        	  1570: ; 			;OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
                        	  1571: ; 			;CONTROL TO IT, LEAVING ALL REGISTER PAIRS UNCHANGED
                        	  1572: 
                        	  1573: ; 		LD		A, (HL)			;MOVE ROUTINE ADDRESS TO HL
                        	  1574: ; 		INC		HL
                        	  1575: ; 		LD		H, (HL)
                        	  1576: ; 		LD		L,A
                        	  1577: ; 		EX		(SP),HL				;RESTORE OLD HL, PUSH ROUTINE ADDRESS
                        	  1578: ; 		RET						; JUMP TO ROUTI NE
                        	  1579: 
                        	  1580: ; LENSUB		EQU		3				;NUMBER OF SUBROUTINES IN TABLE
                        	  1581: ; JMPTAB:                            ;JUMP TABLE
                        	  1582: ; 		DW		SUB0			;ROUTINE 0
                        	  1583: ; 		DW		SUB1			;ROUTINE 1
                        	  1584: ; 		DW		SUB2			;ROUTINE 2
                        	  1585: ;            ;THREE TEST SUBROUTINES FOR JUMP TABLE
                        	  1586: ; SUB0:
                        	  1587: ; 		LD		A,1				; TEST ROUTI NE 0 SETS (A)    1
                        	  1588: ; 		RET
                        	  1589: ; SUB1:
                        	  1590: ; 		LD		A,2				; TEST ROUTI NE 1 SETS (A) = 2
                        	  1591: ; 		RET
                        	  1592: ; SUB2:
                        	  1593: ; 		LD		A,3				;TEST ROUTINE 2 SETS (A)      3
                        	  1594: ; 		RET
                        	  1595: 
                        	  1596: 
                        	  1597: 
                        	  1598: ; 			;SAMPLE EXECUTION:
                        	  1599: 
                        	  1600: 
                        	  1601: ; SC9H:
                        	  1602: ; 		SUB		A				;EXECUTE ROUTINE 0
                        	  1603: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   =1
                        	  1604: 
                        	  1605: ; 		LD		A,1				;EXECUTE ROUTINE 1
                        	  1606: ; 		CALL	JTAB			; AFTER EXECUTION, (A) = 2
                        	  1607: ; 		LD		A,2				;EXECUTE ROUTINE 2
                        	  1608: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   3
                        	  1609: ; 		LD		A,3				;EXECUTE ROUTINE 3
                        	  1610: ; 		CALL	JTAB			; AFTER EXECUTION, CARRY   1
                        	  1611: ; 		JR		SC9H			;LOOP FOR MORE TESTS
                        	  1612: 
                        	  1613: 
                        	  1614: ;********************************************************************************************
                        	  1615: ;********************************************************************************************	
                        	  1616: ; 		xref  	RDATA,RDATA_END,TB_length
                        	  1617: 
                        	  1618: ; 		;--------------------------------------------------
                        	  1619: ; 		; ld A,5
                        	  1620: ; 		; ld 	A,$00	
                        	  1621: ; 		; out (_Z80_BankCS),A		;// set bank register number 	
                        	  1622: ; 		ld 	A,$01
                        	  1623: ; 		out (_CE_RST_BANK),A 		;// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	  1624: 
                        	  1625: ; 		out (_8Bitsout),A
                        	  1626: 
                        	  1627: ; 		ld A, $0F                 ;mode 1 out
                        	  1628: ; 		out (portA_Contr), A         ; set port A as output
                        	  1629: ; 		ld A,$EB
                        	  1630: 
                        	  1631: ; Rtll:	
                        	  1632: 
                        	  1633: ; 		ld (40000),A
                        	  1634: ; 		ld A,0
                        	  1635: ; 		ld A,(40000)
                        	  1636: 
                        	  1637: ; 		out (portA_Data),A		; Data to PIO port A
                        	  1638: ; 		out (_8Bitsout),A
                        	  1639: ; 		;--------------------------------------------------
                        	  1640: ; 		ld	DE,$8200
                        	  1641: ; 		ld	HL,RDATA
                        	  1642: ; 		ld	BC,TB_length
                        	  1643: ; 		; ld	BC,RDATA_END-RDATA
                        	  1644: ; 		ldir
                        	  1645: 
                        	  1646: 
                        	  1647: ; SIO_A_RESET:
                        	  1648: ; 		ld	a,00110000b
                        	  1649: ; 		out	(SIO_A_C),A		;write into WR0: error reset, select WR0
                        	  1650: 
                        	  1651: ; 		ld	a,018h				;write into WR0: channel reset
                        	  1652: ; 		out (SIO_A_C),A 
                        	  1653: 
                        	  1654: ; 		ld	a,004h				;write into WR0: select WR4
                        	  1655: ; 		out	(SIO_A_C),A
                        	  1656: ; 		ld	a,44h				;44h write into WR4: clkx16,1 stop bit, no parity
                        	  1657: ; 		out (SIO_A_C),A
                        	  1658: 
                        	  1659: ; 		ld	a,005h				;write into WR0: select WR5
                        	  1660: ; 		out (SIO_A_C),A
                        	  1661: ; 		ld	a,01101000b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS inactive (bit 2)
                        	  1662: ; 		ld	a,01101010b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS active (bit 2)
                        	  1663: ; 		out (SIO_A_C),A
                        	  1664: ; SIO_A_EI:
                        	  1665: ; 			;enable SIO channel A RX
                        	  1666: ; 		ld	a,003h				;write into WR0: select WR3
                        	  1667: ; 		out (SIO_A_C),A
                        	  1668: ; 		ld	a,11000001b				;RX 8bit, auto enable off 8(bit 5), RX on (bit 0)
                        	  1669: ; 		ld	a,11100001b				;RX 8bit, auto enable on 8(bit 5), RX on (bit 0)
                        	  1670: ; 		out (SIO_A_C),A
                        	  1671: ; 		;Channel A RX active
                        	  1672: 
                        	  1673: 
                        	  1674: ; 		ld 	HL,Str0
                        	  1675: ; tstout:
                        	  1676: ; 		ld 	A,(HL)
                        	  1677: ; 		out (SIO_A_D),A
                        	  1678: ; 		inc HL
                        	  1679: ; 		ld D,A
                        	  1680: ; chkTX:
                        	  1681: ; 		in	A,(SIO_A_C)		; read status
                        	  1682: ; 		bit	2,A					; all sent ?
                        	  1683: ; 		jr z,chkTX				; not all sent..
                        	  1684: 
                        	  1685: ; 		ld 	A,(HL)
                        	  1686: ; 		cp	0
                        	  1687: ; 		jr 	z,endmsg
                        	  1688: 
                        	  1689: ; 		ld	A,D
                        	  1690: ; 		djnz	tstout
                        	  1691: 
                        	  1692: ; endmsg:
                        	  1693: ; chkRX:
                        	  1694: ; 		in	A,(SIO_A_C)		; read status
                        	  1695: ; 		bit	0,A					; char present ??
                        	  1696: ; 		jr z,chkRX				; check again
                        	  1697: 
                        	  1698: ; 		in 	A,(SIO_A_D)		; read the char.
                        	  1699: 
                        	  1700: ; 		out (SIO_A_D),A
                        	  1701: ; chkTX2:
                        	  1702: ; 		in	A,(SIO_A_C)		; read status
                        	  1703: ; 		bit	2,A					; all sent ?
                        	  1704: ; 		jr z,chkTX2
                        	  1705: 		
                        	  1706: ; 		jr	endmsg				; not all sent..
                        	  1707: 
                        	  1708: 
                        	  1709: 
                        	  1710: 
                        	  1711: ; 		halt
                        	  1712: ; 		halt
                        	  1713: ; 		halt
                        	  1714: ; 		inc A
                        	  1715: ; 		jr Rtll			
                        	  1716: 
                        	  1717: ; 	if DOALIGN
                        	  1718: ; 		align 4
                        	  1719: ; 	endif
                        	  1720: 
                        	  1721: 
                        	  1722: .end
                        	  1723: 


Symbols by name:
AddToT_Buf                      external
BLKMOV                          external EXP
BN2DEC                          external EXP
BN2DEC_S                        external EXP
Bin2Hex16                       external EXP
Bin2Hex8                        external EXP
CDEL                             E:00EE
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CONCAT                          external EXP
COPY                            external EXP
CR                               E:000D
CRC16                           external EXP
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       external
CTC_Init                        external
CTC_delay_INT_handler           external
DEC2BN                          external EXP
DELETE                          external EXP
DumpRegisters                   external
Flash_SE_Erase                  external
Flash_WR_Test                   external
HC376S_CheckConnection          external
HC376S_ResetAll                 external
HC376S_USBdiskMount             external
HC376S_diskConnectionStatus     external
HC376S_fileClose                external
HC376S_fileCreate               external
HC376S_fileDelete               external
HC376S_fileOpen                 external
HC376S_fileRead                 external
HC376S_fileWrite                external
HC376S_getFileSize              external
HC376S_setFileName              external
HC376S_setSDMode                external
HC376S_setUSBMode               external
HEX2BN                          external EXP
INSERT_STR                      external EXP
ITEM                             E:001C
InitBuffers                     external EXP
InitInterrupt                   external EXP
JPTable01                       01:04BD
LF                               E:000A
LISTEND                          E:001E
MFILL                           external EXP
MONITOR_Start                   01:0000 EXP
MONITOR_Start0                  00:0148
PCinpFlag                       external
PCvalue                         external
PIO_Init                        external
POS                             external EXP
ReadChar                        external EXP
ReadLine                        external EXP
RegFlags                        external EXP
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
S1x                             external
SD_USB_startup                  00:0003 EXP
SDabort                         00:013B
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        external
SIO_A_EI                        external
SIO_A_RTS_OFF                   external EXP
SIO_A_RTS_ON                    external EXP
SIO_B_C                         external
SIO_B_D                         external
SIO_Init                        external
SIO_Int_Vec                      E:F400
SP_value                        external
STEND                            E:001D
S_head_tail                     external EXP
T_BUFFER                        external
TempVar1                        external
Textbuf                         external EXP
WriteChar                       external EXP
WriteLine                       external
WriteLineCRNL                   external
_CE_RST_BANK                    external
_RAMSTART                       external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
abort                           01:05F6
argumentsError                  01:04D7
bit_test9                       01:07A4
byteEnd                         01:046C
changePCVal                     01:048D
checkArgsTAL                    01:075F
checkaddress                    01:03EF
chkADR                          01:03FA
chkADR1                         01:03FB
chkADR2                         01:040B
chkLVL2                         01:042D
cleanInBuffer                   external EXP
cleanOutBuffer                  external EXP
commAdr1                        external
commAdr2                        external
commListLen                      E:001B
commLvl1                        external
commLvl2                        external
commParseTable                  external
commStr1                        external
commStr2                        external
command_list                    01:01E1
crc16_2                         external EXP
dumpMemory                      external EXP
enableFLASH                     external
enableIC620_OE                  external
endtext                         external EXP
errNoFlash                      01:056E
executeCommand                  01:04A9
findCommandInList               01:017E
findNextITEM                    01:018A
getLvalue                       01:041D
gpioB                           external
gpio_in                         external
gpio_out                        external
inBuffer                        external EXP
inBufferEnd                     external EXP
initCommParseTable              01:0391
initSIOBInterrupt               external
inputerror                      01:01AE
isHex                           external EXP
makeASCIItoHEX                  01:043D
matchInList                     01:03A4
memBankID                       external
nextHalfByte                    01:044B
nextInList                      01:01AA
next_line                       01:0101
noHighNib                       01:0489
p_C_Delete                      01:065E
p_C_Read                        01:05AD
p_C_Read_SD                     00:010B
p_C_Write                       01:0606
p_FOFF                          01:0726
p_FOFF_No_Print                 01:0754
p_FON                           01:06CC
p_clearmem                      01:0519
p_cptFl                         01:0695
p_dumpmem                       01:050D
p_eep                           01:0512
p_exe                           01:052C
p_flbank                        01:06B0
p_flse                          01:0598
p_flwr                          01:0563
p_go                            01:052D
p_incDecPC                      01:053E
p_load                          01:050C
p_pc                            01:0511
p_reset                         01:04F8
p_srbank                        01:069D
p_srbank0                       01:06A3
p_xmod                          01:05A1
paramLoopEntry                  01:03BB
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external
putBank                         01:06C5
putBankF                        01:0721
putDEtoScreen                   external
rfile_name                      00:00FB
rstBankID                       external
scanCommandList                 01:0179
setFLASHBank                    external
setSRAMBank                     external
shiftIn1                        01:07A0
shift_0_1                       01:0793
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             external
skipPriorDelimit                external
sourctext1                      external EXP
sourctext2                      external EXP
src_size                        external EXP
st1g2                           external EXP
st2g1                           external EXP
steq                            external EXP
strCompare                      external EXP
subst                           external EXP
temp_finish                     01:04BA
textloop                        01:07A8
useFlash                        01:0112
waitForFinishedPrintout         external
writeSTRBelow                   external EXP
zero_byte                       01:0189

Symbols by value:
0000 MONITOR_Start
0003 SD_USB_startup
000A LF
000D CR
001B commListLen
001C ITEM
001D STEND
001E LISTEND
00EE CDEL
00FB rfile_name
0101 next_line
010B p_C_Read_SD
0112 useFlash
013B SDabort
0148 MONITOR_Start0
0179 scanCommandList
017E findCommandInList
0189 zero_byte
018A findNextITEM
01AA nextInList
01AE inputerror
01E1 command_list
0391 initCommParseTable
03A4 matchInList
03BB paramLoopEntry
03EF checkaddress
03FA chkADR
03FB chkADR1
040B chkADR2
041D getLvalue
042D chkLVL2
043D makeASCIItoHEX
044B nextHalfByte
046C byteEnd
0489 noHighNib
048D changePCVal
04A9 executeCommand
04BA temp_finish
04BD JPTable01
04D7 argumentsError
04F8 p_reset
050C p_load
050D p_dumpmem
0511 p_pc
0512 p_eep
0519 p_clearmem
052C p_exe
052D p_go
053E p_incDecPC
0563 p_flwr
056E errNoFlash
0598 p_flse
05A1 p_xmod
05AD p_C_Read
05F6 abort
0606 p_C_Write
065E p_C_Delete
0695 p_cptFl
069D p_srbank
06A3 p_srbank0
06B0 p_flbank
06C5 putBank
06CC p_FON
0721 putBankF
0726 p_FOFF
0754 p_FOFF_No_Print
075F checkArgsTAL
0793 shift_0_1
07A0 shiftIn1
07A4 bit_test9
07A8 textloop
F400 SIO_Int_Vec
F412 CTC_CH1_I_Vector
