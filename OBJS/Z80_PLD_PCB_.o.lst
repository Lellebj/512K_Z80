Sections:
00: "SD_USB_Start" (0-21B)
01: "Monitor" (0-7C6)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     4: 		include 	"Salea_Logic.inc"

Source: "Salea_Logic.inc"
                        	     1: 
                        	     2: ;       *** 
                        	     3: 
                        	     4:     macro make_pulse 
                        	     5: 
                        	     6:     xor     A
                        	     7:     set     \1,A    
                        	     8:     out (gpio_out),A
                        	     9:     out (gpio_out),A
                        	    10:     out (gpio_out),A
                        	    11:     out (gpio_out),A
                        	    12:     xor     A
                        	    13:     out (gpio_out),A
                        	    14:     
                        	    15: 
                        	    16:     endm

Source: "stdin"
                        	     5: 	
                        	     6: 
                        	     7: 
                        	     8: 
                        	     9: 
                        	    10: 			xref	Bin2Hex8,Bin2Hex16,  HEX2BN, BN2DEC,BN2DEC_S,DEC2BN,MFILL, BLKMOV,strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR
                        	    11: 			xref	InitBuffers, ReadLine, WriteChar, ReadChar, S_head_tail
                        	    12: 			xref	Textbuf, inBufferEnd,inBuffer,cleanInBuffer,cleanOutBuffer,InitInterrupt
                        	    13: 			xref	dumpMemory
                        	    14: 
                        	    15: 			xref	st2g1,st1g2,steq,subst
                        	    16: 			xref	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	    17: 			xref	sourctext1,sourctext2,endtext,src_size, writeSTRBelow,isHex
                        	    18: 
                        	    19: 			xref 	crc16_2,CRC16
                        	    20: 		
                        	    21: 		xref 	SIO_A_RTS_OFF,SIO_A_RTS_ON
                        	    22: 
                        	    23: 	;***************************************************************
                        	    24: 	;SAMPLE EXECUTION:
                        	    25: 	;***************************************************************
                        	    26: GPIODEBUG EQU 0
                        	    27: 
                        	    28: DO_Debug:	equ	0		; Set to 1 to show debug printing, else 0 
                        	    29: 
                        	    30: 	GLOBAL  MONITOR_Start, SD_USB_startup
                        	    31: ;************************************************************************************************
                        	    32: ;************************************************************************************************
                        	    33: ;***		SDcard/USB startup sequence
                        	    34: ;************************************************************************************************
                        	    35: ;************************************************************************************************
                        	    36: 		section SD_USB_Start
                        	    37: 
                        	    38: 
00:0000 C30000          	    39: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	    40: 
                        	    41: SD_USB_startup:
                        	    42: 
                        	    43: 	if  	GPIODEBUG = 1
                        	    44: 		ld 		A,$33
                        	    45: 		out 	(gpio_out),A
                        	    46: 
                        	    47: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	    48: 
                        	    49: 		ld 		(SP_value),SP
                        	    50: 
                        	    51: 		ld 		A,$AA
                        	    52: 		out 	(gpio_out),A
                        	    53: 		
                        	    54: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    55: 				; initialize buffer counters and pointers.
                        	    56: 		ld 		A,$BB
                        	    57: 		out 	(gpio_out),A
                        	    58: 
                        	    59: 			call	PIO_Init
                        	    60: 		ld 		A,$CC
                        	    61: 		out 	(gpio_out),A
                        	    62: 			call 	CTC_Init
                        	    63: 		ld 		A,$DD
                        	    64: 		out 	(gpio_out),A
                        	    65: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	    66: 		ld 		A,$DF
                        	    67: 		out 	(gpio_out),A
                        	    68: 			call	S_head_tail			; save input heads and tails
                        	    69: 		ld 		A,$81
                        	    70: 		out 	(gpio_out),A
                        	    71: 	
                        	    72: 	else
                        	    73: 	
00:0003 CD0000          	    74: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    75: 			; initialize buffer counters and pointers.
00:0006 CD0000          	    76: 		call	PIO_Init
00:0009 CD0000          	    77: 		call 	CTC_Init
00:000C CD0000          	    78: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
00:000F CD0000          	    79: 		call	S_head_tail			; save input heads and tails
                        	    80: 	endif
                        	    81: 
                        	    82: 
                        	    83: 		; call	sh_test
                        	    84: 		; call 	Flash_WR_Test
                        	    85: 		; ld	HL,$2010
                        	    86: 		; call	Flash_SE_Erase
                        	    87: 
                        	    88: 		; check  $D008-$D00B for $33333333 -> Startup code is preloaded from Arduino 
                        	    89: 		; check  $D008-$D00B for $CCCCCCCC -> start from Flash 
                        	    90: 
00:0012 210000          	    91: 		ld 		HL,BootCodeAdr
00:0015 0604            	    92: 		ld 		B,04
00:0017 3E33            	    93: 		ld 		A,'3'
                        	    94: .checkBootCode:
00:0019 BE              	    95: 		cp 		(HL)	
00:001A 23              	    96: 		inc 	HL
00:001B C2DE00          	    97: 		jp 		NZ,.SDstart
00:001E 10F9            	    98: 		djnz 	.checkBootCode
                        	    99: 
                        	   100: 
00:0020 CD0000          	   101: 		call	CRLF
00:0023 CD0000          	   102: 		call 	writeSTRBelow
00:0026 0D0A            	   103: 		defb   	"\r\n"
00:0028 2B2D3D2D2B2D3D2D	   104: 		defb	"+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-\r\n"
00:0030 2B2D3D2D2B2D3D2D
00:0038 2B2D3D2D2B2D3D2D
00:0040 2B2D3D2D2B2D3D2D
00:0048 2B2D3D2D2B2D3D2D
00:0050 0D0A
00:0052 5374617274206672	   105: 		defb	"Start from Arduino preloaded monitor\r\n"
00:005A 6F6D204172647569
00:0062 6E6F207072656C6F
00:006A 61646564206D6F6E
00:0072 69746F720D0A
00:0078 202020206769743A	   106: 		defb	"    git: UPdate_Jan_25-9-gad024c0-dirty\r\n"
00:0080 205550646174655F
00:0088 4A616E5F32352D39
00:0090 2D67616430323463
00:0098 302D64697274790D
00:00A0 0A
00:00A1 202020206275696C	   107: 		defb	"    build: 2026-02-27_21:13\r\n"
00:00A9 643A20323032362D
00:00B1 30322D32375F3231
00:00B9 3A31330D0A
00:00BE 20202020464C4153	   108: 		defb	"    FLASH->SRAM 0xD000.\r\n"
00:00C6 482D3E5352414D20
00:00CE 3078443030302E0D
00:00D6 0A
00:00D7 00              	   109: 		defb	"\0"
                        	   110: 
00:00D8 CD0000          	   111: 		call 	waitForFinishedPrintout
00:00DB C30000          	   112: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   113: 		
                        	   114: 
                        	   115: .SDstart:
                        	   116: 		
00:00DE CD0000          	   117: 		call	CRLF
00:00E1 CD0000          	   118: 		call 	writeSTRBelow
00:00E4 0D0A            	   119: 		defb   	"\r\n"
00:00E6 3D2D3D2D3D2D3D2D	   120: 		defb	"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\r\n"
00:00EE 3D2D3D2D3D2D3D2D
00:00F6 3D2D3D2D3D2D3D2D
00:00FE 3D2D3D2D3D2D3D2D
00:0106 3D2D3D2D3D2D3D2D
00:010E 0D0A
00:0110 5374617274206672	   121: 		defb	"Start from SD/USB\r\n"
00:0118 6F6D2053442F5553
00:0120 420D0A
                        	   122: 		; defb	"    git: UPdate_Jan_25-9-gad024c0-dirty\r\n"
                        	   123: 		; defb	"    build: 2026-02-27_21:13\r\n"
                        	   124: 		; defb	"    FLASH->SRAM 0xD000.\r\n"
00:0123 00              	   125: 		defb	"\0"
                        	   126: 
00:0124 CD0000          	   127: 		call 	waitForFinishedPrintout
                        	   128: 
                        	   129: 	if 	GPIODEBUG =1
                        	   130: 	ld 		A,$83
                        	   131: 	out 	(gpio_out),A
                        	   132: 	endif
00:0127 CD0000          	   133: 		call	CRLF
                        	   134: 
                        	   135: ;*****	Setup Boot load from SD card.
                        	   136: ;***************************************
00:012A 110000          	   137: 		ld 		DE,commStr1					; save filename in commStr1
00:012D 21CE01          	   138: 		ld 		HL,rfile_name
                        	   139: .nxtchr:
00:0130 EDA0            	   140: 		ldi									; (DE) <- (HL) 
00:0132 7E              	   141: 		ld 		A,(HL)
00:0133 B7              	   142: 		or 		A 							; = 0 ?
00:0134 20FA            	   143: 		jr  	NZ,.nxtchr
00:0136 12              	   144: 		ld 		(DE),A						; save '0'
00:0137 210000          	   145: 		ld 		HL,S1x						; result in S1x
00:013A 220000          	   146: 		ld 		(commAdr1),HL
                        	   147: 
00:013D CDDE01          	   148: 		call 	p_C_Read_SD
                        	   149: 
                        	   150: 
                        	   151: ;***	correct $0A to $00 $00 in S1x (check for ascii lower than $20)
00:0140 210000          	   152: 		ld 		HL,S1x
00:0143 3E20            	   153: 		ld 		A,$20
00:0145 110000          	   154: 		ld 		DE,commStr1
                        	   155: 
                        	   156: .find0A:
00:0148 EDA0            	   157: 		ldi						; (DE) <- (HL) 
00:014A BE              	   158: 		cp 		(HL)			; char lower than ' '  $20 - (HL)
00:014B FA4801          	   159: 		jp 		M,.find0A		; char > ' '...
                        	   160: 
00:014E 3E00            	   161: 		ld 		A,00
00:0150 12              	   162: 		ld 		(de),A
00:0151 13              	   163: 		inc 	de
00:0152 12              	   164: 		ld 		(de),A			; strip eventually $0A, $0D, ...
00:0153 13              	   165: 		inc 	de
00:0154 12              	   166: 		ld 		(de),A			; Boot file name present in commStr1
00:0155 210000          	   167: 		ld 		HL,_RAMSTART
00:0158 220000          	   168: 		ld 		(commAdr1),HL 	; place adress for boot file...
00:015B CDDE01          	   169: 		call 	p_C_Read_SD		; read and place boot file.
                        	   170: 
                        	   171: 
00:015E CD0000          	   172: 		call 	writeSTRBelow
00:0161 0D0A555345205241	   173: 		defb   "\r\nUSE RAM bank #0, Copy FLASH Boot seq\r\n"
00:0169 4D2062616E6B2023
00:0171 302C20436F707920
00:0179 464C41534820426F
00:0181 6F74207365710D0A
00:0189 546F2052414D2062	   174: 		defb   "To RAM bank #1 ($0-$2000) \r\n"
00:0191 616E6B2023312028
00:0199 24302D2432303030
00:01A1 29200D0A
00:01A5 4A756D7020746F20	   175: 		defb	"Jump to MONITOR_Start! ($D000)\r\n",0,0,0
00:01AD 4D4F4E49544F525F
00:01B5 5374617274212028
00:01BD 2444303030290D0A
00:01C5 00
00:01C6 00
00:01C7 00
00:01C8 CD0000          	   176: 		call 	waitForFinishedPrintout
                        	   177: 
00:01CB C30000          	   178: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   179: 
                        	   180: rfile_name:
00:01CE 424F4F5446494C45	   181: 	 db "BOOTFILE.TXT",0,0,0,0
00:01D6 2E545854
00:01DA 00
00:01DB 00
00:01DC 00
00:01DD 00
                        	   182: 	; db "PROVIDE.txt",0,0,0,0
                        	   183: 
                        	   184: 	
                        	   185: ;************************************************************************************************
                        	   186: ;************************************************************************************************
                        	   187: p_C_Read_SD:
                        	   188: 
                        	   189: 		;call 	checkArgsTAL				; check necessary args
                        	   190: 		;jp		NZ,argumentsError			; show argument error and return
                        	   191: 	
00:01DE 110000          	   192: 		ld 		DE,CTC_delay_INT_handler
00:01E1 ED5312F4        	   193: 		ld 		(CTC_CH1_I_Vector),DE
                        	   194: 	if 	GPIODEBUG =1
                        	   195: 		xor A
                        	   196: 		out (gpio_out),A
                        	   197: 	endif
                        	   198: 		; call  	SIO_A_DI					; disable text output
                        	   199: 	if 	GPIODEBUG =1
                        	   200: 		ld a,4
                        	   201: 		out (gpio_out),A
                        	   202: 		ld a,0
                        	   203: 		out (gpio_out),A
                        	   204: 	endif
                        	   205: 
00:01E5 7B              	   206: 		ld a,e	
                        	   207: 
00:01E6 CD0000          	   208: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
00:01E9 CD0000          	   209: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
00:01EC CD0000          	   210: 		call 	HC376S_ResetAll
00:01EF CD0000          	   211: 		call 	HC376S_CheckConnection
                        	   212: 		; ld 		A,(commParseTable)
                        	   213: 		; cp 		15							; 15 read SD; 17-read USB
                        	   214: 		; jr 		Z,.doSD
                        	   215: 		; cp 		21							; 21 read SD enumerate, 22 read USB enumerate
                        	   216: 		; jr 		Z,.doSD
                        	   217: 		; call 	HC376S_setUSBMode
                        	   218: 		; call 	HC376S_diskConnectionStatus		; dont use with SD card
                        	   219: 		; jr 		.cont
                        	   220: .doSD:
00:01F2 CD0000          	   221: 		call 	HC376S_setSDMode
                        	   222: 		
                        	   223: .cont:
00:01F5 CD0000          	   224: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:01F8 2014            	   225: 		jr 		NZ,SDabort
                        	   226: 
                        	   227: 
00:01FA CD0000          	   228: 		call 	HC376S_setFileName
00:01FD CD0000          	   229: 		call 	HC376S_fileOpen
00:0200 200C            	   230: 		jr 		NZ,SDabort
00:0202 CD0000          	   231: 		call 	waitForFinishedPrintout
                        	   232: 
00:0205 CD0000          	   233: 		call 	HC376S_getFileSize
00:0208 CD0000          	   234: 		call 	HC376S_fileRead
00:020B CD0000          	   235: 		call 	HC376S_fileClose
                        	   236: SDabort:
                        	   237: 
                        	   238: 		; ***	reset the interrupt handler for CTC
                        	   239: 		; call 	SIO_A_EI					; enable text output
00:020E CD0000          	   240: 		call 	HC376S_ResetAll
00:0211 CD0000          	   241: 		call 	CTC1_INT_OFF
00:0214 210000          	   242: 		ld		HL,CTC_CH1_Interrupt_Handler
00:0217 2212F4          	   243: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:021A C9              	   244: 		ret
                        	   245: 
                        	   246: 
                        	   247: ;***********************************************************************
                        	   248: ;***********************************************************************
                        	   249: 
                        	   250: 		section	Monitor			; enter point for monitor
                        	   251: 
                        	   252: ;***********************************************************************
                        	   253: ;***	MONITOR_Start:  entry point for monitor, should be at $D000.
                        	   254: ;***********************************************************************
                        	   255: 
                        	   256: MONITOR_Start:		
                        	   257: 
                        	   258: 		; ***	should be start address $D000
                        	   259: 		;jr 		.makeShadowRAM
                        	   260: 
                        	   261: 
01:0000 1838            	   262: 		jr 		.skipBlockCopy		; use Flash mem and SRAM normally
                        	   263: 	align 3
                        	   264: 		; Ref. vlink_Z80_.ld
                        	   265: 		; BootCode in $D008-D00B = $00000000 - $AAAAAAAA': copy from flash
                        	   266: 		; BootCode in $D008-D00B = $CCCCCCCC: code uploaded from xmodem/or DMA. Do not copy from flash
                        	   267: 		; BootCode in $D008-D00B = $33333333: code uploaded from Arduino. Do not copy from flash, 
                        	   268: 		;defl 	    $01010101
01:0008 00000000        	   269: 		defl 		BootCode
                        	   270: 		align	3
                        	   271: 
                        	   272: 
                        	   273: 	;call 	waitForFinishedPrintout
                        	   274: 	
                        	   275: .makeShadowRAM:
                        	   276: 
                        	   277: 	if 	GPIODEBUG =1
                        	   278: 	ld 		A,$33
                        	   279: 	out 	(gpio_out),A
                        	   280: 	endif
                        	   281: ;		***  	NOFLASH - Don not use the FLASH mem -> 64kRAM
                        	   282: ; 		*** 	Copy Flash boot sequence to RAM bank #1
                        	   283: ; 		*** 	first to temp storage area.
                        	   284: 
                        	   285: ;		***	 	Copy 128 blocks of 256 bytes from flash to RAM bank #0, then copy to RAM bank #1
                        	   286: 
01:0010 0680            	   287: 		ld  	B,128		; count 128 blocks of 256 bytes
                        	   288: .loopBlocks:
01:0012 C5              	   289: 		push  	BC 			; save BC as block counter
01:0013 018000          	   290: 		ld     	BC,128		; byte counter
                        	   291: 
01:0016 21FF7F          	   292: 		ld 		HL,$7FFF		; end of flash memory area
01:0019 11FFCF          	   293: 		ld 		DE,$CFFF		; temp storage area 0xCF00-CFFF		
01:001C E5              	   294: 		push 	HL
01:001D D5              	   295: 		push 	DE
01:001E EDB8            	   296: 		lddr					; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0		
                        	   297: 
                        	   298: ; 		*** 	secondly: to Rambank #1 storage area. deselect FLASH mem
                        	   299: ; 		***		Swithch to RAM bank #1
01:0020 CD7207          	   300: 		call  	p_FOFF_No_Print	; ***		Disable Flash memory 
01:0023 3E01            	   301: 		ld 		A,1
01:0025 CDC106          	   302: 		call 	p_srbank0; 		***		Swithch to RAM bank #1
                        	   303: 
                        	   304: 				; from old area (HL), $7FFF  to new area ram area (DE), 0x7FFF
01:0028 E1              	   305: 		pop 	HL			; HL point to temp storage area 0xCFFF (old DE value)
01:0029 D1              	   306: 		pop 	DE 			; DE point to new area in ram bank #1 0xCFFF (old HL value)
01:002A 018000          	   307: 		ld     	BC,128
01:002D EDB8            	   308: 		lddr				; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0
                        	   309: 
                        	   310: ;		***		Enable Flash again and set ram bank #0	
01:002F CD7207          	   311: 		call  	p_FOFF_No_Print
01:0032 3E00            	   312: 		ld 		A,0
01:0034 CDD406          	   313: 		call 	p_flbank0; 		***		Swithch to FLASH bank #0
                        	   314: 
                        	   315: 
01:0037 C1              	   316: 		pop 	BC			; restore BC as block counter
01:0038 10D8            	   317: 		djnz	.loopBlocks
                        	   318: 			
                        	   319: 
                        	   320: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	   321: 
                        	   322: .skipBlockCopy:
                        	   323: 
01:003A ED730000        	   324: 		ld 		(SP_value),SP
                        	   325: 
                        	   326: 		if 	GPIODEBUG =1
                        	   327: 			ld 		A,$AA
                        	   328: 			out 	(gpio_out),A
                        	   329: 			
                        	   330: 
                        	   331: 			CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   332: 					; initialize buffer counters and pointers.
                        	   333: 			ld 		A,$BB
                        	   334: 			out 	(gpio_out),A
                        	   335: 
                        	   336: 			call	PIO_Init
                        	   337: 			ld 		A,$CC
                        	   338: 			out 	(gpio_out),A
                        	   339: 
                        	   340: 			call 	CTC_Init
                        	   341: 			ld 		A,$DD
                        	   342: 			out 	(gpio_out),A
                        	   343: 
                        	   344: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	   345: 			ld 		A,$DF
                        	   346: 			out 	(gpio_out),A
                        	   347: 
                        	   348: 			call	S_head_tail			; save input heads and tails
                        	   349: 			ld 		A,$81
                        	   350: 			out 	(gpio_out),A
                        	   351: 		else 
                        	   352: 
01:003E CD0000          	   353: 			CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   354: 					; initialize buffer counters and pointers.
01:0041 CD0000          	   355: 			call	PIO_Init
01:0044 CD0000          	   356: 			call 	CTC_Init
01:0047 CD0000          	   357: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
01:004A CD0000          	   358: 			call	S_head_tail			; save input heads and tails
                        	   359: 		endif
                        	   360: 
                        	   361: 		; call	sh_test
                        	   362: 		; call 	Flash_WR_Test
                        	   363: 		; ld	HL,$2010
                        	   364: 		; call	Flash_SE_Erase
                        	   365: 
                        	   366: 
01:004D CD0000          	   367: 		call	CRLF
01:0050 CD0000          	   368: 		call 	writeSTRBelow
01:0053 0D0A            	   369: 		defb   	"\r\n"
01:0055 2323232323232323	   370: 		defb	"##########################################################\r\n"
01:005D 2323232323232323
01:0065 2323232323232323
01:006D 2323232323232323
01:0075 2323232323232323
01:007D 2323232323232323
01:0085 2323232323232323
01:008D 23230D0A
01:0091 546865205A383020	   371: 		defb	"The Z80 Board Awakened 2026\r\n"
01:0099 426F617264204177
01:00A1 616B656E65642032
01:00A9 3032360D0A
01:00AE 202020206769743A	   372: 		defb	"    git: UPdate_Jan_25-9-gad024c0-dirty\r\n"
01:00B6 205550646174655F
01:00BE 4A616E5F32352D39
01:00C6 2D67616430323463
01:00CE 302D64697274790D
01:00D6 0A
01:00D7 202020206275696C	   373: 		defb	"    build: 2026-02-27_21:13\r\n"
01:00DF 643A20323032362D
01:00E7 30322D32375F3231
01:00EF 3A31330D0A
01:00F4 20202020464C4153	   374: 		defb	"    FLASH->SRAM 0xD000.\r\n"
01:00FC 482D3E5352414D20
01:0104 3078443030302E0D
01:010C 0A
01:010D 00              	   375: 		defb	"\0"
01:010E CD0000          	   376: 		call 	waitForFinishedPrintout
                        	   377: 
                        	   378: 
                        	   379: 	if 	GPIODEBUG=1
                        	   380: 		ld 		A,$83
                        	   381: 		out 	(gpio_out),A
                        	   382: 	endif
01:0111 CD0000          	   383: 		call	CRLF
01:0114 1800            	   384: 		jr  next_line
                        	   385: 
                        	   386: 
                        	   387: next_line:
                        	   388: 
01:0116 CDA603          	   389: 		call 	initCommParseTable			; Put zeros.....
                        	   390: 	if 	GPIODEBUG =1
                        	   391: 		ld 		A,$85
                        	   392: 		out 	(gpio_out),A
                        	   393: 	endif
                        	   394: 
                        	   395: 		; ***	indicate memory banks   F[x]  Flash memory bank x
                        	   396: 		; ***	indicate memory banks   S[y]  SRAM memory bank y
                        	   397: 				; if bit 3 (rstBankID) = 1  no FLASH memory is selected
                        	   398: 				; if bit 3 (rstBankID) = 0 FLASH memory is lower 32k and SRAM upper 32k
01:0119 210100          	   399: 		ld 		HL,T_BUFFER+1 			; prepare output buffer		
01:011C 3646            	   400: 		ld 		(HL),'F'	
01:011E 3A0000          	   401: 		ld 		A,(rstBankID)
01:0121 CB5F            	   402: 		bit 	3,A					; bit 3 set -> 64kSRAM
01:0123 2802            	   403: 		jr 		Z,useFlash
01:0125 3653            	   404: 		ld 		(HL),'S'	
                        	   405: useFlash:
01:0127 23              	   406: 		inc 	HL
01:0128 365B            	   407: 		ld 		(HL),'['	
01:012A 23              	   408: 		inc 	HL
01:012B CB5F            	   409: 		bit 	3,A					; bit 7 set -> 64kSRAM
01:012D 3A0000          	   410: 		ld  	A,(memBankID)
01:0130 2807            	   411: 		jr 		Z,.IDflash
                        	   412: 
                        	   413: 		; ***	show sram bank number
01:0132 E60F            	   414: 		and 	$0F					; sram bank #
01:0134 CD0000          	   415: 		call 	AddToT_Buf			; convert to 1 ascii char in (HL+)
01:0137 180D            	   416: 		jr 		.cont
                        	   417: .IDflash:
                        	   418: 		; ***	show flash bank number
01:0139 CB3F            	   419: 		srl 	A
01:013B CB3F            	   420: 		srl 	A
01:013D CB3F            	   421: 		srl 	A
01:013F CB3F            	   422: 		srl 	A
01:0141 E607            	   423: 		and 	A,$07				; flash bank #
01:0143 CD0000          	   424: 		call	AddToT_Buf			; convert to 1 ascii char in (HL+)
                        	   425: .cont:
01:0146 365D            	   426: 		ld  	(HL),']'
01:0148 23              	   427: 		inc 	HL
                        	   428: 
                        	   429: 	if 	GPIODEBUG=1
                        	   430: 		ld 		A,$87
                        	   431: 		out 	(gpio_out),A
                        	   432: 	endif
                        	   433: 
                        	   434: 	; 	*** Print prompt text to screen, value of PC and content in memory
01:0149 ED5B0000        	   435: 		ld 		DE,(PCvalue)
01:014D 365B            	   436: 		ld  	(HL),'['
01:014F 23              	   437: 		inc 	HL
                        	   438: 
                        	   439: 		; ***	Address in parenthesis
01:0150 CD0000          	   440: 		call 	Bin2Hex16
01:0153 365D            	   441: 		ld  	(HL),']'
01:0155 23              	   442: 		inc 	HL
01:0156 363D            	   443: 		ld  	(HL),'='
01:0158 23              	   444: 		inc 	HL
                        	   445: 
                        	   446: 		; ***	Value of the bytes in address (2 bytes) to screen
01:0159 E5              	   447: 		push 	HL
01:015A 2A0000          	   448: 		ld 		HL,(PCvalue)
01:015D 56              	   449: 		ld 		D,(HL)
01:015E 23              	   450: 		inc 	HL
01:015F 5E              	   451: 		ld 		E,(HL)
01:0160 E1              	   452: 		pop 	HL
01:0161 CD0000          	   453: 		call	Bin2Hex16
01:0164 362D            	   454: 		ld  	(HL),'-'
01:0166 23              	   455: 		inc 	HL
01:0167 363E            	   456: 		ld  	(HL),'>'
01:0169 23              	   457: 		inc 	HL
                        	   458: 
01:016A 3600            	   459: 		ld  	(HL),$00
01:016C FD210000        	   460: 		ld 		iy,T_BUFFER
01:0170 CD0000          	   461: 		call	WriteLine
                        	   462: 
01:0173 210000          	   463: 		ld 		hl,Textbuf
01:0176 CD0000          	   464: 		call 	ReadLine
                        	   465: 
01:0179 FD210000        	   466: 		ld 		iy,Textbuf
01:017D CD0000          	   467: 		call	WriteLineCRNL
                        	   468: 		; ld 		A,5
                        	   469: 		; out 	(portA_Data),A
                        	   470: 
                        	   471: 		;***  	compare input
                        	   472: 		; ld 		HL,Textbuf
                        	   473: 		; ld 		DE,command_list+2
                        	   474: 		; call	strCompare
                        	   475: 
                        	   476: 	;***************************************************************
                        	   477: 	;	Find /Identify command:
                        	   478: 	;***************************************************************
                        	   479: 
01:0180 210000          	   480: 		ld 		HL,Textbuf
01:0183 CD0000          	   481: 		call 	skipPriorDelimit			; set (HL) first char
                        	   482: 
01:0186 DACF04          	   483: 		jp 		C,temp_finish 				; end encountered; no command (empty line)	
                        	   484: 
01:0189 E5              	   485: 		push 	HL
01:018A D1              	   486: 		pop  	DE							; typed command start in DE
                        	   487: 
                        	   488: 		; ***	Search command in 'command_list:'
                        	   489: 		;  		DE = typed command first char in DE (Textbuf)
01:018B 21F701          	   490: 		ld 		HL,command_list+1			; first char in first command in the list
                        	   491: 		
                        	   492: scanCommandList:
01:018E 4E              	   493: 		ld 		C,(HL)						; command # in C
01:018F 23              	   494: 		inc 	HL 							; (HL)=first char
01:0190 46              	   495: 		ld 		B,(HL)						; # chars in command in list
01:0191 23              	   496: 		inc 	HL 							; (HL)=first char
01:0192 D5              	   497: 		push 	DE 							; save start of typed string (DE) for later
                        	   498: 
                        	   499: findCommandInList:
01:0193 1A              	   500: 		ld 		a,(DE)						; next typed char
                        	   501: 		; or 		$20							; make typed char lower case
01:0194 BE              	   502: 		cp		(HL)
01:0195 2008            	   503: 		jr 		nz,findNextITEM				; different chars-> test next item in list
01:0197 13              	   504: 		inc 	DE
01:0198 23              	   505: 		inc 	HL  
01:0199 10F8            	   506: 		djnz 	findCommandInList
                        	   507: 		
                        	   508: 		; ***	test char (DE); should be a delimiter...
                        	   509: 		; ex 		DE,HL
                        	   510: 		; call 	isDelimit
                        	   511: 		; 				;delimiters found ? =>Z, else ~Z
                        	   512: 		; 				;char in (HL) is '0' ->  set C, else NC
                        	   513: 		; ex 		DE,HL
                        	   514: 
                        	   515: 		; call 	writeSTRBelow
                        	   516: 		; DB 		0,"pop 	HL.. !",CR,LF,00
                        	   517: 		; call 	DumpRegisters
                        	   518: 
                        	   519: 		; jr 		nz,findNextITEM    			; command match but is longer (more chars) cp list					
                        	   520: 
                        	   521: 		; ***	Found a matching command, All char do match...
                        	   522: 		; 		(HL) points to first after command
01:019B C3B903          	   523: 		jp 		matchInList
01:019E 00              	   524: zero_byte:	db  0
                        	   525: 
                        	   526: findNextITEM:
                        	   527: 		; ***	find next ITEM or LISTEND
01:019F 7E              	   528: 		ld 		a,(HL)
01:01A0 FEEE            	   529: 		cp		CDEL					; command adress delimiter
01:01A2 2812            	   530: 		jr 		z,.skipPastCommAdr
                        	   531: 	
01:01A4 FE1C            	   532: 		cp		ITEM					; command adress delimiter
01:01A6 2817            	   533: 		jr 		z,nextInList
                        	   534: 	
01:01A8 FE1E            	   535: 		cp 		LISTEND
01:01AA 2010            	   536: 		jr 		NZ,.cont
                        	   537: 
                        	   538: 		; ***	Command list did not match; check if direct address '$' or byte input
01:01AC 3EFF            	   539: 		ld 		A,$FF
01:01AE 320000          	   540: 		ld 		(PCinpFlag),A			; indicate ev. typed ($)address to change PCV or input bytes ...
01:01B1 E1              	   541: 		pop 	HL						; HL start of typed string (again)
01:01B2 7E              	   542: 		ld 		A,(HL)
01:01B3 C30404          	   543: 		jp 		checkaddress			; No more commands to check, check if address entered , '$'
                        	   544: 										; or relative adress '@'
                        	   545: 										; or direct input of bytes.....
                        	   546: .skipPastCommAdr:
01:01B6 23              	   547: 		inc  	HL		;hig adr.
01:01B7 23              	   548: 		inc  	HL		; low adr.
01:01B8 23              	   549: 		inc  	HL		;  '0'
01:01B9 23              	   550: 		inc  	HL		;  next row
01:01BA 18E3            	   551: 		jr 		findNextITEM
                        	   552: 
01:01BC 23              	   553: .cont:	inc 	HL
01:01BD 18E0            	   554: 		jr 		findNextITEM
                        	   555: 
                        	   556: nextInList:
01:01BF 23              	   557: 		inc 	HL						; points to item #
01:01C0 D1              	   558: 		pop 	DE 						; DE start of typed string (again)
01:01C1 18CB            	   559: 		jr 		scanCommandList
                        	   560: 
                        	   561: 
                        	   562: 	;***************************************************************
                        	   563: 	;	Semantic error occurred in input :
                        	   564: 	;***************************************************************
                        	   565: 
                        	   566: inputerror:
01:01C3 E5              	   567: 		push   	HL
01:01C4 CD0000          	   568: 		call 	writeSTRBelow
01:01C7 00              	   569: 		DB 		0,"Input Semantic Error... ! code(DE):",00
01:01C8 496E707574205365
01:01D0 6D616E7469632045
01:01D8 72726F722E2E2E20
01:01E0 2120636F64652844
01:01E8 45293A
01:01EB 00
01:01EC D1              	   570: 		pop 	DE
01:01ED CD0000          	   571: 		call 	putDEtoScreen
01:01F0 CD0000          	   572: 		call 	CRLF
01:01F3 C31601          	   573: 		jp 		next_line
                        	   574: 
                        	   575: ; command_addresses:
                        	   576: ; 		defw 	00
                        	   577: ; 		defw 	p_load			;1
                        	   578: ; 		defw 	p_dumpmem		;2
                        	   579: ; 		defw 	p_pc			;3
                        	   580: ; 		defw 	p_eep			;4
                        	   581: ; 		defw 	p_clearmem		;5
                        	   582: ; 		defw 	p_exe			;6
                        	   583: ; 		defw 	p_go			;7
                        	   584: ; 		defw 	p_incDecPC		;8
                        	   585: ; 		defw 	p_incDecPC		;9
                        	   586: ; 		defw 	p_FON			;10
                        	   587: ; 		defw 	p_FOFF			;11
                        	   588: ; 		defw 	p_flwr			;12. write data to FLASH
                        	   589: ; 		defw 	p_flse			;13. sector erase
                        	   590: ; 		defw 	p_xmod			;14. transfer files via x-modem
                        	   591: ; 		defw 	p_reset			;16. Jump to $0000
                        	   592: ; 		defw	p_C_Read		;16. Read from SD card   sdrd  "file"  $Addr
                        	   593: ; 		defw	p_C_Write		;17. Write to SD card   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   594: ; 		defw	p_C_Read		;18. Read from USB   sdrd  "file"  $Addr
                        	   595: ; 		defw	p_C_Write		;19. Write to USB   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   596: ; 		defw	p_C_Delete		;20. delete file on SD card   sdrd  "file"  $Addr
                        	   597: ; 		defw	p_C_Delete		;21. delete file on USB  sdrd  "file"  $Addr.l $Addr.h/Num
                        	   598: ; 		defw 	p_C_Read		;22. List root level files/dirs on sd card
                        	   599: ; 		defw 	p_C_Read 		;23. List root level files/dirs on USB
                        	   600: ; 		defw	p_cptFl			;24. copy from mem to flash memory (on selected bank)
                        	   601: ; 		defw 	p_flbank		;25. Set flash bank #
                        	   602: ; 		defw	p_srbank		;26. Set sram bank #
                        	   603: 
                        	   604: command_list:
                        	   605: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	   606: 
01:01F6 1C              	   607: 		db		ITEM,1,4,"load",STEND,%100010,0,CDEL
01:01F7 01
01:01F8 04
01:01F9 6C6F6164
01:01FD 1D
01:01FE 22
01:01FF 00
01:0200 EE
01:0201 2105            	   608: 		dw 		p_load,0
01:0203 0000
01:0205 1C              	   609: 		db		ITEM,2,2,"dm",	STEND,%000010,0,CDEL
01:0206 02
01:0207 02
01:0208 646D
01:020A 1D
01:020B 02
01:020C 00
01:020D EE
01:020E 2205            	   610: 		dw  	p_dumpmem,0
01:0210 0000
01:0212 1C              	   611: 		db		ITEM,3,2,"pc",	STEND,%000000,0,CDEL
01:0213 03
01:0214 02
01:0215 7063
01:0217 1D
01:0218 00
01:0219 00
01:021A EE
01:021B 2605            	   612: 		dw 		p_pc,0
01:021D 0000
01:021F 1C              	   613: 		db		ITEM,4,3,"eep",	STEND,%000000,0,CDEL
01:0220 04
01:0221 03
01:0222 656570
01:0225 1D
01:0226 00
01:0227 00
01:0228 EE
01:0229 2705            	   614: 		dw 		p_eep,0
01:022B 0000
01:022D 1C              	   615: 		db		ITEM,5,2,"cm",	STEND,%000000,0,CDEL
01:022E 05
01:022F 02
01:0230 636D
01:0232 1D
01:0233 00
01:0234 00
01:0235 EE
01:0236 2E05            	   616: 		dw  	p_clearmem,0
01:0238 0000
01:023A 1C              	   617: 		db		ITEM,6,3,"exe",	STEND,%000000,0,CDEL
01:023B 06
01:023C 03
01:023D 657865
01:0240 1D
01:0241 00
01:0242 00
01:0243 EE
01:0244 4105            	   618: 		dw 		p_exe,0
01:0246 0000
01:0248 1C              	   619: 		db		ITEM,7,2,"go",	STEND,%000000,0,CDEL
01:0249 07
01:024A 02
01:024B 676F
01:024D 1D
01:024E 00
01:024F 00
01:0250 EE
01:0251 4205            	   620: 		dw 		p_go,0
01:0253 0000
01:0255 1C              	   621: 		db		ITEM,8,2,"++",	STEND,%000000,0,CDEL
01:0256 08
01:0257 02
01:0258 2B2B
01:025A 1D
01:025B 00
01:025C 00
01:025D EE
01:025E 5305            	   622: 		dw 		p_incDecPC,0
01:0260 0000
01:0262 1C              	   623: 		db		ITEM,9,2,"--",	STEND,%000000,0,CDEL
01:0263 09
01:0264 02
01:0265 2D2D
01:0267 1D
01:0268 00
01:0269 00
01:026A EE
01:026B 5305            	   624: 		dw 		p_incDecPC,0
01:026D 0000
01:026F 1C              	   625: 		db		ITEM,10,3,"fl1",		STEND,%000000,0,CDEL
01:0270 0A
01:0271 03
01:0272 666C31
01:0275 1D
01:0276 00
01:0277 00
01:0278 EE
01:0279 EA06            	   626: 		dw		p_FON,0
01:027B 0000
01:027D 1C              	   627: 		db		ITEM,10,8,"flash-on",	STEND,%000000,0,CDEL
01:027E 0A
01:027F 08
01:0280 666C6173682D6F6E
01:0288 1D
01:0289 00
01:028A 00
01:028B EE
01:028C EA06            	   628: 		dw 		p_FON,0
01:028E 0000
01:0290 1C              	   629: 		db		ITEM,11,3,"fl0",		STEND,%000000,0,CDEL
01:0291 0B
01:0292 03
01:0293 666C30
01:0296 1D
01:0297 00
01:0298 00
01:0299 EE
01:029A 4407            	   630: 		dw 		p_FOFF,0
01:029C 0000
01:029E 1C              	   631: 		db		ITEM,11,9,"flash-off",	STEND,%000000,0,CDEL
01:029F 0B
01:02A0 09
01:02A1 666C6173682D6F66
01:02A9 66
01:02AA 1D
01:02AB 00
01:02AC 00
01:02AD EE
01:02AE 4407            	   632: 		dw 		p_FOFF,0
01:02B0 0000
01:02B2 1C              	   633: 		db		ITEM,12,4,"flwr",	STEND,%001110,0,CDEL
01:02B3 0C
01:02B4 04
01:02B5 666C7772
01:02B9 1D
01:02BA 0E
01:02BB 00
01:02BC EE
01:02BD 7805            	   634: 		dw 		p_flwr,0									; write to flash: flwr  <$Addr.mem> <$Addr.flash>  <Num> (0E)
01:02BF 0000
01:02C1 1C              	   635: 		db		ITEM,13,4,"flse",	STEND,%000000,0,CDEL
01:02C2 0D
01:02C3 04
01:02C4 666C7365
01:02C8 1D
01:02C9 00
01:02CA 00
01:02CB EE
01:02CC AD05            	   636: 		dw 		p_flse,0
01:02CE 0000
01:02D0 1C              	   637: 		db		ITEM,14,4,"xmod",	STEND,%001000,0,CDEL
01:02D1 0E
01:02D2 04
01:02D3 786D6F64
01:02D7 1D
01:02D8 08
01:02D9 00
01:02DA EE
01:02DB B605            	   638: 		dw 		p_xmod,0									; xmodem from PC   xmod <address>
01:02DD 0000
01:02DF 1C              	   639: 		db		ITEM,15,3,"rst",	STEND,%000000,0,CDEL
01:02E0 0F
01:02E1 03
01:02E2 727374
01:02E5 1D
01:02E6 00
01:02E7 00
01:02E8 EE
01:02E9 0D05            	   640: 		dw 		p_reset,0
01:02EB 0000
01:02ED 1C              	   641: 		db		ITEM,16,4,"sdrd",	STEND,%101000,0,CDEL
01:02EE 10
01:02EF 04
01:02F0 73647264
01:02F4 1D
01:02F5 28
01:02F6 00
01:02F7 EE
01:02F8 CB05            	   642: 		dw		p_C_Read,0									; Read from SD card   sdrd  "file"  $Addr
01:02FA 0000
01:02FC 1C              	   643: 		db		ITEM,17,4,"sdwr",	STEND,%101010,0,CDEL
01:02FD 11
01:02FE 04
01:02FF 73647772
01:0303 1D
01:0304 2A
01:0305 00
01:0306 EE
01:0307 2406            	   644: 		dw 		p_C_Write,0									; Write to SD card   sdwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0309 0000
01:030B 1C              	   645: 		db		ITEM,18,5,"usbrd",	STEND,%101000,0,CDEL
01:030C 12
01:030D 05
01:030E 7573627264
01:0313 1D
01:0314 28
01:0315 00
01:0316 EE
01:0317 CB05            	   646: 		dw 		p_C_Read,0									; Read from USB      usbrd  "file"  $Addr
01:0319 0000
01:031B 1C              	   647: 		db		ITEM,19,5,"usbwr",	STEND,%101010,0,CDEL
01:031C 13
01:031D 05
01:031E 7573627772
01:0323 1D
01:0324 2A
01:0325 00
01:0326 EE
01:0327 2406            	   648: 		dw 		p_C_Write,0									; Write to USB        usbwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0329 0000
01:032B 1C              	   649: 		db		ITEM,20,5,"sddel",	STEND,%100000,0,CDEL
01:032C 14
01:032D 05
01:032E 736464656C
01:0333 1D
01:0334 20
01:0335 00
01:0336 EE
01:0337 7C06            	   650: 		dw 		p_C_Delete,0 								; Delete file on SD card   sddel  "file"  
01:0339 0000
01:033B 1C              	   651: 		db		ITEM,21,6,"usbdel",	STEND,%100000,0,CDEL
01:033C 15
01:033D 06
01:033E 75736264656C
01:0344 1D
01:0345 20
01:0346 00
01:0347 EE
01:0348 7C06            	   652: 		dw 		p_C_Delete,0 								; Delete file on USB   usbdel  "file"  
01:034A 0000
01:034C 1C              	   653: 		db		ITEM,22,5,"sddir",	STEND,%100000,0,CDEL
01:034D 16
01:034E 05
01:034F 7364646972
01:0354 1D
01:0355 20
01:0356 00
01:0357 EE
01:0358 CB05            	   654: 		dw 		p_C_Read,0 									; List root level files/dirs on sd card
01:035A 0000
01:035C 1C              	   655: 		db		ITEM,23,6,"usbdir",	STEND,%100000,0,CDEL
01:035D 17
01:035E 06
01:035F 757362646972
01:0365 1D
01:0366 20
01:0367 00
01:0368 EE
01:0369 CB05            	   656: 		dw 		p_C_Read,0 									; List root level files/dirs on USB
01:036B 0000
01:036D 1C              	   657: 		db 		ITEM,24,5,"cptfl",	STEND,%001100,0,CDEL
01:036E 18
01:036F 05
01:0370 637074666C
01:0375 1D
01:0376 0C
01:0377 00
01:0378 EE
01:0379 B306            	   658: 		dw 		p_cptFl,0									; copy from adress range to flash   cptfl  $Addr   $Addr
01:037B 0000
01:037D 1C              	   659: 		db 		ITEM,25,2,"fb",		STEND,%000010,0,CDEL
01:037E 19
01:037F 02
01:0380 6662
01:0382 1D
01:0383 02
01:0384 00
01:0385 EE
01:0386 CE06            	   660: 		dw 		p_flbank,0									; set flash bank #	
01:0388 0000
01:038A 1C              	   661: 		db 		ITEM,26,2,"sb",		STEND,%000010,0,CDEL
01:038B 1A
01:038C 02
01:038D 7362
01:038F 1D
01:0390 02
01:0391 00
01:0392 EE
01:0393 BB06            	   662: 		dw		p_srbank,0									; set sram bank #	
01:0395 0000
01:0397 1C              	   663: 		db		ITEM,27,3,"nop",	STEND,%000000,0,CDEL
01:0398 1B
01:0399 03
01:039A 6E6F70
01:039D 1D
01:039E 00
01:039F 00
01:03A0 EE
01:03A1 0000            	   664: 		dw 		0,0
01:03A3 0000
01:03A5 1E              	   665: 		db		LISTEND
                        	   666: commListLen  equ   27
                        	   667: 
                        	   668: 		; ld		HL,$6000
                        	   669: 		; ld		(packetBaseAddress),HL			; store the address for target code (for error correction)
                        	   670: 		; ld		A,01
                        	   671: 		; ld		(prevPacketByte01),A 				; store of packet numbers
                        	   672: 
                        	   673: 		; call 	SetupXMODEM_TXandRX					 
                        	   674: 	
                        	   675: 
                        	   676: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   677: ;---------------------------------------------------------------------------------
                        	   678: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   679: 
                        	   680: ;		skipPriorDelimit 		; increase A0 until non delimiter (NZ) or #0 (Z) 
                        	   681: ;		***		store string value in textarea and reference in table
                        	   682: ;		skipCharsUntilDelim		; increase A0 until blank (NZ) or #0 (Z) 
                        	   683: ;		***		read/store either address or lvalue and store in table
                        	   684: ; 		isDelimit(S)  is char in (A0) any of the delimiters specified in (A1) ? =>Z, else ~Z
                        	   685: ; 		Parameters returned; A0 - Address of char
                        	   686: 
                        	   687: ;		commParseTable
                        	   688: ;		***************************************************
                        	   689: ;		***	decode input line;
                        	   690: ;		*** <cmd>    "TEXT"  	$xxyy  xxyy
                        	   691: ;		*** command textstring 	address	 lvalue
                        	   692: ;		************************************************************
                        	   693: ;		*** commParseTable:
                        	   694: ;		*** 00 : W : offset in jumptable  (F080)
                        	   695: ;		*** 04 : L : address 1  (F084-F087)
                        	   696: ;		*** 08 : L : address 2  (F088-F08B)
                        	   697: ;		*** 10 : L : lvalue1  (F090-F09F)
                        	   698: ;		*** 20 : L : lvalue2  (F0A0-F0AF)
                        	   699: ;		*** 57 : L : text1   (F0B0-F0D7)
                        	   700: ;		*** 58 : L : text2 	 (F0D8-F0FF)	
                        	   701: ;		***
                        	   702: ;		***--------------------------------------
                        	   703: 
                        	   704: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   705: ;---------------------------------------------------------------------------------
                        	   706: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   707: 
                        	   708: 		; call	skipCharsUntilDelim			; set (HL) to first delimiter
                        	   709: 		; push 	HL
                        	   710: 		; pop  	BC							; typed command end+1 in BC
                        	   711: 
                        	   712: 		; ***	Prepares the commParseTable. Consumes HL,B,A
                        	   713: initCommParseTable:
01:03A6 3E00            	   714: 		ld 		A,0
01:03A8 320000          	   715: 		ld 		(PCinpFlag),A
01:03AB 320100          	   716: 		ld 		(PCinpFlag+1),A
01:03AE 210000          	   717: 		ld 		HL,commParseTable
                        	   718: 
01:03B1 0680            	   719: 		ld 		B,$80
01:03B3 97              	   720: 		sub 	A 					; clear A.
                        	   721: .icpt:
01:03B4 77              	   722: 		ld 		(HL),A
01:03B5 23              	   723: 		inc 	HL
01:03B6 10FC            	   724: 		djnz 	.icpt
                        	   725: 
01:03B8 C9              	   726: 		ret
                        	   727: 
                        	   728: ;---------------------------------------------------------------------------------
                        	   729: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   730: 
                        	   731: 	;***************************************************************
                        	   732: 	;	Command identified -> now search for string :
                        	   733: 	;***************************************************************
                        	   734: 
                        	   735: matchInList:
                        	   736: 		; ***	Command found. Then, check for string input "<string>"
                        	   737: 		; ***	DE points to first delimiter after command 
                        	   738: 						;delimiters found ? =>Z, else ~Z
                        	   739: 						;char in (HL) is '0' ->  set C, else NC
                        	   740: 
01:03B9 33              	   741: 		inc 	sp
01:03BA 33              	   742: 		inc 	sp						; restore PC from PUSH in <scanCommandList>
01:03BB 23              	   743: 		inc 	HL 						; HL point to first after <STEND>  ->req arguments  (STEND,%100010,0,CDEL,p_load,0)
01:03BC 7E              	   744: 		ld 		A,(HL) 					; A= required arguments from table
01:03BD FD210000        	   745: 		ld 		IY,commParseTable		; IY =commParseTable =	0x80 + _String_HEAP
01:03C1 FD7502          	   746: 		ld   	(IY+2),L 
01:03C4 FD7403          	   747: 		ld   	(IY+3),H				; save the command adress.
                        	   748: 		
01:03C7 FD7100          	   749: 		ld 		(IY),C 					; store the command number in (commParseTable, 0x80)
01:03CA FD7701          	   750: 		ld 		(IY+1),A				; store required arguments  in (commParseTable+1, 0x81)
                        	   751: 		; call 	writeSTRBelow_CRLF
                        	   752: 		; DB 		0,"Found a valid command  see (C).. !",CR,LF,00
01:03CD D5              	   753: 		push 	DE
01:03CE E1              	   754: 		pop 	HL						; HL=DE = first delimiter after command
01:03CF 2B              	   755: 		dec 	HL							; DE -> HL -> last char before delimiter
                        	   756: paramLoopEntry:	
                        	   757: 
01:03D0 CD0000          	   758: 		call 	skipPriorDelimit 			; look for next char (  '"' ?)
01:03D3 DABE04          	   759: 		jp 		C,executeCommand			; C set from 'skipPriorDelimit', no command parameters
                        	   760: 
01:03D6 7E              	   761: 		ld 		A,(HL)
                        	   762: 
01:03D7 FE22            	   763: 		cp 		'"'							; beginning of string ?
01:03D9 2029            	   764: 		jr 		NZ,checkaddress				;  NZ -> (HL) points to non delimiter
                        	   765: 
                        	   766: 		; ***	extract string 
01:03DB 23              	   767: 		inc 	HL 							; skip '"' (HL)-> first char
                        	   768: 
01:03DC E5              	   769: 		push  	HL
01:03DD D1              	   770: 		pop  	DE							; DE -> first char after '"' <source>
01:03DE CD0000          	   771: 		call 	skipCharsUntilDelim			; find second '"'
01:03E1 2B              	   772: 		dec 	HL 							; skip first delimiter (ev. CR)
01:03E2 7E              	   773: 		ld 		A,(HL)
01:03E3 FE22            	   774: 		cp 		'"' 						; found second '"' ??
01:03E5 C2C301          	   775: 		jp 		NZ,inputerror
01:03E8 2B              	   776: 		dec 	HL 							; skip second '"'
                        	   777: 	;***************************************************************
                        	   778: 	;	copy string to  'commParseTable'
                        	   779: 	;***************************************************************
                        	   780: 
01:03E9 A7              	   781: 		and 	A
01:03EA ED52            	   782: 		sbc 	HL,DE 						; amount of chars...
01:03EC 44              	   783: 		ld 		B,H							; amount of chars...
01:03ED 4D              	   784: 		ld 		C,L							; amount of chars...
01:03EE 03              	   785: 		inc 	BC
                        	   786: 
01:03EF 210000          	   787: 		ld 		HL,commStr1				; address for first string
01:03F2 7E              	   788: 		ld 		A,(HL)
01:03F3 B7              	   789: 		or 		A 						; =0?
01:03F4 2808            	   790: 		jr 		Z, .strone
01:03F6 210000          	   791: 		ld 		HL,commStr2				; address for second string
01:03F9 7E              	   792: 		ld 		A,(HL)
01:03FA B7              	   793: 		or  	A						; =0 ?
01:03FB C2C301          	   794: 		jp 		NZ,inputerror			; too many strings
                        	   795: .strone:
01:03FE EB              	   796: 		ex 		DE,HL 					; HL = <source>, DE = <dest>, size = BC
01:03FF EDB0            	   797: 		ldir 							; make the copy
                        	   798: 		; ex		DE,HL
01:0401 23              	   799: 		inc 	HL 						; (HL) past the second '"'
                        	   800: 
01:0402 18CC            	   801: 		jr 		paramLoopEntry
                        	   802: 
                        	   803: 
                        	   804: 	;***************************************************************
                        	   805: 	;	Check if address is specified in input 
                        	   806: 	;***************************************************************
                        	   807: 
                        	   808: 
                        	   809: checkaddress:
                        	   810: 		; ***	A = (HL), first char after delimiter
                        	   811: 
01:0404 320100          	   812: 		ld 		(PCinpFlag+1),A			; if value '(PCinpFlag+1)' == '$' -> address input
                        	   813: 										; if value '(PCinpFlag+1)' == '@' -> relative (PCval) address input
01:0407 FE24            	   814: 		cp 		'$'						; identified address id
01:0409 3E00            	   815: 		ld 		A,0
01:040B 2802            	   816: 		jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   817: 		; cp 		'@'						; identified address id
                        	   818: 		; jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   819: 
01:040D 1823            	   820: 		jr 		getLvalue				
                        	   821: 
01:040F 23              	   822: chkADR:		inc 	HL 						; skip past '$' or '@'
                        	   823: 
                        	   824: chkADR1:
                        	   825: 	; ***		Check where to store address...
                        	   826: 
01:0410 DD210000        	   827: 		ld 		IX,commAdr1
                        	   828: 		; ld 		A,0
01:0414 DDBE00          	   829: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0417 2007            	   830: 		jr 		NZ,chkADR2
01:0419 DDBE01          	   831: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:041C 2002            	   832: 		jr 		NZ,chkADR2
01:041E 1832            	   833: 		jr 		makeASCIItoHEX
                        	   834: chkADR2:
                        	   835: 
01:0420 DD210000        	   836: 		ld 		IX,commAdr2
                        	   837: 		; ld 		A,0
01:0424 DDBE00          	   838: 		cp 		(IX)			; check if zero ? (already stored)
01:0427 C2C301          	   839: 		jp 		NZ,inputerror	; error : No more addresses to store
01:042A DDBE01          	   840: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
01:042D C2C301          	   841: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0430 1820            	   842: 		jr 		makeASCIItoHEX
                        	   843: 
                        	   844: getLvalue:
01:0432 DD210000        	   845: 		ld 		IX,commLvl1
01:0436 DDBE00          	   846: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0439 2007            	   847: 		jr 		NZ,chkLVL2
01:043B DDBE01          	   848: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:043E 2002            	   849: 		jr 		NZ,chkLVL2
01:0440 1810            	   850: 		jr 		makeASCIItoHEX
                        	   851: 
                        	   852: chkLVL2:
01:0442 DD210000        	   853: 		ld 		IX,commLvl2
01:0446 DDBE00          	   854: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0449 C2C301          	   855: 		jp 		NZ,inputerror	; error : No more addresses to store
01:044C DDBE01          	   856: 		cp 		(IX+1)			; check if zero (byte 2) ? (ascii value already stored)
01:044F C2C301          	   857: 		jp 		NZ,inputerror	; error : No more addresses to store
                        	   858: 
                        	   859: 
                        	   860: makeASCIItoHEX:
                        	   861: 		; ***	copy from command line to adr or lvalue in table
                        	   862: 		; ***	only two bytes (four chars)....
                        	   863: 		; 		IX point to destination...
01:0452 54              	   864: 		ld 		D,H
01:0453 5D              	   865: 		ld		E,L						; DE -> first char after '$' | '@' <source>
01:0454 CD0000          	   866: 		call 	skipCharsUntilDelim		; find next delimiter or CR ; adr in HL
01:0457 7E              	   867: 		ld 		A,(HL)
                        	   868: 
                        	   869: 	;***************************************************************
                        	   870: 	;	copy string to  'commParseTable', IX points to dest address.
                        	   871: 	;***************************************************************
                        	   872: 
01:0458 A7              	   873: 		and 	A						; clear Carry
01:0459 ED52            	   874: 		sbc 	HL,DE 					; amount of chars...->HL ( H=0); DE -> first char after '$' <source>
                        	   875: 
                        	   876: 		; ***	Do not check even or odd...
                        	   877: 		; bit 	0,L 					; even or odd (=1)?
                        	   878: 		; jp 		NZ,inputerror
                        	   879: 
01:045B 45              	   880: 		ld 		B,L 					; char counter
01:045C 210000          	   881: 		ld 		HL,00					;  
                        	   882: 
01:045F EB              	   883: 		ex 		DE,HL					; HL -> first char after '$' <ascii source>	
                        	   884: 
                        	   885: nextHalfByte:
                        	   886: 
01:0460 CD0000          	   887: 		call 	isHex					; check char in (HL) return with Carry, value in A is NOT HEX
01:0463 DAC301          	   888: 		jp 		C,inputerror			; return with Carry, value in A is NOT HEX
                        	   889: 
01:0466 CB23            	   890: 		sla 	E						; shift left E-> Carry
01:0468 CB12            	   891: 		rl 		D 						; Carry -> rotate left D
01:046A CB23            	   892: 		sla 	E						; shift left E-> Carry
01:046C CB12            	   893: 		rl 		D 						; Carry -> rotate left D
01:046E CB23            	   894: 		sla 	E						; shift left E-> Carry
01:0470 CB12            	   895: 		rl 		D 						; Carry -> rotate left D
01:0472 CB23            	   896: 		sla 	E						; shift left E-> Carry
01:0474 CB12            	   897: 		rl 		D 						; Carry -> rotate left D
01:0476 B3              	   898: 		or      E  						; A OR E(0..3) are zero
01:0477 5F              	   899: 		ld 		E,A
                        	   900: 
01:0478 DD7300          	   901: 		ld 		(IX),E					; store E value [big endian]
01:047B DD7201          	   902: 		ld 		(IX+1),D				; store D value [big endian]
                        	   903: 
01:047E 23              	   904: 		inc 	HL
                        	   905: 
01:047F 10DF            	   906: 		djnz 	nextHalfByte
                        	   907: 		;***	HL should point to first delimiter...
                        	   908: 
                        	   909: byteEnd:
                        	   910: 
01:0481 3A0000          	   911: 		ld  	A,(PCinpFlag)
01:0484 B7              	   912: 		or  	A 						; check Z; =0 -> normal parameter save
01:0485 CAD003          	   913: 		jp 	   	Z,paramLoopEntry
                        	   914: 
01:0488 3A0100          	   915: 		ld  	A,(PCinpFlag+1) 		; address input for PCValue ?
01:048B FE24            	   916: 		cp 		'$' 					; adress flag ?
                        	   917: 		; jr 		Z,changePCVal
                        	   918: 		; cp 		'@' 					; relative adress flag ?
01:048D 2813            	   919: 		jr 		Z,changePCVal
                        	   920: 
                        	   921: 		; ***	Store  bytes from LVL1 to (PCval)
01:048F E5              	   922: 		push 	HL
01:0490 ED5B0000        	   923: 		ld 		DE,(PCvalue)	
01:0494 210000          	   924: 		ld 		HL,commLvl1
                        	   925: 		; ld 		A,(DE)
                        	   926: 		; ld 		(HL),A
                        	   927: 		; inc 	HL
                        	   928: 		; inc 	DE
01:0497 EDA0            	   929: 		ldi  							; (DE)<-(HL), inc HL,DE, dec BC
01:0499 7E              	   930: 		ld 		A,(HL)
01:049A B7              	   931: 		or 		A
01:049B 2801            	   932: 		jr 		Z,noHighNib
01:049D 12              	   933: 		ld 		(DE),A
                        	   934: noHighNib:
01:049E E1              	   935: 		pop 	HL		
                        	   936: 		; ***	reset flag
                        	   937: 		; ld 		A,0
                        	   938: 		; ld 		(PCinpFlag),A
                        	   939: 		; ld 		(PCinpFlag+1),A
01:049F C3D003          	   940: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   941: 
                        	   942: 		
                        	   943: changePCVal:
                        	   944: 		; ***	Change relative PCvalue from 'commAdr1' or
                        	   945: 		; ***	change PCvalue from 'commAdr1'
                        	   946: 		; ***	A contains '$' or '@'
01:04A2 E5              	   947: 		push 	HL
01:04A3 D5              	   948: 		push  	DE
01:04A4 FE40            	   949: 		cp   	'@' 					; relative adress ?
01:04A6 2806            	   950: 		jr 		Z,.reladr
                        	   951: ; 		***		absolute adr !		
01:04A8 210000          	   952: 		ld 		HL,00
01:04AB 220000          	   953: 		ld 		(PCvalue),HL				; clear and then add value from commAdr1
                        	   954: 
                        	   955: .reladr:		
01:04AE 2A0000          	   956: 		ld 		HL,(commAdr1)
01:04B1 ED5B0000        	   957: 		ld  	DE,(PCvalue)
01:04B5 19              	   958: 		add 	HL,DE
01:04B6 220000          	   959: 		ld 		(PCvalue),HL
01:04B9 D1              	   960: 		pop 	DE
01:04BA E1              	   961: 		pop 	HL 						; restore value of first delimiter
01:04BB C3D003          	   962: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   963: 
                        	   964: executeCommand:	
                        	   965: 		; ***	execute commands (and arguments)
                        	   966: 		; call 	writeSTRBelow
                        	   967: 		; DB 		0,"Finish parsing !",CR,LF,00
                        	   968: 		; call 	DumpRegisters			; checkpoint for list of arguments
                        	   969: 		; ***	IY+2 point to command address. IY=commParseTable
                        	   970: 
01:04BE 3A0000          	   971: 		ld 		A,(PCinpFlag)
01:04C1 B7              	   972: 		or 		A   					; check if zero  
01:04C2 2003            	   973: 		jr 		NZ,.noJump
                        	   974: 
01:04C4 CDD204          	   975: 		call 	JPTable01
                        	   976: .noJump:
                        	   977: 		; ***	reset flag
01:04C7 3E00            	   978: 		ld 		A,0
01:04C9 320000          	   979: 		ld 		(PCinpFlag),A
01:04CC 320100          	   980: 		ld 		(PCinpFlag+1),A
                        	   981: 
                        	   982: 		
                        	   983: 		; jp 		paramLoopEntry 				; loop and check for more parameters
                        	   984: 
                        	   985: temp_finish:
                        	   986: 		; call 	DumpRegisters
01:04CF C31601          	   987: 		jp 		next_line
                        	   988: 
                        	   989: 	;***************************************************************
                        	   990: 	;	Check if LVALUE is specified in input 
                        	   991: 	;***************************************************************
                        	   992: 
                        	   993: JPTable01:
01:04D2 3A0000          	   994: 		ld 		A,(commParseTable) 			; retrieve command number
01:04D5 B7              	   995: 		or 	  	A 							; error if 0
01:04D6 CAC301          	   996: 		jp 		Z,inputerror
01:04D9 FE1B            	   997: 		cp 		commListLen
01:04DB 3F              	   998: 		ccf 						;complement carry for error indicator
                        	   999: 
01:04DC DAC301          	  1000: 		jp      C,inputerror
                        	  1001: 
01:04DF E5              	  1002: 		push  	HL					; make space in stack for 'return' address
                        	  1003: 
                        	  1004: 		; 								;obtain routine address from table and transfer 
                        	  1005: 		; 								;control to it, leaving all register pairs unchanged
                        	  1006: 		
01:04E0 FD2A0200        	  1007: 		ld   	IY,(commParseTable+2)	; get address $F080+2
01:04E4 FD6E03          	  1008: 		ld   	L,(IY+3)				; load address in HL, move pointer 3 pos forward
01:04E7 FD6604          	  1009: 		ld   	H,(IY+4)
                        	  1010: 
01:04EA E3              	  1011: 		ex 		(SP),HL					;restore old HL, push routine address
01:04EB C9              	  1012: 		ret 							; jump to routine
                        	  1013: 
                        	  1014: argumentsError:
01:04EC CD0000          	  1015: 		call 	writeSTRBelow
01:04EF 00              	  1016: 		DB 		0,"Some arguments mismatch !",CR,LF,00
01:04F0 536F6D6520617267
01:04F8 756D656E7473206D
01:0500 69736D6174636820
01:0508 21
01:0509 0D
01:050A 0A
01:050B 00
01:050C C9              	  1017: 		ret
                        	  1018: 
                        	  1019: 
                        	  1020: p_reset:
01:050D AF              	  1021: 		xor 	A
01:050E 320000          	  1022: 		ld 		(memBankID),A			; set memory banks #0
01:0511 CD0000          	  1023: 		call 	setFLASHBank			; FLASH bank #0
01:0514 AF              	  1024: 		xor 	A
01:0515 CD0000          	  1025: 		call 	setSRAMBank				; ram bank #0
                        	  1026: 
01:0518 CD0000          	  1027: 		call 	enableFLASH			; start from FLASH
                        	  1028: 
01:051B CD0000          	  1029: 		call 	enableIC620_OE 			; enable the outputs.
                        	  1030: 
01:051E C30000          	  1031: 		jp $0000
                        	  1032: 
                        	  1033: p_load:
01:0521 C9              	  1034: 		ret
                        	  1035: p_dumpmem:
01:0522 CD0000          	  1036: 		call 	dumpMemory
                        	  1037: 
01:0525 C9              	  1038: 		ret
                        	  1039: p_pc:
01:0526 C9              	  1040: 		ret
                        	  1041: 
                        	  1042: p_eep:
                        	  1043: 
01:0527 210000          	  1044: 		ld 		HL,000
01:052A 220000          	  1045: 		ld 		(PCvalue),hl
01:052D C9              	  1046: 		ret
                        	  1047: 
                        	  1048: p_clearmem:
                        	  1049: ;		***		clear memory from PC/Adr n bytes from ram memory
                        	  1050: 
01:052E ED4B0000        	  1051: 		ld 		BC,(commLvl1)    	;amount of bytes
01:0532 ED5B0000        	  1052: 		ld   	DE,(PCvalue)		 
01:0536 214005          	  1053: 		ld		hl,.zero_byte
                        	  1054: 		
                        	  1055: .cl_vars:
01:0539 EDA0            	  1056: 		ldi							; (DE)<-(HL)
01:053B 2B              	  1057: 		dec 	hl
01:053C EA3905          	  1058: 		jp		PE,.cl_vars			; 		P/V is set if BC  1  0; otherwise, it is reset.
                        	  1059: 
01:053F C9              	  1060: 		ret
01:0540 00              	  1061: .zero_byte:	db  0
                        	  1062: 
                        	  1063: p_exe:
                        	  1064: 
                        	  1065: 		; call 	LCD_Test
                        	  1066: 
01:0541 C9              	  1067: 		ret
                        	  1068: p_go:
                        	  1069: 
01:0542 18FD            	  1070: 		jr 	p_exe
                        	  1071: 
                        	  1072: 
01:0544 3A0000          	  1073: 		ld 		A,(TempVar1)
01:0547 3C              	  1074: 		inc 	A
01:0548 320000          	  1075: 		ld 		(TempVar1),A
01:054B FE0F            	  1076: 		cp 		15
01:054D CD0000          	  1077: 		call 	DumpRegisters
                        	  1078: 		
01:0550 F0              	  1079: 		ret 	P
01:0551 18EF            	  1080: 		jr 		p_go
                        	  1081: p_incDecPC:
01:0553 210000          	  1082: 		ld 		HL,commLvl1
01:0556 3E00            	  1083: 		ld 		A,0
01:0558 5E              	  1084: 		ld 		E,(HL)
01:0559 23              	  1085: 		inc 	HL
01:055A 56              	  1086: 		ld 		D,(hl) 				; DE = (commLvl1)
                        	  1087: 		; ***	if both D and E is 0 -> DE = 1 		; no param -> A=1
01:055B BB              	  1088: 		cp 		E
01:055C 2006            	  1089: 		jr 		NZ,.justOne
01:055E BA              	  1090: 		cp 		D
01:055F 2003            	  1091: 		jr 		NZ,.justOne
01:0561 110100          	  1092: 		ld 		DE,1
                        	  1093: .justOne:
01:0564 3A0000          	  1094: 		ld 		A,(commParseTable)	; command number in commParseTable
01:0567 2A0000          	  1095: 		ld 		HL,(PCvalue)
01:056A FE08            	  1096: 		cp 		8 					; ++ (increase) ??
01:056C 2003            	  1097: 		jr  	nz,.sub
01:056E 19              	  1098: 		add 	HL,DE 				; increase HL (PCvalue) with DE
01:056F 1803            	  1099: 		jr 		.common
                        	  1100: .sub:
01:0571 A7              	  1101: 		and 	A					; clear C
01:0572 ED52            	  1102: 		sbc 	HL,DE 				; decrease HL (PCvalue) with DE
                        	  1103: .common:
01:0574 220000          	  1104: 		ld 		(PCvalue),HL
01:0577 C9              	  1105: 		ret
                        	  1106: p_flwr:
                        	  1107: 		; *** 	testwrite to FLASH
                        	  1108: 		
                        	  1109: 		; call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
                        	  1110: 		; jp		NZ,argumentsError			; show argument error and return
                        	  1111: 		; 	*** Check if flashmem is enabled
01:0578 3A0000          	  1112: 		ld 		A,(memBankID)
01:057B CB7F            	  1113: 		bit 	7,A
01:057D 2004            	  1114: 		jr 		NZ,errNoFlash
                        	  1115: 
01:057F CD0000          	  1116: 		call 	Flash_WR_Test
01:0582 C9              	  1117: 		ret
                        	  1118: errNoFlash:
01:0583 CD0000          	  1119: 		call 	writeSTRBelow
01:0586 00              	  1120: 		DB 		0," Can't write to deselected FLASH !",CR,LF,00
01:0587 2043616E27742077
01:058F 7269746520746F20
01:0597 646573656C656374
01:059F 656420464C415348
01:05A7 2021
01:05A9 0D
01:05AA 0A
01:05AB 00
                        	  1121: 
01:05AC C9              	  1122: 		ret
                        	  1123: 
                        	  1124: 
                        	  1125: p_flse:
                        	  1126: 		; *** 	erase the sector that contain the address of HL
                        	  1127: 
01:05AD E5              	  1128: 		push	HL
01:05AE 211020          	  1129: 		ld 		HL,$2010
01:05B1 CD0000          	  1130: 		call 	Flash_SE_Erase
01:05B4 E1              	  1131: 		pop 	HL
01:05B5 C9              	  1132: 		ret
                        	  1133: 
                        	  1134: p_xmod:
                        	  1135: 		; ***	Transfer files via x-modem
                        	  1136: 		; ***	Check commParseTable+1 if required parameters
                        	  1137: 
01:05B6 3A0100          	  1138: 		ld 		A,(commParseTable+1)
01:05B9 CB47            	  1139: 		bit 	0,A 			; should be a <2-textstring 	1-address	 0-lvalue>
01:05BB 2804            	  1140: 		jr 		Z,.nxta
                        	  1141: 		; ***	check the commLvl1 if zero
01:05BD ED5B0000        	  1142: 		ld 		DE,(commLvl1)
                        	  1143: .nxta:		
                        	  1144: 
                        	  1145: 		ifndef 	BOOTLOAD				; don not use during BOOT
01:05C1 CD0000          	  1146: 		call 	doImportXMODEM
                        	  1147: 
01:05C4 CD0000          	  1148: 		call 	SIO_A_TXRX_INTon
01:05C7 CD0000          	  1149: 		call 	CTC1_INT_OFF
                        	  1150: 		endif	
01:05CA C9              	  1151: 		ret
                        	  1152: 
                        	  1153: p_C_Read:
                        	  1154: 
01:05CB CD7D07          	  1155: 		call 	checkArgsTAL				; check necessary args
01:05CE C2EC04          	  1156: 		jp		NZ,argumentsError			; show argument error and return
                        	  1157: 	
01:05D1 110000          	  1158: 		ld 		DE,CTC_delay_INT_handler
01:05D4 ED5312F4        	  1159: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1160: 
                        	  1161: 	if 	GPIODEBUG=1
                        	  1162: 		xor A
                        	  1163: 		out (gpio_out),A
                        	  1164: 	endif
                        	  1165: 
01:05D8 CD0000          	  1166: 		call  	SIO_A_DI					; disable text output
                        	  1167: 	if 	GPIODEBUG=1
                        	  1168: 		ld a,4
                        	  1169: 		out (gpio_out),A
                        	  1170: 		ld a,0
                        	  1171: 		out (gpio_out),A
                        	  1172: 	endif
                        	  1173: 	
01:05DB 7B              	  1174: 		ld a,e
01:05DC CD0000          	  1175: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
01:05DF CD0000          	  1176: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
01:05E2 CD0000          	  1177: 		call 	HC376S_ResetAll
01:05E5 CD0000          	  1178: 		call 	HC376S_CheckConnection
01:05E8 3A0000          	  1179: 		ld 		A,(commParseTable)
01:05EB FE0F            	  1180: 		cp 		15							; 15 read SD; 17-read USB
01:05ED 280C            	  1181: 		jr 		Z,.doSD
01:05EF FE15            	  1182: 		cp 		21							; 21 read SD enumerate, 22 read USB enumerate
01:05F1 2808            	  1183: 		jr 		Z,.doSD
01:05F3 CD0000          	  1184: 		call 	HC376S_setUSBMode
01:05F6 CD0000          	  1185: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:05F9 1803            	  1186: 		jr 		.cont
                        	  1187: .doSD:
01:05FB CD0000          	  1188: 		call 	HC376S_setSDMode
                        	  1189: 		
                        	  1190: .cont:
01:05FE CD0000          	  1191: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:0601 2011            	  1192: 		jr 		NZ,abort
                        	  1193: 
01:0603 CD0000          	  1194: 		call 	HC376S_setFileName
01:0606 CD0000          	  1195: 		call 	HC376S_fileOpen
01:0609 2009            	  1196: 		jr 		NZ,abort
                        	  1197: 
01:060B CD0000          	  1198: 		call 	HC376S_getFileSize
01:060E CD0000          	  1199: 		call 	HC376S_fileRead
01:0611 CD0000          	  1200: 		call 	HC376S_fileClose
                        	  1201: abort:
                        	  1202: 
                        	  1203: 		; ***	reset the interrupt handler for CTC
01:0614 CD0000          	  1204: 		call 	SIO_A_EI					; enable text output
01:0617 CD0000          	  1205: 		call 	HC376S_ResetAll
01:061A CD0000          	  1206: 		call 	CTC1_INT_OFF
01:061D 210000          	  1207: 		ld		HL,CTC_CH1_Interrupt_Handler
01:0620 2212F4          	  1208: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
01:0623 C9              	  1209: 		ret
                        	  1210: 
                        	  1211: 		
                        	  1212: p_C_Write:
01:0624 CD7D07          	  1213: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
01:0627 2816            	  1214: 		jr 		Z,.contWR
                        	  1215: 		; ***	check alternative (2 adresses)
01:0629 3E2C            	  1216: 		ld 		A,%101100					; alt. with "string" $Adr1 < $Adr2
01:062B 77              	  1217: 		ld 		(HL),A						; HL-> (commParseTable+1);
01:062C 23              	  1218: 		inc 	HL			; HL-> (commParseTable+2); get the resulting arguments counted
01:062D BE              	  1219: 		cp 		(HL) 						; compare resulting arguments with req arguments
                        	  1220: 
01:062E C2EC04          	  1221: 		jp		NZ,argumentsError			; show argument error and return
                        	  1222: 		
                        	  1223: 		; ***	calculate size from addresses $Adr2 - $Adr1
01:0631 37              	  1224: 		scf
01:0632 3F              	  1225: 		ccf
01:0633 2A0000          	  1226: 		ld 		HL,(commAdr2)
01:0636 ED5B0000        	  1227: 		ld		DE,(commAdr1)
01:063A ED52            	  1228: 		sbc		HL,DE
01:063C 220000          	  1229: 		ld 		(commLvl1),HL				; resulting size in commLvl1
                        	  1230: 
                        	  1231: 
                        	  1232: .contWR:
01:063F 110000          	  1233: 		ld 		DE,CTC_delay_INT_handler
01:0642 ED5312F4        	  1234: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1235: 
01:0646 CD0000          	  1236: 		call 	purgeRXB
01:0649 CD0000          	  1237: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
01:064C CD0000          	  1238: 		call 	HC376S_ResetAll
01:064F CD0000          	  1239: 		call 	HC376S_CheckConnection
01:0652 3A0000          	  1240: 		ld 		A,(commParseTable)
01:0655 FE10            	  1241: 		cp 		16							; 16 read SD; 18-read USB
01:0657 2808            	  1242: 		jr 		Z,.doSD
01:0659 CD0000          	  1243: 		call 	HC376S_setUSBMode
01:065C CD0000          	  1244: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:065F 1803            	  1245: 		jr 		.cont
                        	  1246: .doSD:
01:0661 CD0000          	  1247: 		call 	HC376S_setSDMode
                        	  1248: .cont:
01:0664 CD0000          	  1249: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:0667 20AB            	  1250: 		jr 		NZ,abort
01:0669 CD0000          	  1251: 		call 	HC376S_setFileName
01:066C CD0000          	  1252: 		call 	HC376S_fileCreate
01:066F 20A3            	  1253: 		jr		NZ,abort
01:0671 CD0000          	  1254: 		call 	HC376S_fileWrite
                        	  1255: 		
01:0674 CD0000          	  1256: 		call 	HC376S_fileClose
01:0677 CD0000          	  1257: 		call 	HC376S_ResetAll
01:067A 1898            	  1258: 		jr 		abort
                        	  1259: 
                        	  1260: p_C_Delete:
01:067C CD7D07          	  1261: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1  )
01:067F C2EC04          	  1262: 		jP 		NZ,argumentsError
01:0682 110000          	  1263: 		ld 		DE,CTC_delay_INT_handler
01:0685 ED5312F4        	  1264: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1265: 
01:0689 CD0000          	  1266: 		call 	purgeRXB
01:068C CD0000          	  1267: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
                        	  1268: 
01:068F CD0000          	  1269: 		call 	HC376S_ResetAll
01:0692 CD0000          	  1270: 		call 	HC376S_CheckConnection
01:0695 3A0000          	  1271: 		ld 		A,(commParseTable)
01:0698 FE13            	  1272: 		cp 		19							; 19 delete file SD; 20-delete file USB
01:069A 2808            	  1273: 		jr 		Z,.doSD
01:069C CD0000          	  1274: 		call 	HC376S_setUSBMode
01:069F CD0000          	  1275: 		call 	HC376S_diskConnectionStatus
01:06A2 1803            	  1276: 		jr 		.cont
                        	  1277: .doSD:
01:06A4 CD0000          	  1278: 		call 	HC376S_setSDMode
                        	  1279: .cont:
01:06A7 CD0000          	  1280: 		call 	HC376S_USBdiskMount
                        	  1281: 		 
                        	  1282: 		; call 	HC376S_fileOpen
                        	  1283: 		; call 	HC376S_getFileSize
                        	  1284: 		; call 	HC376S_fileRead
                        	  1285: 
01:06AA CD0000          	  1286: 		call 	HC376S_fileDelete
01:06AD CD0000          	  1287: 		call 	HC376S_ResetAll
                        	  1288: 
01:06B0 C31406          	  1289: 		jp 		abort
                        	  1290: 
                        	  1291: p_cptFl:
01:06B3 CD0000          	  1292: 		call 	setFLASHBank				; change to bank
01:06B6 C9              	  1293: 		ret
01:06B7 CD0000          	  1294: 		call 	setSRAMBank 			; change to bank
01:06BA C9              	  1295: 		ret
                        	  1296: ;********************************************************************************************
                        	  1297: ;********************************************************************************************	
                        	  1298: p_srbank:
                        	  1299: 	; ***	set sram bank #
01:06BB CD4407          	  1300: 	call 	p_FOFF				; disable the flash memory
01:06BE 3A0000          	  1301: 	ld 		A,(commLvl1) 			; load param into A
                        	  1302: ; ***	set the SRAM bank ID; Bank ID in A
                        	  1303: p_srbank0:
                        	  1304: 
01:06C1 E5              	  1305: 	push 	HL
01:06C2 C5              	  1306: 	push 	BC
01:06C3 210000          	  1307: 	ld 		HL,memBankID
01:06C6 E60F            	  1308: 	and 	$0F 				; clear all bits but 0-3 in A
                        	  1309: 
01:06C8 47              	  1310: 	ld 		B,A
01:06C9 7E              	  1311: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:06CA E6F0            	  1312: 	and 	$F0  				; zero bits 0-3
01:06CC 1815            	  1313: 	jr 		putBank
                        	  1314: 
                        	  1315: ;********************************************************************************************
                        	  1316: ;********************************************************************************************	
                        	  1317: 
                        	  1318: p_flbank:
                        	  1319: 	; ***	set flash bank #
                        	  1320: 
01:06CE CDEA06          	  1321: 	call 	p_FON				; enable  the  flash memory
01:06D1 3A0000          	  1322: 	ld 		A,(commLvl1) 			; load param into A
                        	  1323: ; ***	set the FLASH bank ID; Bank ID in A
                        	  1324: p_flbank0:
                        	  1325: 
01:06D4 E5              	  1326: 	push 	HL
01:06D5 C5              	  1327: 	push 	BC
01:06D6 210000          	  1328: 	ld 		HL,memBankID
01:06D9 E607            	  1329: 	and 	$07 				; clear all bits but 0-2
01:06DB 07              	  1330: 	rlca
01:06DC 07              	  1331: 	rlca
01:06DD 07              	  1332: 	rlca
01:06DE 07              	  1333: 	rlca						; bank ID = bits 4-6
                        	  1334: 
01:06DF 47              	  1335: 	ld 		B,A
01:06E0 7E              	  1336: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:06E1 E68F            	  1337: 	and 	$8F  				; zero bits 4-6
                        	  1338: putBank:
01:06E3 B0              	  1339: 	or 		B					; put new EEP bank ID in A...
01:06E4 77              	  1340: 	ld 		(HL),A				; store new value
01:06E5 D300            	  1341: 	out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
01:06E7 C1              	  1342: 	pop  	BC
01:06E8 E1              	  1343: 	pop 	HL
01:06E9 C9              	  1344: 	ret
                        	  1345: 
                        	  1346: ;********************************************************************************************
                        	  1347: ;********************************************************************************************	
                        	  1348: 
                        	  1349: p_FON:
                        	  1350: 		; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0)
                        	  1351: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	  1352: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1353: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:06EA CD0000          	  1354: 	call 	writeSTRBelow
01:06ED 00              	  1355: 	DB 		0," Use 256k FLASH (7 banks),lower 32k and SRAM (16 banks),upper 32k !",CR,LF,00
01:06EE 2055736520323536
01:06F6 6B20464C41534820
01:06FE 28372062616E6B73
01:0706 292C6C6F77657220
01:070E 33326B20616E6420
01:0716 5352414D20283136
01:071E 2062616E6B73292C
01:0726 7570706572203332
01:072E 6B2021
01:0731 0D
01:0732 0A
01:0733 00
01:0734 CD0000          	  1356: 	call 	waitForFinishedPrintout
                        	  1357: p_FON_No_Print: 		;; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0) without printout		
01:0737 E5              	  1358: 	push 	HL
01:0738 210000          	  1359: 	ld 		HL,rstBankID
01:073B CB9E            	  1360: 	res 	3,(HL)				; clear bit 3 -> enable FLASH
01:073D CB96            	  1361: 	res 	2,(HL)				; temp enable reset of IC622
                        	  1362: putBankF:
01:073F 7E              	  1363: 	ld 		A,(HL)
01:0740 D300            	  1364: 	out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
01:0742 E1              	  1365: 	pop 	HL
01:0743 C9              	  1366: 	ret 
                        	  1367: 	
                        	  1368: ;********************************************************************************************
                        	  1369: ;********************************************************************************************	
                        	  1370: p_FOFF:
                        	  1371: 	; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1)
                        	  1372: 	; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	  1373: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1374: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:0744 CD0000          	  1375: 	call 	writeSTRBelow
01:0747 20557365206F6E6C	  1376: 	DB 		" Use only SRAM (16 banks),upper 32k !",CR,LF,00
01:074F 79205352414D2028
01:0757 31362062616E6B73
01:075F 292C757070657220
01:0767 33326B2021
01:076C 0D
01:076D 0A
01:076E 00
01:076F CD0000          	  1377: 	call 	waitForFinishedPrintout
                        	  1378: 
                        	  1379: p_FOFF_No_Print:		; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1) without printout
01:0772 E5              	  1380: 	push 	HL
01:0773 210000          	  1381: 	ld 		HL,rstBankID
01:0776 CBD6            	  1382: 	set 	2,(HL) 			; temp disable reset of IC622
01:0778 CBDE            	  1383: 	set 	3,(HL)			; set bit 3 -> disable FLASH
01:077A 18C3            	  1384: 	jr 		putBankF
                        	  1385: 	; ld 		A,(HL)
                        	  1386: 	; out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
                        	  1387: 	; pop 	HL
                        	  1388: 	; call 	writeSTRBelow
                        	  1389: 	; DB 		0," Use only 512k (16 banks) SRAM !",CR,LF,00
01:077C C9              	  1390: 	ret 
                        	  1391: 
                        	  1392: ;********************************************************************************************     
                        	  1393: ;********************************************************************************************     
                        	  1394: 
                        	  1395: 		; ***	Check commParseTable+1 if required parameters
                        	  1396: checkArgsTAL:		
                        	  1397: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	  1398: 
                        	  1399: 		; ***	try to connect to USB
01:077D 210200          	  1400: 		ld 		HL,commParseTable+2				; resulting typed arguments
01:0780 3E00            	  1401: 		ld 		A,0
01:0782 77              	  1402: 		ld 		(HL),A
                        	  1403: 
01:0783 DD210000        	  1404: 		ld 		IX,commStr1			; commStr1 =			0xB0
01:0787 CDB107          	  1405: 		call 	shift_0_1:
01:078A DD210000        	  1406: 		ld 		IX,commStr2			; commStr2 =			0xD8
01:078E CDB107          	  1407: 		call 	shift_0_1:
01:0791 DD210000        	  1408: 		ld 		IX,commAdr1			; commAdr1 =			0x84
01:0795 CDB107          	  1409: 		call 	shift_0_1:
01:0798 DD210000        	  1410: 		ld 		IX,commAdr2			; commAdr2 =			0x88
01:079C CDB107          	  1411: 		call 	shift_0_1:
01:079F DD210000        	  1412: 		ld 		IX,commLvl1			; commLvl1 =			0x90
01:07A3 CDB107          	  1413: 		call 	shift_0_1:
01:07A6 DD210000        	  1414: 		ld 		IX,commLvl2			; commLvl2 =			0xA0
01:07AA CDB107          	  1415: 		call 	shift_0_1:
                        	  1416: 
01:07AD 7E              	  1417: 		ld 		A,(HL)						; get the resulting arguments counted
01:07AE 2B              	  1418: 		dec 	HL
01:07AF BE              	  1419: 		cp 		(HL) 						; compare resulting arguments with req arguments
01:07B0 C9              	  1420: 		ret 	 					; return with Z or NZ  arguments
                        	  1421: 
                        	  1422: shift_0_1:
01:07B1 DDBE00          	  1423: 		cp 		(IX)
01:07B4 2008            	  1424: 		jr 		NZ,shiftIn1
01:07B6 DDBE01          	  1425: 		cp 		(IX+1)
01:07B9 2003            	  1426: 		jr 		NZ,shiftIn1
                        	  1427: 		; ***	both =0 shift in '0'
01:07BB CB26            	  1428: 		sla		(HL)
01:07BD C9              	  1429: 		ret
                        	  1430: shiftIn1:
                        	  1431: 		; ***	least one not '0' shift in '1'
01:07BE 37              	  1432: 		scf		
01:07BF CB16            	  1433: 		rl 		(HL)
01:07C1 C9              	  1434: 		ret
                        	  1435: 
                        	  1436: 
                        	  1437: ;********************************************************************************************     
                        	  1438: ;********************************************************************************************     
                        	  1439: 
                        	  1440: bit_test9:
01:07C2 01              	  1441: 	db	0x01,0x02,0x80,0x40
01:07C3 02
01:07C4 80
01:07C5 40
                        	  1442: 
                        	  1443: 
                        	  1444: ; debug:		equ	0		; Set to 1 to show debug printing, else 0 
                        	  1445: 
                        	  1446: 
                        	  1447: 	; Spin loop here because there is nothing else to do
                        	  1448: ; halt_loop:
                        	  1449: ; 	halt
                        	  1450: ; 	jp	halt_loop
                        	  1451: 
                        	  1452: 
                        	  1453: 
                        	  1454: 
                        	  1455: 
                        	  1456: ;*******************************************************************************     
                        	  1457: ;*******************************************************************************     
                        	  1458: 
                        	  1459: 
                        	  1460: 
                        	  1461: 		; ld 		hl,Textbuf
                        	  1462: 		; ; call	ReadLine 			;to textbuf  (A=length of input string)
                        	  1463: 
                        	  1464: 		; ld		HL,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	  1465: 		; ld		DE,Textbuf			;DE = 32767
                        	  1466: 		; call	BN2DEC				; C0NVERT
                        	  1467: 		; jp		textloop
                        	  1468: 
                        	  1469: 
                        	  1470: 		; ld 		hl,Textbuf
                        	  1471: 		; call	DEC2BN			; result in HL
                        	  1472: 
                        	  1473: 		; ld 		E,L
                        	  1474: 		; 	; Binary to HEX  BN2HEX   E->(HL)
                        	  1475: 		; ld 		hl,T_BUFFER
                        	  1476: 		; inc		hl
                        	  1477: 		; call	Bin2Hex8			;result in T_buffer
                        	  1478: 
                        	  1479: 		; ld 		iy,T_BUFFER
                        	  1480: 		; call 	WriteLineCRNL
                        	  1481: 
                        	  1482: 		; ld 		iy,Textbuf
                        	  1483: 		; call	WriteLineCRNL
                        	  1484: 
                        	  1485: 		; jp 		next_line
                        	  1486: 
                        	  1487: 
                        	  1488: 
                        	  1489: textloop:
                        	  1490: 		; LD		HL,sourctext1
                        	  1491: 		; LD		DE,S1x
                        	  1492: 		; LD		BC,src_size
                        	  1493: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1494: 
                        	  1495: 
                        	  1496: 		; LD		HL,sourctext2
                        	  1497: 		; LD		DE,S2x
                        	  1498: 		; LD		BC,14
                        	  1499: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1500: 
                        	  1501: 		; test of string concat
                        	  1502: 		; LD		HL,S1_8B		;HL = BASE ADDRESS OF S1
                        	  1503: 		; LD		DE,S2_8B		;DE = BASE ADDRESS OF S2
                        	  1504: 		; LD		B,40			;B = MAXIMUM LENGTH OF STRING 1
                        	  1505: 		; CALL 	CONCAT 			;CONCATENATE STRINGS to S1_8B
                        	  1506: 
                        	  1507: 
                        	  1508: 		; test of POS
                        	  1509: 		; LD		HL,Str2			;HL = BASE ADDRESS OF STRING
                        	  1510: 		; LD		DE,subst		;DE = BASE ADDRESS OF SUBSTRING	
                        	  1511: 		; CALL	POS				;FIND POSITION OF SUBSTRING
                        	  1512: 								; RESULTS IN REGISTER A = 8
                        	  1513: 
                        	  1514: 
                        	  1515: 		; test copy
                        	  1516: 		; LD		HL,Str4			; SOURCE STRING
                        	  1517: 		; LD		DE,COPY_BUFFER	;	DESTINATION STRING
                        	  1518: 		
                        	  1519: 		; LD		C,4				; STARTING INDEX FOR COPYING
                        	  1520: 
                        	  1521: 		; LD		B,6				; NUMBER OF BYTES TO COPY
                        	  1522: 		; LD		A, 25			; MAXIMUM LENGTH OF SUBSTRING
                        	  1523: 		; CALL 	COPY			; COPY SUBSTRING
                        	  1524: 
                        	  1525: 		; ld 		iy,COPY_BUFFER
                        	  1526: 		; call 		WriteLineCRNL ; print the copy string
                        	  1527: 
                        	  1528: 
                        	  1529: 		; ; test DELETE
                        	  1530: 		; LD		HL,Str0		;HL	= BASE 	ADDRESS OF STRING
                        	  1531: 		; LD		A,8			
                        	  1532: 		; LD		C,8				;	C= STARTING INDEX FOR DELETION
                        	  1533: 		; LD		A,4			
                        	  1534: 		; LD		B,4			; B = NUMBER OF CHARACTERS TO DELETE
                        	  1535: 		; CALL 	DELETE 			; DELETE CHARACTERS
                        	  1536: 									; DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	  1537: 		; ld 		iy,Str0
                        	  1538: 		; call 		WriteLineCRNL ; print the copy string
                        	  1539: 
                        	  1540: 
                        	  1541: ; 		;test INSERT
                        	  1542: 
                        	  1543: ; 		LD		HL,Str3				; HL = BASE ADDRESS OF STRING
                        	  1544: ; 		LD		DE,subst			; DE = BASE ADDRESS OF SUBSTRING
                        	  1545: 
                        	  1546: ; 		LD		C,7					; C = STARTING INDEX FOR INSERTION
                        	  1547: 
                        	  1548: ; 		LD		B,0x40				; B = MAXIMUM LENGTH OF STRING
                        	  1549: ; 		CALL 	INSERT_STR			; INSERT SUBSTRING
                        	  1550: ; 		ld 		iy,Str3
                        	  1551: ; 		; call	WriteLineCRNL 		; print the modified string
                        	  1552: 
                        	  1553: 
                        	  1554: ; 		jp		next_line
                        	  1555: 
                        	  1556: ; 		;TEST DATA. CHANGE FOR OTHER VALUES
                        	  1557: ; S1_8B:	DB		8H				; LENGTH OF SI
                        	  1558: ; 		DB      "LASTNAME                        "	; 32 BYTE MAX LENGTH
                        	  1559: ; S2_8B:	DB		0BH				;LENGTH OF S2
                        	  1560: ; 		DB		". FIRSTNAME                     "	; 32 BYTE MAX LENGTH
                        	  1561: 
                        	  1562: ;********************************************************************************************
                        	  1563: ;********************************************************************************************	
                        	  1564: ; sh_test:
                        	  1565: ; 		; turn shadow off then halt
                        	  1566: ; 		xor A
                        	  1567: ; 		out (_CE_RST_BANK),A 		;// clear '64K_SRAM' signal
                        	  1568: 
                        	  1569: ; 		halt
                        	  1570: 
                        	  1571: ; 		ld	A,$80
                        	  1572: ; 		out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	  1573: ; 		ld 	A,1
                        	  1574: ; 		out (_CE_RST_BANK),A 		; engage 3-state on bank#
                        	  1575: ; 		ret
                        	  1576: 
                        	  1577: 
                        	  1578: ;********************************************************************************************
                        	  1579: ;********************************************************************************************	
                        	  1580: 			;9H JUMP TABLE (JTAB)   353
                        	  1581:         ; Title               Jump table
                        	  1582:         ; Name:               JTAB
                        	  1583:         ; Purpose:            Given an index, jump to the subroutine with
                        	  1584:         ;                     that index in a table.
                        	  1585:         ; Entry:              Register A is the subroutine number (0 to
                        	  1586:         ;                                LENSUB-l, the number of subroutines)
                        	  1587:         ;                                LENSUB must be less than or equal to
                        	  1588:         ;                                128.
                        	  1589:         ; Exit:               If the routine number is valid then
                        	  1590:         ;                       execute the routine
                        	  1591:         ;                     else
                        	  1592:         ;                       Carry flag = 1
                        	  1593:         ; Registers used: AF
                        	  1594:         ; Time:               117 cycles plus execution time of subroutine
                        	  1595:         ; Size:               Program 21 bytes plus size of table (2*LENSUB)
                        	  1596: 
                        	  1597:         ;EXIT WITH CARRY SET IF ROUTINE NUMBER IS INVALID
                        	  1598:         ; THAT IS, IF IT IS TOO LARGE FOR TABLE OLENSUB -     1)
                        	  1599: 
                        	  1600: 
                        	  1601: ; JTAB:
                        	  1602: ; 		CP		LENSUB			;COMPARE ROUTINE NUMBER, TABLE SIZE
                        	  1603: ; 		CCF						;COMPLEMENT CARRY FOR ERROR INDICATOR
                        	  1604: ; 		RET		C				;RETURN IF ROUTINE NUMBER TOO LARGE
                        	  1605: ; 									; WITH CARRY SET
                        	  1606: ; 		; INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
                        	  1607: ; 		; LEAVE REGISTER PAIRS UNCHANGED SO THEY CAN BE USED FOR PASSING PARAMETERS
                        	  1608: 
                        	  1609: ; 		PUSH	HL				;SAVE HL
                        	  1610: ; 		ADD		A,A				;DOUBLE INDEX FOR WORD-LENGTH ENTRIES
                        	  1611: ; 		LD		HL,JMPTAB		;INDEX INTO TABLE USING 8-BIT
                        	  1612: ; 		ADD		A,L			; ADDITION TO AVOID DISTURBING
                        	  1613: ; 		LD		L,A				; ANOTHER REGISTER PAIR
                        	  1614: ; 		LD		A,0
                        	  1615: ; 		ADC		A,H
                        	  1616: ; 		LD		H,A			; ACCESS ROUTINE ADDRESS
                        	  1617: ; 			;OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
                        	  1618: ; 			;CONTROL TO IT, LEAVING ALL REGISTER PAIRS UNCHANGED
                        	  1619: 
                        	  1620: ; 		LD		A, (HL)			;MOVE ROUTINE ADDRESS TO HL
                        	  1621: ; 		INC		HL
                        	  1622: ; 		LD		H, (HL)
                        	  1623: ; 		LD		L,A
                        	  1624: ; 		EX		(SP),HL				;RESTORE OLD HL, PUSH ROUTINE ADDRESS
                        	  1625: ; 		RET						; JUMP TO ROUTI NE
                        	  1626: 
                        	  1627: ; LENSUB		EQU		3				;NUMBER OF SUBROUTINES IN TABLE
                        	  1628: ; JMPTAB:                            ;JUMP TABLE
                        	  1629: ; 		DW		SUB0			;ROUTINE 0
                        	  1630: ; 		DW		SUB1			;ROUTINE 1
                        	  1631: ; 		DW		SUB2			;ROUTINE 2
                        	  1632: ;            ;THREE TEST SUBROUTINES FOR JUMP TABLE
                        	  1633: ; SUB0:
                        	  1634: ; 		LD		A,1				; TEST ROUTI NE 0 SETS (A)    1
                        	  1635: ; 		RET
                        	  1636: ; SUB1:
                        	  1637: ; 		LD		A,2				; TEST ROUTI NE 1 SETS (A) = 2
                        	  1638: ; 		RET
                        	  1639: ; SUB2:
                        	  1640: ; 		LD		A,3				;TEST ROUTINE 2 SETS (A)      3
                        	  1641: ; 		RET
                        	  1642: 
                        	  1643: 
                        	  1644: 
                        	  1645: ; 			;SAMPLE EXECUTION:
                        	  1646: 
                        	  1647: 
                        	  1648: ; SC9H:
                        	  1649: ; 		SUB		A				;EXECUTE ROUTINE 0
                        	  1650: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   =1
                        	  1651: 
                        	  1652: ; 		LD		A,1				;EXECUTE ROUTINE 1
                        	  1653: ; 		CALL	JTAB			; AFTER EXECUTION, (A) = 2
                        	  1654: ; 		LD		A,2				;EXECUTE ROUTINE 2
                        	  1655: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   3
                        	  1656: ; 		LD		A,3				;EXECUTE ROUTINE 3
                        	  1657: ; 		CALL	JTAB			; AFTER EXECUTION, CARRY   1
                        	  1658: ; 		JR		SC9H			;LOOP FOR MORE TESTS
                        	  1659: 
                        	  1660: 
                        	  1661: ;********************************************************************************************
                        	  1662: ;********************************************************************************************	
                        	  1663: ; 		xref  	RDATA,RDATA_END,TB_length
                        	  1664: 
                        	  1665: ; 		;--------------------------------------------------
                        	  1666: ; 		; ld A,5
                        	  1667: ; 		; ld 	A,$00	
                        	  1668: ; 		; out (_Z80_BankCS),A		;// set bank register number 	
                        	  1669: ; 		ld 	A,$01
                        	  1670: ; 		out (_CE_RST_BANK),A 		;// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	  1671: 
                        	  1672: ; 		out (_8Bitsout),A
                        	  1673: 
                        	  1674: ; 		ld A, $0F                 ;mode 1 out
                        	  1675: ; 		out (portA_Contr), A         ; set port A as output
                        	  1676: ; 		ld A,$EB
                        	  1677: 
                        	  1678: ; Rtll:	
                        	  1679: 
                        	  1680: ; 		ld (40000),A
                        	  1681: ; 		ld A,0
                        	  1682: ; 		ld A,(40000)
                        	  1683: 
                        	  1684: ; 		out (portA_Data),A		; Data to PIO port A
                        	  1685: ; 		out (_8Bitsout),A
                        	  1686: ; 		;--------------------------------------------------
                        	  1687: ; 		ld	DE,$8200
                        	  1688: ; 		ld	HL,RDATA
                        	  1689: ; 		ld	BC,TB_length
                        	  1690: ; 		; ld	BC,RDATA_END-RDATA
                        	  1691: ; 		ldir
                        	  1692: 
                        	  1693: 
                        	  1694: ; SIO_A_RESET:
                        	  1695: ; 		ld	a,00110000b
                        	  1696: ; 		out	(SIO_A_C),A		;write into WR0: error reset, select WR0
                        	  1697: 
                        	  1698: ; 		ld	a,018h				;write into WR0: channel reset
                        	  1699: ; 		out (SIO_A_C),A 
                        	  1700: 
                        	  1701: ; 		ld	a,004h				;write into WR0: select WR4
                        	  1702: ; 		out	(SIO_A_C),A
                        	  1703: ; 		ld	a,44h				;44h write into WR4: clkx16,1 stop bit, no parity
                        	  1704: ; 		out (SIO_A_C),A
                        	  1705: 
                        	  1706: ; 		ld	a,005h				;write into WR0: select WR5
                        	  1707: ; 		out (SIO_A_C),A
                        	  1708: ; 		ld	a,01101000b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS inactive (bit 2)
                        	  1709: ; 		ld	a,01101010b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS active (bit 2)
                        	  1710: ; 		out (SIO_A_C),A
                        	  1711: ; SIO_A_EI:
                        	  1712: ; 			;enable SIO channel A RX
                        	  1713: ; 		ld	a,003h				;write into WR0: select WR3
                        	  1714: ; 		out (SIO_A_C),A
                        	  1715: ; 		ld	a,11000001b				;RX 8bit, auto enable off 8(bit 5), RX on (bit 0)
                        	  1716: ; 		ld	a,11100001b				;RX 8bit, auto enable on 8(bit 5), RX on (bit 0)
                        	  1717: ; 		out (SIO_A_C),A
                        	  1718: ; 		;Channel A RX active
                        	  1719: 
                        	  1720: 
                        	  1721: ; 		ld 	HL,Str0
                        	  1722: ; tstout:
                        	  1723: ; 		ld 	A,(HL)
                        	  1724: ; 		out (SIO_A_D),A
                        	  1725: ; 		inc HL
                        	  1726: ; 		ld D,A
                        	  1727: ; chkTX:
                        	  1728: ; 		in	A,(SIO_A_C)		; read status
                        	  1729: ; 		bit	2,A					; all sent ?
                        	  1730: ; 		jr z,chkTX				; not all sent..
                        	  1731: 
                        	  1732: ; 		ld 	A,(HL)
                        	  1733: ; 		cp	0
                        	  1734: ; 		jr 	z,endmsg
                        	  1735: 
                        	  1736: ; 		ld	A,D
                        	  1737: ; 		djnz	tstout
                        	  1738: 
                        	  1739: ; endmsg:
                        	  1740: ; chkRX:
                        	  1741: ; 		in	A,(SIO_A_C)		; read status
                        	  1742: ; 		bit	0,A					; char present ??
                        	  1743: ; 		jr z,chkRX				; check again
                        	  1744: 
                        	  1745: ; 		in 	A,(SIO_A_D)		; read the char.
                        	  1746: 
                        	  1747: ; 		out (SIO_A_D),A
                        	  1748: ; chkTX2:
                        	  1749: ; 		in	A,(SIO_A_C)		; read status
                        	  1750: ; 		bit	2,A					; all sent ?
                        	  1751: ; 		jr z,chkTX2
                        	  1752: 		
                        	  1753: ; 		jr	endmsg				; not all sent..
                        	  1754: 
                        	  1755: 
                        	  1756: 
                        	  1757: 
                        	  1758: ; 		halt
                        	  1759: ; 		halt
                        	  1760: ; 		halt
                        	  1761: ; 		inc A
                        	  1762: ; 		jr Rtll			
                        	  1763: 
                        	  1764: ; 	if DOALIGN
                        	  1765: ; 		align 4
                        	  1766: ; 	endif
                        	  1767: 
                        	  1768: 
                        	  1769: .end
                        	  1770: 


Symbols by name:
AddToT_Buf                      external
BLKMOV                          external EXP
BN2DEC                          external EXP
BN2DEC_S                        external EXP
Bin2Hex16                       external EXP
Bin2Hex8                        external EXP
BootCode                        external
BootCodeAdr                     external
CDEL                             E:00EE
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CONCAT                          external EXP
COPY                            external EXP
CR                               E:000D
CRC16                           external EXP
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       external
CTC_Init                        external
CTC_delay_INT_handler           external
DEC2BN                          external EXP
DELETE                          external EXP
DumpRegisters                   external
Flash_SE_Erase                  external
Flash_WR_Test                   external
GPIODEBUG                        E:0000
HC376S_CheckConnection          external
HC376S_ResetAll                 external
HC376S_USBdiskMount             external
HC376S_diskConnectionStatus     external
HC376S_fileClose                external
HC376S_fileCreate               external
HC376S_fileDelete               external
HC376S_fileOpen                 external
HC376S_fileRead                 external
HC376S_fileWrite                external
HC376S_getFileSize              external
HC376S_setFileName              external
HC376S_setSDMode                external
HC376S_setUSBMode               external
HEX2BN                          external EXP
INSERT_STR                      external EXP
ITEM                             E:001C
InitBuffers                     external EXP
InitInterrupt                   external EXP
JPTable01                       01:04D2
LF                               E:000A
LISTEND                          E:001E
MFILL                           external EXP
MONITOR_Start                   01:0000 EXP
PCinpFlag                       external
PCvalue                         external
PIO_Init                        external
POS                             external EXP
ReadChar                        external EXP
ReadLine                        external EXP
RegFlags                        external EXP
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
S1x                             external
SD_USB_startup                  00:0003 EXP
SDabort                         00:020E
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        external
SIO_A_EI                        external
SIO_A_RTS_OFF                   external EXP
SIO_A_RTS_ON                    external EXP
SIO_A_TXRX_INTon                external
SIO_B_C                         external
SIO_B_D                         external
SIO_Init                        external
SIO_Int_Vec                      E:F400
SP_value                        external
STEND                            E:001D
S_head_tail                     external EXP
T_BUFFER                        external
TempVar1                        external
Textbuf                         external EXP
WriteChar                       external EXP
WriteLine                       external
WriteLineCRNL                   external
_CE_RST_BANK                    external
_RAMSTART                       external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
abort                           01:0614
argumentsError                  01:04EC
bit_test9                       01:07C2
byteEnd                         01:0481
changePCVal                     01:04A2
checkArgsTAL                    01:077D
checkaddress                    01:0404
chkADR                          01:040F
chkADR1                         01:0410
chkADR2                         01:0420
chkLVL2                         01:0442
cleanInBuffer                   external EXP
cleanOutBuffer                  external EXP
commAdr1                        external
commAdr2                        external
commListLen                      E:001B
commLvl1                        external
commLvl2                        external
commParseTable                  external
commStr1                        external
commStr2                        external
command_list                    01:01F6
crc16_2                         external EXP
doImportXMODEM                  external
dumpMemory                      external EXP
enableFLASH                     external
enableIC620_OE                  external
endtext                         external EXP
errNoFlash                      01:0583
executeCommand                  01:04BE
findCommandInList               01:0193
findNextITEM                    01:019F
getLvalue                       01:0432
gpioB                           external
gpio_in                         external
gpio_out                        external
inBuffer                        external EXP
inBufferEnd                     external EXP
initCommParseTable              01:03A6
initSIOBInterrupt               external
inputerror                      01:01C3
isHex                           external EXP
makeASCIItoHEX                  01:0452
matchInList                     01:03B9
memBankID                       external
nextHalfByte                    01:0460
nextInList                      01:01BF
next_line                       01:0116
noHighNib                       01:049E
p_C_Delete                      01:067C
p_C_Read                        01:05CB
p_C_Read_SD                     00:01DE
p_C_Write                       01:0624
p_FOFF                          01:0744
p_FOFF_No_Print                 01:0772
p_FON                           01:06EA
p_FON_No_Print                  01:0737
p_clearmem                      01:052E
p_cptFl                         01:06B3
p_dumpmem                       01:0522
p_eep                           01:0527
p_exe                           01:0541
p_flbank                        01:06CE
p_flbank0                       01:06D4
p_flse                          01:05AD
p_flwr                          01:0578
p_go                            01:0542
p_incDecPC                      01:0553
p_load                          01:0521
p_pc                            01:0526
p_reset                         01:050D
p_srbank                        01:06BB
p_srbank0                       01:06C1
p_xmod                          01:05B6
paramLoopEntry                  01:03D0
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external
putBank                         01:06E3
putBankF                        01:073F
putDEtoScreen                   external
rfile_name                      00:01CE
rstBankID                       external
scanCommandList                 01:018E
setFLASHBank                    external
setSRAMBank                     external
shiftIn1                        01:07BE
shift_0_1                       01:07B1
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             external
skipPriorDelimit                external
sourctext1                      external EXP
sourctext2                      external EXP
src_size                        external EXP
st1g2                           external EXP
st2g1                           external EXP
steq                            external EXP
strCompare                      external EXP
subst                           external EXP
temp_finish                     01:04CF
textloop                        01:07C6
useFlash                        01:0127
waitForFinishedPrintout         external
writeSTRBelow                   external EXP
zero_byte                       01:019E

Symbols by value:
0000 GPIODEBUG
0000 MONITOR_Start
0003 SD_USB_startup
000A LF
000D CR
001B commListLen
001C ITEM
001D STEND
001E LISTEND
00EE CDEL
0116 next_line
0127 useFlash
018E scanCommandList
0193 findCommandInList
019E zero_byte
019F findNextITEM
01BF nextInList
01C3 inputerror
01CE rfile_name
01DE p_C_Read_SD
01F6 command_list
020E SDabort
03A6 initCommParseTable
03B9 matchInList
03D0 paramLoopEntry
0404 checkaddress
040F chkADR
0410 chkADR1
0420 chkADR2
0432 getLvalue
0442 chkLVL2
0452 makeASCIItoHEX
0460 nextHalfByte
0481 byteEnd
049E noHighNib
04A2 changePCVal
04BE executeCommand
04CF temp_finish
04D2 JPTable01
04EC argumentsError
050D p_reset
0521 p_load
0522 p_dumpmem
0526 p_pc
0527 p_eep
052E p_clearmem
0541 p_exe
0542 p_go
0553 p_incDecPC
0578 p_flwr
0583 errNoFlash
05AD p_flse
05B6 p_xmod
05CB p_C_Read
0614 abort
0624 p_C_Write
067C p_C_Delete
06B3 p_cptFl
06BB p_srbank
06C1 p_srbank0
06CE p_flbank
06D4 p_flbank0
06E3 putBank
06EA p_FON
0737 p_FON_No_Print
073F putBankF
0744 p_FOFF
0772 p_FOFF_No_Print
077D checkArgsTAL
07B1 shift_0_1
07BE shiftIn1
07C2 bit_test9
07C6 textloop
F400 SIO_Int_Vec
F412 CTC_CH1_I_Vector
