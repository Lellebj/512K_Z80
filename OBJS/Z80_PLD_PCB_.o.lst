Sections:
00: "SD_USB_Start" (0-22B)
01: "Monitor" (0-80E)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     4: 		include 	"Salea_Logic.inc"

Source: "Salea_Logic.inc"
                        	     1: 
                        	     2: ;       *** 
                        	     3: 
                        	     4:     macro make_pulse 
                        	     5: 
                        	     6:     xor     A
                        	     7:     set     \1,A    
                        	     8:     out (gpio_out),A
                        	     9:     out (gpio_out),A
                        	    10:     out (gpio_out),A
                        	    11:     out (gpio_out),A
                        	    12:     xor     A
                        	    13:     out (gpio_out),A
                        	    14:     
                        	    15: 
                        	    16:     endm

Source: "stdin"
                        	     5: 	
                        	     6: 
                        	     7: 
                        	     8: 
                        	     9: 
                        	    10: 			xref	Bin2Hex8,Bin2Hex16,  HEX2BN, BN2DEC,BN2DEC_S,DEC2BN,MFILL, BLKMOV,strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR
                        	    11: 			xref	InitBuffers, ReadLine, WriteChar, ReadChar, S_head_tail
                        	    12: 			xref	Textbuf, inBufferEnd,inBuffer,cleanInBuffer,cleanOutBuffer,InitInterrupt
                        	    13: 			xref	dumpMemory
                        	    14: 
                        	    15: 			xref	st2g1,st1g2,steq,subst
                        	    16: 			xref	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	    17: 			xref	sourctext1,sourctext2,endtext,src_size, writeSTRBelow,isHex
                        	    18: 
                        	    19: 			xref 	crc16_2,CRC16
                        	    20: 		
                        	    21: 		xref 	SIO_A_RTS_OFF,SIO_A_RTS_ON
                        	    22: 
                        	    23: 	;***************************************************************
                        	    24: 	;SAMPLE EXECUTION:
                        	    25: 	;***************************************************************
                        	    26: GPIODEBUG EQU 0
                        	    27: 
                        	    28: DO_Debug:	equ	0		; Set to 1 to show debug printing, else 0 
                        	    29: 
                        	    30: 	GLOBAL  MONITOR_Start, SD_USB_startup
                        	    31: ;************************************************************************************************
                        	    32: ;************************************************************************************************
                        	    33: ;***		SDcard/USB startup sequence
                        	    34: ;************************************************************************************************
                        	    35: ;************************************************************************************************
                        	    36: 		section SD_USB_Start
                        	    37: 
                        	    38: 
00:0000 C30000          	    39: 		jp 		MONITOR_Start 		; jump to MONITOR_Start if hard call to $D000
                        	    40: 
                        	    41: SD_USB_startup:
                        	    42: 
                        	    43: 	if  	GPIODEBUG = 1
                        	    44: 		ld 		A,$33
                        	    45: 		out 	(gpio_out),A
                        	    46: 
                        	    47: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	    48: 
                        	    49: 		ld 		(SP_value),SP
                        	    50: 
                        	    51: 		ld 		A,$AA
                        	    52: 		out 	(gpio_out),A
                        	    53: 		
                        	    54: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    55: 				; initialize buffer counters and pointers.
                        	    56: 		ld 		A,$BB
                        	    57: 		out 	(gpio_out),A
                        	    58: 
                        	    59: 			call	PIO_Init
                        	    60: 		ld 		A,$CC
                        	    61: 		out 	(gpio_out),A
                        	    62: 			call 	CTC_Init
                        	    63: 		ld 		A,$DD
                        	    64: 		out 	(gpio_out),A
                        	    65: 			call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	    66: 		ld 		A,$DF
                        	    67: 		out 	(gpio_out),A
                        	    68: 			call	S_head_tail			; save input heads and tails
                        	    69: 		ld 		A,$81
                        	    70: 		out 	(gpio_out),A
                        	    71: 	
                        	    72: 	else
                        	    73: 	
00:0003 CD0000          	    74: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    75: 			; initialize buffer counters and pointers.
00:0006 CD0000          	    76: 		call	PIO_Init
00:0009 CD0000          	    77: 		call 	CTC_Init
00:000C CD0000          	    78: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
00:000F CD0000          	    79: 		call	S_head_tail			; save input heads and tails
                        	    80: 	endif
                        	    81: 
                        	    82: 
                        	    83: 		; call	sh_test
                        	    84: 		; call 	Flash_WR_Test
                        	    85: 		; ld	HL,$2010
                        	    86: 		; call	Flash_SE_Erase
                        	    87: 
                        	    88: 		; check  $D008-$D00B for $33333333 -> Startup code is preloaded from Arduino 
                        	    89: 		; check  $D008-$D00B for $CCCCCCCC -> start from Flash 
                        	    90: 
00:0012 210000          	    91: 		ld 		HL,BootCodeAdr
00:0015 0604            	    92: 		ld 		B,04
00:0017 3E33            	    93: 		ld 		A,'3'
                        	    94: .checkBootCode:
00:0019 BE              	    95: 		cp 		(HL)	
00:001A 23              	    96: 		inc 	HL
00:001B C2DF00          	    97: 		jp 		NZ,.SDstart
00:001E 10F9            	    98: 		djnz 	.checkBootCode
                        	    99: 
                        	   100: 
00:0020 CD0000          	   101: 		call	CRLF
00:0023 CD0000          	   102: 		call 	writeSTRBelow
00:0026 0D0A            	   103: 		defb   	"\r\n"
00:0028 2B2D3D2D2B2D3D2D	   104: 		defb	"+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-\r\n"
00:0030 2B2D3D2D2B2D3D2D
00:0038 2B2D3D2D2B2D3D2D
00:0040 2B2D3D2D2B2D3D2D
00:0048 2B2D3D2D2B2D3D2D
00:0050 0D0A
00:0052 5374617274206672	   105: 		defb	"Start from Arduino preloaded monitor\r\n"
00:005A 6F6D204172647569
00:0062 6E6F207072656C6F
00:006A 61646564206D6F6E
00:0072 69746F720D0A
00:0078 202020206769743A	   106: 		defb	"    git: Working-260225-0-gf9cc9ce-dirty\r\n"
00:0080 20576F726B696E67
00:0088 2D3236303232352D
00:0090 302D676639636339
00:0098 63652D6469727479
00:00A0 0D0A
00:00A2 202020206275696C	   107: 		defb	"    build: 2026-02-27_20:39\r\n"
00:00AA 643A20323032362D
00:00B2 30322D32375F3230
00:00BA 3A33390D0A
00:00BF 20202020464C4153	   108: 		defb	"    FLASH->SRAM 0xD000.\r\n"
00:00C7 482D3E5352414D20
00:00CF 3078443030302E0D
00:00D7 0A
00:00D8 00              	   109: 		defb	"\0"
                        	   110: 
00:00D9 CD0000          	   111: 		call 	waitForFinishedPrintout
00:00DC C30000          	   112: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   113: 		
                        	   114: 
                        	   115: .SDstart:
                        	   116: 		
00:00DF CD0000          	   117: 		call	CRLF
00:00E2 CD0000          	   118: 		call 	writeSTRBelow
00:00E5 0D0A            	   119: 		defb   	"\r\n"
00:00E7 3D2D3D2D3D2D3D2D	   120: 		defb	"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\r\n"
00:00EF 3D2D3D2D3D2D3D2D
00:00F7 3D2D3D2D3D2D3D2D
00:00FF 3D2D3D2D3D2D3D2D
00:0107 3D2D3D2D3D2D3D2D
00:010F 0D0A
00:0111 5374617274206672	   121: 		defb	"Start from SD/USB\r\n"
00:0119 6F6D2053442F5553
00:0121 420D0A
                        	   122: 		; defb	"    git: Working-260225-0-gf9cc9ce-dirty\r\n"
                        	   123: 		; defb	"    build: 2026-02-27_20:39\r\n"
                        	   124: 		; defb	"    FLASH->SRAM 0xD000.\r\n"
00:0124 00              	   125: 		defb	"\0"
                        	   126: 
00:0125 CD0000          	   127: 		call 	waitForFinishedPrintout
                        	   128: 
                        	   129: 	ifd 	GPIODEBUG
00:0128 3E83            	   130: 	ld 		A,$83
00:012A D302            	   131: 	out 	(gpio_out),A
                        	   132: 	endif
00:012C CD0000          	   133: 		call	CRLF
                        	   134: 
                        	   135: ;*****	Setup Boot load from SD card.
                        	   136: ;***************************************
00:012F 110000          	   137: 		ld 		DE,commStr1					; save filename in commStr1
00:0132 21D301          	   138: 		ld 		HL,rfile_name
                        	   139: .nxtchr:
00:0135 EDA0            	   140: 		ldi									; (DE) <- (HL) 
00:0137 7E              	   141: 		ld 		A,(HL)
00:0138 B7              	   142: 		or 		A 							; = 0 ?
00:0139 20FA            	   143: 		jr  	NZ,.nxtchr
00:013B 12              	   144: 		ld 		(DE),A						; save '0'
00:013C 210000          	   145: 		ld 		HL,S1x						; result in S1x
00:013F 220000          	   146: 		ld 		(commAdr1),HL
                        	   147: 
00:0142 CDE301          	   148: 		call 	p_C_Read_SD
                        	   149: 
                        	   150: 
                        	   151: ;***	correct $0A to $00 $00 in S1x (check for ascii lower than $20)
00:0145 210000          	   152: 		ld 		HL,S1x
00:0148 3E20            	   153: 		ld 		A,$20
00:014A 110000          	   154: 		ld 		DE,commStr1
                        	   155: 
                        	   156: .find0A:
00:014D EDA0            	   157: 		ldi						; (DE) <- (HL) 
00:014F BE              	   158: 		cp 		(HL)			; char lower than ' '  $20 - (HL)
00:0150 FA4D01          	   159: 		jp 		M,.find0A		; char > ' '...
                        	   160: 
00:0153 3E00            	   161: 		ld 		A,00
00:0155 12              	   162: 		ld 		(de),A
00:0156 13              	   163: 		inc 	de
00:0157 12              	   164: 		ld 		(de),A			; strip eventually $0A, $0D, ...
00:0158 13              	   165: 		inc 	de
00:0159 12              	   166: 		ld 		(de),A			; Boot file name present in commStr1
00:015A 210000          	   167: 		ld 		HL,_RAMSTART
00:015D 220000          	   168: 		ld 		(commAdr1),HL 	; place adress for boot file...
00:0160 CDE301          	   169: 		call 	p_C_Read_SD		; read and place boot file.
                        	   170: 
                        	   171: 
00:0163 CD0000          	   172: 		call 	writeSTRBelow
00:0166 0D0A555345205241	   173: 		defb   "\r\nUSE RAM bank #0, Copy FLASH Boot seq\r\n"
00:016E 4D2062616E6B2023
00:0176 302C20436F707920
00:017E 464C41534820426F
00:0186 6F74207365710D0A
00:018E 546F2052414D2062	   174: 		defb   "To RAM bank #1 ($0-$2000) \r\n"
00:0196 616E6B2023312028
00:019E 24302D2432303030
00:01A6 29200D0A
00:01AA 4A756D7020746F20	   175: 		defb	"Jump to MONITOR_Start! ($D000)\r\n",0,0,0
00:01B2 4D4F4E49544F525F
00:01BA 5374617274212028
00:01C2 2444303030290D0A
00:01CA 00
00:01CB 00
00:01CC 00
00:01CD CD0000          	   176: 		call 	waitForFinishedPrintout
                        	   177: 
00:01D0 C30000          	   178: 		jp 		MONITOR_Start			; monitor start $D000 MONITOR_Start:
                        	   179: 
                        	   180: rfile_name:
00:01D3 424F4F5446494C45	   181: 	 db "BOOTFILE.TXT",0,0,0,0
00:01DB 2E545854
00:01DF 00
00:01E0 00
00:01E1 00
00:01E2 00
                        	   182: 	; db "PROVIDE.txt",0,0,0,0
                        	   183: 
                        	   184: 	
                        	   185: ;************************************************************************************************
                        	   186: ;************************************************************************************************
                        	   187: p_C_Read_SD:
                        	   188: 
                        	   189: 		;call 	checkArgsTAL				; check necessary args
                        	   190: 		;jp		NZ,argumentsError			; show argument error and return
                        	   191: 	
00:01E3 110000          	   192: 		ld 		DE,CTC_delay_INT_handler
00:01E6 ED5312F4        	   193: 		ld 		(CTC_CH1_I_Vector),DE
                        	   194: 	ifd 	GPIODEBUG
00:01EA AF              	   195: 	xor A
00:01EB D302            	   196: 	out (gpio_out),A
                        	   197: 	endif
                        	   198: 		; call  	SIO_A_DI					; disable text output
                        	   199: 	ifd 	GPIODEBUG
00:01ED 3E04            	   200: 	ld a,4
00:01EF D302            	   201: 	out (gpio_out),A
00:01F1 3E00            	   202: 	ld a,0
00:01F3 D302            	   203: 	out (gpio_out),A
                        	   204: 	endif
                        	   205: 
00:01F5 7B              	   206: 		ld a,e	
                        	   207: 
00:01F6 CD0000          	   208: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
00:01F9 CD0000          	   209: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
00:01FC CD0000          	   210: 		call 	HC376S_ResetAll
00:01FF CD0000          	   211: 		call 	HC376S_CheckConnection
                        	   212: 		; ld 		A,(commParseTable)
                        	   213: 		; cp 		15							; 15 read SD; 17-read USB
                        	   214: 		; jr 		Z,.doSD
                        	   215: 		; cp 		21							; 21 read SD enumerate, 22 read USB enumerate
                        	   216: 		; jr 		Z,.doSD
                        	   217: 		; call 	HC376S_setUSBMode
                        	   218: 		; call 	HC376S_diskConnectionStatus		; dont use with SD card
                        	   219: 		; jr 		.cont
                        	   220: .doSD:
00:0202 CD0000          	   221: 		call 	HC376S_setSDMode
                        	   222: 		
                        	   223: .cont:
00:0205 CD0000          	   224: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:0208 2014            	   225: 		jr 		NZ,SDabort
                        	   226: 
                        	   227: 
00:020A CD0000          	   228: 		call 	HC376S_setFileName
00:020D CD0000          	   229: 		call 	HC376S_fileOpen
00:0210 200C            	   230: 		jr 		NZ,SDabort
00:0212 CD0000          	   231: 		call 	waitForFinishedPrintout
                        	   232: 
00:0215 CD0000          	   233: 		call 	HC376S_getFileSize
00:0218 CD0000          	   234: 		call 	HC376S_fileRead
00:021B CD0000          	   235: 		call 	HC376S_fileClose
                        	   236: SDabort:
                        	   237: 
                        	   238: 		; ***	reset the interrupt handler for CTC
                        	   239: 		; call 	SIO_A_EI					; enable text output
00:021E CD0000          	   240: 		call 	HC376S_ResetAll
00:0221 CD0000          	   241: 		call 	CTC1_INT_OFF
00:0224 210000          	   242: 		ld		HL,CTC_CH1_Interrupt_Handler
00:0227 2212F4          	   243: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:022A C9              	   244: 		ret
                        	   245: 
                        	   246: MONITOR_Start0:	
                        	   247: 
                        	   248: ;***********************************************************************
                        	   249: ;***********************************************************************
                        	   250: 
                        	   251: 		section	Monitor			; enter point for monitor
                        	   252: 
                        	   253: ;***********************************************************************
                        	   254: ;***	MONITOR_Start:  entry point for monitor, should be at $D000.
                        	   255: ;***********************************************************************
                        	   256: 
                        	   257: MONITOR_Start:		
                        	   258: 
                        	   259: 		; ***	should be start address $D000
                        	   260: 		;jr 		.makeShadowRAM
01:0000 CD0000          	   261: 		call	CRLF
01:0003 CD0000          	   262: 		call 	writeSTRBelow
01:0006 0D0A            	   263: 		defb   	"\r\n"
01:0008 536B697020536861	   264: 		defb	"Skip Shadowram \r\n\0"
01:0010 646F7772616D200D
01:0018 0A00
01:001A 00              	   265: 		defb 	0x00
                        	   266: 
                        	   267: 
01:001B 1839            	   268: 		jr 		.skipBlockCopy		; use Flash mem and SRAM normally
                        	   269: 	align 3
                        	   270: 		; Ref. vlink_Z80_.ld
                        	   271: 		; BootCode in $D008-D00B = $00000000 - $AAAAAAAA': copy from flash
                        	   272: 		; BootCode in $D008-D00B = $CCCCCCCC: code uploaded from xmodem/or DMA. Do not copy from flash
                        	   273: 		; BootCode in $D008-D00B = $33333333: code uploaded from Arduino. Do not copy from flash, 
01:0020 01010101        	   274: 		defl 	    $01010101
                        	   275: 		;defl 		BootCode
                        	   276: 		align	3
                        	   277: 
                        	   278: 
                        	   279: 	;call 	waitForFinishedPrintout
                        	   280: 	
                        	   281: .makeShadowRAM:
                        	   282: 
                        	   283: 	ifd 	GPIODEBUG
01:0028 3E33            	   284: 	ld 		A,$33
01:002A D302            	   285: 	out 	(gpio_out),A
                        	   286: 	endif
                        	   287: ;		***  	NOFLASH - Don not use the FLASH mem -> 64kRAM
                        	   288: ; 		*** 	Copy Flash boot sequence to RAM bank #1
                        	   289: ; 		*** 	first to temp storage area.
                        	   290: 
                        	   291: ;		***	 	Copy 128 blocks of 256 bytes from flash to RAM bank #0, then copy to RAM bank #1
                        	   292: 
01:002C 0680            	   293: 		ld  	B,128		; count 128 blocks of 256 bytes
                        	   294: .loopBlocks:
01:002E C5              	   295: 		push  	BC 			; save BC as block counter
01:002F 018000          	   296: 		ld     	BC,128		; byte counter
                        	   297: 
01:0032 21FF7F          	   298: 		ld 		HL,$7FFF		; end of flash memory area
01:0035 11FFCF          	   299: 		ld 		DE,$CFFF		; temp storage area 0xCF00-CFFF		
01:0038 E5              	   300: 		push 	HL
01:0039 D5              	   301: 		push 	DE
01:003A EDB8            	   302: 		lddr					; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0		
                        	   303: 
                        	   304: ; 		*** 	secondly: to Rambank #1 storage area. deselect FLASH mem
                        	   305: ; 		***		Swithch to RAM bank #1
01:003C CDBA07          	   306: 		call  	p_FOFF_No_Print	; ***		Disable Flash memory 
01:003F 3E01            	   307: 		ld 		A,1
01:0041 CD0907          	   308: 		call 	p_srbank0; 		***		Swithch to RAM bank #1
                        	   309: 
                        	   310: 				; from old area (HL), $7FFF  to new area ram area (DE), 0x7FFF
01:0044 E1              	   311: 		pop 	HL			; HL point to temp storage area 0xCFFF (old DE value)
01:0045 D1              	   312: 		pop 	DE 			; DE point to new area in ram bank #1 0xCFFF (old HL value)
01:0046 018000          	   313: 		ld     	BC,128
01:0049 EDB8            	   314: 		lddr				; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0
                        	   315: 
                        	   316: ;		***		Enable Flash again and set ram bank #0	
01:004B CDBA07          	   317: 		call  	p_FOFF_No_Print
01:004E 3E00            	   318: 		ld 		A,0
01:0050 CD1C07          	   319: 		call 	p_flbank0; 		***		Swithch to FLASH bank #0
                        	   320: 
                        	   321: 
01:0053 C1              	   322: 		pop 	BC			; restore BC as block counter
01:0054 10D8            	   323: 		djnz	.loopBlocks
                        	   324: 			
                        	   325: 
                        	   326: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	   327: 
                        	   328: .skipBlockCopy:
                        	   329: 
01:0056 ED730000        	   330: 		ld 		(SP_value),SP
                        	   331: 
                        	   332: 		ifd 	GPIODEBUG
01:005A 3EAA            	   333: 		ld 		A,$AA
01:005C D302            	   334: 		out 	(gpio_out),A
                        	   335: 		endif
                        	   336: 
01:005E CD0000          	   337: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   338: 				; initialize buffer counters and pointers.
                        	   339: 		ifd		PIODEBUG
                        	   340: 		ld 		A,$BB
                        	   341: 		out 	(gpio_out),A
                        	   342: 		endif
                        	   343: 
01:0061 CD0000          	   344: 		call	PIO_Init
                        	   345: 		ifd 	GPIODEBUG
01:0064 3ECC            	   346: 		ld 		A,$CC
01:0066 D302            	   347: 		out 	(gpio_out),A
                        	   348: 		endif
                        	   349: 
01:0068 CD0000          	   350: 		call 	CTC_Init
                        	   351: 		ifd 	GPIODEBUG
01:006B 3EDD            	   352: 		ld 		A,$DD
01:006D D302            	   353: 		out 	(gpio_out),A
                        	   354: 		endif
                        	   355: 
01:006F CD0000          	   356: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	   357: 		ifd 	GPIODEBUG
01:0072 3EDF            	   358: 		ld 		A,$DF
01:0074 D302            	   359: 		out 	(gpio_out),A
                        	   360: 		endif
                        	   361: 
01:0076 CD0000          	   362: 		call	S_head_tail			; save input heads and tails
                        	   363: 		ifd 	GPIODEBUG
01:0079 3E81            	   364: 		ld 		A,$81
01:007B D302            	   365: 		out 	(gpio_out),A
                        	   366: 		endif
                        	   367: 
                        	   368: 		; call	sh_test
                        	   369: 		; call 	Flash_WR_Test
                        	   370: 		; ld	HL,$2010
                        	   371: 		; call	Flash_SE_Erase
                        	   372: 
                        	   373: 
01:007D CD0000          	   374: 		call	CRLF
01:0080 CD0000          	   375: 		call 	writeSTRBelow
01:0083 0D0A            	   376: 		defb   	"\r\n"
01:0085 2323232323232323	   377: 		defb	"##########################################################\r\n"
01:008D 2323232323232323
01:0095 2323232323232323
01:009D 2323232323232323
01:00A5 2323232323232323
01:00AD 2323232323232323
01:00B5 2323232323232323
01:00BD 23230D0A
01:00C1 546865205A383020	   378: 		defb	"The Z80 Board Awakened 2026\r\n"
01:00C9 426F617264204177
01:00D1 616B656E65642032
01:00D9 3032360D0A
01:00DE 202020206769743A	   379: 		defb	"    git: Working-260225-0-gf9cc9ce-dirty\r\n"
01:00E6 20576F726B696E67
01:00EE 2D3236303232352D
01:00F6 302D676639636339
01:00FE 63652D6469727479
01:0106 0D0A
01:0108 202020206275696C	   380: 		defb	"    build: 2026-02-27_20:39\r\n"
01:0110 643A20323032362D
01:0118 30322D32375F3230
01:0120 3A33390D0A
01:0125 20202020464C4153	   381: 		defb	"    FLASH->SRAM 0xD000.\r\n"
01:012D 482D3E5352414D20
01:0135 3078443030302E0D
01:013D 0A
01:013E 00              	   382: 		defb	"\0"
01:013F CD0000          	   383: 		call 	waitForFinishedPrintout
                        	   384: 
                        	   385: 
                        	   386: 		ifd 	GPIODEBUG
01:0142 3E83            	   387: 		ld 		A,$83
01:0144 D302            	   388: 		out 	(gpio_out),A
                        	   389: 		endif
01:0146 CD0000          	   390: 		call	CRLF
01:0149 1800            	   391: 		jr  next_line
                        	   392: 
                        	   393: 
                        	   394: next_line:
                        	   395: 
01:014B CDE303          	   396: 		call 	initCommParseTable			; Put zeros.....
                        	   397: 		ifd 	GPIODEBUG
01:014E 3E85            	   398: 		ld 		A,$85
01:0150 D302            	   399: 		out 	(gpio_out),A
                        	   400: 		endif
                        	   401: 
                        	   402: 		; ***	indicate memory banks   F[x]  Flash memory bank x
                        	   403: 		; ***	indicate memory banks   S[y]  SRAM memory bank y
                        	   404: 				; if bit 3 (rstBankID) = 1  no FLASH memory is selected
                        	   405: 				; if bit 3 (rstBankID) = 0 FLASH memory is lower 32k and SRAM upper 32k
01:0152 210100          	   406: 		ld 		HL,T_BUFFER+1 			; prepare output buffer		
01:0155 3646            	   407: 		ld 		(HL),'F'	
01:0157 3A0000          	   408: 		ld 		A,(rstBankID)
01:015A CB5F            	   409: 		bit 	3,A					; bit 3 set -> 64kSRAM
01:015C 2802            	   410: 		jr 		Z,useFlash
01:015E 3653            	   411: 		ld 		(HL),'S'	
                        	   412: useFlash:
01:0160 23              	   413: 		inc 	HL
01:0161 365B            	   414: 		ld 		(HL),'['	
01:0163 23              	   415: 		inc 	HL
01:0164 CB5F            	   416: 		bit 	3,A					; bit 7 set -> 64kSRAM
01:0166 3A0000          	   417: 		ld  	A,(memBankID)
01:0169 2807            	   418: 		jr 		Z,.IDflash
                        	   419: 
                        	   420: 		; ***	show sram bank number
01:016B E60F            	   421: 		and 	$0F					; sram bank #
01:016D CD0000          	   422: 		call 	AddToT_Buf			; convert to 1 ascii char in (HL+)
01:0170 180D            	   423: 		jr 		.cont
                        	   424: .IDflash:
                        	   425: 		; ***	show flash bank number
01:0172 CB3F            	   426: 		srl 	A
01:0174 CB3F            	   427: 		srl 	A
01:0176 CB3F            	   428: 		srl 	A
01:0178 CB3F            	   429: 		srl 	A
01:017A E607            	   430: 		and 	A,$07				; flash bank #
01:017C CD0000          	   431: 		call	AddToT_Buf			; convert to 1 ascii char in (HL+)
                        	   432: .cont:
01:017F 365D            	   433: 		ld  	(HL),']'
01:0181 23              	   434: 		inc 	HL
                        	   435: 
                        	   436: 		ifd 	GPIODEBUG	
01:0182 3E87            	   437: 		ld 		A,$87
01:0184 D302            	   438: 		out 	(gpio_out),A
                        	   439: 		endif
                        	   440: 
                        	   441: 	; 	*** Print prompt text to screen, value of PC and content in memory
01:0186 ED5B0000        	   442: 		ld 		DE,(PCvalue)
01:018A 365B            	   443: 		ld  	(HL),'['
01:018C 23              	   444: 		inc 	HL
                        	   445: 
                        	   446: 		; ***	Address in parenthesis
01:018D CD0000          	   447: 		call 	Bin2Hex16
01:0190 365D            	   448: 		ld  	(HL),']'
01:0192 23              	   449: 		inc 	HL
01:0193 363D            	   450: 		ld  	(HL),'='
01:0195 23              	   451: 		inc 	HL
                        	   452: 
                        	   453: 		; ***	Value of the bytes in address (2 bytes) to screen
01:0196 E5              	   454: 		push 	HL
01:0197 2A0000          	   455: 		ld 		HL,(PCvalue)
01:019A 56              	   456: 		ld 		D,(HL)
01:019B 23              	   457: 		inc 	HL
01:019C 5E              	   458: 		ld 		E,(HL)
01:019D E1              	   459: 		pop 	HL
01:019E CD0000          	   460: 		call	Bin2Hex16
01:01A1 362D            	   461: 		ld  	(HL),'-'
01:01A3 23              	   462: 		inc 	HL
01:01A4 363E            	   463: 		ld  	(HL),'>'
01:01A6 23              	   464: 		inc 	HL
                        	   465: 
01:01A7 3600            	   466: 		ld  	(HL),$00
01:01A9 FD210000        	   467: 		ld 		iy,T_BUFFER
01:01AD CD0000          	   468: 		call	WriteLine
                        	   469: 
01:01B0 210000          	   470: 		ld 		hl,Textbuf
01:01B3 CD0000          	   471: 		call 	ReadLine
                        	   472: 
01:01B6 FD210000        	   473: 		ld 		iy,Textbuf
01:01BA CD0000          	   474: 		call	WriteLineCRNL
                        	   475: 		; ld 		A,5
                        	   476: 		; out 	(portA_Data),A
                        	   477: 
                        	   478: 		;***  	compare input
                        	   479: 		; ld 		HL,Textbuf
                        	   480: 		; ld 		DE,command_list+2
                        	   481: 		; call	strCompare
                        	   482: 
                        	   483: 	;***************************************************************
                        	   484: 	;	Find /Identify command:
                        	   485: 	;***************************************************************
                        	   486: 
01:01BD 210000          	   487: 		ld 		HL,Textbuf
01:01C0 CD0000          	   488: 		call 	skipPriorDelimit			; set (HL) first char
                        	   489: 
01:01C3 DA0C05          	   490: 		jp 		C,temp_finish 				; end encountered; no command (empty line)	
                        	   491: 
01:01C6 E5              	   492: 		push 	HL
01:01C7 D1              	   493: 		pop  	DE							; typed command start in DE
                        	   494: 
                        	   495: 		; ***	Search command in 'command_list:'
                        	   496: 		;  		DE = typed command first char in DE (Textbuf)
01:01C8 213402          	   497: 		ld 		HL,command_list+1			; first char in first command in the list
                        	   498: 		
                        	   499: scanCommandList:
01:01CB 4E              	   500: 		ld 		C,(HL)						; command # in C
01:01CC 23              	   501: 		inc 	HL 							; (HL)=first char
01:01CD 46              	   502: 		ld 		B,(HL)						; # chars in command in list
01:01CE 23              	   503: 		inc 	HL 							; (HL)=first char
01:01CF D5              	   504: 		push 	DE 							; save start of typed string (DE) for later
                        	   505: 
                        	   506: findCommandInList:
01:01D0 1A              	   507: 		ld 		a,(DE)						; next typed char
                        	   508: 		; or 		$20							; make typed char lower case
01:01D1 BE              	   509: 		cp		(HL)
01:01D2 2008            	   510: 		jr 		nz,findNextITEM				; different chars-> test next item in list
01:01D4 13              	   511: 		inc 	DE
01:01D5 23              	   512: 		inc 	HL  
01:01D6 10F8            	   513: 		djnz 	findCommandInList
                        	   514: 		
                        	   515: 		; ***	test char (DE); should be a delimiter...
                        	   516: 		; ex 		DE,HL
                        	   517: 		; call 	isDelimit
                        	   518: 		; 				;delimiters found ? =>Z, else ~Z
                        	   519: 		; 				;char in (HL) is '0' ->  set C, else NC
                        	   520: 		; ex 		DE,HL
                        	   521: 
                        	   522: 		; call 	writeSTRBelow
                        	   523: 		; DB 		0,"pop 	HL.. !",CR,LF,00
                        	   524: 		; call 	DumpRegisters
                        	   525: 
                        	   526: 		; jr 		nz,findNextITEM    			; command match but is longer (more chars) cp list					
                        	   527: 
                        	   528: 		; ***	Found a matching command, All char do match...
                        	   529: 		; 		(HL) points to first after command
01:01D8 C3F603          	   530: 		jp 		matchInList
01:01DB 00              	   531: zero_byte:	db  0
                        	   532: 
                        	   533: findNextITEM:
                        	   534: 		; ***	find next ITEM or LISTEND
01:01DC 7E              	   535: 		ld 		a,(HL)
01:01DD FEEE            	   536: 		cp		CDEL					; command adress delimiter
01:01DF 2812            	   537: 		jr 		z,.skipPastCommAdr
                        	   538: 	
01:01E1 FE1C            	   539: 		cp		ITEM					; command adress delimiter
01:01E3 2817            	   540: 		jr 		z,nextInList
                        	   541: 	
01:01E5 FE1E            	   542: 		cp 		LISTEND
01:01E7 2010            	   543: 		jr 		NZ,.cont
                        	   544: 
                        	   545: 		; ***	Command list did not match; check if direct address '$' or byte input
01:01E9 3EFF            	   546: 		ld 		A,$FF
01:01EB 320000          	   547: 		ld 		(PCinpFlag),A			; indicate ev. typed ($)address to change PCV or input bytes ...
01:01EE E1              	   548: 		pop 	HL						; HL start of typed string (again)
01:01EF 7E              	   549: 		ld 		A,(HL)
01:01F0 C34104          	   550: 		jp 		checkaddress			; No more commands to check, check if address entered , '$'
                        	   551: 										; or relative adress '@'
                        	   552: 										; or direct input of bytes.....
                        	   553: .skipPastCommAdr:
01:01F3 23              	   554: 		inc  	HL		;hig adr.
01:01F4 23              	   555: 		inc  	HL		; low adr.
01:01F5 23              	   556: 		inc  	HL		;  '0'
01:01F6 23              	   557: 		inc  	HL		;  next row
01:01F7 18E3            	   558: 		jr 		findNextITEM
                        	   559: 
01:01F9 23              	   560: .cont:	inc 	HL
01:01FA 18E0            	   561: 		jr 		findNextITEM
                        	   562: 
                        	   563: nextInList:
01:01FC 23              	   564: 		inc 	HL						; points to item #
01:01FD D1              	   565: 		pop 	DE 						; DE start of typed string (again)
01:01FE 18CB            	   566: 		jr 		scanCommandList
                        	   567: 
                        	   568: 
                        	   569: 	;***************************************************************
                        	   570: 	;	Semantic error occurred in input :
                        	   571: 	;***************************************************************
                        	   572: 
                        	   573: inputerror:
01:0200 E5              	   574: 		push   	HL
01:0201 CD0000          	   575: 		call 	writeSTRBelow
01:0204 00              	   576: 		DB 		0,"Input Semantic Error... ! code(DE):",00
01:0205 496E707574205365
01:020D 6D616E7469632045
01:0215 72726F722E2E2E20
01:021D 2120636F64652844
01:0225 45293A
01:0228 00
01:0229 D1              	   577: 		pop 	DE
01:022A CD0000          	   578: 		call 	putDEtoScreen
01:022D CD0000          	   579: 		call 	CRLF
01:0230 C34B01          	   580: 		jp 		next_line
                        	   581: 
                        	   582: ; command_addresses:
                        	   583: ; 		defw 	00
                        	   584: ; 		defw 	p_load			;1
                        	   585: ; 		defw 	p_dumpmem		;2
                        	   586: ; 		defw 	p_pc			;3
                        	   587: ; 		defw 	p_eep			;4
                        	   588: ; 		defw 	p_clearmem		;5
                        	   589: ; 		defw 	p_exe			;6
                        	   590: ; 		defw 	p_go			;7
                        	   591: ; 		defw 	p_incDecPC		;8
                        	   592: ; 		defw 	p_incDecPC		;9
                        	   593: ; 		defw 	p_FON			;10
                        	   594: ; 		defw 	p_FOFF			;11
                        	   595: ; 		defw 	p_flwr			;12. write data to FLASH
                        	   596: ; 		defw 	p_flse			;13. sector erase
                        	   597: ; 		defw 	p_xmod			;14. transfer files via x-modem
                        	   598: ; 		defw 	p_reset			;16. Jump to $0000
                        	   599: ; 		defw	p_C_Read		;16. Read from SD card   sdrd  "file"  $Addr
                        	   600: ; 		defw	p_C_Write		;17. Write to SD card   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   601: ; 		defw	p_C_Read		;18. Read from USB   sdrd  "file"  $Addr
                        	   602: ; 		defw	p_C_Write		;19. Write to USB   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   603: ; 		defw	p_C_Delete		;20. delete file on SD card   sdrd  "file"  $Addr
                        	   604: ; 		defw	p_C_Delete		;21. delete file on USB  sdrd  "file"  $Addr.l $Addr.h/Num
                        	   605: ; 		defw 	p_C_Read		;22. List root level files/dirs on sd card
                        	   606: ; 		defw 	p_C_Read 		;23. List root level files/dirs on USB
                        	   607: ; 		defw	p_cptFl			;24. copy from mem to flash memory (on selected bank)
                        	   608: ; 		defw 	p_flbank		;25. Set flash bank #
                        	   609: ; 		defw	p_srbank		;26. Set sram bank #
                        	   610: 
                        	   611: command_list:
                        	   612: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	   613: 
01:0233 1C              	   614: 		db		ITEM,1,4,"load",STEND,%100010,0,CDEL
01:0234 01
01:0235 04
01:0236 6C6F6164
01:023A 1D
01:023B 22
01:023C 00
01:023D EE
01:023E 5E05            	   615: 		dw 		p_load,0
01:0240 0000
01:0242 1C              	   616: 		db		ITEM,2,2,"dm",	STEND,%000010,0,CDEL
01:0243 02
01:0244 02
01:0245 646D
01:0247 1D
01:0248 02
01:0249 00
01:024A EE
01:024B 5F05            	   617: 		dw  	p_dumpmem,0
01:024D 0000
01:024F 1C              	   618: 		db		ITEM,3,2,"pc",	STEND,%000000,0,CDEL
01:0250 03
01:0251 02
01:0252 7063
01:0254 1D
01:0255 00
01:0256 00
01:0257 EE
01:0258 6305            	   619: 		dw 		p_pc,0
01:025A 0000
01:025C 1C              	   620: 		db		ITEM,4,3,"eep",	STEND,%000000,0,CDEL
01:025D 04
01:025E 03
01:025F 656570
01:0262 1D
01:0263 00
01:0264 00
01:0265 EE
01:0266 6405            	   621: 		dw 		p_eep,0
01:0268 0000
01:026A 1C              	   622: 		db		ITEM,5,2,"cm",	STEND,%000000,0,CDEL
01:026B 05
01:026C 02
01:026D 636D
01:026F 1D
01:0270 00
01:0271 00
01:0272 EE
01:0273 6B05            	   623: 		dw  	p_clearmem,0
01:0275 0000
01:0277 1C              	   624: 		db		ITEM,6,3,"exe",	STEND,%000000,0,CDEL
01:0278 06
01:0279 03
01:027A 657865
01:027D 1D
01:027E 00
01:027F 00
01:0280 EE
01:0281 7E05            	   625: 		dw 		p_exe,0
01:0283 0000
01:0285 1C              	   626: 		db		ITEM,7,2,"go",	STEND,%000000,0,CDEL
01:0286 07
01:0287 02
01:0288 676F
01:028A 1D
01:028B 00
01:028C 00
01:028D EE
01:028E 7F05            	   627: 		dw 		p_go,0
01:0290 0000
01:0292 1C              	   628: 		db		ITEM,8,2,"++",	STEND,%000000,0,CDEL
01:0293 08
01:0294 02
01:0295 2B2B
01:0297 1D
01:0298 00
01:0299 00
01:029A EE
01:029B 9005            	   629: 		dw 		p_incDecPC,0
01:029D 0000
01:029F 1C              	   630: 		db		ITEM,9,2,"--",	STEND,%000000,0,CDEL
01:02A0 09
01:02A1 02
01:02A2 2D2D
01:02A4 1D
01:02A5 00
01:02A6 00
01:02A7 EE
01:02A8 9005            	   631: 		dw 		p_incDecPC,0
01:02AA 0000
01:02AC 1C              	   632: 		db		ITEM,10,3,"fl1",		STEND,%000000,0,CDEL
01:02AD 0A
01:02AE 03
01:02AF 666C31
01:02B2 1D
01:02B3 00
01:02B4 00
01:02B5 EE
01:02B6 3207            	   633: 		dw		p_FON,0
01:02B8 0000
01:02BA 1C              	   634: 		db		ITEM,10,8,"flash-on",	STEND,%000000,0,CDEL
01:02BB 0A
01:02BC 08
01:02BD 666C6173682D6F6E
01:02C5 1D
01:02C6 00
01:02C7 00
01:02C8 EE
01:02C9 3207            	   635: 		dw 		p_FON,0
01:02CB 0000
01:02CD 1C              	   636: 		db		ITEM,11,3,"fl0",		STEND,%000000,0,CDEL
01:02CE 0B
01:02CF 03
01:02D0 666C30
01:02D3 1D
01:02D4 00
01:02D5 00
01:02D6 EE
01:02D7 8C07            	   637: 		dw 		p_FOFF,0
01:02D9 0000
01:02DB 1C              	   638: 		db		ITEM,11,9,"flash-off",	STEND,%000000,0,CDEL
01:02DC 0B
01:02DD 09
01:02DE 666C6173682D6F66
01:02E6 66
01:02E7 1D
01:02E8 00
01:02E9 00
01:02EA EE
01:02EB 8C07            	   639: 		dw 		p_FOFF,0
01:02ED 0000
01:02EF 1C              	   640: 		db		ITEM,12,4,"flwr",	STEND,%001110,0,CDEL
01:02F0 0C
01:02F1 04
01:02F2 666C7772
01:02F6 1D
01:02F7 0E
01:02F8 00
01:02F9 EE
01:02FA B505            	   641: 		dw 		p_flwr,0									; write to flash: flwr  <$Addr.mem> <$Addr.flash>  <Num> (0E)
01:02FC 0000
01:02FE 1C              	   642: 		db		ITEM,13,4,"flse",	STEND,%000000,0,CDEL
01:02FF 0D
01:0300 04
01:0301 666C7365
01:0305 1D
01:0306 00
01:0307 00
01:0308 EE
01:0309 EA05            	   643: 		dw 		p_flse,0
01:030B 0000
01:030D 1C              	   644: 		db		ITEM,14,4,"xmod",	STEND,%001000,0,CDEL
01:030E 0E
01:030F 04
01:0310 786D6F64
01:0314 1D
01:0315 08
01:0316 00
01:0317 EE
01:0318 F305            	   645: 		dw 		p_xmod,0									; xmodem from PC   xmod <address>
01:031A 0000
01:031C 1C              	   646: 		db		ITEM,15,3,"rst",	STEND,%000000,0,CDEL
01:031D 0F
01:031E 03
01:031F 727374
01:0322 1D
01:0323 00
01:0324 00
01:0325 EE
01:0326 4A05            	   647: 		dw 		p_reset,0
01:0328 0000
01:032A 1C              	   648: 		db		ITEM,16,4,"sdrd",	STEND,%101000,0,CDEL
01:032B 10
01:032C 04
01:032D 73647264
01:0331 1D
01:0332 28
01:0333 00
01:0334 EE
01:0335 0806            	   649: 		dw		p_C_Read,0									; Read from SD card   sdrd  "file"  $Addr
01:0337 0000
01:0339 1C              	   650: 		db		ITEM,17,4,"sdwr",	STEND,%101010,0,CDEL
01:033A 11
01:033B 04
01:033C 73647772
01:0340 1D
01:0341 2A
01:0342 00
01:0343 EE
01:0344 6C06            	   651: 		dw 		p_C_Write,0									; Write to SD card   sdwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0346 0000
01:0348 1C              	   652: 		db		ITEM,18,5,"usbrd",	STEND,%101000,0,CDEL
01:0349 12
01:034A 05
01:034B 7573627264
01:0350 1D
01:0351 28
01:0352 00
01:0353 EE
01:0354 0806            	   653: 		dw 		p_C_Read,0									; Read from USB      usbrd  "file"  $Addr
01:0356 0000
01:0358 1C              	   654: 		db		ITEM,19,5,"usbwr",	STEND,%101010,0,CDEL
01:0359 13
01:035A 05
01:035B 7573627772
01:0360 1D
01:0361 2A
01:0362 00
01:0363 EE
01:0364 6C06            	   655: 		dw 		p_C_Write,0									; Write to USB        usbwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0366 0000
01:0368 1C              	   656: 		db		ITEM,20,5,"sddel",	STEND,%100000,0,CDEL
01:0369 14
01:036A 05
01:036B 736464656C
01:0370 1D
01:0371 20
01:0372 00
01:0373 EE
01:0374 C406            	   657: 		dw 		p_C_Delete,0 								; Delete file on SD card   sddel  "file"  
01:0376 0000
01:0378 1C              	   658: 		db		ITEM,21,6,"usbdel",	STEND,%100000,0,CDEL
01:0379 15
01:037A 06
01:037B 75736264656C
01:0381 1D
01:0382 20
01:0383 00
01:0384 EE
01:0385 C406            	   659: 		dw 		p_C_Delete,0 								; Delete file on USB   usbdel  "file"  
01:0387 0000
01:0389 1C              	   660: 		db		ITEM,22,5,"sddir",	STEND,%100000,0,CDEL
01:038A 16
01:038B 05
01:038C 7364646972
01:0391 1D
01:0392 20
01:0393 00
01:0394 EE
01:0395 0806            	   661: 		dw 		p_C_Read,0 									; List root level files/dirs on sd card
01:0397 0000
01:0399 1C              	   662: 		db		ITEM,23,6,"usbdir",	STEND,%100000,0,CDEL
01:039A 17
01:039B 06
01:039C 757362646972
01:03A2 1D
01:03A3 20
01:03A4 00
01:03A5 EE
01:03A6 0806            	   663: 		dw 		p_C_Read,0 									; List root level files/dirs on USB
01:03A8 0000
01:03AA 1C              	   664: 		db 		ITEM,24,5,"cptfl",	STEND,%001100,0,CDEL
01:03AB 18
01:03AC 05
01:03AD 637074666C
01:03B2 1D
01:03B3 0C
01:03B4 00
01:03B5 EE
01:03B6 FB06            	   665: 		dw 		p_cptFl,0									; copy from adress range to flash   cptfl  $Addr   $Addr
01:03B8 0000
01:03BA 1C              	   666: 		db 		ITEM,25,2,"fb",		STEND,%000010,0,CDEL
01:03BB 19
01:03BC 02
01:03BD 6662
01:03BF 1D
01:03C0 02
01:03C1 00
01:03C2 EE
01:03C3 1607            	   667: 		dw 		p_flbank,0									; set flash bank #	
01:03C5 0000
01:03C7 1C              	   668: 		db 		ITEM,26,2,"sb",		STEND,%000010,0,CDEL
01:03C8 1A
01:03C9 02
01:03CA 7362
01:03CC 1D
01:03CD 02
01:03CE 00
01:03CF EE
01:03D0 0307            	   669: 		dw		p_srbank,0									; set sram bank #	
01:03D2 0000
01:03D4 1C              	   670: 		db		ITEM,27,3,"nop",	STEND,%000000,0,CDEL
01:03D5 1B
01:03D6 03
01:03D7 6E6F70
01:03DA 1D
01:03DB 00
01:03DC 00
01:03DD EE
01:03DE 0000            	   671: 		dw 		0,0
01:03E0 0000
01:03E2 1E              	   672: 		db		LISTEND
                        	   673: commListLen  equ   27
                        	   674: 
                        	   675: 		; ld		HL,$6000
                        	   676: 		; ld		(packetBaseAddress),HL			; store the address for target code (for error correction)
                        	   677: 		; ld		A,01
                        	   678: 		; ld		(prevPacketByte01),A 				; store of packet numbers
                        	   679: 
                        	   680: 		; call 	SetupXMODEM_TXandRX					 
                        	   681: 	
                        	   682: 
                        	   683: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   684: ;---------------------------------------------------------------------------------
                        	   685: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   686: 
                        	   687: ;		skipPriorDelimit 		; increase A0 until non delimiter (NZ) or #0 (Z) 
                        	   688: ;		***		store string value in textarea and reference in table
                        	   689: ;		skipCharsUntilDelim		; increase A0 until blank (NZ) or #0 (Z) 
                        	   690: ;		***		read/store either address or lvalue and store in table
                        	   691: ; 		isDelimit(S)  is char in (A0) any of the delimiters specified in (A1) ? =>Z, else ~Z
                        	   692: ; 		Parameters returned; A0 - Address of char
                        	   693: 
                        	   694: ;		commParseTable
                        	   695: ;		***************************************************
                        	   696: ;		***	decode input line;
                        	   697: ;		*** <cmd>    "TEXT"  	$xxyy  xxyy
                        	   698: ;		*** command textstring 	address	 lvalue
                        	   699: ;		************************************************************
                        	   700: ;		*** commParseTable:
                        	   701: ;		*** 00 : W : offset in jumptable  (F080)
                        	   702: ;		*** 04 : L : address 1  (F084-F087)
                        	   703: ;		*** 08 : L : address 2  (F088-F08B)
                        	   704: ;		*** 10 : L : lvalue1  (F090-F09F)
                        	   705: ;		*** 20 : L : lvalue2  (F0A0-F0AF)
                        	   706: ;		*** 57 : L : text1   (F0B0-F0D7)
                        	   707: ;		*** 58 : L : text2 	 (F0D8-F0FF)	
                        	   708: ;		***
                        	   709: ;		***--------------------------------------
                        	   710: 
                        	   711: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   712: ;---------------------------------------------------------------------------------
                        	   713: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   714: 
                        	   715: 		; call	skipCharsUntilDelim			; set (HL) to first delimiter
                        	   716: 		; push 	HL
                        	   717: 		; pop  	BC							; typed command end+1 in BC
                        	   718: 
                        	   719: 		; ***	Prepares the commParseTable. Consumes HL,B,A
                        	   720: initCommParseTable:
01:03E3 3E00            	   721: 		ld 		A,0
01:03E5 320000          	   722: 		ld 		(PCinpFlag),A
01:03E8 320100          	   723: 		ld 		(PCinpFlag+1),A
01:03EB 210000          	   724: 		ld 		HL,commParseTable
                        	   725: 
01:03EE 0680            	   726: 		ld 		B,$80
01:03F0 97              	   727: 		sub 	A 					; clear A.
                        	   728: .icpt:
01:03F1 77              	   729: 		ld 		(HL),A
01:03F2 23              	   730: 		inc 	HL
01:03F3 10FC            	   731: 		djnz 	.icpt
                        	   732: 
01:03F5 C9              	   733: 		ret
                        	   734: 
                        	   735: ;---------------------------------------------------------------------------------
                        	   736: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   737: 
                        	   738: 	;***************************************************************
                        	   739: 	;	Command identified -> now search for string :
                        	   740: 	;***************************************************************
                        	   741: 
                        	   742: matchInList:
                        	   743: 		; ***	Command found. Then, check for string input "<string>"
                        	   744: 		; ***	DE points to first delimiter after command 
                        	   745: 						;delimiters found ? =>Z, else ~Z
                        	   746: 						;char in (HL) is '0' ->  set C, else NC
                        	   747: 
01:03F6 33              	   748: 		inc 	sp
01:03F7 33              	   749: 		inc 	sp						; restore PC from PUSH in <scanCommandList>
01:03F8 23              	   750: 		inc 	HL 						; HL point to first after <STEND>  ->req arguments  (STEND,%100010,0,CDEL,p_load,0)
01:03F9 7E              	   751: 		ld 		A,(HL) 					; A= required arguments from table
01:03FA FD210000        	   752: 		ld 		IY,commParseTable		; IY =commParseTable =	0x80 + _String_HEAP
01:03FE FD7502          	   753: 		ld   	(IY+2),L 
01:0401 FD7403          	   754: 		ld   	(IY+3),H				; save the command adress.
                        	   755: 		
01:0404 FD7100          	   756: 		ld 		(IY),C 					; store the command number in (commParseTable, 0x80)
01:0407 FD7701          	   757: 		ld 		(IY+1),A				; store required arguments  in (commParseTable+1, 0x81)
                        	   758: 		; call 	writeSTRBelow_CRLF
                        	   759: 		; DB 		0,"Found a valid command  see (C).. !",CR,LF,00
01:040A D5              	   760: 		push 	DE
01:040B E1              	   761: 		pop 	HL						; HL=DE = first delimiter after command
01:040C 2B              	   762: 		dec 	HL							; DE -> HL -> last char before delimiter
                        	   763: paramLoopEntry:	
                        	   764: 
01:040D CD0000          	   765: 		call 	skipPriorDelimit 			; look for next char (  '"' ?)
01:0410 DAFB04          	   766: 		jp 		C,executeCommand			; C set from 'skipPriorDelimit', no command parameters
                        	   767: 
01:0413 7E              	   768: 		ld 		A,(HL)
                        	   769: 
01:0414 FE22            	   770: 		cp 		'"'							; beginning of string ?
01:0416 2029            	   771: 		jr 		NZ,checkaddress				;  NZ -> (HL) points to non delimiter
                        	   772: 
                        	   773: 		; ***	extract string 
01:0418 23              	   774: 		inc 	HL 							; skip '"' (HL)-> first char
                        	   775: 
01:0419 E5              	   776: 		push  	HL
01:041A D1              	   777: 		pop  	DE							; DE -> first char after '"' <source>
01:041B CD0000          	   778: 		call 	skipCharsUntilDelim			; find second '"'
01:041E 2B              	   779: 		dec 	HL 							; skip first delimiter (ev. CR)
01:041F 7E              	   780: 		ld 		A,(HL)
01:0420 FE22            	   781: 		cp 		'"' 						; found second '"' ??
01:0422 C20002          	   782: 		jp 		NZ,inputerror
01:0425 2B              	   783: 		dec 	HL 							; skip second '"'
                        	   784: 	;***************************************************************
                        	   785: 	;	copy string to  'commParseTable'
                        	   786: 	;***************************************************************
                        	   787: 
01:0426 A7              	   788: 		and 	A
01:0427 ED52            	   789: 		sbc 	HL,DE 						; amount of chars...
01:0429 44              	   790: 		ld 		B,H							; amount of chars...
01:042A 4D              	   791: 		ld 		C,L							; amount of chars...
01:042B 03              	   792: 		inc 	BC
                        	   793: 
01:042C 210000          	   794: 		ld 		HL,commStr1				; address for first string
01:042F 7E              	   795: 		ld 		A,(HL)
01:0430 B7              	   796: 		or 		A 						; =0?
01:0431 2808            	   797: 		jr 		Z, .strone
01:0433 210000          	   798: 		ld 		HL,commStr2				; address for second string
01:0436 7E              	   799: 		ld 		A,(HL)
01:0437 B7              	   800: 		or  	A						; =0 ?
01:0438 C20002          	   801: 		jp 		NZ,inputerror			; too many strings
                        	   802: .strone:
01:043B EB              	   803: 		ex 		DE,HL 					; HL = <source>, DE = <dest>, size = BC
01:043C EDB0            	   804: 		ldir 							; make the copy
                        	   805: 		; ex		DE,HL
01:043E 23              	   806: 		inc 	HL 						; (HL) past the second '"'
                        	   807: 
01:043F 18CC            	   808: 		jr 		paramLoopEntry
                        	   809: 
                        	   810: 
                        	   811: 	;***************************************************************
                        	   812: 	;	Check if address is specified in input 
                        	   813: 	;***************************************************************
                        	   814: 
                        	   815: 
                        	   816: checkaddress:
                        	   817: 		; ***	A = (HL), first char after delimiter
                        	   818: 
01:0441 320100          	   819: 		ld 		(PCinpFlag+1),A			; if value '(PCinpFlag+1)' == '$' -> address input
                        	   820: 										; if value '(PCinpFlag+1)' == '@' -> relative (PCval) address input
01:0444 FE24            	   821: 		cp 		'$'						; identified address id
01:0446 3E00            	   822: 		ld 		A,0
01:0448 2802            	   823: 		jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   824: 		; cp 		'@'						; identified address id
                        	   825: 		; jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   826: 
01:044A 1823            	   827: 		jr 		getLvalue				
                        	   828: 
01:044C 23              	   829: chkADR:		inc 	HL 						; skip past '$' or '@'
                        	   830: 
                        	   831: chkADR1:
                        	   832: 	; ***		Check where to store address...
                        	   833: 
01:044D DD210000        	   834: 		ld 		IX,commAdr1
                        	   835: 		; ld 		A,0
01:0451 DDBE00          	   836: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0454 2007            	   837: 		jr 		NZ,chkADR2
01:0456 DDBE01          	   838: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:0459 2002            	   839: 		jr 		NZ,chkADR2
01:045B 1832            	   840: 		jr 		makeASCIItoHEX
                        	   841: chkADR2:
                        	   842: 
01:045D DD210000        	   843: 		ld 		IX,commAdr2
                        	   844: 		; ld 		A,0
01:0461 DDBE00          	   845: 		cp 		(IX)			; check if zero ? (already stored)
01:0464 C20002          	   846: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0467 DDBE01          	   847: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
01:046A C20002          	   848: 		jp 		NZ,inputerror	; error : No more addresses to store
01:046D 1820            	   849: 		jr 		makeASCIItoHEX
                        	   850: 
                        	   851: getLvalue:
01:046F DD210000        	   852: 		ld 		IX,commLvl1
01:0473 DDBE00          	   853: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0476 2007            	   854: 		jr 		NZ,chkLVL2
01:0478 DDBE01          	   855: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:047B 2002            	   856: 		jr 		NZ,chkLVL2
01:047D 1810            	   857: 		jr 		makeASCIItoHEX
                        	   858: 
                        	   859: chkLVL2:
01:047F DD210000        	   860: 		ld 		IX,commLvl2
01:0483 DDBE00          	   861: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0486 C20002          	   862: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0489 DDBE01          	   863: 		cp 		(IX+1)			; check if zero (byte 2) ? (ascii value already stored)
01:048C C20002          	   864: 		jp 		NZ,inputerror	; error : No more addresses to store
                        	   865: 
                        	   866: 
                        	   867: makeASCIItoHEX:
                        	   868: 		; ***	copy from command line to adr or lvalue in table
                        	   869: 		; ***	only two bytes (four chars)....
                        	   870: 		; 		IX point to destination...
01:048F 54              	   871: 		ld 		D,H
01:0490 5D              	   872: 		ld		E,L						; DE -> first char after '$' | '@' <source>
01:0491 CD0000          	   873: 		call 	skipCharsUntilDelim		; find next delimiter or CR ; adr in HL
01:0494 7E              	   874: 		ld 		A,(HL)
                        	   875: 
                        	   876: 	;***************************************************************
                        	   877: 	;	copy string to  'commParseTable', IX points to dest address.
                        	   878: 	;***************************************************************
                        	   879: 
01:0495 A7              	   880: 		and 	A						; clear Carry
01:0496 ED52            	   881: 		sbc 	HL,DE 					; amount of chars...->HL ( H=0); DE -> first char after '$' <source>
                        	   882: 
                        	   883: 		; ***	Do not check even or odd...
                        	   884: 		; bit 	0,L 					; even or odd (=1)?
                        	   885: 		; jp 		NZ,inputerror
                        	   886: 
01:0498 45              	   887: 		ld 		B,L 					; char counter
01:0499 210000          	   888: 		ld 		HL,00					;  
                        	   889: 
01:049C EB              	   890: 		ex 		DE,HL					; HL -> first char after '$' <ascii source>	
                        	   891: 
                        	   892: nextHalfByte:
                        	   893: 
01:049D CD0000          	   894: 		call 	isHex					; check char in (HL) return with Carry, value in A is NOT HEX
01:04A0 DA0002          	   895: 		jp 		C,inputerror			; return with Carry, value in A is NOT HEX
                        	   896: 
01:04A3 CB23            	   897: 		sla 	E						; shift left E-> Carry
01:04A5 CB12            	   898: 		rl 		D 						; Carry -> rotate left D
01:04A7 CB23            	   899: 		sla 	E						; shift left E-> Carry
01:04A9 CB12            	   900: 		rl 		D 						; Carry -> rotate left D
01:04AB CB23            	   901: 		sla 	E						; shift left E-> Carry
01:04AD CB12            	   902: 		rl 		D 						; Carry -> rotate left D
01:04AF CB23            	   903: 		sla 	E						; shift left E-> Carry
01:04B1 CB12            	   904: 		rl 		D 						; Carry -> rotate left D
01:04B3 B3              	   905: 		or      E  						; A OR E(0..3) are zero
01:04B4 5F              	   906: 		ld 		E,A
                        	   907: 
01:04B5 DD7300          	   908: 		ld 		(IX),E					; store E value [big endian]
01:04B8 DD7201          	   909: 		ld 		(IX+1),D				; store D value [big endian]
                        	   910: 
01:04BB 23              	   911: 		inc 	HL
                        	   912: 
01:04BC 10DF            	   913: 		djnz 	nextHalfByte
                        	   914: 		;***	HL should point to first delimiter...
                        	   915: 
                        	   916: byteEnd:
                        	   917: 
01:04BE 3A0000          	   918: 		ld  	A,(PCinpFlag)
01:04C1 B7              	   919: 		or  	A 						; check Z; =0 -> normal parameter save
01:04C2 CA0D04          	   920: 		jp 	   	Z,paramLoopEntry
                        	   921: 
01:04C5 3A0100          	   922: 		ld  	A,(PCinpFlag+1) 		; address input for PCValue ?
01:04C8 FE24            	   923: 		cp 		'$' 					; adress flag ?
                        	   924: 		; jr 		Z,changePCVal
                        	   925: 		; cp 		'@' 					; relative adress flag ?
01:04CA 2813            	   926: 		jr 		Z,changePCVal
                        	   927: 
                        	   928: 		; ***	Store  bytes from LVL1 to (PCval)
01:04CC E5              	   929: 		push 	HL
01:04CD ED5B0000        	   930: 		ld 		DE,(PCvalue)	
01:04D1 210000          	   931: 		ld 		HL,commLvl1
                        	   932: 		; ld 		A,(DE)
                        	   933: 		; ld 		(HL),A
                        	   934: 		; inc 	HL
                        	   935: 		; inc 	DE
01:04D4 EDA0            	   936: 		ldi  							; (DE)<-(HL), inc HL,DE, dec BC
01:04D6 7E              	   937: 		ld 		A,(HL)
01:04D7 B7              	   938: 		or 		A
01:04D8 2801            	   939: 		jr 		Z,noHighNib
01:04DA 12              	   940: 		ld 		(DE),A
                        	   941: noHighNib:
01:04DB E1              	   942: 		pop 	HL		
                        	   943: 		; ***	reset flag
                        	   944: 		; ld 		A,0
                        	   945: 		; ld 		(PCinpFlag),A
                        	   946: 		; ld 		(PCinpFlag+1),A
01:04DC C30D04          	   947: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   948: 
                        	   949: 		
                        	   950: changePCVal:
                        	   951: 		; ***	Change relative PCvalue from 'commAdr1' or
                        	   952: 		; ***	change PCvalue from 'commAdr1'
                        	   953: 		; ***	A contains '$' or '@'
01:04DF E5              	   954: 		push 	HL
01:04E0 D5              	   955: 		push  	DE
01:04E1 FE40            	   956: 		cp   	'@' 					; relative adress ?
01:04E3 2806            	   957: 		jr 		Z,.reladr
                        	   958: ; 		***		absolute adr !		
01:04E5 210000          	   959: 		ld 		HL,00
01:04E8 220000          	   960: 		ld 		(PCvalue),HL				; clear and then add value from commAdr1
                        	   961: 
                        	   962: .reladr:		
01:04EB 2A0000          	   963: 		ld 		HL,(commAdr1)
01:04EE ED5B0000        	   964: 		ld  	DE,(PCvalue)
01:04F2 19              	   965: 		add 	HL,DE
01:04F3 220000          	   966: 		ld 		(PCvalue),HL
01:04F6 D1              	   967: 		pop 	DE
01:04F7 E1              	   968: 		pop 	HL 						; restore value of first delimiter
01:04F8 C30D04          	   969: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   970: 
                        	   971: executeCommand:	
                        	   972: 		; ***	execute commands (and arguments)
                        	   973: 		; call 	writeSTRBelow
                        	   974: 		; DB 		0,"Finish parsing !",CR,LF,00
                        	   975: 		; call 	DumpRegisters			; checkpoint for list of arguments
                        	   976: 		; ***	IY+2 point to command address. IY=commParseTable
                        	   977: 
01:04FB 3A0000          	   978: 		ld 		A,(PCinpFlag)
01:04FE B7              	   979: 		or 		A   					; check if zero  
01:04FF 2003            	   980: 		jr 		NZ,.noJump
                        	   981: 
01:0501 CD0F05          	   982: 		call 	JPTable01
                        	   983: .noJump:
                        	   984: 		; ***	reset flag
01:0504 3E00            	   985: 		ld 		A,0
01:0506 320000          	   986: 		ld 		(PCinpFlag),A
01:0509 320100          	   987: 		ld 		(PCinpFlag+1),A
                        	   988: 
                        	   989: 		
                        	   990: 		; jp 		paramLoopEntry 				; loop and check for more parameters
                        	   991: 
                        	   992: temp_finish:
                        	   993: 		; call 	DumpRegisters
01:050C C34B01          	   994: 		jp 		next_line
                        	   995: 
                        	   996: 	;***************************************************************
                        	   997: 	;	Check if LVALUE is specified in input 
                        	   998: 	;***************************************************************
                        	   999: 
                        	  1000: JPTable01:
01:050F 3A0000          	  1001: 		ld 		A,(commParseTable) 			; retrieve command number
01:0512 B7              	  1002: 		or 	  	A 							; error if 0
01:0513 CA0002          	  1003: 		jp 		Z,inputerror
01:0516 FE1B            	  1004: 		cp 		commListLen
01:0518 3F              	  1005: 		ccf 						;complement carry for error indicator
                        	  1006: 
01:0519 DA0002          	  1007: 		jp      C,inputerror
                        	  1008: 
01:051C E5              	  1009: 		push  	HL					; make space in stack for 'return' address
                        	  1010: 
                        	  1011: 		; 								;obtain routine address from table and transfer 
                        	  1012: 		; 								;control to it, leaving all register pairs unchanged
                        	  1013: 		
01:051D FD2A0200        	  1014: 		ld   	IY,(commParseTable+2)	; get address $F080+2
01:0521 FD6E03          	  1015: 		ld   	L,(IY+3)				; load address in HL, move pointer 3 pos forward
01:0524 FD6604          	  1016: 		ld   	H,(IY+4)
                        	  1017: 
01:0527 E3              	  1018: 		ex 		(SP),HL					;restore old HL, push routine address
01:0528 C9              	  1019: 		ret 							; jump to routine
                        	  1020: 
                        	  1021: argumentsError:
01:0529 CD0000          	  1022: 		call 	writeSTRBelow
01:052C 00              	  1023: 		DB 		0,"Some arguments mismatch !",CR,LF,00
01:052D 536F6D6520617267
01:0535 756D656E7473206D
01:053D 69736D6174636820
01:0545 21
01:0546 0D
01:0547 0A
01:0548 00
01:0549 C9              	  1024: 		ret
                        	  1025: 
                        	  1026: 
                        	  1027: p_reset:
01:054A AF              	  1028: 		xor 	A
01:054B 320000          	  1029: 		ld 		(memBankID),A			; set memory banks #0
01:054E CD0000          	  1030: 		call 	setFLASHBank			; FLASH bank #0
01:0551 AF              	  1031: 		xor 	A
01:0552 CD0000          	  1032: 		call 	setSRAMBank				; ram bank #0
                        	  1033: 
01:0555 CD0000          	  1034: 		call 	enableFLASH			; start from FLASH
                        	  1035: 
01:0558 CD0000          	  1036: 		call 	enableIC620_OE 			; enable the outputs.
                        	  1037: 
01:055B C30000          	  1038: 		jp $0000
                        	  1039: 
                        	  1040: p_load:
01:055E C9              	  1041: 		ret
                        	  1042: p_dumpmem:
01:055F CD0000          	  1043: 		call 	dumpMemory
                        	  1044: 
01:0562 C9              	  1045: 		ret
                        	  1046: p_pc:
01:0563 C9              	  1047: 		ret
                        	  1048: 
                        	  1049: p_eep:
                        	  1050: 
01:0564 210000          	  1051: 		ld 		HL,000
01:0567 220000          	  1052: 		ld 		(PCvalue),hl
01:056A C9              	  1053: 		ret
                        	  1054: 
                        	  1055: p_clearmem:
                        	  1056: ;		***		clear memory from PC/Adr n bytes from ram memory
                        	  1057: 
01:056B ED4B0000        	  1058: 		ld 		BC,(commLvl1)    	;amount of bytes
01:056F ED5B0000        	  1059: 		ld   	DE,(PCvalue)		 
01:0573 217D05          	  1060: 		ld		hl,.zero_byte
                        	  1061: 		
                        	  1062: .cl_vars:
01:0576 EDA0            	  1063: 		ldi							; (DE)<-(HL)
01:0578 2B              	  1064: 		dec 	hl
01:0579 EA7605          	  1065: 		jp		PE,.cl_vars			; 		P/V is set if BC  1  0; otherwise, it is reset.
                        	  1066: 
01:057C C9              	  1067: 		ret
01:057D 00              	  1068: .zero_byte:	db  0
                        	  1069: 
                        	  1070: p_exe:
                        	  1071: 
                        	  1072: 		; call 	LCD_Test
                        	  1073: 
01:057E C9              	  1074: 		ret
                        	  1075: p_go:
                        	  1076: 
01:057F 18FD            	  1077: 		jr 	p_exe
                        	  1078: 
                        	  1079: 
01:0581 3A0000          	  1080: 		ld 		A,(TempVar1)
01:0584 3C              	  1081: 		inc 	A
01:0585 320000          	  1082: 		ld 		(TempVar1),A
01:0588 FE0F            	  1083: 		cp 		15
01:058A CD0000          	  1084: 		call 	DumpRegisters
                        	  1085: 		
01:058D F0              	  1086: 		ret 	P
01:058E 18EF            	  1087: 		jr 		p_go
                        	  1088: p_incDecPC:
01:0590 210000          	  1089: 		ld 		HL,commLvl1
01:0593 3E00            	  1090: 		ld 		A,0
01:0595 5E              	  1091: 		ld 		E,(HL)
01:0596 23              	  1092: 		inc 	HL
01:0597 56              	  1093: 		ld 		D,(hl) 				; DE = (commLvl1)
                        	  1094: 		; ***	if both D and E is 0 -> DE = 1 		; no param -> A=1
01:0598 BB              	  1095: 		cp 		E
01:0599 2006            	  1096: 		jr 		NZ,.justOne
01:059B BA              	  1097: 		cp 		D
01:059C 2003            	  1098: 		jr 		NZ,.justOne
01:059E 110100          	  1099: 		ld 		DE,1
                        	  1100: .justOne:
01:05A1 3A0000          	  1101: 		ld 		A,(commParseTable)	; command number in commParseTable
01:05A4 2A0000          	  1102: 		ld 		HL,(PCvalue)
01:05A7 FE08            	  1103: 		cp 		8 					; ++ (increase) ??
01:05A9 2003            	  1104: 		jr  	nz,.sub
01:05AB 19              	  1105: 		add 	HL,DE 				; increase HL (PCvalue) with DE
01:05AC 1803            	  1106: 		jr 		.common
                        	  1107: .sub:
01:05AE A7              	  1108: 		and 	A					; clear C
01:05AF ED52            	  1109: 		sbc 	HL,DE 				; decrease HL (PCvalue) with DE
                        	  1110: .common:
01:05B1 220000          	  1111: 		ld 		(PCvalue),HL
01:05B4 C9              	  1112: 		ret
                        	  1113: p_flwr:
                        	  1114: 		; *** 	testwrite to FLASH
                        	  1115: 		
                        	  1116: 		; call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
                        	  1117: 		; jp		NZ,argumentsError			; show argument error and return
                        	  1118: 		; 	*** Check if flashmem is enabled
01:05B5 3A0000          	  1119: 		ld 		A,(memBankID)
01:05B8 CB7F            	  1120: 		bit 	7,A
01:05BA 2004            	  1121: 		jr 		NZ,errNoFlash
                        	  1122: 
01:05BC CD0000          	  1123: 		call 	Flash_WR_Test
01:05BF C9              	  1124: 		ret
                        	  1125: errNoFlash:
01:05C0 CD0000          	  1126: 		call 	writeSTRBelow
01:05C3 00              	  1127: 		DB 		0," Can't write to deselected FLASH !",CR,LF,00
01:05C4 2043616E27742077
01:05CC 7269746520746F20
01:05D4 646573656C656374
01:05DC 656420464C415348
01:05E4 2021
01:05E6 0D
01:05E7 0A
01:05E8 00
                        	  1128: 
01:05E9 C9              	  1129: 		ret
                        	  1130: 
                        	  1131: 
                        	  1132: p_flse:
                        	  1133: 		; *** 	erase the sector that contain the address of HL
                        	  1134: 
01:05EA E5              	  1135: 		push	HL
01:05EB 211020          	  1136: 		ld 		HL,$2010
01:05EE CD0000          	  1137: 		call 	Flash_SE_Erase
01:05F1 E1              	  1138: 		pop 	HL
01:05F2 C9              	  1139: 		ret
                        	  1140: 
                        	  1141: p_xmod:
                        	  1142: 		; ***	Transfer files via x-modem
                        	  1143: 		; ***	Check commParseTable+1 if required parameters
                        	  1144: 
01:05F3 3A0100          	  1145: 		ld 		A,(commParseTable+1)
01:05F6 CB47            	  1146: 		bit 	0,A 			; should be a <2-textstring 	1-address	 0-lvalue>
01:05F8 2804            	  1147: 		jr 		Z,.nxta
                        	  1148: 		; ***	check the commLvl1 if zero
01:05FA ED5B0000        	  1149: 		ld 		DE,(commLvl1)
                        	  1150: .nxta:		
                        	  1151: 
                        	  1152: 		ifndef 	BOOTLOAD				; don not use during BOOT
01:05FE CD0000          	  1153: 		call 	doImportXMODEM
                        	  1154: 
01:0601 CD0000          	  1155: 		call 	SIO_A_TXRX_INTon
01:0604 CD0000          	  1156: 		call 	CTC1_INT_OFF
                        	  1157: 		endif	
01:0607 C9              	  1158: 		ret
                        	  1159: 
                        	  1160: p_C_Read:
                        	  1161: 
01:0608 CDC507          	  1162: 		call 	checkArgsTAL				; check necessary args
01:060B C22905          	  1163: 		jp		NZ,argumentsError			; show argument error and return
                        	  1164: 	
01:060E 110000          	  1165: 		ld 		DE,CTC_delay_INT_handler
01:0611 ED5312F4        	  1166: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1167: 
                        	  1168: 	ifd 	GPIODEBUG
01:0615 AF              	  1169: 	xor A
01:0616 D302            	  1170: 	out (gpio_out),A
                        	  1171: 	endif
                        	  1172: 
01:0618 CD0000          	  1173: 		call  	SIO_A_DI					; disable text output
                        	  1174: 	ifd 	GPIODEBUG
01:061B 3E04            	  1175: 	ld a,4
01:061D D302            	  1176: 	out (gpio_out),A
01:061F 3E00            	  1177: 	ld a,0
01:0621 D302            	  1178: 	out (gpio_out),A
                        	  1179: 	endif
                        	  1180: 	
01:0623 7B              	  1181: 		ld a,e
01:0624 CD0000          	  1182: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
01:0627 CD0000          	  1183: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
01:062A CD0000          	  1184: 		call 	HC376S_ResetAll
01:062D CD0000          	  1185: 		call 	HC376S_CheckConnection
01:0630 3A0000          	  1186: 		ld 		A,(commParseTable)
01:0633 FE0F            	  1187: 		cp 		15							; 15 read SD; 17-read USB
01:0635 280C            	  1188: 		jr 		Z,.doSD
01:0637 FE15            	  1189: 		cp 		21							; 21 read SD enumerate, 22 read USB enumerate
01:0639 2808            	  1190: 		jr 		Z,.doSD
01:063B CD0000          	  1191: 		call 	HC376S_setUSBMode
01:063E CD0000          	  1192: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:0641 1803            	  1193: 		jr 		.cont
                        	  1194: .doSD:
01:0643 CD0000          	  1195: 		call 	HC376S_setSDMode
                        	  1196: 		
                        	  1197: .cont:
01:0646 CD0000          	  1198: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:0649 2011            	  1199: 		jr 		NZ,abort
                        	  1200: 
01:064B CD0000          	  1201: 		call 	HC376S_setFileName
01:064E CD0000          	  1202: 		call 	HC376S_fileOpen
01:0651 2009            	  1203: 		jr 		NZ,abort
                        	  1204: 
01:0653 CD0000          	  1205: 		call 	HC376S_getFileSize
01:0656 CD0000          	  1206: 		call 	HC376S_fileRead
01:0659 CD0000          	  1207: 		call 	HC376S_fileClose
                        	  1208: abort:
                        	  1209: 
                        	  1210: 		; ***	reset the interrupt handler for CTC
01:065C CD0000          	  1211: 		call 	SIO_A_EI					; enable text output
01:065F CD0000          	  1212: 		call 	HC376S_ResetAll
01:0662 CD0000          	  1213: 		call 	CTC1_INT_OFF
01:0665 210000          	  1214: 		ld		HL,CTC_CH1_Interrupt_Handler
01:0668 2212F4          	  1215: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
01:066B C9              	  1216: 		ret
                        	  1217: 
                        	  1218: 		
                        	  1219: p_C_Write:
01:066C CDC507          	  1220: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
01:066F 2816            	  1221: 		jr 		Z,.contWR
                        	  1222: 		; ***	check alternative (2 adresses)
01:0671 3E2C            	  1223: 		ld 		A,%101100					; alt. with "string" $Adr1 < $Adr2
01:0673 77              	  1224: 		ld 		(HL),A						; HL-> (commParseTable+1);
01:0674 23              	  1225: 		inc 	HL			; HL-> (commParseTable+2); get the resulting arguments counted
01:0675 BE              	  1226: 		cp 		(HL) 						; compare resulting arguments with req arguments
                        	  1227: 
01:0676 C22905          	  1228: 		jp		NZ,argumentsError			; show argument error and return
                        	  1229: 		
                        	  1230: 		; ***	calculate size from addresses $Adr2 - $Adr1
01:0679 37              	  1231: 		scf
01:067A 3F              	  1232: 		ccf
01:067B 2A0000          	  1233: 		ld 		HL,(commAdr2)
01:067E ED5B0000        	  1234: 		ld		DE,(commAdr1)
01:0682 ED52            	  1235: 		sbc		HL,DE
01:0684 220000          	  1236: 		ld 		(commLvl1),HL				; resulting size in commLvl1
                        	  1237: 
                        	  1238: 
                        	  1239: .contWR:
01:0687 110000          	  1240: 		ld 		DE,CTC_delay_INT_handler
01:068A ED5312F4        	  1241: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1242: 
01:068E CD0000          	  1243: 		call 	purgeRXB
01:0691 CD0000          	  1244: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
01:0694 CD0000          	  1245: 		call 	HC376S_ResetAll
01:0697 CD0000          	  1246: 		call 	HC376S_CheckConnection
01:069A 3A0000          	  1247: 		ld 		A,(commParseTable)
01:069D FE10            	  1248: 		cp 		16							; 16 read SD; 18-read USB
01:069F 2808            	  1249: 		jr 		Z,.doSD
01:06A1 CD0000          	  1250: 		call 	HC376S_setUSBMode
01:06A4 CD0000          	  1251: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:06A7 1803            	  1252: 		jr 		.cont
                        	  1253: .doSD:
01:06A9 CD0000          	  1254: 		call 	HC376S_setSDMode
                        	  1255: .cont:
01:06AC CD0000          	  1256: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:06AF 20AB            	  1257: 		jr 		NZ,abort
01:06B1 CD0000          	  1258: 		call 	HC376S_setFileName
01:06B4 CD0000          	  1259: 		call 	HC376S_fileCreate
01:06B7 20A3            	  1260: 		jr		NZ,abort
01:06B9 CD0000          	  1261: 		call 	HC376S_fileWrite
                        	  1262: 		
01:06BC CD0000          	  1263: 		call 	HC376S_fileClose
01:06BF CD0000          	  1264: 		call 	HC376S_ResetAll
01:06C2 1898            	  1265: 		jr 		abort
                        	  1266: 
                        	  1267: p_C_Delete:
01:06C4 CDC507          	  1268: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1  )
01:06C7 C22905          	  1269: 		jP 		NZ,argumentsError
01:06CA 110000          	  1270: 		ld 		DE,CTC_delay_INT_handler
01:06CD ED5312F4        	  1271: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1272: 
01:06D1 CD0000          	  1273: 		call 	purgeRXB
01:06D4 CD0000          	  1274: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
                        	  1275: 
01:06D7 CD0000          	  1276: 		call 	HC376S_ResetAll
01:06DA CD0000          	  1277: 		call 	HC376S_CheckConnection
01:06DD 3A0000          	  1278: 		ld 		A,(commParseTable)
01:06E0 FE13            	  1279: 		cp 		19							; 19 delete file SD; 20-delete file USB
01:06E2 2808            	  1280: 		jr 		Z,.doSD
01:06E4 CD0000          	  1281: 		call 	HC376S_setUSBMode
01:06E7 CD0000          	  1282: 		call 	HC376S_diskConnectionStatus
01:06EA 1803            	  1283: 		jr 		.cont
                        	  1284: .doSD:
01:06EC CD0000          	  1285: 		call 	HC376S_setSDMode
                        	  1286: .cont:
01:06EF CD0000          	  1287: 		call 	HC376S_USBdiskMount
                        	  1288: 		 
                        	  1289: 		; call 	HC376S_fileOpen
                        	  1290: 		; call 	HC376S_getFileSize
                        	  1291: 		; call 	HC376S_fileRead
                        	  1292: 
01:06F2 CD0000          	  1293: 		call 	HC376S_fileDelete
01:06F5 CD0000          	  1294: 		call 	HC376S_ResetAll
                        	  1295: 
01:06F8 C35C06          	  1296: 		jp 		abort
                        	  1297: 
                        	  1298: p_cptFl:
01:06FB CD0000          	  1299: 		call 	setFLASHBank				; change to bank
01:06FE C9              	  1300: 		ret
01:06FF CD0000          	  1301: 		call 	setSRAMBank 			; change to bank
01:0702 C9              	  1302: 		ret
                        	  1303: ;********************************************************************************************
                        	  1304: ;********************************************************************************************	
                        	  1305: p_srbank:
                        	  1306: 	; ***	set sram bank #
01:0703 CD8C07          	  1307: 	call 	p_FOFF				; disable the flash memory
01:0706 3A0000          	  1308: 	ld 		A,(commLvl1) 			; load param into A
                        	  1309: ; ***	set the SRAM bank ID; Bank ID in A
                        	  1310: p_srbank0:
                        	  1311: 
01:0709 E5              	  1312: 	push 	HL
01:070A C5              	  1313: 	push 	BC
01:070B 210000          	  1314: 	ld 		HL,memBankID
01:070E E60F            	  1315: 	and 	$0F 				; clear all bits but 0-3 in A
                        	  1316: 
01:0710 47              	  1317: 	ld 		B,A
01:0711 7E              	  1318: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:0712 E6F0            	  1319: 	and 	$F0  				; zero bits 0-3
01:0714 1815            	  1320: 	jr 		putBank
                        	  1321: 
                        	  1322: ;********************************************************************************************
                        	  1323: ;********************************************************************************************	
                        	  1324: 
                        	  1325: p_flbank:
                        	  1326: 	; ***	set flash bank #
                        	  1327: 
01:0716 CD3207          	  1328: 	call 	p_FON				; enable  the  flash memory
01:0719 3A0000          	  1329: 	ld 		A,(commLvl1) 			; load param into A
                        	  1330: ; ***	set the FLASH bank ID; Bank ID in A
                        	  1331: p_flbank0:
                        	  1332: 
01:071C E5              	  1333: 	push 	HL
01:071D C5              	  1334: 	push 	BC
01:071E 210000          	  1335: 	ld 		HL,memBankID
01:0721 E607            	  1336: 	and 	$07 				; clear all bits but 0-2
01:0723 07              	  1337: 	rlca
01:0724 07              	  1338: 	rlca
01:0725 07              	  1339: 	rlca
01:0726 07              	  1340: 	rlca						; bank ID = bits 4-6
                        	  1341: 
01:0727 47              	  1342: 	ld 		B,A
01:0728 7E              	  1343: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:0729 E68F            	  1344: 	and 	$8F  				; zero bits 4-6
                        	  1345: putBank:
01:072B B0              	  1346: 	or 		B					; put new EEP bank ID in A...
01:072C 77              	  1347: 	ld 		(HL),A				; store new value
01:072D D300            	  1348: 	out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
01:072F C1              	  1349: 	pop  	BC
01:0730 E1              	  1350: 	pop 	HL
01:0731 C9              	  1351: 	ret
                        	  1352: 
                        	  1353: ;********************************************************************************************
                        	  1354: ;********************************************************************************************	
                        	  1355: 
                        	  1356: p_FON:
                        	  1357: 		; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0)
                        	  1358: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	  1359: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1360: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:0732 CD0000          	  1361: 	call 	writeSTRBelow
01:0735 00              	  1362: 	DB 		0," Use 256k FLASH (7 banks),lower 32k and SRAM (16 banks),upper 32k !",CR,LF,00
01:0736 2055736520323536
01:073E 6B20464C41534820
01:0746 28372062616E6B73
01:074E 292C6C6F77657220
01:0756 33326B20616E6420
01:075E 5352414D20283136
01:0766 2062616E6B73292C
01:076E 7570706572203332
01:0776 6B2021
01:0779 0D
01:077A 0A
01:077B 00
01:077C CD0000          	  1363: 	call 	waitForFinishedPrintout
                        	  1364: p_FON_No_Print: 		;; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0) without printout		
01:077F E5              	  1365: 	push 	HL
01:0780 210000          	  1366: 	ld 		HL,rstBankID
01:0783 CB9E            	  1367: 	res 	3,(HL)				; clear bit 3 -> enable FLASH
01:0785 CB96            	  1368: 	res 	2,(HL)				; temp enable reset of IC622
                        	  1369: putBankF:
01:0787 7E              	  1370: 	ld 		A,(HL)
01:0788 D300            	  1371: 	out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
01:078A E1              	  1372: 	pop 	HL
01:078B C9              	  1373: 	ret 
                        	  1374: 	
                        	  1375: ;********************************************************************************************
                        	  1376: ;********************************************************************************************	
                        	  1377: p_FOFF:
                        	  1378: 	; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1)
                        	  1379: 	; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	  1380: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1381: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:078C CD0000          	  1382: 	call 	writeSTRBelow
01:078F 20557365206F6E6C	  1383: 	DB 		" Use only SRAM (16 banks),upper 32k !",CR,LF,00
01:0797 79205352414D2028
01:079F 31362062616E6B73
01:07A7 292C757070657220
01:07AF 33326B2021
01:07B4 0D
01:07B5 0A
01:07B6 00
01:07B7 CD0000          	  1384: 	call 	waitForFinishedPrintout
                        	  1385: 
                        	  1386: p_FOFF_No_Print:		; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1) without printout
01:07BA E5              	  1387: 	push 	HL
01:07BB 210000          	  1388: 	ld 		HL,rstBankID
01:07BE CBD6            	  1389: 	set 	2,(HL) 			; temp disable reset of IC622
01:07C0 CBDE            	  1390: 	set 	3,(HL)			; set bit 3 -> disable FLASH
01:07C2 18C3            	  1391: 	jr 		putBankF
                        	  1392: 	; ld 		A,(HL)
                        	  1393: 	; out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
                        	  1394: 	; pop 	HL
                        	  1395: 	; call 	writeSTRBelow
                        	  1396: 	; DB 		0," Use only 512k (16 banks) SRAM !",CR,LF,00
01:07C4 C9              	  1397: 	ret 
                        	  1398: 
                        	  1399: ;********************************************************************************************     
                        	  1400: ;********************************************************************************************     
                        	  1401: 
                        	  1402: 		; ***	Check commParseTable+1 if required parameters
                        	  1403: checkArgsTAL:		
                        	  1404: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	  1405: 
                        	  1406: 		; ***	try to connect to USB
01:07C5 210200          	  1407: 		ld 		HL,commParseTable+2				; resulting typed arguments
01:07C8 3E00            	  1408: 		ld 		A,0
01:07CA 77              	  1409: 		ld 		(HL),A
                        	  1410: 
01:07CB DD210000        	  1411: 		ld 		IX,commStr1			; commStr1 =			0xB0
01:07CF CDF907          	  1412: 		call 	shift_0_1:
01:07D2 DD210000        	  1413: 		ld 		IX,commStr2			; commStr2 =			0xD8
01:07D6 CDF907          	  1414: 		call 	shift_0_1:
01:07D9 DD210000        	  1415: 		ld 		IX,commAdr1			; commAdr1 =			0x84
01:07DD CDF907          	  1416: 		call 	shift_0_1:
01:07E0 DD210000        	  1417: 		ld 		IX,commAdr2			; commAdr2 =			0x88
01:07E4 CDF907          	  1418: 		call 	shift_0_1:
01:07E7 DD210000        	  1419: 		ld 		IX,commLvl1			; commLvl1 =			0x90
01:07EB CDF907          	  1420: 		call 	shift_0_1:
01:07EE DD210000        	  1421: 		ld 		IX,commLvl2			; commLvl2 =			0xA0
01:07F2 CDF907          	  1422: 		call 	shift_0_1:
                        	  1423: 
01:07F5 7E              	  1424: 		ld 		A,(HL)						; get the resulting arguments counted
01:07F6 2B              	  1425: 		dec 	HL
01:07F7 BE              	  1426: 		cp 		(HL) 						; compare resulting arguments with req arguments
01:07F8 C9              	  1427: 		ret 	 					; return with Z or NZ  arguments
                        	  1428: 
                        	  1429: shift_0_1:
01:07F9 DDBE00          	  1430: 		cp 		(IX)
01:07FC 2008            	  1431: 		jr 		NZ,shiftIn1
01:07FE DDBE01          	  1432: 		cp 		(IX+1)
01:0801 2003            	  1433: 		jr 		NZ,shiftIn1
                        	  1434: 		; ***	both =0 shift in '0'
01:0803 CB26            	  1435: 		sla		(HL)
01:0805 C9              	  1436: 		ret
                        	  1437: shiftIn1:
                        	  1438: 		; ***	least one not '0' shift in '1'
01:0806 37              	  1439: 		scf		
01:0807 CB16            	  1440: 		rl 		(HL)
01:0809 C9              	  1441: 		ret
                        	  1442: 
                        	  1443: 
                        	  1444: ;********************************************************************************************     
                        	  1445: ;********************************************************************************************     
                        	  1446: 
                        	  1447: bit_test9:
01:080A 01              	  1448: 	db	0x01,0x02,0x80,0x40
01:080B 02
01:080C 80
01:080D 40
                        	  1449: 
                        	  1450: 
                        	  1451: ; debug:		equ	0		; Set to 1 to show debug printing, else 0 
                        	  1452: 
                        	  1453: 
                        	  1454: 	; Spin loop here because there is nothing else to do
                        	  1455: ; halt_loop:
                        	  1456: ; 	halt
                        	  1457: ; 	jp	halt_loop
                        	  1458: 
                        	  1459: 
                        	  1460: 
                        	  1461: 
                        	  1462: 
                        	  1463: ;*******************************************************************************     
                        	  1464: ;*******************************************************************************     
                        	  1465: 
                        	  1466: 
                        	  1467: 
                        	  1468: 		; ld 		hl,Textbuf
                        	  1469: 		; ; call	ReadLine 			;to textbuf  (A=length of input string)
                        	  1470: 
                        	  1471: 		; ld		HL,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	  1472: 		; ld		DE,Textbuf			;DE = 32767
                        	  1473: 		; call	BN2DEC				; C0NVERT
                        	  1474: 		; jp		textloop
                        	  1475: 
                        	  1476: 
                        	  1477: 		; ld 		hl,Textbuf
                        	  1478: 		; call	DEC2BN			; result in HL
                        	  1479: 
                        	  1480: 		; ld 		E,L
                        	  1481: 		; 	; Binary to HEX  BN2HEX   E->(HL)
                        	  1482: 		; ld 		hl,T_BUFFER
                        	  1483: 		; inc		hl
                        	  1484: 		; call	Bin2Hex8			;result in T_buffer
                        	  1485: 
                        	  1486: 		; ld 		iy,T_BUFFER
                        	  1487: 		; call 	WriteLineCRNL
                        	  1488: 
                        	  1489: 		; ld 		iy,Textbuf
                        	  1490: 		; call	WriteLineCRNL
                        	  1491: 
                        	  1492: 		; jp 		next_line
                        	  1493: 
                        	  1494: 
                        	  1495: 
                        	  1496: textloop:
                        	  1497: 		; LD		HL,sourctext1
                        	  1498: 		; LD		DE,S1x
                        	  1499: 		; LD		BC,src_size
                        	  1500: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1501: 
                        	  1502: 
                        	  1503: 		; LD		HL,sourctext2
                        	  1504: 		; LD		DE,S2x
                        	  1505: 		; LD		BC,14
                        	  1506: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1507: 
                        	  1508: 		; test of string concat
                        	  1509: 		; LD		HL,S1_8B		;HL = BASE ADDRESS OF S1
                        	  1510: 		; LD		DE,S2_8B		;DE = BASE ADDRESS OF S2
                        	  1511: 		; LD		B,40			;B = MAXIMUM LENGTH OF STRING 1
                        	  1512: 		; CALL 	CONCAT 			;CONCATENATE STRINGS to S1_8B
                        	  1513: 
                        	  1514: 
                        	  1515: 		; test of POS
                        	  1516: 		; LD		HL,Str2			;HL = BASE ADDRESS OF STRING
                        	  1517: 		; LD		DE,subst		;DE = BASE ADDRESS OF SUBSTRING	
                        	  1518: 		; CALL	POS				;FIND POSITION OF SUBSTRING
                        	  1519: 								; RESULTS IN REGISTER A = 8
                        	  1520: 
                        	  1521: 
                        	  1522: 		; test copy
                        	  1523: 		; LD		HL,Str4			; SOURCE STRING
                        	  1524: 		; LD		DE,COPY_BUFFER	;	DESTINATION STRING
                        	  1525: 		
                        	  1526: 		; LD		C,4				; STARTING INDEX FOR COPYING
                        	  1527: 
                        	  1528: 		; LD		B,6				; NUMBER OF BYTES TO COPY
                        	  1529: 		; LD		A, 25			; MAXIMUM LENGTH OF SUBSTRING
                        	  1530: 		; CALL 	COPY			; COPY SUBSTRING
                        	  1531: 
                        	  1532: 		; ld 		iy,COPY_BUFFER
                        	  1533: 		; call 		WriteLineCRNL ; print the copy string
                        	  1534: 
                        	  1535: 
                        	  1536: 		; ; test DELETE
                        	  1537: 		; LD		HL,Str0		;HL	= BASE 	ADDRESS OF STRING
                        	  1538: 		; LD		A,8			
                        	  1539: 		; LD		C,8				;	C= STARTING INDEX FOR DELETION
                        	  1540: 		; LD		A,4			
                        	  1541: 		; LD		B,4			; B = NUMBER OF CHARACTERS TO DELETE
                        	  1542: 		; CALL 	DELETE 			; DELETE CHARACTERS
                        	  1543: 									; DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	  1544: 		; ld 		iy,Str0
                        	  1545: 		; call 		WriteLineCRNL ; print the copy string
                        	  1546: 
                        	  1547: 
                        	  1548: ; 		;test INSERT
                        	  1549: 
                        	  1550: ; 		LD		HL,Str3				; HL = BASE ADDRESS OF STRING
                        	  1551: ; 		LD		DE,subst			; DE = BASE ADDRESS OF SUBSTRING
                        	  1552: 
                        	  1553: ; 		LD		C,7					; C = STARTING INDEX FOR INSERTION
                        	  1554: 
                        	  1555: ; 		LD		B,0x40				; B = MAXIMUM LENGTH OF STRING
                        	  1556: ; 		CALL 	INSERT_STR			; INSERT SUBSTRING
                        	  1557: ; 		ld 		iy,Str3
                        	  1558: ; 		; call	WriteLineCRNL 		; print the modified string
                        	  1559: 
                        	  1560: 
                        	  1561: ; 		jp		next_line
                        	  1562: 
                        	  1563: ; 		;TEST DATA. CHANGE FOR OTHER VALUES
                        	  1564: ; S1_8B:	DB		8H				; LENGTH OF SI
                        	  1565: ; 		DB      "LASTNAME                        "	; 32 BYTE MAX LENGTH
                        	  1566: ; S2_8B:	DB		0BH				;LENGTH OF S2
                        	  1567: ; 		DB		". FIRSTNAME                     "	; 32 BYTE MAX LENGTH
                        	  1568: 
                        	  1569: ;********************************************************************************************
                        	  1570: ;********************************************************************************************	
                        	  1571: ; sh_test:
                        	  1572: ; 		; turn shadow off then halt
                        	  1573: ; 		xor A
                        	  1574: ; 		out (_CE_RST_BANK),A 		;// clear '64K_SRAM' signal
                        	  1575: 
                        	  1576: ; 		halt
                        	  1577: 
                        	  1578: ; 		ld	A,$80
                        	  1579: ; 		out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	  1580: ; 		ld 	A,1
                        	  1581: ; 		out (_CE_RST_BANK),A 		; engage 3-state on bank#
                        	  1582: ; 		ret
                        	  1583: 
                        	  1584: 
                        	  1585: ;********************************************************************************************
                        	  1586: ;********************************************************************************************	
                        	  1587: 			;9H JUMP TABLE (JTAB)   353
                        	  1588:         ; Title               Jump table
                        	  1589:         ; Name:               JTAB
                        	  1590:         ; Purpose:            Given an index, jump to the subroutine with
                        	  1591:         ;                     that index in a table.
                        	  1592:         ; Entry:              Register A is the subroutine number (0 to
                        	  1593:         ;                                LENSUB-l, the number of subroutines)
                        	  1594:         ;                                LENSUB must be less than or equal to
                        	  1595:         ;                                128.
                        	  1596:         ; Exit:               If the routine number is valid then
                        	  1597:         ;                       execute the routine
                        	  1598:         ;                     else
                        	  1599:         ;                       Carry flag = 1
                        	  1600:         ; Registers used: AF
                        	  1601:         ; Time:               117 cycles plus execution time of subroutine
                        	  1602:         ; Size:               Program 21 bytes plus size of table (2*LENSUB)
                        	  1603: 
                        	  1604:         ;EXIT WITH CARRY SET IF ROUTINE NUMBER IS INVALID
                        	  1605:         ; THAT IS, IF IT IS TOO LARGE FOR TABLE OLENSUB -     1)
                        	  1606: 
                        	  1607: 
                        	  1608: ; JTAB:
                        	  1609: ; 		CP		LENSUB			;COMPARE ROUTINE NUMBER, TABLE SIZE
                        	  1610: ; 		CCF						;COMPLEMENT CARRY FOR ERROR INDICATOR
                        	  1611: ; 		RET		C				;RETURN IF ROUTINE NUMBER TOO LARGE
                        	  1612: ; 									; WITH CARRY SET
                        	  1613: ; 		; INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
                        	  1614: ; 		; LEAVE REGISTER PAIRS UNCHANGED SO THEY CAN BE USED FOR PASSING PARAMETERS
                        	  1615: 
                        	  1616: ; 		PUSH	HL				;SAVE HL
                        	  1617: ; 		ADD		A,A				;DOUBLE INDEX FOR WORD-LENGTH ENTRIES
                        	  1618: ; 		LD		HL,JMPTAB		;INDEX INTO TABLE USING 8-BIT
                        	  1619: ; 		ADD		A,L			; ADDITION TO AVOID DISTURBING
                        	  1620: ; 		LD		L,A				; ANOTHER REGISTER PAIR
                        	  1621: ; 		LD		A,0
                        	  1622: ; 		ADC		A,H
                        	  1623: ; 		LD		H,A			; ACCESS ROUTINE ADDRESS
                        	  1624: ; 			;OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
                        	  1625: ; 			;CONTROL TO IT, LEAVING ALL REGISTER PAIRS UNCHANGED
                        	  1626: 
                        	  1627: ; 		LD		A, (HL)			;MOVE ROUTINE ADDRESS TO HL
                        	  1628: ; 		INC		HL
                        	  1629: ; 		LD		H, (HL)
                        	  1630: ; 		LD		L,A
                        	  1631: ; 		EX		(SP),HL				;RESTORE OLD HL, PUSH ROUTINE ADDRESS
                        	  1632: ; 		RET						; JUMP TO ROUTI NE
                        	  1633: 
                        	  1634: ; LENSUB		EQU		3				;NUMBER OF SUBROUTINES IN TABLE
                        	  1635: ; JMPTAB:                            ;JUMP TABLE
                        	  1636: ; 		DW		SUB0			;ROUTINE 0
                        	  1637: ; 		DW		SUB1			;ROUTINE 1
                        	  1638: ; 		DW		SUB2			;ROUTINE 2
                        	  1639: ;            ;THREE TEST SUBROUTINES FOR JUMP TABLE
                        	  1640: ; SUB0:
                        	  1641: ; 		LD		A,1				; TEST ROUTI NE 0 SETS (A)    1
                        	  1642: ; 		RET
                        	  1643: ; SUB1:
                        	  1644: ; 		LD		A,2				; TEST ROUTI NE 1 SETS (A) = 2
                        	  1645: ; 		RET
                        	  1646: ; SUB2:
                        	  1647: ; 		LD		A,3				;TEST ROUTINE 2 SETS (A)      3
                        	  1648: ; 		RET
                        	  1649: 
                        	  1650: 
                        	  1651: 
                        	  1652: ; 			;SAMPLE EXECUTION:
                        	  1653: 
                        	  1654: 
                        	  1655: ; SC9H:
                        	  1656: ; 		SUB		A				;EXECUTE ROUTINE 0
                        	  1657: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   =1
                        	  1658: 
                        	  1659: ; 		LD		A,1				;EXECUTE ROUTINE 1
                        	  1660: ; 		CALL	JTAB			; AFTER EXECUTION, (A) = 2
                        	  1661: ; 		LD		A,2				;EXECUTE ROUTINE 2
                        	  1662: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   3
                        	  1663: ; 		LD		A,3				;EXECUTE ROUTINE 3
                        	  1664: ; 		CALL	JTAB			; AFTER EXECUTION, CARRY   1
                        	  1665: ; 		JR		SC9H			;LOOP FOR MORE TESTS
                        	  1666: 
                        	  1667: 
                        	  1668: ;********************************************************************************************
                        	  1669: ;********************************************************************************************	
                        	  1670: ; 		xref  	RDATA,RDATA_END,TB_length
                        	  1671: 
                        	  1672: ; 		;--------------------------------------------------
                        	  1673: ; 		; ld A,5
                        	  1674: ; 		; ld 	A,$00	
                        	  1675: ; 		; out (_Z80_BankCS),A		;// set bank register number 	
                        	  1676: ; 		ld 	A,$01
                        	  1677: ; 		out (_CE_RST_BANK),A 		;// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	  1678: 
                        	  1679: ; 		out (_8Bitsout),A
                        	  1680: 
                        	  1681: ; 		ld A, $0F                 ;mode 1 out
                        	  1682: ; 		out (portA_Contr), A         ; set port A as output
                        	  1683: ; 		ld A,$EB
                        	  1684: 
                        	  1685: ; Rtll:	
                        	  1686: 
                        	  1687: ; 		ld (40000),A
                        	  1688: ; 		ld A,0
                        	  1689: ; 		ld A,(40000)
                        	  1690: 
                        	  1691: ; 		out (portA_Data),A		; Data to PIO port A
                        	  1692: ; 		out (_8Bitsout),A
                        	  1693: ; 		;--------------------------------------------------
                        	  1694: ; 		ld	DE,$8200
                        	  1695: ; 		ld	HL,RDATA
                        	  1696: ; 		ld	BC,TB_length
                        	  1697: ; 		; ld	BC,RDATA_END-RDATA
                        	  1698: ; 		ldir
                        	  1699: 
                        	  1700: 
                        	  1701: ; SIO_A_RESET:
                        	  1702: ; 		ld	a,00110000b
                        	  1703: ; 		out	(SIO_A_C),A		;write into WR0: error reset, select WR0
                        	  1704: 
                        	  1705: ; 		ld	a,018h				;write into WR0: channel reset
                        	  1706: ; 		out (SIO_A_C),A 
                        	  1707: 
                        	  1708: ; 		ld	a,004h				;write into WR0: select WR4
                        	  1709: ; 		out	(SIO_A_C),A
                        	  1710: ; 		ld	a,44h				;44h write into WR4: clkx16,1 stop bit, no parity
                        	  1711: ; 		out (SIO_A_C),A
                        	  1712: 
                        	  1713: ; 		ld	a,005h				;write into WR0: select WR5
                        	  1714: ; 		out (SIO_A_C),A
                        	  1715: ; 		ld	a,01101000b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS inactive (bit 2)
                        	  1716: ; 		ld	a,01101010b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS active (bit 2)
                        	  1717: ; 		out (SIO_A_C),A
                        	  1718: ; SIO_A_EI:
                        	  1719: ; 			;enable SIO channel A RX
                        	  1720: ; 		ld	a,003h				;write into WR0: select WR3
                        	  1721: ; 		out (SIO_A_C),A
                        	  1722: ; 		ld	a,11000001b				;RX 8bit, auto enable off 8(bit 5), RX on (bit 0)
                        	  1723: ; 		ld	a,11100001b				;RX 8bit, auto enable on 8(bit 5), RX on (bit 0)
                        	  1724: ; 		out (SIO_A_C),A
                        	  1725: ; 		;Channel A RX active
                        	  1726: 
                        	  1727: 
                        	  1728: ; 		ld 	HL,Str0
                        	  1729: ; tstout:
                        	  1730: ; 		ld 	A,(HL)
                        	  1731: ; 		out (SIO_A_D),A
                        	  1732: ; 		inc HL
                        	  1733: ; 		ld D,A
                        	  1734: ; chkTX:
                        	  1735: ; 		in	A,(SIO_A_C)		; read status
                        	  1736: ; 		bit	2,A					; all sent ?
                        	  1737: ; 		jr z,chkTX				; not all sent..
                        	  1738: 
                        	  1739: ; 		ld 	A,(HL)
                        	  1740: ; 		cp	0
                        	  1741: ; 		jr 	z,endmsg
                        	  1742: 
                        	  1743: ; 		ld	A,D
                        	  1744: ; 		djnz	tstout
                        	  1745: 
                        	  1746: ; endmsg:
                        	  1747: ; chkRX:
                        	  1748: ; 		in	A,(SIO_A_C)		; read status
                        	  1749: ; 		bit	0,A					; char present ??
                        	  1750: ; 		jr z,chkRX				; check again
                        	  1751: 
                        	  1752: ; 		in 	A,(SIO_A_D)		; read the char.
                        	  1753: 
                        	  1754: ; 		out (SIO_A_D),A
                        	  1755: ; chkTX2:
                        	  1756: ; 		in	A,(SIO_A_C)		; read status
                        	  1757: ; 		bit	2,A					; all sent ?
                        	  1758: ; 		jr z,chkTX2
                        	  1759: 		
                        	  1760: ; 		jr	endmsg				; not all sent..
                        	  1761: 
                        	  1762: 
                        	  1763: 
                        	  1764: 
                        	  1765: ; 		halt
                        	  1766: ; 		halt
                        	  1767: ; 		halt
                        	  1768: ; 		inc A
                        	  1769: ; 		jr Rtll			
                        	  1770: 
                        	  1771: ; 	if DOALIGN
                        	  1772: ; 		align 4
                        	  1773: ; 	endif
                        	  1774: 
                        	  1775: 
                        	  1776: .end
                        	  1777: 


Symbols by name:
AddToT_Buf                      external
BLKMOV                          external EXP
BN2DEC                          external EXP
BN2DEC_S                        external EXP
Bin2Hex16                       external EXP
Bin2Hex8                        external EXP
BootCodeAdr                     external
CDEL                             E:00EE
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CONCAT                          external EXP
COPY                            external EXP
CR                               E:000D
CRC16                           external EXP
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       external
CTC_Init                        external
CTC_delay_INT_handler           external
DEC2BN                          external EXP
DELETE                          external EXP
DumpRegisters                   external
Flash_SE_Erase                  external
Flash_WR_Test                   external
GPIODEBUG                        E:0000
HC376S_CheckConnection          external
HC376S_ResetAll                 external
HC376S_USBdiskMount             external
HC376S_diskConnectionStatus     external
HC376S_fileClose                external
HC376S_fileCreate               external
HC376S_fileDelete               external
HC376S_fileOpen                 external
HC376S_fileRead                 external
HC376S_fileWrite                external
HC376S_getFileSize              external
HC376S_setFileName              external
HC376S_setSDMode                external
HC376S_setUSBMode               external
HEX2BN                          external EXP
INSERT_STR                      external EXP
ITEM                             E:001C
InitBuffers                     external EXP
InitInterrupt                   external EXP
JPTable01                       01:050F
LF                               E:000A
LISTEND                          E:001E
MFILL                           external EXP
MONITOR_Start                   01:0000 EXP
MONITOR_Start0                  00:022B
PCinpFlag                       external
PCvalue                         external
PIO_Init                        external
POS                             external EXP
ReadChar                        external EXP
ReadLine                        external EXP
RegFlags                        external EXP
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
S1x                             external
SD_USB_startup                  00:0003 EXP
SDabort                         00:021E
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        external
SIO_A_EI                        external
SIO_A_RTS_OFF                   external EXP
SIO_A_RTS_ON                    external EXP
SIO_A_TXRX_INTon                external
SIO_B_C                         external
SIO_B_D                         external
SIO_Init                        external
SIO_Int_Vec                      E:F400
SP_value                        external
STEND                            E:001D
S_head_tail                     external EXP
T_BUFFER                        external
TempVar1                        external
Textbuf                         external EXP
WriteChar                       external EXP
WriteLine                       external
WriteLineCRNL                   external
_CE_RST_BANK                    external
_RAMSTART                       external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
abort                           01:065C
argumentsError                  01:0529
bit_test9                       01:080A
byteEnd                         01:04BE
changePCVal                     01:04DF
checkArgsTAL                    01:07C5
checkaddress                    01:0441
chkADR                          01:044C
chkADR1                         01:044D
chkADR2                         01:045D
chkLVL2                         01:047F
cleanInBuffer                   external EXP
cleanOutBuffer                  external EXP
commAdr1                        external
commAdr2                        external
commListLen                      E:001B
commLvl1                        external
commLvl2                        external
commParseTable                  external
commStr1                        external
commStr2                        external
command_list                    01:0233
crc16_2                         external EXP
doImportXMODEM                  external
dumpMemory                      external EXP
enableFLASH                     external
enableIC620_OE                  external
endtext                         external EXP
errNoFlash                      01:05C0
executeCommand                  01:04FB
findCommandInList               01:01D0
findNextITEM                    01:01DC
getLvalue                       01:046F
gpioB                           external
gpio_in                         external
gpio_out                        external
inBuffer                        external EXP
inBufferEnd                     external EXP
initCommParseTable              01:03E3
initSIOBInterrupt               external
inputerror                      01:0200
isHex                           external EXP
makeASCIItoHEX                  01:048F
matchInList                     01:03F6
memBankID                       external
nextHalfByte                    01:049D
nextInList                      01:01FC
next_line                       01:014B
noHighNib                       01:04DB
p_C_Delete                      01:06C4
p_C_Read                        01:0608
p_C_Read_SD                     00:01E3
p_C_Write                       01:066C
p_FOFF                          01:078C
p_FOFF_No_Print                 01:07BA
p_FON                           01:0732
p_FON_No_Print                  01:077F
p_clearmem                      01:056B
p_cptFl                         01:06FB
p_dumpmem                       01:055F
p_eep                           01:0564
p_exe                           01:057E
p_flbank                        01:0716
p_flbank0                       01:071C
p_flse                          01:05EA
p_flwr                          01:05B5
p_go                            01:057F
p_incDecPC                      01:0590
p_load                          01:055E
p_pc                            01:0563
p_reset                         01:054A
p_srbank                        01:0703
p_srbank0                       01:0709
p_xmod                          01:05F3
paramLoopEntry                  01:040D
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external
putBank                         01:072B
putBankF                        01:0787
putDEtoScreen                   external
rfile_name                      00:01D3
rstBankID                       external
scanCommandList                 01:01CB
setFLASHBank                    external
setSRAMBank                     external
shiftIn1                        01:0806
shift_0_1                       01:07F9
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             external
skipPriorDelimit                external
sourctext1                      external EXP
sourctext2                      external EXP
src_size                        external EXP
st1g2                           external EXP
st2g1                           external EXP
steq                            external EXP
strCompare                      external EXP
subst                           external EXP
temp_finish                     01:050C
textloop                        01:080E
useFlash                        01:0160
waitForFinishedPrintout         external
writeSTRBelow                   external EXP
zero_byte                       01:01DB

Symbols by value:
0000 GPIODEBUG
0000 MONITOR_Start
0003 SD_USB_startup
000A LF
000D CR
001B commListLen
001C ITEM
001D STEND
001E LISTEND
00EE CDEL
014B next_line
0160 useFlash
01CB scanCommandList
01D0 findCommandInList
01D3 rfile_name
01DB zero_byte
01DC findNextITEM
01E3 p_C_Read_SD
01FC nextInList
0200 inputerror
021E SDabort
022B MONITOR_Start0
0233 command_list
03E3 initCommParseTable
03F6 matchInList
040D paramLoopEntry
0441 checkaddress
044C chkADR
044D chkADR1
045D chkADR2
046F getLvalue
047F chkLVL2
048F makeASCIItoHEX
049D nextHalfByte
04BE byteEnd
04DB noHighNib
04DF changePCVal
04FB executeCommand
050C temp_finish
050F JPTable01
0529 argumentsError
054A p_reset
055E p_load
055F p_dumpmem
0563 p_pc
0564 p_eep
056B p_clearmem
057E p_exe
057F p_go
0590 p_incDecPC
05B5 p_flwr
05C0 errNoFlash
05EA p_flse
05F3 p_xmod
0608 p_C_Read
065C abort
066C p_C_Write
06C4 p_C_Delete
06FB p_cptFl
0703 p_srbank
0709 p_srbank0
0716 p_flbank
071C p_flbank0
072B putBank
0732 p_FON
077F p_FON_No_Print
0787 putBankF
078C p_FOFF
07BA p_FOFF_No_Print
07C5 checkArgsTAL
07F9 shift_0_1
0806 shiftIn1
080A bit_test9
080E textloop
F400 SIO_Int_Vec
F412 CTC_CH1_I_Vector
