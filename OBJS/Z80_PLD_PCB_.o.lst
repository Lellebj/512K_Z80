Sections:
00: "SD_USB_Start" (0-24A)
01: "Monitor" (0-80F)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     4: 		include 	"Salea_Logic.inc"

Source: "Salea_Logic.inc"
                        	     1: 
                        	     2: ;       *** 
                        	     3: 
                        	     4:     macro make_pulse 
                        	     5: 
                        	     6:     xor     A
                        	     7:     set     \1,A    
                        	     8:     out (gpio_out),A
                        	     9:     out (gpio_out),A
                        	    10:     out (gpio_out),A
                        	    11:     out (gpio_out),A
                        	    12:     xor     A
                        	    13:     out (gpio_out),A
                        	    14:     
                        	    15: 
                        	    16:     endm

Source: "stdin"
                        	     5: 	
                        	     6: 
                        	     7: 
                        	     8: 
                        	     9: 
                        	    10: 			xref	Bin2Hex8,Bin2Hex16,  HEX2BN, BN2DEC,BN2DEC_S,DEC2BN,MFILL, BLKMOV,strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR
                        	    11: 			xref	InitBuffers, ReadLine, WriteChar, ReadChar, S_head_tail
                        	    12: 			xref	Textbuf, inBufferEnd,inBuffer,cleanInBuffer,cleanOutBuffer,InitInterrupt
                        	    13: 			xref	dumpMemory
                        	    14: 
                        	    15: 			xref	st2g1,st1g2,steq,subst
                        	    16: 			xref	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	    17: 			xref	sourctext1,sourctext2,endtext,src_size, writeSTRBelow,isHex
                        	    18: 
                        	    19: 			xref 	crc16_2,CRC16
                        	    20: 		
                        	    21: 		xref 	SIO_A_RTS_OFF,SIO_A_RTS_ON
                        	    22: 
                        	    23: 	;***************************************************************
                        	    24: 	;SAMPLE EXECUTION:
                        	    25: 	;***************************************************************
                        	    26: GPIODEBUG EQU 1
                        	    27: 
                        	    28: DO_Debug:	equ	0		; Set to 1 to show debug printing, else 0 
                        	    29: 
                        	    30: 	GLOBAL  MONITOR_Start, SD_USB_startup
                        	    31: ;************************************************************************************************
                        	    32: ;************************************************************************************************
                        	    33: ;***		SDcard/USB startup sequence
                        	    34: ;************************************************************************************************
                        	    35: ;************************************************************************************************
                        	    36: 		section SD_USB_Start
                        	    37: 
                        	    38: 
                        	    39: 		; jp 		MONITOR_Start0 		; jump to MONITOR_Start if hard call to $D000
                        	    40: 
                        	    41: SD_USB_startup:
                        	    42: 
                        	    43: 	ifdef  	GPIODEBUG
00:0000 3E33            	    44: 	ld 		A,$33
00:0002 D302            	    45: 	out 	(gpio_out),A
                        	    46: 
                        	    47: 	; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	    48: 
00:0004 ED730000        	    49: 	ld 		(SP_value),SP
                        	    50: 
00:0008 3EAA            	    51: 	ld 		A,$AA
00:000A D302            	    52: 	out 	(gpio_out),A
                        	    53: 	
00:000C CD0000          	    54: 	CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    55: 			; initialize buffer counters and pointers.
00:000F 3EBB            	    56: 	ld 		A,$BB
00:0011 D302            	    57: 	out 	(gpio_out),A
                        	    58: 
00:0013 CD0000          	    59: 		call	PIO_Init
00:0016 3ECC            	    60: 	ld 		A,$CC
00:0018 D302            	    61: 	out 	(gpio_out),A
00:001A CD0000          	    62: 		call 	CTC_Init
00:001D 3EDD            	    63: 	ld 		A,$DD
00:001F D302            	    64: 	out 	(gpio_out),A
00:0021 CD0000          	    65: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
00:0024 3EDF            	    66: 	ld 		A,$DF
00:0026 D302            	    67: 	out 	(gpio_out),A
00:0028 CD0000          	    68: 		call	S_head_tail			; save input heads and tails
00:002B 3E81            	    69: 	ld 		A,$81
00:002D D302            	    70: 	out 	(gpio_out),A
                        	    71: 	
                        	    72: 	else
                        	    73: 	
                        	    74: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	    75: 			; initialize buffer counters and pointers.
                        	    76: 		call	PIO_Init
                        	    77: 		call 	CTC_Init
                        	    78: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	    79: 		call	S_head_tail			; save input heads and tails
                        	    80: 	endif
                        	    81: 
                        	    82: 
                        	    83: 		; call	sh_test
                        	    84: 		; call 	Flash_WR_Test
                        	    85: 		; ld	HL,$2010
                        	    86: 		; call	Flash_SE_Erase
                        	    87: 
                        	    88: 		; check  $D008-$D00B for $33333333 -> Startup code is preloaded from Arduino 
                        	    89: 		; check  $D008-$D00B for $CCCCCCCC -> start from Flash 
                        	    90: 
00:002F 210000          	    91: 		ld 		HL,BootCodeAdr
00:0032 0604            	    92: 		ld 		B,04
00:0034 3E33            	    93: 		ld 		A,'3'
                        	    94: .checkBootCode:
00:0036 BE              	    95: 		cp 		(HL)	
00:0037 23              	    96: 		inc 	HL
00:0038 C2FB00          	    97: 		jp 		NZ,.SDstart
00:003B 10F9            	    98: 		djnz 	.checkBootCode
                        	    99: 
                        	   100: 
00:003D CD0000          	   101: 		call	CRLF
00:0040 CD0000          	   102: 		call 	writeSTRBelow
00:0043 0D0A            	   103: 		defb   	"\r\n"
00:0045 2B2D3D2D2B2D3D2D	   104: 		defb	"+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-+-=-\r\n"
00:004D 2B2D3D2D2B2D3D2D
00:0055 2B2D3D2D2B2D3D2D
00:005D 2B2D3D2D2B2D3D2D
00:0065 2B2D3D2D2B2D3D2D
00:006D 0D0A
00:006F 5374617274206672	   105: 		defb	"Start from Arduino preloaded monitor\r\n"
00:0077 6F6D204172647569
00:007F 6E6F207072656C6F
00:0087 61646564206D6F6E
00:008F 69746F720D0A
00:0095 202020206769743A	   106: 		defb	"    git: UPdate_Jan_25-7-gbbba3ce-dirty\r\n"
00:009D 205550646174655F
00:00A5 4A616E5F32352D37
00:00AD 2D67626262613363
00:00B5 652D64697274790D
00:00BD 0A
00:00BE 202020206275696C	   107: 		defb	"    build: 2026-02-24_22:40\r\n"
00:00C6 643A20323032362D
00:00CE 30322D32345F3232
00:00D6 3A34300D0A
00:00DB 20202020464C4153	   108: 		defb	"    FLASH->SRAM 0xD000.\r\n"
00:00E3 482D3E5352414D20
00:00EB 3078443030302E0D
00:00F3 0A
00:00F4 00              	   109: 		defb	"\0"
                        	   110: 
00:00F5 CD0000          	   111: 		call 	waitForFinishedPrintout
00:00F8 C30000          	   112: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   113: 		
                        	   114: 
                        	   115: .SDstart:
                        	   116: 		
00:00FB CD0000          	   117: 		call	CRLF
00:00FE CD0000          	   118: 		call 	writeSTRBelow
00:0101 0D0A            	   119: 		defb   	"\r\n"
00:0103 3D2D3D2D3D2D3D2D	   120: 		defb	"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\r\n"
00:010B 3D2D3D2D3D2D3D2D
00:0113 3D2D3D2D3D2D3D2D
00:011B 3D2D3D2D3D2D3D2D
00:0123 3D2D3D2D3D2D3D2D
00:012B 0D0A
00:012D 5374617274206672	   121: 		defb	"Start from SD/USB\r\n"
00:0135 6F6D2053442F5553
00:013D 420D0A
                        	   122: 		; defb	"    git: UPdate_Jan_25-7-gbbba3ce-dirty\r\n"
                        	   123: 		; defb	"    build: 2026-02-24_22:40\r\n"
                        	   124: 		; defb	"    FLASH->SRAM 0xD000.\r\n"
00:0140 00              	   125: 		defb	"\0"
                        	   126: 
00:0141 CD0000          	   127: 		 call 	waitForFinishedPrintout
                        	   128: 
                        	   129: 	ifd 	GPIODEBUG
00:0144 3E83            	   130: 	ld 		A,$83
00:0146 D302            	   131: 	out 	(gpio_out),A
                        	   132: 	endif
00:0148 CD0000          	   133: 		call	CRLF
                        	   134: 
                        	   135: ;*****	Setup Boot load from SD card.
                        	   136: ;***************************************
00:014B 110000          	   137: 		ld 		DE,commStr1					; save filename in commStr1
00:014E 21F201          	   138: 		ld 		HL,rfile_name
                        	   139: .nxtchr:
00:0151 EDA0            	   140: 		ldi									; (DE) <- (HL) 
00:0153 7E              	   141: 		ld 		A,(HL)
00:0154 B7              	   142: 		or 		A 							; = 0 ?
00:0155 20FA            	   143: 		jr  	NZ,.nxtchr
00:0157 12              	   144: 		ld 		(DE),A						; save '0'
00:0158 210000          	   145: 		ld 		HL,S1x						; result in S1x
00:015B 220000          	   146: 		ld 		(commAdr1),HL
                        	   147: 
00:015E CD0202          	   148: 		call 	p_C_Read_SD
                        	   149: 
                        	   150: 
                        	   151: ;***	correct $0A to $00 $00 in S1x (check for ascii lower than $20)
00:0161 210000          	   152: 		ld 		HL,S1x
00:0164 3E20            	   153: 		ld 		A,$20
00:0166 110000          	   154: 		ld 		DE,commStr1
                        	   155: 
                        	   156: .find0A:
00:0169 EDA0            	   157: 		ldi						; (DE) <- (HL) 
00:016B BE              	   158: 		cp 		(HL)			; char lower than ' '  $20 - (HL)
00:016C FA6901          	   159: 		jp 		M,.find0A		; char > ' '...
                        	   160: 
00:016F 3E00            	   161: 		ld 		A,00
00:0171 12              	   162: 		ld 		(de),A
00:0172 13              	   163: 		inc 	de
00:0173 12              	   164: 		ld 		(de),A			; strip eventually $0A, $0D, ...
00:0174 13              	   165: 		inc 	de
00:0175 12              	   166: 		ld 		(de),A			; Boot file name present in commStr1
00:0176 210000          	   167: 		ld 		HL,_RAMSTART
00:0179 220000          	   168: 		ld 		(commAdr1),HL 	; place adress for boot file...
00:017C CD0202          	   169: 		call 	p_C_Read_SD		; read and place boot file.
                        	   170: 
                        	   171: 
00:017F CD0000          	   172: 		call 	writeSTRBelow
00:0182 0D0A555345205241	   173: 		defb   "\r\nUSE RAM bank #0, Copy FLASH Boot seq\r\n"
00:018A 4D2062616E6B2023
00:0192 302C20436F707920
00:019A 464C41534820426F
00:01A2 6F74207365710D0A
00:01AA 546F2052414D2062	   174: 		defb   "To RAM bank #1 ($0-$2000) \r\n"
00:01B2 616E6B2023312028
00:01BA 24302D2432303030
00:01C2 29200D0A
00:01C6 4A756D7020746F20	   175: 		defb	"Jump to MONITOR_Start! ($D000)\r\n",0,0,0
00:01CE 4D4F4E49544F525F
00:01D6 5374617274212028
00:01DE 2444303030290D0A
00:01E6 00
00:01E7 00
00:01E8 00
                        	   176: 
00:01E9 C30000          	   177: 		jp 		_RAMSTART			; monitor start $D000 MONITOR_Start:
                        	   178: 
                        	   179: .loopINF:
                        	   180: 	ifd 	GPIODEBUG	
00:01EC 3E99            	   181: 	ld 		A,$99
00:01EE D302            	   182: 	out 	(gpio_out),A
                        	   183: 	endif
00:01F0 18FA            	   184: 		jr 		.loopINF
                        	   185: rfile_name:
00:01F2 424F4F5446494C45	   186: 	 db "BOOTFILE.TXT",0,0,0,0
00:01FA 2E545854
00:01FE 00
00:01FF 00
00:0200 00
00:0201 00
                        	   187: 	; db "PROVIDE.txt",0,0,0,0
                        	   188: 
                        	   189: 	
                        	   190: ;************************************************************************************************
                        	   191: ;************************************************************************************************
                        	   192: p_C_Read_SD:
                        	   193: 
                        	   194: 		;call 	checkArgsTAL				; check necessary args
                        	   195: 		;jp		NZ,argumentsError			; show argument error and return
                        	   196: 	
00:0202 110000          	   197: 		ld 		DE,CTC_delay_INT_handler
00:0205 ED5312F4        	   198: 		ld 		(CTC_CH1_I_Vector),DE
                        	   199: 	ifd 	GPIODEBUG
00:0209 AF              	   200: 	xor A
00:020A D302            	   201: 	out (gpio_out),A
                        	   202: 	endif
                        	   203: 		; call  	SIO_A_DI					; disable text output
                        	   204: 	ifd 	GPIODEBUG
00:020C 3E04            	   205: 	ld a,4
00:020E D302            	   206: 	out (gpio_out),A
00:0210 3E00            	   207: 	ld a,0
00:0212 D302            	   208: 	out (gpio_out),A
                        	   209: 	endif
                        	   210: 
00:0214 7B              	   211: 		ld a,e	
                        	   212: 
00:0215 CD0000          	   213: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
00:0218 CD0000          	   214: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
00:021B CD0000          	   215: 		call 	HC376S_ResetAll
00:021E CD0000          	   216: 		call 	HC376S_CheckConnection
                        	   217: 		; ld 		A,(commParseTable)
                        	   218: 		; cp 		15							; 15 read SD; 17-read USB
                        	   219: 		; jr 		Z,.doSD
                        	   220: 		; cp 		21							; 21 read SD enumerate, 22 read USB enumerate
                        	   221: 		; jr 		Z,.doSD
                        	   222: 		; call 	HC376S_setUSBMode
                        	   223: 		; call 	HC376S_diskConnectionStatus		; dont use with SD card
                        	   224: 		; jr 		.cont
                        	   225: .doSD:
00:0221 CD0000          	   226: 		call 	HC376S_setSDMode
                        	   227: 		
                        	   228: .cont:
00:0224 CD0000          	   229: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
00:0227 2014            	   230: 		jr 		NZ,SDabort
                        	   231: 
                        	   232: 
00:0229 CD0000          	   233: 		call 	HC376S_setFileName
00:022C CD0000          	   234: 		call 	HC376S_fileOpen
00:022F 200C            	   235: 		jr 		NZ,SDabort
00:0231 CD0000          	   236: 		call 	waitForFinishedPrintout
                        	   237: 
00:0234 CD0000          	   238: 		call 	HC376S_getFileSize
00:0237 CD0000          	   239: 		call 	HC376S_fileRead
00:023A CD0000          	   240: 		call 	HC376S_fileClose
                        	   241: SDabort:
                        	   242: 
                        	   243: 		; ***	reset the interrupt handler for CTC
                        	   244: 		; call 	SIO_A_EI					; enable text output
00:023D CD0000          	   245: 		call 	HC376S_ResetAll
00:0240 CD0000          	   246: 		call 	CTC1_INT_OFF
00:0243 210000          	   247: 		ld		HL,CTC_CH1_Interrupt_Handler
00:0246 2212F4          	   248: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:0249 C9              	   249: 		ret
                        	   250: 
                        	   251: MONITOR_Start0:	
                        	   252: 
                        	   253: ;***********************************************************************
                        	   254: ;***********************************************************************
                        	   255: 
                        	   256: 		section	Monitor			; enter point for monitor
                        	   257: 
                        	   258: ;***********************************************************************
                        	   259: ;***	MONITOR_Start:  entry point for monitor, should be at $D000.
                        	   260: ;***********************************************************************
                        	   261: 
                        	   262: MONITOR_Start:		
                        	   263: 
                        	   264: 		; ***	should be start address $D000
                        	   265: 		;jr 		.makeShadowRAM
01:0000 183C            	   266: 		jr 		.skipBlockCopy		; use Flash mem and SRAM normally
                        	   267: 	align 3
                        	   268: 		; Ref. vlink_Z80_.ld
                        	   269: 		; BootCode in $D008-D00B = $00000000 - $AAAAAAAA': copy from flash
                        	   270: 		; BootCode in $D008-D00B = $CCCCCCCC: code uploaded from xmodem/or DMA. Do not copy from flash
                        	   271: 		; BootCode in $D008-D00B = $33333333: code uploaded from Arduino. Do not copy from flash, 
01:0008 01010101        	   272: 		defl 	    $01010101
                        	   273: 		;defl 		BootCode
                        	   274: 		align	3
                        	   275: 
                        	   276: 
                        	   277: 	;call 	waitForFinishedPrintout
                        	   278: 	
                        	   279: .makeShadowRAM:
                        	   280: 
                        	   281: 	ifd 	GPIODEBUG
01:0010 3E33            	   282: 	ld 		A,$33
01:0012 D302            	   283: 	out 	(gpio_out),A
                        	   284: 	endif
                        	   285: ;		***  	NOFLASH - Don not use the FLASH mem -> 64kRAM
                        	   286: ; 		*** 	Copy Flash boot sequence to RAM bank #1
                        	   287: ; 		*** 	first to temp storage area.
                        	   288: 
                        	   289: ;		***	 	Copy 128 blocks of 256 bytes from flash to RAM bank #0, then copy to RAM bank #1
                        	   290: 
01:0014 0680            	   291: 			ld  	B,128		; count 128 blocks of 256 bytes
                        	   292: .loopBlocks:
01:0016 C5              	   293: 			push  	BC 			; save BC as block counter
01:0017 018000          	   294: 			ld     	BC,128		; byte counter
                        	   295: 
01:001A 21FF7F          	   296: 			ld 		HL,$7FFF		; end of flash memory area
01:001D 11FFCF          	   297: 			ld 		DE,$CFFF		; temp storage area 0xCF00-CFFF		
01:0020 E5              	   298: 			push 	HL
01:0021 D5              	   299: 			push 	DE
01:0022 EDB8            	   300: 			lddr					; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0		
                        	   301: 
                        	   302: 	; 		*** 	secondly: to Rambank #1 storage area. deselect FLASH mem
                        	   303: 	; 		***		Swithch to RAM bank #1
01:0024 CDBB07          	   304: 			call  	p_FOFF_No_Print	; ***		Disable Flash memory 
01:0027 3E01            	   305: 			ld 		A,1
01:0029 CD0A07          	   306: 			call 	p_srbank0; 		***		Swithch to RAM bank #1
                        	   307: 
                        	   308: 					; from old area (HL), $7FFF  to new area ram area (DE), 0x7FFF
01:002C E1              	   309: 			pop 	HL			; HL point to temp storage area 0xCFFF (old DE value)
01:002D D1              	   310: 			pop 	DE 			; DE point to new area in ram bank #1 0xCFFF (old HL value)
01:002E 018000          	   311: 			ld     	BC,128
01:0031 EDB8            	   312: 			lddr				; (DE)<-(HL) and DE,HL auto decrement, BC auto decrement, repeat until BC=0
                        	   313: 
                        	   314: 	;		***		Enable Flash again and set ram bank #0	
01:0033 CDBB07          	   315: 			call  	p_FOFF_No_Print
01:0036 3E00            	   316: 			ld 		A,0
01:0038 CD1D07          	   317: 			call 	p_flbank0; 		***		Swithch to FLASH bank #0
                        	   318: 
                        	   319: 
01:003B C1              	   320: 			pop 	BC			; restore BC as block counter
01:003C 10D8            	   321: 			djnz	.loopBlocks
                        	   322: 			
                        	   323: 
                        	   324: 		; call	Init_RAM_HEAP			; put zero values to addr $F000 - $FFF0
                        	   325: 
                        	   326: .skipBlockCopy:
                        	   327: 
01:003E ED730000        	   328: 		ld 		(SP_value),SP
01:0042 76              	   329: 	halt
                        	   330: 
                        	   331: 	ifd 	GPIODEBUG
01:0043 3EAA            	   332: 	ld 		A,$AA
01:0045 D302            	   333: 	out 	(gpio_out),A
                        	   334: 	endif
                        	   335: 
01:0047 CD0000          	   336: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   337: 			; initialize buffer counters and pointers.
                        	   338: 	ifd		PIODEBUG
                        	   339: 	ld 		A,$BB
                        	   340: 	out 	(gpio_out),A
                        	   341: 	endif
                        	   342: 
01:004A CD0000          	   343: 		call	PIO_Init
                        	   344: 	ifd 	GPIODEBUG
01:004D 3ECC            	   345: 	ld 		A,$CC
01:004F D302            	   346: 	out 	(gpio_out),A
                        	   347: 	endif
                        	   348: 
01:0051 CD0000          	   349: 		call 	CTC_Init
                        	   350: 	ifd 	GPIODEBUG
01:0054 3EDD            	   351: 	ld 		A,$DD
01:0056 D302            	   352: 	out 	(gpio_out),A
                        	   353: 	endif
                        	   354: 
01:0058 CD0000          	   355: 		call 	SIO_Init			; LEV_Sect11_IO_Interrupts.s
                        	   356: 	ifd 	GPIODEBUG
01:005B 3EDF            	   357: 	ld 		A,$DF
01:005D D302            	   358: 	out 	(gpio_out),A
                        	   359: 	endif
                        	   360: 
01:005F CD0000          	   361: 		call	S_head_tail			; save input heads and tails
                        	   362: 	ifd 	GPIODEBUG
01:0062 3E81            	   363: 	ld 		A,$81
01:0064 D302            	   364: 	out 	(gpio_out),A
                        	   365: 	endif
                        	   366: 
                        	   367: 		; call	sh_test
                        	   368: 		; call 	Flash_WR_Test
                        	   369: 		; ld	HL,$2010
                        	   370: 		; call	Flash_SE_Erase
01:0066 FD213701        	   371: 			ld 		iy,testdumpText
01:006A CD0000          	   372: 			call	WriteLineCRNL
                        	   373: 
                        	   374: 
01:006D CD0000          	   375: 		call	CRLF
01:0070 CD0000          	   376: 		call 	writeSTRBelow
01:0073 0D0A            	   377: 		defb   	"\r\n"
01:0075 2323232323232323	   378: 		defb	"##########################################################\r\n"
01:007D 2323232323232323
01:0085 2323232323232323
01:008D 2323232323232323
01:0095 2323232323232323
01:009D 2323232323232323
01:00A5 2323232323232323
01:00AD 23230D0A
01:00B1 546865205A383020	   379: 		defb	"The Z80 Board Awakened 2026\r\n"
01:00B9 426F617264204177
01:00C1 616B656E65642032
01:00C9 3032360D0A
01:00CE 202020206769743A	   380: 		defb	"    git: UPdate_Jan_25-7-gbbba3ce-dirty\r\n"
01:00D6 205550646174655F
01:00DE 4A616E5F32352D37
01:00E6 2D67626262613363
01:00EE 652D64697274790D
01:00F6 0A
01:00F7 202020206275696C	   381: 		defb	"    build: 2026-02-24_22:40\r\n"
01:00FF 643A20323032362D
01:0107 30322D32345F3232
01:010F 3A34300D0A
01:0114 20202020464C4153	   382: 		defb	"    FLASH->SRAM 0xD000.\r\n"
01:011C 482D3E5352414D20
01:0124 3078443030302E0D
01:012C 0A
01:012D 00              	   383: 		defb	"\0"
                        	   384: 
                        	   385: 
                        	   386: 	ifd 	GPIODEBUG
01:012E 3E83            	   387: 	ld 		A,$83
01:0130 D302            	   388: 	out 	(gpio_out),A
                        	   389: 	endif
01:0132 CD0000          	   390: 		call	CRLF
01:0135 181E            	   391: 	jr  next_line
                        	   392: 
01:0137 2054657374204475	   393: testdumpText: defb		" Test Dump Test Dump ABC123\r\n",0
01:013F 6D70205465737420
01:0147 44756D7020414243
01:014F 3132330D0A
01:0154 00
                        	   394: 
                        	   395: next_line:
                        	   396: 
01:0155 CDED03          	   397: 		call 	initCommParseTable			; Put zeros.....
                        	   398: 	ifd 	GPIODEBUG
01:0158 3E85            	   399: 	ld 		A,$85
01:015A D302            	   400: 	out 	(gpio_out),A
                        	   401: 	endif
                        	   402: 
                        	   403: 		; ***	indicate memory banks   F[x]  Flash memory bank x
                        	   404: 		; ***	indicate memory banks   S[y]  SRAM memory bank y
                        	   405: 				; if bit 3 (rstBankID) = 1  no FLASH memory is selected
                        	   406: 				; if bit 3 (rstBankID) = 0 FLASH memory is lower 32k and SRAM upper 32k
01:015C 210100          	   407: 		ld 		HL,T_BUFFER+1 			; prepare output buffer		
01:015F 3646            	   408: 		ld 		(HL),'F'	
01:0161 3A0000          	   409: 		ld 		A,(rstBankID)
01:0164 CB5F            	   410: 		bit 	3,A					; bit 3 set -> 64kSRAM
01:0166 2802            	   411: 		jr 		Z,useFlash
01:0168 3653            	   412: 		ld 		(HL),'S'	
                        	   413: useFlash:
01:016A 23              	   414: 		inc 	HL
01:016B 365B            	   415: 		ld 		(HL),'['	
01:016D 23              	   416: 		inc 	HL
01:016E CB5F            	   417: 		bit 	3,A					; bit 7 set -> 64kSRAM
01:0170 3A0000          	   418: 		ld  	A,(memBankID)
01:0173 2807            	   419: 		jr 		Z,.IDflash
                        	   420: 
                        	   421: 		; ***	show sram bank number
01:0175 E60F            	   422: 		and 	$0F					; sram bank #
01:0177 CD0000          	   423: 		call 	AddToT_Buf			; convert to 1 ascii char in (HL+)
01:017A 180D            	   424: 		jr 		.cont
                        	   425: .IDflash:
                        	   426: 		; ***	show flash bank number
01:017C CB3F            	   427: 		srl 	A
01:017E CB3F            	   428: 		srl 	A
01:0180 CB3F            	   429: 		srl 	A
01:0182 CB3F            	   430: 		srl 	A
01:0184 E607            	   431: 		and 	A,$07				; flash bank #
01:0186 CD0000          	   432: 		call	AddToT_Buf			; convert to 1 ascii char in (HL+)
                        	   433: .cont:
01:0189 365D            	   434: 		ld  	(HL),']'
01:018B 23              	   435: 		inc 	HL
                        	   436: 
                        	   437: 	ifd 	GPIODEBUG	
01:018C 3E87            	   438: 	ld 		A,$87
01:018E D302            	   439: 	out 	(gpio_out),A
                        	   440: 	endif
                        	   441: 
                        	   442: 	; 	*** Print prompt text to screen, value of PC and content in memory
01:0190 ED5B0000        	   443: 		ld 		DE,(PCvalue)
01:0194 365B            	   444: 		ld  	(HL),'['
01:0196 23              	   445: 		inc 	HL
                        	   446: 
                        	   447: 		; ***	Address in parenthesis
01:0197 CD0000          	   448: 		call 	Bin2Hex16
01:019A 365D            	   449: 		ld  	(HL),']'
01:019C 23              	   450: 		inc 	HL
01:019D 363D            	   451: 		ld  	(HL),'='
01:019F 23              	   452: 		inc 	HL
                        	   453: 
                        	   454: 		; ***	Value of the bytes in address (2 bytes) to screen
01:01A0 E5              	   455: 		push 	HL
01:01A1 2A0000          	   456: 		ld 		HL,(PCvalue)
01:01A4 56              	   457: 		ld 		D,(HL)
01:01A5 23              	   458: 		inc 	HL
01:01A6 5E              	   459: 		ld 		E,(HL)
01:01A7 E1              	   460: 		pop 	HL
01:01A8 CD0000          	   461: 		call	Bin2Hex16
01:01AB 362D            	   462: 		ld  	(HL),'-'
01:01AD 23              	   463: 		inc 	HL
01:01AE 363E            	   464: 		ld  	(HL),'>'
01:01B0 23              	   465: 		inc 	HL
                        	   466: 
01:01B1 3600            	   467: 		ld  	(HL),$00
01:01B3 FD210000        	   468: 		ld 		iy,T_BUFFER
01:01B7 CD0000          	   469: 		call	WriteLine
                        	   470: 
01:01BA 210000          	   471: 		ld 		hl,Textbuf
01:01BD CD0000          	   472: 		call 	ReadLine
                        	   473: 
01:01C0 FD210000        	   474: 		ld 		iy,Textbuf
01:01C4 CD0000          	   475: 		call	WriteLineCRNL
                        	   476: 		; ld 		A,5
                        	   477: 		; out 	(portA_Data),A
                        	   478: 
                        	   479: 		;***  	compare input
                        	   480: 		; ld 		HL,Textbuf
                        	   481: 		; ld 		DE,command_list+2
                        	   482: 		; call	strCompare
                        	   483: 
                        	   484: 	;***************************************************************
                        	   485: 	;	Find /Identify command:
                        	   486: 	;***************************************************************
                        	   487: 
01:01C7 210000          	   488: 		ld 		HL,Textbuf
01:01CA CD0000          	   489: 		call 	skipPriorDelimit			; set (HL) first char
                        	   490: 
01:01CD DA1605          	   491: 		jp 		C,temp_finish 				; end encountered; no command (empty line)	
                        	   492: 
01:01D0 E5              	   493: 		push 	HL
01:01D1 D1              	   494: 		pop  	DE							; typed command start in DE
                        	   495: 
                        	   496: 		; ***	Search command in 'command_list:'
                        	   497: 		;  		DE = typed command first char in DE (Textbuf)
01:01D2 213E02          	   498: 		ld 		HL,command_list+1			; first char in first command in the list
                        	   499: 		
                        	   500: scanCommandList:
01:01D5 4E              	   501: 		ld 		C,(HL)						; command # in C
01:01D6 23              	   502: 		inc 	HL 							; (HL)=first char
01:01D7 46              	   503: 		ld 		B,(HL)						; # chars in command in list
01:01D8 23              	   504: 		inc 	HL 							; (HL)=first char
01:01D9 D5              	   505: 		push 	DE 							; save start of typed string (DE) for later
                        	   506: 
                        	   507: findCommandInList:
01:01DA 1A              	   508: 		ld 		a,(DE)						; next typed char
                        	   509: 		; or 		$20							; make typed char lower case
01:01DB BE              	   510: 		cp		(HL)
01:01DC 2008            	   511: 		jr 		nz,findNextITEM				; different chars-> test next item in list
01:01DE 13              	   512: 		inc 	DE
01:01DF 23              	   513: 		inc 	HL  
01:01E0 10F8            	   514: 		djnz 	findCommandInList
                        	   515: 		
                        	   516: 		; ***	test char (DE); should be a delimiter...
                        	   517: 		; ex 		DE,HL
                        	   518: 		; call 	isDelimit
                        	   519: 		; 				;delimiters found ? =>Z, else ~Z
                        	   520: 		; 				;char in (HL) is '0' ->  set C, else NC
                        	   521: 		; ex 		DE,HL
                        	   522: 
                        	   523: 		; call 	writeSTRBelow
                        	   524: 		; DB 		0,"pop 	HL.. !",CR,LF,00
                        	   525: 		; call 	DumpRegisters
                        	   526: 
                        	   527: 		; jr 		nz,findNextITEM    			; command match but is longer (more chars) cp list					
                        	   528: 
                        	   529: 		; ***	Found a matching command, All char do match...
                        	   530: 		; 		(HL) points to first after command
01:01E2 C30004          	   531: 		jp 		matchInList
01:01E5 00              	   532: zero_byte:	db  0
                        	   533: 
                        	   534: findNextITEM:
                        	   535: 		; ***	find next ITEM or LISTEND
01:01E6 7E              	   536: 		ld 		a,(HL)
01:01E7 FEEE            	   537: 		cp		CDEL					; command adress delimiter
01:01E9 2812            	   538: 		jr 		z,.skipPastCommAdr
                        	   539: 	
01:01EB FE1C            	   540: 		cp		ITEM					; command adress delimiter
01:01ED 2817            	   541: 		jr 		z,nextInList
                        	   542: 	
01:01EF FE1E            	   543: 		cp 		LISTEND
01:01F1 2010            	   544: 		jr 		NZ,.cont
                        	   545: 
                        	   546: 		; ***	Command list did not match; check if direct address '$' or byte input
01:01F3 3EFF            	   547: 		ld 		A,$FF
01:01F5 320000          	   548: 		ld 		(PCinpFlag),A			; indicate ev. typed ($)address to change PCV or input bytes ...
01:01F8 E1              	   549: 		pop 	HL						; HL start of typed string (again)
01:01F9 7E              	   550: 		ld 		A,(HL)
01:01FA C34B04          	   551: 		jp 		checkaddress			; No more commands to check, check if address entered , '$'
                        	   552: 										; or relative adress '@'
                        	   553: 										; or direct input of bytes.....
                        	   554: .skipPastCommAdr:
01:01FD 23              	   555: 		inc  	HL		;hig adr.
01:01FE 23              	   556: 		inc  	HL		; low adr.
01:01FF 23              	   557: 		inc  	HL		;  '0'
01:0200 23              	   558: 		inc  	HL		;  next row
01:0201 18E3            	   559: 		jr 		findNextITEM
                        	   560: 
01:0203 23              	   561: .cont:	inc 	HL
01:0204 18E0            	   562: 		jr 		findNextITEM
                        	   563: 
                        	   564: nextInList:
01:0206 23              	   565: 		inc 	HL						; points to item #
01:0207 D1              	   566: 		pop 	DE 						; DE start of typed string (again)
01:0208 18CB            	   567: 		jr 		scanCommandList
                        	   568: 
                        	   569: 
                        	   570: 	;***************************************************************
                        	   571: 	;	Semantic error occurred in input :
                        	   572: 	;***************************************************************
                        	   573: 
                        	   574: inputerror:
01:020A E5              	   575: 		push   	HL
01:020B CD0000          	   576: 		call 	writeSTRBelow
01:020E 00              	   577: 		DB 		0,"Input Semantic Error... ! code(DE):",00
01:020F 496E707574205365
01:0217 6D616E7469632045
01:021F 72726F722E2E2E20
01:0227 2120636F64652844
01:022F 45293A
01:0232 00
01:0233 D1              	   578: 		pop 	DE
01:0234 CD0000          	   579: 		call 	putDEtoScreen
01:0237 CD0000          	   580: 		call 	CRLF
01:023A C35501          	   581: 		jp 		next_line
                        	   582: 
                        	   583: ; command_addresses:
                        	   584: ; 		defw 	00
                        	   585: ; 		defw 	p_load			;1
                        	   586: ; 		defw 	p_dumpmem		;2
                        	   587: ; 		defw 	p_pc			;3
                        	   588: ; 		defw 	p_eep			;4
                        	   589: ; 		defw 	p_clearmem		;5
                        	   590: ; 		defw 	p_exe			;6
                        	   591: ; 		defw 	p_go			;7
                        	   592: ; 		defw 	p_incDecPC		;8
                        	   593: ; 		defw 	p_incDecPC		;9
                        	   594: ; 		defw 	p_FON			;10
                        	   595: ; 		defw 	p_FOFF			;11
                        	   596: ; 		defw 	p_flwr			;12. write data to FLASH
                        	   597: ; 		defw 	p_flse			;13. sector erase
                        	   598: ; 		defw 	p_xmod			;14. transfer files via x-modem
                        	   599: ; 		defw 	p_reset			;16. Jump to $0000
                        	   600: ; 		defw	p_C_Read		;16. Read from SD card   sdrd  "file"  $Addr
                        	   601: ; 		defw	p_C_Write		;17. Write to SD card   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   602: ; 		defw	p_C_Read		;18. Read from USB   sdrd  "file"  $Addr
                        	   603: ; 		defw	p_C_Write		;19. Write to USB   sdrd  "file"  $Addr.l $Addr.h/Num
                        	   604: ; 		defw	p_C_Delete		;20. delete file on SD card   sdrd  "file"  $Addr
                        	   605: ; 		defw	p_C_Delete		;21. delete file on USB  sdrd  "file"  $Addr.l $Addr.h/Num
                        	   606: ; 		defw 	p_C_Read		;22. List root level files/dirs on sd card
                        	   607: ; 		defw 	p_C_Read 		;23. List root level files/dirs on USB
                        	   608: ; 		defw	p_cptFl			;24. copy from mem to flash memory (on selected bank)
                        	   609: ; 		defw 	p_flbank		;25. Set flash bank #
                        	   610: ; 		defw	p_srbank		;26. Set sram bank #
                        	   611: 
                        	   612: command_list:
                        	   613: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	   614: 
01:023D 1C              	   615: 		db		ITEM,1,4,"load",STEND,%100010,0,CDEL
01:023E 01
01:023F 04
01:0240 6C6F6164
01:0244 1D
01:0245 22
01:0246 00
01:0247 EE
01:0248 6805            	   616: 		dw 		p_load,0
01:024A 0000
01:024C 1C              	   617: 		db		ITEM,2,2,"dm",	STEND,%000010,0,CDEL
01:024D 02
01:024E 02
01:024F 646D
01:0251 1D
01:0252 02
01:0253 00
01:0254 EE
01:0255 6905            	   618: 		dw  	p_dumpmem,0
01:0257 0000
01:0259 1C              	   619: 		db		ITEM,3,2,"pc",	STEND,%000000,0,CDEL
01:025A 03
01:025B 02
01:025C 7063
01:025E 1D
01:025F 00
01:0260 00
01:0261 EE
01:0262 6D05            	   620: 		dw 		p_pc,0
01:0264 0000
01:0266 1C              	   621: 		db		ITEM,4,3,"eep",	STEND,%000000,0,CDEL
01:0267 04
01:0268 03
01:0269 656570
01:026C 1D
01:026D 00
01:026E 00
01:026F EE
01:0270 6E05            	   622: 		dw 		p_eep,0
01:0272 0000
01:0274 1C              	   623: 		db		ITEM,5,2,"cm",	STEND,%000000,0,CDEL
01:0275 05
01:0276 02
01:0277 636D
01:0279 1D
01:027A 00
01:027B 00
01:027C EE
01:027D 7505            	   624: 		dw  	p_clearmem,0
01:027F 0000
01:0281 1C              	   625: 		db		ITEM,6,3,"exe",	STEND,%000000,0,CDEL
01:0282 06
01:0283 03
01:0284 657865
01:0287 1D
01:0288 00
01:0289 00
01:028A EE
01:028B 8805            	   626: 		dw 		p_exe,0
01:028D 0000
01:028F 1C              	   627: 		db		ITEM,7,2,"go",	STEND,%000000,0,CDEL
01:0290 07
01:0291 02
01:0292 676F
01:0294 1D
01:0295 00
01:0296 00
01:0297 EE
01:0298 8905            	   628: 		dw 		p_go,0
01:029A 0000
01:029C 1C              	   629: 		db		ITEM,8,2,"++",	STEND,%000000,0,CDEL
01:029D 08
01:029E 02
01:029F 2B2B
01:02A1 1D
01:02A2 00
01:02A3 00
01:02A4 EE
01:02A5 9A05            	   630: 		dw 		p_incDecPC,0
01:02A7 0000
01:02A9 1C              	   631: 		db		ITEM,9,2,"--",	STEND,%000000,0,CDEL
01:02AA 09
01:02AB 02
01:02AC 2D2D
01:02AE 1D
01:02AF 00
01:02B0 00
01:02B1 EE
01:02B2 9A05            	   632: 		dw 		p_incDecPC,0
01:02B4 0000
01:02B6 1C              	   633: 		db		ITEM,10,3,"fl1",		STEND,%000000,0,CDEL
01:02B7 0A
01:02B8 03
01:02B9 666C31
01:02BC 1D
01:02BD 00
01:02BE 00
01:02BF EE
01:02C0 3307            	   634: 		dw		p_FON,0
01:02C2 0000
01:02C4 1C              	   635: 		db		ITEM,10,8,"flash-on",	STEND,%000000,0,CDEL
01:02C5 0A
01:02C6 08
01:02C7 666C6173682D6F6E
01:02CF 1D
01:02D0 00
01:02D1 00
01:02D2 EE
01:02D3 3307            	   636: 		dw 		p_FON,0
01:02D5 0000
01:02D7 1C              	   637: 		db		ITEM,11,3,"fl0",		STEND,%000000,0,CDEL
01:02D8 0B
01:02D9 03
01:02DA 666C30
01:02DD 1D
01:02DE 00
01:02DF 00
01:02E0 EE
01:02E1 8D07            	   638: 		dw 		p_FOFF,0
01:02E3 0000
01:02E5 1C              	   639: 		db		ITEM,11,9,"flash-off",	STEND,%000000,0,CDEL
01:02E6 0B
01:02E7 09
01:02E8 666C6173682D6F66
01:02F0 66
01:02F1 1D
01:02F2 00
01:02F3 00
01:02F4 EE
01:02F5 8D07            	   640: 		dw 		p_FOFF,0
01:02F7 0000
01:02F9 1C              	   641: 		db		ITEM,12,4,"flwr",	STEND,%001110,0,CDEL
01:02FA 0C
01:02FB 04
01:02FC 666C7772
01:0300 1D
01:0301 0E
01:0302 00
01:0303 EE
01:0304 BF05            	   642: 		dw 		p_flwr,0									; write to flash: flwr  <$Addr.mem> <$Addr.flash>  <Num> (0E)
01:0306 0000
01:0308 1C              	   643: 		db		ITEM,13,4,"flse",	STEND,%000000,0,CDEL
01:0309 0D
01:030A 04
01:030B 666C7365
01:030F 1D
01:0310 00
01:0311 00
01:0312 EE
01:0313 F405            	   644: 		dw 		p_flse,0
01:0315 0000
01:0317 1C              	   645: 		db		ITEM,14,4,"xmod",	STEND,%001000,0,CDEL
01:0318 0E
01:0319 04
01:031A 786D6F64
01:031E 1D
01:031F 08
01:0320 00
01:0321 EE
01:0322 FD05            	   646: 		dw 		p_xmod,0									; xmodem from PC   xmod <address>
01:0324 0000
01:0326 1C              	   647: 		db		ITEM,15,3,"rst",	STEND,%000000,0,CDEL
01:0327 0F
01:0328 03
01:0329 727374
01:032C 1D
01:032D 00
01:032E 00
01:032F EE
01:0330 5405            	   648: 		dw 		p_reset,0
01:0332 0000
01:0334 1C              	   649: 		db		ITEM,16,4,"sdrd",	STEND,%101000,0,CDEL
01:0335 10
01:0336 04
01:0337 73647264
01:033B 1D
01:033C 28
01:033D 00
01:033E EE
01:033F 0906            	   650: 		dw		p_C_Read,0									; Read from SD card   sdrd  "file"  $Addr
01:0341 0000
01:0343 1C              	   651: 		db		ITEM,17,4,"sdwr",	STEND,%101010,0,CDEL
01:0344 11
01:0345 04
01:0346 73647772
01:034A 1D
01:034B 2A
01:034C 00
01:034D EE
01:034E 6D06            	   652: 		dw 		p_C_Write,0									; Write to SD card   sdwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0350 0000
01:0352 1C              	   653: 		db		ITEM,18,5,"usbrd",	STEND,%101000,0,CDEL
01:0353 12
01:0354 05
01:0355 7573627264
01:035A 1D
01:035B 28
01:035C 00
01:035D EE
01:035E 0906            	   654: 		dw 		p_C_Read,0									; Read from USB      usbrd  "file"  $Addr
01:0360 0000
01:0362 1C              	   655: 		db		ITEM,19,5,"usbwr",	STEND,%101010,0,CDEL
01:0363 13
01:0364 05
01:0365 7573627772
01:036A 1D
01:036B 2A
01:036C 00
01:036D EE
01:036E 6D06            	   656: 		dw 		p_C_Write,0									; Write to USB        usbwr  "file"  $Addr.l  $Addr.h/Num (2A/2C)
01:0370 0000
01:0372 1C              	   657: 		db		ITEM,20,5,"sddel",	STEND,%100000,0,CDEL
01:0373 14
01:0374 05
01:0375 736464656C
01:037A 1D
01:037B 20
01:037C 00
01:037D EE
01:037E C506            	   658: 		dw 		p_C_Delete,0 								; Delete file on SD card   sddel  "file"  
01:0380 0000
01:0382 1C              	   659: 		db		ITEM,21,6,"usbdel",	STEND,%100000,0,CDEL
01:0383 15
01:0384 06
01:0385 75736264656C
01:038B 1D
01:038C 20
01:038D 00
01:038E EE
01:038F C506            	   660: 		dw 		p_C_Delete,0 								; Delete file on USB   usbdel  "file"  
01:0391 0000
01:0393 1C              	   661: 		db		ITEM,22,5,"sddir",	STEND,%100000,0,CDEL
01:0394 16
01:0395 05
01:0396 7364646972
01:039B 1D
01:039C 20
01:039D 00
01:039E EE
01:039F 0906            	   662: 		dw 		p_C_Read,0 									; List root level files/dirs on sd card
01:03A1 0000
01:03A3 1C              	   663: 		db		ITEM,23,6,"usbdir",	STEND,%100000,0,CDEL
01:03A4 17
01:03A5 06
01:03A6 757362646972
01:03AC 1D
01:03AD 20
01:03AE 00
01:03AF EE
01:03B0 0906            	   664: 		dw 		p_C_Read,0 									; List root level files/dirs on USB
01:03B2 0000
01:03B4 1C              	   665: 		db 		ITEM,24,5,"cptfl",	STEND,%001100,0,CDEL
01:03B5 18
01:03B6 05
01:03B7 637074666C
01:03BC 1D
01:03BD 0C
01:03BE 00
01:03BF EE
01:03C0 FC06            	   666: 		dw 		p_cptFl,0									; copy from adress range to flash   cptfl  $Addr   $Addr
01:03C2 0000
01:03C4 1C              	   667: 		db 		ITEM,25,2,"fb",		STEND,%000010,0,CDEL
01:03C5 19
01:03C6 02
01:03C7 6662
01:03C9 1D
01:03CA 02
01:03CB 00
01:03CC EE
01:03CD 1707            	   668: 		dw 		p_flbank,0									; set flash bank #	
01:03CF 0000
01:03D1 1C              	   669: 		db 		ITEM,26,2,"sb",		STEND,%000010,0,CDEL
01:03D2 1A
01:03D3 02
01:03D4 7362
01:03D6 1D
01:03D7 02
01:03D8 00
01:03D9 EE
01:03DA 0407            	   670: 		dw		p_srbank,0									; set sram bank #	
01:03DC 0000
01:03DE 1C              	   671: 		db		ITEM,27,3,"nop",	STEND,%000000,0,CDEL
01:03DF 1B
01:03E0 03
01:03E1 6E6F70
01:03E4 1D
01:03E5 00
01:03E6 00
01:03E7 EE
01:03E8 0000            	   672: 		dw 		0,0
01:03EA 0000
01:03EC 1E              	   673: 		db		LISTEND
                        	   674: commListLen  equ   27
                        	   675: 
                        	   676: 		; ld		HL,$6000
                        	   677: 		; ld		(packetBaseAddress),HL			; store the address for target code (for error correction)
                        	   678: 		; ld		A,01
                        	   679: 		; ld		(prevPacketByte01),A 				; store of packet numbers
                        	   680: 
                        	   681: 		; call 	SetupXMODEM_TXandRX					 
                        	   682: 	
                        	   683: 
                        	   684: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   685: ;---------------------------------------------------------------------------------
                        	   686: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   687: 
                        	   688: ;		skipPriorDelimit 		; increase A0 until non delimiter (NZ) or #0 (Z) 
                        	   689: ;		***		store string value in textarea and reference in table
                        	   690: ;		skipCharsUntilDelim		; increase A0 until blank (NZ) or #0 (Z) 
                        	   691: ;		***		read/store either address or lvalue and store in table
                        	   692: ; 		isDelimit(S)  is char in (A0) any of the delimiters specified in (A1) ? =>Z, else ~Z
                        	   693: ; 		Parameters returned; A0 - Address of char
                        	   694: 
                        	   695: ;		commParseTable
                        	   696: ;		***************************************************
                        	   697: ;		***	decode input line;
                        	   698: ;		*** <cmd>    "TEXT"  	$xxyy  xxyy
                        	   699: ;		*** command textstring 	address	 lvalue
                        	   700: ;		************************************************************
                        	   701: ;		*** commParseTable:
                        	   702: ;		*** 00 : W : offset in jumptable  (F080)
                        	   703: ;		*** 04 : L : address 1  (F084-F087)
                        	   704: ;		*** 08 : L : address 2  (F088-F08B)
                        	   705: ;		*** 10 : L : lvalue1  (F090-F09F)
                        	   706: ;		*** 20 : L : lvalue2  (F0A0-F0AF)
                        	   707: ;		*** 57 : L : text1   (F0B0-F0D7)
                        	   708: ;		*** 58 : L : text2 	 (F0D8-F0FF)	
                        	   709: ;		***
                        	   710: ;		***--------------------------------------
                        	   711: 
                        	   712: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   713: ;---------------------------------------------------------------------------------
                        	   714: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   715: 
                        	   716: 		; call	skipCharsUntilDelim			; set (HL) to first delimiter
                        	   717: 		; push 	HL
                        	   718: 		; pop  	BC							; typed command end+1 in BC
                        	   719: 
                        	   720: 		; ***	Prepares the commParseTable. Consumes HL,B,A
                        	   721: initCommParseTable:
01:03ED 3E00            	   722: 		ld 		A,0
01:03EF 320000          	   723: 		ld 		(PCinpFlag),A
01:03F2 320100          	   724: 		ld 		(PCinpFlag+1),A
01:03F5 210000          	   725: 		ld 		HL,commParseTable
                        	   726: 
01:03F8 0680            	   727: 		ld 		B,$80
01:03FA 97              	   728: 		sub 	A 					; clear A.
                        	   729: .icpt:
01:03FB 77              	   730: 		ld 		(HL),A
01:03FC 23              	   731: 		inc 	HL
01:03FD 10FC            	   732: 		djnz 	.icpt
                        	   733: 
01:03FF C9              	   734: 		ret
                        	   735: 
                        	   736: ;---------------------------------------------------------------------------------
                        	   737: ;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
                        	   738: 
                        	   739: 	;***************************************************************
                        	   740: 	;	Command identified -> now search for string :
                        	   741: 	;***************************************************************
                        	   742: 
                        	   743: matchInList:
                        	   744: 		; ***	Command found. Then, check for string input "<string>"
                        	   745: 		; ***	DE points to first delimiter after command 
                        	   746: 						;delimiters found ? =>Z, else ~Z
                        	   747: 						;char in (HL) is '0' ->  set C, else NC
                        	   748: 
01:0400 33              	   749: 		inc 	sp
01:0401 33              	   750: 		inc 	sp						; restore PC from PUSH in <scanCommandList>
01:0402 23              	   751: 		inc 	HL 						; HL point to first after <STEND>  ->req arguments  (STEND,%100010,0,CDEL,p_load,0)
01:0403 7E              	   752: 		ld 		A,(HL) 					; A= required arguments from table
01:0404 FD210000        	   753: 		ld 		IY,commParseTable		; IY =commParseTable =	0x80 + _String_HEAP
01:0408 FD7502          	   754: 		ld   	(IY+2),L 
01:040B FD7403          	   755: 		ld   	(IY+3),H				; save the command adress.
                        	   756: 		
01:040E FD7100          	   757: 		ld 		(IY),C 					; store the command number in (commParseTable, 0x80)
01:0411 FD7701          	   758: 		ld 		(IY+1),A				; store required arguments  in (commParseTable+1, 0x81)
                        	   759: 		; call 	writeSTRBelow_CRLF
                        	   760: 		; DB 		0,"Found a valid command  see (C).. !",CR,LF,00
01:0414 D5              	   761: 		push 	DE
01:0415 E1              	   762: 		pop 	HL						; HL=DE = first delimiter after command
01:0416 2B              	   763: 		dec 	HL							; DE -> HL -> last char before delimiter
                        	   764: paramLoopEntry:	
                        	   765: 
01:0417 CD0000          	   766: 		call 	skipPriorDelimit 			; look for next char (  '"' ?)
01:041A DA0505          	   767: 		jp 		C,executeCommand			; C set from 'skipPriorDelimit', no command parameters
                        	   768: 
01:041D 7E              	   769: 		ld 		A,(HL)
                        	   770: 
01:041E FE22            	   771: 		cp 		'"'							; beginning of string ?
01:0420 2029            	   772: 		jr 		NZ,checkaddress				;  NZ -> (HL) points to non delimiter
                        	   773: 
                        	   774: 		; ***	extract string 
01:0422 23              	   775: 		inc 	HL 							; skip '"' (HL)-> first char
                        	   776: 
01:0423 E5              	   777: 		push  	HL
01:0424 D1              	   778: 		pop  	DE							; DE -> first char after '"' <source>
01:0425 CD0000          	   779: 		call 	skipCharsUntilDelim			; find second '"'
01:0428 2B              	   780: 		dec 	HL 							; skip first delimiter (ev. CR)
01:0429 7E              	   781: 		ld 		A,(HL)
01:042A FE22            	   782: 		cp 		'"' 						; found second '"' ??
01:042C C20A02          	   783: 		jp 		NZ,inputerror
01:042F 2B              	   784: 		dec 	HL 							; skip second '"'
                        	   785: 	;***************************************************************
                        	   786: 	;	copy string to  'commParseTable'
                        	   787: 	;***************************************************************
                        	   788: 
01:0430 A7              	   789: 		and 	A
01:0431 ED52            	   790: 		sbc 	HL,DE 						; amount of chars...
01:0433 44              	   791: 		ld 		B,H							; amount of chars...
01:0434 4D              	   792: 		ld 		C,L							; amount of chars...
01:0435 03              	   793: 		inc 	BC
                        	   794: 
01:0436 210000          	   795: 		ld 		HL,commStr1				; address for first string
01:0439 7E              	   796: 		ld 		A,(HL)
01:043A B7              	   797: 		or 		A 						; =0?
01:043B 2808            	   798: 		jr 		Z, .strone
01:043D 210000          	   799: 		ld 		HL,commStr2				; address for second string
01:0440 7E              	   800: 		ld 		A,(HL)
01:0441 B7              	   801: 		or  	A						; =0 ?
01:0442 C20A02          	   802: 		jp 		NZ,inputerror			; too many strings
                        	   803: .strone:
01:0445 EB              	   804: 		ex 		DE,HL 					; HL = <source>, DE = <dest>, size = BC
01:0446 EDB0            	   805: 		ldir 							; make the copy
                        	   806: 		; ex		DE,HL
01:0448 23              	   807: 		inc 	HL 						; (HL) past the second '"'
                        	   808: 
01:0449 18CC            	   809: 		jr 		paramLoopEntry
                        	   810: 
                        	   811: 
                        	   812: 	;***************************************************************
                        	   813: 	;	Check if address is specified in input 
                        	   814: 	;***************************************************************
                        	   815: 
                        	   816: 
                        	   817: checkaddress:
                        	   818: 		; ***	A = (HL), first char after delimiter
                        	   819: 
01:044B 320100          	   820: 		ld 		(PCinpFlag+1),A			; if value '(PCinpFlag+1)' == '$' -> address input
                        	   821: 										; if value '(PCinpFlag+1)' == '@' -> relative (PCval) address input
01:044E FE24            	   822: 		cp 		'$'						; identified address id
01:0450 3E00            	   823: 		ld 		A,0
01:0452 2802            	   824: 		jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   825: 		; cp 		'@'						; identified address id
                        	   826: 		; jr 		Z,chkADR			; first value of A (PCinpFlag+1) is '$' ??
                        	   827: 
01:0454 1823            	   828: 		jr 		getLvalue				
                        	   829: 
01:0456 23              	   830: chkADR:		inc 	HL 						; skip past '$' or '@'
                        	   831: 
                        	   832: chkADR1:
                        	   833: 	; ***		Check where to store address...
                        	   834: 
01:0457 DD210000        	   835: 		ld 		IX,commAdr1
                        	   836: 		; ld 		A,0
01:045B DDBE00          	   837: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:045E 2007            	   838: 		jr 		NZ,chkADR2
01:0460 DDBE01          	   839: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:0463 2002            	   840: 		jr 		NZ,chkADR2
01:0465 1832            	   841: 		jr 		makeASCIItoHEX
                        	   842: chkADR2:
                        	   843: 
01:0467 DD210000        	   844: 		ld 		IX,commAdr2
                        	   845: 		; ld 		A,0
01:046B DDBE00          	   846: 		cp 		(IX)			; check if zero ? (already stored)
01:046E C20A02          	   847: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0471 DDBE01          	   848: 		cp 		(IX+1)			; check if zero (byte 2)? (already stored)
01:0474 C20A02          	   849: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0477 1820            	   850: 		jr 		makeASCIItoHEX
                        	   851: 
                        	   852: getLvalue:
01:0479 DD210000        	   853: 		ld 		IX,commLvl1
01:047D DDBE00          	   854: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0480 2007            	   855: 		jr 		NZ,chkLVL2
01:0482 DDBE01          	   856: 		cp 		(IX+1)			; check if zero (byte 2)? (ascii value already stored)
01:0485 2002            	   857: 		jr 		NZ,chkLVL2
01:0487 1810            	   858: 		jr 		makeASCIItoHEX
                        	   859: 
                        	   860: chkLVL2:
01:0489 DD210000        	   861: 		ld 		IX,commLvl2
01:048D DDBE00          	   862: 		cp 		(IX)			; check if zero ? (ascii value already stored)
01:0490 C20A02          	   863: 		jp 		NZ,inputerror	; error : No more addresses to store
01:0493 DDBE01          	   864: 		cp 		(IX+1)			; check if zero (byte 2) ? (ascii value already stored)
01:0496 C20A02          	   865: 		jp 		NZ,inputerror	; error : No more addresses to store
                        	   866: 
                        	   867: 
                        	   868: makeASCIItoHEX:
                        	   869: 		; ***	copy from command line to adr or lvalue in table
                        	   870: 		; ***	only two bytes (four chars)....
                        	   871: 		; 		IX point to destination...
01:0499 54              	   872: 		ld 		D,H
01:049A 5D              	   873: 		ld		E,L						; DE -> first char after '$' | '@' <source>
01:049B CD0000          	   874: 		call 	skipCharsUntilDelim		; find next delimiter or CR ; adr in HL
01:049E 7E              	   875: 		ld 		A,(HL)
                        	   876: 
                        	   877: 	;***************************************************************
                        	   878: 	;	copy string to  'commParseTable', IX points to dest address.
                        	   879: 	;***************************************************************
                        	   880: 
01:049F A7              	   881: 		and 	A						; clear Carry
01:04A0 ED52            	   882: 		sbc 	HL,DE 					; amount of chars...->HL ( H=0); DE -> first char after '$' <source>
                        	   883: 
                        	   884: 		; ***	Do not check even or odd...
                        	   885: 		; bit 	0,L 					; even or odd (=1)?
                        	   886: 		; jp 		NZ,inputerror
                        	   887: 
01:04A2 45              	   888: 		ld 		B,L 					; char counter
01:04A3 210000          	   889: 		ld 		HL,00					;  
                        	   890: 
01:04A6 EB              	   891: 		ex 		DE,HL					; HL -> first char after '$' <ascii source>	
                        	   892: 
                        	   893: nextHalfByte:
                        	   894: 
01:04A7 CD0000          	   895: 		call 	isHex					; check char in (HL) return with Carry, value in A is NOT HEX
01:04AA DA0A02          	   896: 		jp 		C,inputerror			; return with Carry, value in A is NOT HEX
                        	   897: 
01:04AD CB23            	   898: 		sla 	E						; shift left E-> Carry
01:04AF CB12            	   899: 		rl 		D 						; Carry -> rotate left D
01:04B1 CB23            	   900: 		sla 	E						; shift left E-> Carry
01:04B3 CB12            	   901: 		rl 		D 						; Carry -> rotate left D
01:04B5 CB23            	   902: 		sla 	E						; shift left E-> Carry
01:04B7 CB12            	   903: 		rl 		D 						; Carry -> rotate left D
01:04B9 CB23            	   904: 		sla 	E						; shift left E-> Carry
01:04BB CB12            	   905: 		rl 		D 						; Carry -> rotate left D
01:04BD B3              	   906: 		or      E  						; A OR E(0..3) are zero
01:04BE 5F              	   907: 		ld 		E,A
                        	   908: 
01:04BF DD7300          	   909: 		ld 		(IX),E					; store E value [big endian]
01:04C2 DD7201          	   910: 		ld 		(IX+1),D				; store D value [big endian]
                        	   911: 
01:04C5 23              	   912: 		inc 	HL
                        	   913: 
01:04C6 10DF            	   914: 		djnz 	nextHalfByte
                        	   915: 		;***	HL should point to first delimiter...
                        	   916: 
                        	   917: byteEnd:
                        	   918: 
01:04C8 3A0000          	   919: 		ld  	A,(PCinpFlag)
01:04CB B7              	   920: 		or  	A 						; check Z; =0 -> normal parameter save
01:04CC CA1704          	   921: 		jp 	   	Z,paramLoopEntry
                        	   922: 
01:04CF 3A0100          	   923: 		ld  	A,(PCinpFlag+1) 		; address input for PCValue ?
01:04D2 FE24            	   924: 		cp 		'$' 					; adress flag ?
                        	   925: 		; jr 		Z,changePCVal
                        	   926: 		; cp 		'@' 					; relative adress flag ?
01:04D4 2813            	   927: 		jr 		Z,changePCVal
                        	   928: 
                        	   929: 		; ***	Store  bytes from LVL1 to (PCval)
01:04D6 E5              	   930: 		push 	HL
01:04D7 ED5B0000        	   931: 		ld 		DE,(PCvalue)	
01:04DB 210000          	   932: 		ld 		HL,commLvl1
                        	   933: 		; ld 		A,(DE)
                        	   934: 		; ld 		(HL),A
                        	   935: 		; inc 	HL
                        	   936: 		; inc 	DE
01:04DE EDA0            	   937: 		ldi  							; (DE)<-(HL), inc HL,DE, dec BC
01:04E0 7E              	   938: 		ld 		A,(HL)
01:04E1 B7              	   939: 		or 		A
01:04E2 2801            	   940: 		jr 		Z,noHighNib
01:04E4 12              	   941: 		ld 		(DE),A
                        	   942: noHighNib:
01:04E5 E1              	   943: 		pop 	HL		
                        	   944: 		; ***	reset flag
                        	   945: 		; ld 		A,0
                        	   946: 		; ld 		(PCinpFlag),A
                        	   947: 		; ld 		(PCinpFlag+1),A
01:04E6 C31704          	   948: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   949: 
                        	   950: 		
                        	   951: changePCVal:
                        	   952: 		; ***	Change relative PCvalue from 'commAdr1' or
                        	   953: 		; ***	change PCvalue from 'commAdr1'
                        	   954: 		; ***	A contains '$' or '@'
01:04E9 E5              	   955: 		push 	HL
01:04EA D5              	   956: 		push  	DE
01:04EB FE40            	   957: 		cp   	'@' 					; relative adress ?
01:04ED 2806            	   958: 		jr 		Z,.reladr
                        	   959: ; 		***		absolute adr !		
01:04EF 210000          	   960: 		ld 		HL,00
01:04F2 220000          	   961: 		ld 		(PCvalue),HL				; clear and then add value from commAdr1
                        	   962: 
                        	   963: .reladr:		
01:04F5 2A0000          	   964: 		ld 		HL,(commAdr1)
01:04F8 ED5B0000        	   965: 		ld  	DE,(PCvalue)
01:04FC 19              	   966: 		add 	HL,DE
01:04FD 220000          	   967: 		ld 		(PCvalue),HL
01:0500 D1              	   968: 		pop 	DE
01:0501 E1              	   969: 		pop 	HL 						; restore value of first delimiter
01:0502 C31704          	   970: 		jp 		paramLoopEntry 				; loop and check for more parameters
                        	   971: 
                        	   972: executeCommand:	
                        	   973: 		; ***	execute commands (and arguments)
                        	   974: 		; call 	writeSTRBelow
                        	   975: 		; DB 		0,"Finish parsing !",CR,LF,00
                        	   976: 		; call 	DumpRegisters			; checkpoint for list of arguments
                        	   977: 		; ***	IY+2 point to command address. IY=commParseTable
                        	   978: 
01:0505 3A0000          	   979: 		ld 		A,(PCinpFlag)
01:0508 B7              	   980: 		or 		A   					; check if zero  
01:0509 2003            	   981: 		jr 		NZ,.noJump
                        	   982: 
01:050B CD1905          	   983: 		call 	JPTable01
                        	   984: .noJump:
                        	   985: 		; ***	reset flag
01:050E 3E00            	   986: 		ld 		A,0
01:0510 320000          	   987: 		ld 		(PCinpFlag),A
01:0513 320100          	   988: 		ld 		(PCinpFlag+1),A
                        	   989: 
                        	   990: 		
                        	   991: 		; jp 		paramLoopEntry 				; loop and check for more parameters
                        	   992: 
                        	   993: temp_finish:
                        	   994: 		; call 	DumpRegisters
01:0516 C35501          	   995: 		jp 		next_line
                        	   996: 
                        	   997: 	;***************************************************************
                        	   998: 	;	Check if LVALUE is specified in input 
                        	   999: 	;***************************************************************
                        	  1000: 
                        	  1001: JPTable01:
01:0519 3A0000          	  1002: 		ld 		A,(commParseTable) 			; retrieve command number
01:051C B7              	  1003: 		or 	  	A 							; error if 0
01:051D CA0A02          	  1004: 		jp 		Z,inputerror
01:0520 FE1B            	  1005: 		cp 		commListLen
01:0522 3F              	  1006: 		ccf 						;complement carry for error indicator
                        	  1007: 
01:0523 DA0A02          	  1008: 		jp      C,inputerror
                        	  1009: 
01:0526 E5              	  1010: 		push  	HL					; make space in stack for 'return' address
                        	  1011: 
                        	  1012: 		; 								;obtain routine address from table and transfer 
                        	  1013: 		; 								;control to it, leaving all register pairs unchanged
                        	  1014: 		
01:0527 FD2A0200        	  1015: 		ld   	IY,(commParseTable+2)	; get address $F080+2
01:052B FD6E03          	  1016: 		ld   	L,(IY+3)				; load address in HL, move pointer 3 pos forward
01:052E FD6604          	  1017: 		ld   	H,(IY+4)
                        	  1018: 
01:0531 E3              	  1019: 		ex 		(SP),HL					;restore old HL, push routine address
01:0532 C9              	  1020: 		ret 							; jump to routine
                        	  1021: 
                        	  1022: argumentsError:
01:0533 CD0000          	  1023: 		call 	writeSTRBelow
01:0536 00              	  1024: 		DB 		0,"Some arguments mismatch !",CR,LF,00
01:0537 536F6D6520617267
01:053F 756D656E7473206D
01:0547 69736D6174636820
01:054F 21
01:0550 0D
01:0551 0A
01:0552 00
01:0553 C9              	  1025: 		ret
                        	  1026: 
                        	  1027: 
                        	  1028: p_reset:
01:0554 AF              	  1029: 		xor 	A
01:0555 320000          	  1030: 		ld 		(memBankID),A			; set memory banks #0
01:0558 CD0000          	  1031: 		call 	setFLASHBank			; FLASH bank #0
01:055B AF              	  1032: 		xor 	A
01:055C CD0000          	  1033: 		call 	setSRAMBank				; ram bank #0
                        	  1034: 
01:055F CD0000          	  1035: 		call 	enableFLASH			; start from FLASH
                        	  1036: 
01:0562 CD0000          	  1037: 		call 	enableIC620_OE 			; enable the outputs.
                        	  1038: 
01:0565 C30000          	  1039: 		jp $0000
                        	  1040: 
                        	  1041: p_load:
01:0568 C9              	  1042: 		ret
                        	  1043: p_dumpmem:
01:0569 CD0000          	  1044: 		call 	dumpMemory
                        	  1045: 
01:056C C9              	  1046: 		ret
                        	  1047: p_pc:
01:056D C9              	  1048: 		ret
                        	  1049: 
                        	  1050: p_eep:
                        	  1051: 
01:056E 210000          	  1052: 		ld 		HL,000
01:0571 220000          	  1053: 		ld 		(PCvalue),hl
01:0574 C9              	  1054: 		ret
                        	  1055: 
                        	  1056: p_clearmem:
                        	  1057: ;		***		clear memory from PC/Adr n bytes from ram memory
                        	  1058: 
01:0575 ED4B0000        	  1059: 		ld 		BC,(commLvl1)    	;amount of bytes
01:0579 ED5B0000        	  1060: 		ld   	DE,(PCvalue)		 
01:057D 218705          	  1061: 		ld		hl,.zero_byte
                        	  1062: 		
                        	  1063: .cl_vars:
01:0580 EDA0            	  1064: 		ldi							; (DE)<-(HL)
01:0582 2B              	  1065: 		dec 	hl
01:0583 EA8005          	  1066: 		jp		PE,.cl_vars			; 		P/V is set if BC  1  0; otherwise, it is reset.
                        	  1067: 
01:0586 C9              	  1068: 		ret
01:0587 00              	  1069: .zero_byte:	db  0
                        	  1070: 
                        	  1071: p_exe:
                        	  1072: 
                        	  1073: 		; call 	LCD_Test
                        	  1074: 
01:0588 C9              	  1075: 		ret
                        	  1076: p_go:
                        	  1077: 
01:0589 18FD            	  1078: 		jr 	p_exe
                        	  1079: 
                        	  1080: 
01:058B 3A0000          	  1081: 		ld 		A,(TempVar1)
01:058E 3C              	  1082: 		inc 	A
01:058F 320000          	  1083: 		ld 		(TempVar1),A
01:0592 FE0F            	  1084: 		cp 		15
01:0594 CD0000          	  1085: 		call 	DumpRegisters
                        	  1086: 		
01:0597 F0              	  1087: 		ret 	P
01:0598 18EF            	  1088: 		jr 		p_go
                        	  1089: p_incDecPC:
01:059A 210000          	  1090: 		ld 		HL,commLvl1
01:059D 3E00            	  1091: 		ld 		A,0
01:059F 5E              	  1092: 		ld 		E,(HL)
01:05A0 23              	  1093: 		inc 	HL
01:05A1 56              	  1094: 		ld 		D,(hl) 				; DE = (commLvl1)
                        	  1095: 		; ***	if both D and E is 0 -> DE = 1 		; no param -> A=1
01:05A2 BB              	  1096: 		cp 		E
01:05A3 2006            	  1097: 		jr 		NZ,.justOne
01:05A5 BA              	  1098: 		cp 		D
01:05A6 2003            	  1099: 		jr 		NZ,.justOne
01:05A8 110100          	  1100: 		ld 		DE,1
                        	  1101: .justOne:
01:05AB 3A0000          	  1102: 		ld 		A,(commParseTable)	; command number in commParseTable
01:05AE 2A0000          	  1103: 		ld 		HL,(PCvalue)
01:05B1 FE08            	  1104: 		cp 		8 					; ++ (increase) ??
01:05B3 2003            	  1105: 		jr  	nz,.sub
01:05B5 19              	  1106: 		add 	HL,DE 				; increase HL (PCvalue) with DE
01:05B6 1803            	  1107: 		jr 		.common
                        	  1108: .sub:
01:05B8 A7              	  1109: 		and 	A					; clear C
01:05B9 ED52            	  1110: 		sbc 	HL,DE 				; decrease HL (PCvalue) with DE
                        	  1111: .common:
01:05BB 220000          	  1112: 		ld 		(PCvalue),HL
01:05BE C9              	  1113: 		ret
                        	  1114: p_flwr:
                        	  1115: 		; *** 	testwrite to FLASH
                        	  1116: 		
                        	  1117: 		; call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
                        	  1118: 		; jp		NZ,argumentsError			; show argument error and return
                        	  1119: 		; 	*** Check if flashmem is enabled
01:05BF 3A0000          	  1120: 		ld 		A,(memBankID)
01:05C2 CB7F            	  1121: 		bit 	7,A
01:05C4 2004            	  1122: 		jr 		NZ,errNoFlash
                        	  1123: 
01:05C6 CD0000          	  1124: 		call 	Flash_WR_Test
01:05C9 C9              	  1125: 		ret
                        	  1126: errNoFlash:
01:05CA CD0000          	  1127: 		call 	writeSTRBelow
01:05CD 00              	  1128: 		DB 		0," Can't write to deselected FLASH !",CR,LF,00
01:05CE 2043616E27742077
01:05D6 7269746520746F20
01:05DE 646573656C656374
01:05E6 656420464C415348
01:05EE 2021
01:05F0 0D
01:05F1 0A
01:05F2 00
                        	  1129: 
01:05F3 C9              	  1130: 		ret
                        	  1131: 
                        	  1132: 
                        	  1133: p_flse:
                        	  1134: 		; *** 	erase the sector that contain the address of HL
                        	  1135: 
01:05F4 E5              	  1136: 		push	HL
01:05F5 211020          	  1137: 		ld 		HL,$2010
01:05F8 CD0000          	  1138: 		call 	Flash_SE_Erase
01:05FB E1              	  1139: 		pop 	HL
01:05FC C9              	  1140: 		ret
                        	  1141: 
                        	  1142: p_xmod:
                        	  1143: 		; ***	Transfer files via x-modem
                        	  1144: 		; ***	Check commParseTable+1 if required parameters
                        	  1145: 
01:05FD 3A0100          	  1146: 		ld 		A,(commParseTable+1)
01:0600 CB47            	  1147: 		bit 	0,A 			; should be a <2-textstring 	1-address	 0-lvalue>
01:0602 2804            	  1148: 		jr 		Z,.nxta
                        	  1149: 		; ***	check the commLvl1 if zero
01:0604 ED5B0000        	  1150: 		ld 		DE,(commLvl1)
                        	  1151: .nxta:		
                        	  1152: 
                        	  1153: 		ifndef 	BOOTLOAD				; don not use during BOOT
                        	  1154: 		call 	doImportXMODEM
                        	  1155: 
                        	  1156: 		call 	SIO_A_TXRX_INTon
                        	  1157: 		call 	CTC1_INT_OFF
                        	  1158: 		endif	
01:0608 C9              	  1159: 		ret
                        	  1160: 
                        	  1161: p_C_Read:
                        	  1162: 
01:0609 CDC607          	  1163: 		call 	checkArgsTAL				; check necessary args
01:060C C23305          	  1164: 		jp		NZ,argumentsError			; show argument error and return
                        	  1165: 	
01:060F 110000          	  1166: 		ld 		DE,CTC_delay_INT_handler
01:0612 ED5312F4        	  1167: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1168: 
                        	  1169: 	ifd 	GPIODEBUG
01:0616 AF              	  1170: 	xor A
01:0617 D302            	  1171: 	out (gpio_out),A
                        	  1172: 	endif
                        	  1173: 
01:0619 CD0000          	  1174: 		call  	SIO_A_DI					; disable text output
                        	  1175: 	ifd 	GPIODEBUG
01:061C 3E04            	  1176: 	ld a,4
01:061E D302            	  1177: 	out (gpio_out),A
01:0620 3E00            	  1178: 	ld a,0
01:0622 D302            	  1179: 	out (gpio_out),A
                        	  1180: 	endif
                        	  1181: 	
01:0624 7B              	  1182: 		ld a,e
01:0625 CD0000          	  1183: 		call 	purgeRXB					; XMODEM_CRC_SUB.s
01:0628 CD0000          	  1184: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S) LEV_Sect11_IO_Interrupts.s
01:062B CD0000          	  1185: 		call 	HC376S_ResetAll
01:062E CD0000          	  1186: 		call 	HC376S_CheckConnection
01:0631 3A0000          	  1187: 		ld 		A,(commParseTable)
01:0634 FE0F            	  1188: 		cp 		15							; 15 read SD; 17-read USB
01:0636 280C            	  1189: 		jr 		Z,.doSD
01:0638 FE15            	  1190: 		cp 		21							; 21 read SD enumerate, 22 read USB enumerate
01:063A 2808            	  1191: 		jr 		Z,.doSD
01:063C CD0000          	  1192: 		call 	HC376S_setUSBMode
01:063F CD0000          	  1193: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:0642 1803            	  1194: 		jr 		.cont
                        	  1195: .doSD:
01:0644 CD0000          	  1196: 		call 	HC376S_setSDMode
                        	  1197: 		
                        	  1198: .cont:
01:0647 CD0000          	  1199: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:064A 2011            	  1200: 		jr 		NZ,abort
                        	  1201: 
01:064C CD0000          	  1202: 		call 	HC376S_setFileName
01:064F CD0000          	  1203: 		call 	HC376S_fileOpen
01:0652 2009            	  1204: 		jr 		NZ,abort
                        	  1205: 
01:0654 CD0000          	  1206: 		call 	HC376S_getFileSize
01:0657 CD0000          	  1207: 		call 	HC376S_fileRead
01:065A CD0000          	  1208: 		call 	HC376S_fileClose
                        	  1209: abort:
                        	  1210: 
                        	  1211: 		; ***	reset the interrupt handler for CTC
01:065D CD0000          	  1212: 		call 	SIO_A_EI					; enable text output
01:0660 CD0000          	  1213: 		call 	HC376S_ResetAll
01:0663 CD0000          	  1214: 		call 	CTC1_INT_OFF
01:0666 210000          	  1215: 		ld		HL,CTC_CH1_Interrupt_Handler
01:0669 2212F4          	  1216: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
01:066C C9              	  1217: 		ret
                        	  1218: 
                        	  1219: 		
                        	  1220: p_C_Write:
01:066D CDC607          	  1221: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1   Lvl1)
01:0670 2816            	  1222: 		jr 		Z,.contWR
                        	  1223: 		; ***	check alternative (2 adresses)
01:0672 3E2C            	  1224: 		ld 		A,%101100					; alt. with "string" $Adr1 < $Adr2
01:0674 77              	  1225: 		ld 		(HL),A						; HL-> (commParseTable+1);
01:0675 23              	  1226: 		inc 	HL			; HL-> (commParseTable+2); get the resulting arguments counted
01:0676 BE              	  1227: 		cp 		(HL) 						; compare resulting arguments with req arguments
                        	  1228: 
01:0677 C23305          	  1229: 		jp		NZ,argumentsError			; show argument error and return
                        	  1230: 		
                        	  1231: 		; ***	calculate size from addresses $Adr2 - $Adr1
01:067A 37              	  1232: 		scf
01:067B 3F              	  1233: 		ccf
01:067C 2A0000          	  1234: 		ld 		HL,(commAdr2)
01:067F ED5B0000        	  1235: 		ld		DE,(commAdr1)
01:0683 ED52            	  1236: 		sbc		HL,DE
01:0685 220000          	  1237: 		ld 		(commLvl1),HL				; resulting size in commLvl1
                        	  1238: 
                        	  1239: 
                        	  1240: .contWR:
01:0688 110000          	  1241: 		ld 		DE,CTC_delay_INT_handler
01:068B ED5312F4        	  1242: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1243: 
01:068F CD0000          	  1244: 		call 	purgeRXB
01:0692 CD0000          	  1245: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
01:0695 CD0000          	  1246: 		call 	HC376S_ResetAll
01:0698 CD0000          	  1247: 		call 	HC376S_CheckConnection
01:069B 3A0000          	  1248: 		ld 		A,(commParseTable)
01:069E FE10            	  1249: 		cp 		16							; 16 read SD; 18-read USB
01:06A0 2808            	  1250: 		jr 		Z,.doSD
01:06A2 CD0000          	  1251: 		call 	HC376S_setUSBMode
01:06A5 CD0000          	  1252: 		call 	HC376S_diskConnectionStatus		; dont use with SD card
01:06A8 1803            	  1253: 		jr 		.cont
                        	  1254: .doSD:
01:06AA CD0000          	  1255: 		call 	HC376S_setSDMode
                        	  1256: .cont:
01:06AD CD0000          	  1257: 		call 	HC376S_USBdiskMount				; ret with NZ  on failure
01:06B0 20AB            	  1258: 		jr 		NZ,abort
01:06B2 CD0000          	  1259: 		call 	HC376S_setFileName
01:06B5 CD0000          	  1260: 		call 	HC376S_fileCreate
01:06B8 20A3            	  1261: 		jr		NZ,abort
01:06BA CD0000          	  1262: 		call 	HC376S_fileWrite
                        	  1263: 		
01:06BD CD0000          	  1264: 		call 	HC376S_fileClose
01:06C0 CD0000          	  1265: 		call 	HC376S_ResetAll
01:06C3 1898            	  1266: 		jr 		abort
                        	  1267: 
                        	  1268: p_C_Delete:
01:06C5 CDC607          	  1269: 		call 	checkArgsTAL				; check necessary args ("string" $Adr1  )
01:06C8 C23305          	  1270: 		jP 		NZ,argumentsError
01:06CB 110000          	  1271: 		ld 		DE,CTC_delay_INT_handler
01:06CE ED5312F4        	  1272: 		ld 		(CTC_CH1_I_Vector),DE
                        	  1273: 
01:06D2 CD0000          	  1274: 		call 	purgeRXB
01:06D5 CD0000          	  1275: 		call 	initSIOBInterrupt			; turn on interrupt on SIO B (CH376S)
                        	  1276: 
01:06D8 CD0000          	  1277: 		call 	HC376S_ResetAll
01:06DB CD0000          	  1278: 		call 	HC376S_CheckConnection
01:06DE 3A0000          	  1279: 		ld 		A,(commParseTable)
01:06E1 FE13            	  1280: 		cp 		19							; 19 delete file SD; 20-delete file USB
01:06E3 2808            	  1281: 		jr 		Z,.doSD
01:06E5 CD0000          	  1282: 		call 	HC376S_setUSBMode
01:06E8 CD0000          	  1283: 		call 	HC376S_diskConnectionStatus
01:06EB 1803            	  1284: 		jr 		.cont
                        	  1285: .doSD:
01:06ED CD0000          	  1286: 		call 	HC376S_setSDMode
                        	  1287: .cont:
01:06F0 CD0000          	  1288: 		call 	HC376S_USBdiskMount
                        	  1289: 		 
                        	  1290: 		; call 	HC376S_fileOpen
                        	  1291: 		; call 	HC376S_getFileSize
                        	  1292: 		; call 	HC376S_fileRead
                        	  1293: 
01:06F3 CD0000          	  1294: 		call 	HC376S_fileDelete
01:06F6 CD0000          	  1295: 		call 	HC376S_ResetAll
                        	  1296: 
01:06F9 C35D06          	  1297: 		jp 		abort
                        	  1298: 
                        	  1299: p_cptFl:
01:06FC CD0000          	  1300: 		call 	setFLASHBank				; change to bank
01:06FF C9              	  1301: 		ret
01:0700 CD0000          	  1302: 		call 	setSRAMBank 			; change to bank
01:0703 C9              	  1303: 		ret
                        	  1304: ;********************************************************************************************
                        	  1305: ;********************************************************************************************	
                        	  1306: p_srbank:
                        	  1307: 	; ***	set sram bank #
01:0704 CD8D07          	  1308: 	call 	p_FOFF				; disable the flash memory
01:0707 3A0000          	  1309: 	ld 		A,(commLvl1) 			; load param into A
                        	  1310: ; ***	set the SRAM bank ID; Bank ID in A
                        	  1311: p_srbank0:
                        	  1312: 
01:070A E5              	  1313: 	push 	HL
01:070B C5              	  1314: 	push 	BC
01:070C 210000          	  1315: 	ld 		HL,memBankID
01:070F E60F            	  1316: 	and 	$0F 				; clear all bits but 0-3 in A
                        	  1317: 
01:0711 47              	  1318: 	ld 		B,A
01:0712 7E              	  1319: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:0713 E6F0            	  1320: 	and 	$F0  				; zero bits 0-3
01:0715 1815            	  1321: 	jr 		putBank
                        	  1322: 
                        	  1323: ;********************************************************************************************
                        	  1324: ;********************************************************************************************	
                        	  1325: 
                        	  1326: p_flbank:
                        	  1327: 	; ***	set flash bank #
                        	  1328: 
01:0717 CD3307          	  1329: 	call 	p_FON				; enable  the  flash memory
01:071A 3A0000          	  1330: 	ld 		A,(commLvl1) 			; load param into A
                        	  1331: ; ***	set the FLASH bank ID; Bank ID in A
                        	  1332: p_flbank0:
                        	  1333: 
01:071D E5              	  1334: 	push 	HL
01:071E C5              	  1335: 	push 	BC
01:071F 210000          	  1336: 	ld 		HL,memBankID
01:0722 E607            	  1337: 	and 	$07 				; clear all bits but 0-2
01:0724 07              	  1338: 	rlca
01:0725 07              	  1339: 	rlca
01:0726 07              	  1340: 	rlca
01:0727 07              	  1341: 	rlca						; bank ID = bits 4-6
                        	  1342: 
01:0728 47              	  1343: 	ld 		B,A
01:0729 7E              	  1344: 	ld 		A,(HL)				; get the actl. mem Bank ID
01:072A E68F            	  1345: 	and 	$8F  				; zero bits 4-6
                        	  1346: putBank:
01:072C B0              	  1347: 	or 		B					; put new EEP bank ID in A...
01:072D 77              	  1348: 	ld 		(HL),A				; store new value
01:072E D300            	  1349: 	out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
01:0730 C1              	  1350: 	pop  	BC
01:0731 E1              	  1351: 	pop 	HL
01:0732 C9              	  1352: 	ret
                        	  1353: 
                        	  1354: ;********************************************************************************************
                        	  1355: ;********************************************************************************************	
                        	  1356: 
                        	  1357: p_FON:
                        	  1358: 		; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0)
                        	  1359: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	  1360: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1361: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:0733 CD0000          	  1362: 	call 	writeSTRBelow
01:0736 00              	  1363: 	DB 		0," Use 256k FLASH (7 banks),lower 32k and SRAM (16 banks),upper 32k !",CR,LF,00
01:0737 2055736520323536
01:073F 6B20464C41534820
01:0747 28372062616E6B73
01:074F 292C6C6F77657220
01:0757 33326B20616E6420
01:075F 5352414D20283136
01:0767 2062616E6B73292C
01:076F 7570706572203332
01:0777 6B2021
01:077A 0D
01:077B 0A
01:077C 00
01:077D CD0000          	  1364: 	call 	waitForFinishedPrintout
                        	  1365: p_FON_No_Print: 		;; ***  Activate FLASH MEMORY (set 64K_SRAM signal 0) without printout		
01:0780 E5              	  1366: 	push 	HL
01:0781 210000          	  1367: 	ld 		HL,rstBankID
01:0784 CB9E            	  1368: 	res 	3,(HL)				; clear bit 3 -> enable FLASH
01:0786 CB96            	  1369: 	res 	2,(HL)				; temp enable reset of IC622
                        	  1370: putBankF:
01:0788 7E              	  1371: 	ld 		A,(HL)
01:0789 D300            	  1372: 	out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
01:078B E1              	  1373: 	pop 	HL
01:078C C9              	  1374: 	ret 
                        	  1375: 	
                        	  1376: ;********************************************************************************************
                        	  1377: ;********************************************************************************************	
                        	  1378: p_FOFF:
                        	  1379: 	; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1)
                        	  1380: 	; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	  1381: 			; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	  1382: 			; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
01:078D CD0000          	  1383: 	call 	writeSTRBelow
01:0790 20557365206F6E6C	  1384: 	DB 		" Use only SRAM (16 banks),upper 32k !",CR,LF,00
01:0798 79205352414D2028
01:07A0 31362062616E6B73
01:07A8 292C757070657220
01:07B0 33326B2021
01:07B5 0D
01:07B6 0A
01:07B7 00
01:07B8 CD0000          	  1385: 	call 	waitForFinishedPrintout
                        	  1386: 
                        	  1387: p_FOFF_No_Print:		; ***  Do Not USE FLASH MEMORY(set 64K_SRAM signal 1) without printout
01:07BB E5              	  1388: 	push 	HL
01:07BC 210000          	  1389: 	ld 		HL,rstBankID
01:07BF CBD6            	  1390: 	set 	2,(HL) 			; temp disable reset of IC622
01:07C1 CBDE            	  1391: 	set 	3,(HL)			; set bit 3 -> disable FLASH
01:07C3 18C3            	  1392: 	jr 		putBankF
                        	  1393: 	; ld 		A,(HL)
                        	  1394: 	; out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
                        	  1395: 	; pop 	HL
                        	  1396: 	; call 	writeSTRBelow
                        	  1397: 	; DB 		0," Use only 512k (16 banks) SRAM !",CR,LF,00
01:07C5 C9              	  1398: 	ret 
                        	  1399: 
                        	  1400: ;********************************************************************************************     
                        	  1401: ;********************************************************************************************     
                        	  1402: 
                        	  1403: 		; ***	Check commParseTable+1 if required parameters
                        	  1404: checkArgsTAL:		
                        	  1405: ;		*** command textstring1/2 	address1/2	 lvalue1/2
                        	  1406: 
                        	  1407: 		; ***	try to connect to USB
01:07C6 210200          	  1408: 		ld 		HL,commParseTable+2				; resulting typed arguments
01:07C9 3E00            	  1409: 		ld 		A,0
01:07CB 77              	  1410: 		ld 		(HL),A
                        	  1411: 
01:07CC DD210000        	  1412: 		ld 		IX,commStr1			; commStr1 =			0xB0
01:07D0 CDFA07          	  1413: 		call 	shift_0_1:
01:07D3 DD210000        	  1414: 		ld 		IX,commStr2			; commStr2 =			0xD8
01:07D7 CDFA07          	  1415: 		call 	shift_0_1:
01:07DA DD210000        	  1416: 		ld 		IX,commAdr1			; commAdr1 =			0x84
01:07DE CDFA07          	  1417: 		call 	shift_0_1:
01:07E1 DD210000        	  1418: 		ld 		IX,commAdr2			; commAdr2 =			0x88
01:07E5 CDFA07          	  1419: 		call 	shift_0_1:
01:07E8 DD210000        	  1420: 		ld 		IX,commLvl1			; commLvl1 =			0x90
01:07EC CDFA07          	  1421: 		call 	shift_0_1:
01:07EF DD210000        	  1422: 		ld 		IX,commLvl2			; commLvl2 =			0xA0
01:07F3 CDFA07          	  1423: 		call 	shift_0_1:
                        	  1424: 
01:07F6 7E              	  1425: 		ld 		A,(HL)						; get the resulting arguments counted
01:07F7 2B              	  1426: 		dec 	HL
01:07F8 BE              	  1427: 		cp 		(HL) 						; compare resulting arguments with req arguments
01:07F9 C9              	  1428: 		ret 	 					; return with Z or NZ  arguments
                        	  1429: 
                        	  1430: shift_0_1:
01:07FA DDBE00          	  1431: 		cp 		(IX)
01:07FD 2008            	  1432: 		jr 		NZ,shiftIn1
01:07FF DDBE01          	  1433: 		cp 		(IX+1)
01:0802 2003            	  1434: 		jr 		NZ,shiftIn1
                        	  1435: 		; ***	both =0 shift in '0'
01:0804 CB26            	  1436: 		sla		(HL)
01:0806 C9              	  1437: 		ret
                        	  1438: shiftIn1:
                        	  1439: 		; ***	least one not '0' shift in '1'
01:0807 37              	  1440: 		scf		
01:0808 CB16            	  1441: 		rl 		(HL)
01:080A C9              	  1442: 		ret
                        	  1443: 
                        	  1444: 
                        	  1445: ;********************************************************************************************     
                        	  1446: ;********************************************************************************************     
                        	  1447: 
                        	  1448: bit_test9:
01:080B 01              	  1449: 	db	0x01,0x02,0x80,0x40
01:080C 02
01:080D 80
01:080E 40
                        	  1450: 
                        	  1451: 
                        	  1452: ; debug:		equ	0		; Set to 1 to show debug printing, else 0 
                        	  1453: 
                        	  1454: 
                        	  1455: 	; Spin loop here because there is nothing else to do
                        	  1456: ; halt_loop:
                        	  1457: ; 	halt
                        	  1458: ; 	jp	halt_loop
                        	  1459: 
                        	  1460: 
                        	  1461: 
                        	  1462: 
                        	  1463: 
                        	  1464: ;*******************************************************************************     
                        	  1465: ;*******************************************************************************     
                        	  1466: 
                        	  1467: 
                        	  1468: 
                        	  1469: 		; ld 		hl,Textbuf
                        	  1470: 		; ; call	ReadLine 			;to textbuf  (A=length of input string)
                        	  1471: 
                        	  1472: 		; ld		HL,T_BUFFER			;HL = BASE ADDRESS 0F BUFFER
                        	  1473: 		; ld		DE,Textbuf			;DE = 32767
                        	  1474: 		; call	BN2DEC				; C0NVERT
                        	  1475: 		; jp		textloop
                        	  1476: 
                        	  1477: 
                        	  1478: 		; ld 		hl,Textbuf
                        	  1479: 		; call	DEC2BN			; result in HL
                        	  1480: 
                        	  1481: 		; ld 		E,L
                        	  1482: 		; 	; Binary to HEX  BN2HEX   E->(HL)
                        	  1483: 		; ld 		hl,T_BUFFER
                        	  1484: 		; inc		hl
                        	  1485: 		; call	Bin2Hex8			;result in T_buffer
                        	  1486: 
                        	  1487: 		; ld 		iy,T_BUFFER
                        	  1488: 		; call 	WriteLineCRNL
                        	  1489: 
                        	  1490: 		; ld 		iy,Textbuf
                        	  1491: 		; call	WriteLineCRNL
                        	  1492: 
                        	  1493: 		; jp 		next_line
                        	  1494: 
                        	  1495: 
                        	  1496: 
                        	  1497: textloop:
                        	  1498: 		; LD		HL,sourctext1
                        	  1499: 		; LD		DE,S1x
                        	  1500: 		; LD		BC,src_size
                        	  1501: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1502: 
                        	  1503: 
                        	  1504: 		; LD		HL,sourctext2
                        	  1505: 		; LD		DE,S2x
                        	  1506: 		; LD		BC,14
                        	  1507: 		; CALL 	BLKMOV		;	MOVE DATA FROM SOURCE TO DESTINATION
                        	  1508: 
                        	  1509: 		; test of string concat
                        	  1510: 		; LD		HL,S1_8B		;HL = BASE ADDRESS OF S1
                        	  1511: 		; LD		DE,S2_8B		;DE = BASE ADDRESS OF S2
                        	  1512: 		; LD		B,40			;B = MAXIMUM LENGTH OF STRING 1
                        	  1513: 		; CALL 	CONCAT 			;CONCATENATE STRINGS to S1_8B
                        	  1514: 
                        	  1515: 
                        	  1516: 		; test of POS
                        	  1517: 		; LD		HL,Str2			;HL = BASE ADDRESS OF STRING
                        	  1518: 		; LD		DE,subst		;DE = BASE ADDRESS OF SUBSTRING	
                        	  1519: 		; CALL	POS				;FIND POSITION OF SUBSTRING
                        	  1520: 								; RESULTS IN REGISTER A = 8
                        	  1521: 
                        	  1522: 
                        	  1523: 		; test copy
                        	  1524: 		; LD		HL,Str4			; SOURCE STRING
                        	  1525: 		; LD		DE,COPY_BUFFER	;	DESTINATION STRING
                        	  1526: 		
                        	  1527: 		; LD		C,4				; STARTING INDEX FOR COPYING
                        	  1528: 
                        	  1529: 		; LD		B,6				; NUMBER OF BYTES TO COPY
                        	  1530: 		; LD		A, 25			; MAXIMUM LENGTH OF SUBSTRING
                        	  1531: 		; CALL 	COPY			; COPY SUBSTRING
                        	  1532: 
                        	  1533: 		; ld 		iy,COPY_BUFFER
                        	  1534: 		; call 		WriteLineCRNL ; print the copy string
                        	  1535: 
                        	  1536: 
                        	  1537: 		; ; test DELETE
                        	  1538: 		; LD		HL,Str0		;HL	= BASE 	ADDRESS OF STRING
                        	  1539: 		; LD		A,8			
                        	  1540: 		; LD		C,8				;	C= STARTING INDEX FOR DELETION
                        	  1541: 		; LD		A,4			
                        	  1542: 		; LD		B,4			; B = NUMBER OF CHARACTERS TO DELETE
                        	  1543: 		; CALL 	DELETE 			; DELETE CHARACTERS
                        	  1544: 									; DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	  1545: 		; ld 		iy,Str0
                        	  1546: 		; call 		WriteLineCRNL ; print the copy string
                        	  1547: 
                        	  1548: 
                        	  1549: ; 		;test INSERT
                        	  1550: 
                        	  1551: ; 		LD		HL,Str3				; HL = BASE ADDRESS OF STRING
                        	  1552: ; 		LD		DE,subst			; DE = BASE ADDRESS OF SUBSTRING
                        	  1553: 
                        	  1554: ; 		LD		C,7					; C = STARTING INDEX FOR INSERTION
                        	  1555: 
                        	  1556: ; 		LD		B,0x40				; B = MAXIMUM LENGTH OF STRING
                        	  1557: ; 		CALL 	INSERT_STR			; INSERT SUBSTRING
                        	  1558: ; 		ld 		iy,Str3
                        	  1559: ; 		; call	WriteLineCRNL 		; print the modified string
                        	  1560: 
                        	  1561: 
                        	  1562: ; 		jp		next_line
                        	  1563: 
                        	  1564: ; 		;TEST DATA. CHANGE FOR OTHER VALUES
                        	  1565: ; S1_8B:	DB		8H				; LENGTH OF SI
                        	  1566: ; 		DB      "LASTNAME                        "	; 32 BYTE MAX LENGTH
                        	  1567: ; S2_8B:	DB		0BH				;LENGTH OF S2
                        	  1568: ; 		DB		". FIRSTNAME                     "	; 32 BYTE MAX LENGTH
                        	  1569: 
                        	  1570: ;********************************************************************************************
                        	  1571: ;********************************************************************************************	
                        	  1572: ; sh_test:
                        	  1573: ; 		; turn shadow off then halt
                        	  1574: ; 		xor A
                        	  1575: ; 		out (_CE_RST_BANK),A 		;// clear '64K_SRAM' signal
                        	  1576: 
                        	  1577: ; 		halt
                        	  1578: 
                        	  1579: ; 		ld	A,$80
                        	  1580: ; 		out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	  1581: ; 		ld 	A,1
                        	  1582: ; 		out (_CE_RST_BANK),A 		; engage 3-state on bank#
                        	  1583: ; 		ret
                        	  1584: 
                        	  1585: 
                        	  1586: ;********************************************************************************************
                        	  1587: ;********************************************************************************************	
                        	  1588: 			;9H JUMP TABLE (JTAB)   353
                        	  1589:         ; Title               Jump table
                        	  1590:         ; Name:               JTAB
                        	  1591:         ; Purpose:            Given an index, jump to the subroutine with
                        	  1592:         ;                     that index in a table.
                        	  1593:         ; Entry:              Register A is the subroutine number (0 to
                        	  1594:         ;                                LENSUB-l, the number of subroutines)
                        	  1595:         ;                                LENSUB must be less than or equal to
                        	  1596:         ;                                128.
                        	  1597:         ; Exit:               If the routine number is valid then
                        	  1598:         ;                       execute the routine
                        	  1599:         ;                     else
                        	  1600:         ;                       Carry flag = 1
                        	  1601:         ; Registers used: AF
                        	  1602:         ; Time:               117 cycles plus execution time of subroutine
                        	  1603:         ; Size:               Program 21 bytes plus size of table (2*LENSUB)
                        	  1604: 
                        	  1605:         ;EXIT WITH CARRY SET IF ROUTINE NUMBER IS INVALID
                        	  1606:         ; THAT IS, IF IT IS TOO LARGE FOR TABLE OLENSUB -     1)
                        	  1607: 
                        	  1608: 
                        	  1609: ; JTAB:
                        	  1610: ; 		CP		LENSUB			;COMPARE ROUTINE NUMBER, TABLE SIZE
                        	  1611: ; 		CCF						;COMPLEMENT CARRY FOR ERROR INDICATOR
                        	  1612: ; 		RET		C				;RETURN IF ROUTINE NUMBER TOO LARGE
                        	  1613: ; 									; WITH CARRY SET
                        	  1614: ; 		; INDEX INTO TABLE OF WORD-LENGTH ADDRESSES
                        	  1615: ; 		; LEAVE REGISTER PAIRS UNCHANGED SO THEY CAN BE USED FOR PASSING PARAMETERS
                        	  1616: 
                        	  1617: ; 		PUSH	HL				;SAVE HL
                        	  1618: ; 		ADD		A,A				;DOUBLE INDEX FOR WORD-LENGTH ENTRIES
                        	  1619: ; 		LD		HL,JMPTAB		;INDEX INTO TABLE USING 8-BIT
                        	  1620: ; 		ADD		A,L			; ADDITION TO AVOID DISTURBING
                        	  1621: ; 		LD		L,A				; ANOTHER REGISTER PAIR
                        	  1622: ; 		LD		A,0
                        	  1623: ; 		ADC		A,H
                        	  1624: ; 		LD		H,A			; ACCESS ROUTINE ADDRESS
                        	  1625: ; 			;OBTAIN ROUTINE ADDRESS FROM TABLE AND TRANSFER
                        	  1626: ; 			;CONTROL TO IT, LEAVING ALL REGISTER PAIRS UNCHANGED
                        	  1627: 
                        	  1628: ; 		LD		A, (HL)			;MOVE ROUTINE ADDRESS TO HL
                        	  1629: ; 		INC		HL
                        	  1630: ; 		LD		H, (HL)
                        	  1631: ; 		LD		L,A
                        	  1632: ; 		EX		(SP),HL				;RESTORE OLD HL, PUSH ROUTINE ADDRESS
                        	  1633: ; 		RET						; JUMP TO ROUTI NE
                        	  1634: 
                        	  1635: ; LENSUB		EQU		3				;NUMBER OF SUBROUTINES IN TABLE
                        	  1636: ; JMPTAB:                            ;JUMP TABLE
                        	  1637: ; 		DW		SUB0			;ROUTINE 0
                        	  1638: ; 		DW		SUB1			;ROUTINE 1
                        	  1639: ; 		DW		SUB2			;ROUTINE 2
                        	  1640: ;            ;THREE TEST SUBROUTINES FOR JUMP TABLE
                        	  1641: ; SUB0:
                        	  1642: ; 		LD		A,1				; TEST ROUTI NE 0 SETS (A)    1
                        	  1643: ; 		RET
                        	  1644: ; SUB1:
                        	  1645: ; 		LD		A,2				; TEST ROUTI NE 1 SETS (A) = 2
                        	  1646: ; 		RET
                        	  1647: ; SUB2:
                        	  1648: ; 		LD		A,3				;TEST ROUTINE 2 SETS (A)      3
                        	  1649: ; 		RET
                        	  1650: 
                        	  1651: 
                        	  1652: 
                        	  1653: ; 			;SAMPLE EXECUTION:
                        	  1654: 
                        	  1655: 
                        	  1656: ; SC9H:
                        	  1657: ; 		SUB		A				;EXECUTE ROUTINE 0
                        	  1658: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   =1
                        	  1659: 
                        	  1660: ; 		LD		A,1				;EXECUTE ROUTINE 1
                        	  1661: ; 		CALL	JTAB			; AFTER EXECUTION, (A) = 2
                        	  1662: ; 		LD		A,2				;EXECUTE ROUTINE 2
                        	  1663: ; 		CALL	JTAB			; AFTER EXECUTION, (A)   3
                        	  1664: ; 		LD		A,3				;EXECUTE ROUTINE 3
                        	  1665: ; 		CALL	JTAB			; AFTER EXECUTION, CARRY   1
                        	  1666: ; 		JR		SC9H			;LOOP FOR MORE TESTS
                        	  1667: 
                        	  1668: 
                        	  1669: ;********************************************************************************************
                        	  1670: ;********************************************************************************************	
                        	  1671: ; 		xref  	RDATA,RDATA_END,TB_length
                        	  1672: 
                        	  1673: ; 		;--------------------------------------------------
                        	  1674: ; 		; ld A,5
                        	  1675: ; 		; ld 	A,$00	
                        	  1676: ; 		; out (_Z80_BankCS),A		;// set bank register number 	
                        	  1677: ; 		ld 	A,$01
                        	  1678: ; 		out (_CE_RST_BANK),A 		;// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	  1679: 
                        	  1680: ; 		out (_8Bitsout),A
                        	  1681: 
                        	  1682: ; 		ld A, $0F                 ;mode 1 out
                        	  1683: ; 		out (portA_Contr), A         ; set port A as output
                        	  1684: ; 		ld A,$EB
                        	  1685: 
                        	  1686: ; Rtll:	
                        	  1687: 
                        	  1688: ; 		ld (40000),A
                        	  1689: ; 		ld A,0
                        	  1690: ; 		ld A,(40000)
                        	  1691: 
                        	  1692: ; 		out (portA_Data),A		; Data to PIO port A
                        	  1693: ; 		out (_8Bitsout),A
                        	  1694: ; 		;--------------------------------------------------
                        	  1695: ; 		ld	DE,$8200
                        	  1696: ; 		ld	HL,RDATA
                        	  1697: ; 		ld	BC,TB_length
                        	  1698: ; 		; ld	BC,RDATA_END-RDATA
                        	  1699: ; 		ldir
                        	  1700: 
                        	  1701: 
                        	  1702: ; SIO_A_RESET:
                        	  1703: ; 		ld	a,00110000b
                        	  1704: ; 		out	(SIO_A_C),A		;write into WR0: error reset, select WR0
                        	  1705: 
                        	  1706: ; 		ld	a,018h				;write into WR0: channel reset
                        	  1707: ; 		out (SIO_A_C),A 
                        	  1708: 
                        	  1709: ; 		ld	a,004h				;write into WR0: select WR4
                        	  1710: ; 		out	(SIO_A_C),A
                        	  1711: ; 		ld	a,44h				;44h write into WR4: clkx16,1 stop bit, no parity
                        	  1712: ; 		out (SIO_A_C),A
                        	  1713: 
                        	  1714: ; 		ld	a,005h				;write into WR0: select WR5
                        	  1715: ; 		out (SIO_A_C),A
                        	  1716: ; 		ld	a,01101000b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS inactive (bit 2)
                        	  1717: ; 		ld	a,01101010b			;NO DTR , TX 8bit, BREAK off, TX on(4), RTS active (bit 2)
                        	  1718: ; 		out (SIO_A_C),A
                        	  1719: ; SIO_A_EI:
                        	  1720: ; 			;enable SIO channel A RX
                        	  1721: ; 		ld	a,003h				;write into WR0: select WR3
                        	  1722: ; 		out (SIO_A_C),A
                        	  1723: ; 		ld	a,11000001b				;RX 8bit, auto enable off 8(bit 5), RX on (bit 0)
                        	  1724: ; 		ld	a,11100001b				;RX 8bit, auto enable on 8(bit 5), RX on (bit 0)
                        	  1725: ; 		out (SIO_A_C),A
                        	  1726: ; 		;Channel A RX active
                        	  1727: 
                        	  1728: 
                        	  1729: ; 		ld 	HL,Str0
                        	  1730: ; tstout:
                        	  1731: ; 		ld 	A,(HL)
                        	  1732: ; 		out (SIO_A_D),A
                        	  1733: ; 		inc HL
                        	  1734: ; 		ld D,A
                        	  1735: ; chkTX:
                        	  1736: ; 		in	A,(SIO_A_C)		; read status
                        	  1737: ; 		bit	2,A					; all sent ?
                        	  1738: ; 		jr z,chkTX				; not all sent..
                        	  1739: 
                        	  1740: ; 		ld 	A,(HL)
                        	  1741: ; 		cp	0
                        	  1742: ; 		jr 	z,endmsg
                        	  1743: 
                        	  1744: ; 		ld	A,D
                        	  1745: ; 		djnz	tstout
                        	  1746: 
                        	  1747: ; endmsg:
                        	  1748: ; chkRX:
                        	  1749: ; 		in	A,(SIO_A_C)		; read status
                        	  1750: ; 		bit	0,A					; char present ??
                        	  1751: ; 		jr z,chkRX				; check again
                        	  1752: 
                        	  1753: ; 		in 	A,(SIO_A_D)		; read the char.
                        	  1754: 
                        	  1755: ; 		out (SIO_A_D),A
                        	  1756: ; chkTX2:
                        	  1757: ; 		in	A,(SIO_A_C)		; read status
                        	  1758: ; 		bit	2,A					; all sent ?
                        	  1759: ; 		jr z,chkTX2
                        	  1760: 		
                        	  1761: ; 		jr	endmsg				; not all sent..
                        	  1762: 
                        	  1763: 
                        	  1764: 
                        	  1765: 
                        	  1766: ; 		halt
                        	  1767: ; 		halt
                        	  1768: ; 		halt
                        	  1769: ; 		inc A
                        	  1770: ; 		jr Rtll			
                        	  1771: 
                        	  1772: ; 	if DOALIGN
                        	  1773: ; 		align 4
                        	  1774: ; 	endif
                        	  1775: 
                        	  1776: 
                        	  1777: .end
                        	  1778: 


Symbols by name:
AddToT_Buf                      external
BLKMOV                          external EXP
BN2DEC                          external EXP
BN2DEC_S                        external EXP
Bin2Hex16                       external EXP
Bin2Hex8                        external EXP
BootCodeAdr                     external
CDEL                             E:00EE
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CONCAT                          external EXP
COPY                            external EXP
CR                               E:000D
CRC16                           external EXP
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       external
CTC_Init                        external
CTC_delay_INT_handler           external
DEC2BN                          external EXP
DELETE                          external EXP
DumpRegisters                   external
Flash_SE_Erase                  external
Flash_WR_Test                   external
HC376S_CheckConnection          external
HC376S_ResetAll                 external
HC376S_USBdiskMount             external
HC376S_diskConnectionStatus     external
HC376S_fileClose                external
HC376S_fileCreate               external
HC376S_fileDelete               external
HC376S_fileOpen                 external
HC376S_fileRead                 external
HC376S_fileWrite                external
HC376S_getFileSize              external
HC376S_setFileName              external
HC376S_setSDMode                external
HC376S_setUSBMode               external
HEX2BN                          external EXP
INSERT_STR                      external EXP
ITEM                             E:001C
InitBuffers                     external EXP
InitInterrupt                   external EXP
JPTable01                       01:0519
LF                               E:000A
LISTEND                          E:001E
MFILL                           external EXP
MONITOR_Start                   01:0000 EXP
MONITOR_Start0                  00:024A
PCinpFlag                       external
PCvalue                         external
PIO_Init                        external
POS                             external EXP
ReadChar                        external EXP
ReadLine                        external EXP
RegFlags                        external EXP
RegLabels1                      external EXP
RegLabels2                      external EXP
RegLabels3                      external EXP
S1x                             external
SD_USB_startup                  00:0000 EXP
SDabort                         00:023D
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        external
SIO_A_EI                        external
SIO_A_RTS_OFF                   external EXP
SIO_A_RTS_ON                    external EXP
SIO_B_C                         external
SIO_B_D                         external
SIO_Init                        external
SIO_Int_Vec                      E:F400
SP_value                        external
STEND                            E:001D
S_head_tail                     external EXP
T_BUFFER                        external
TempVar1                        external
Textbuf                         external EXP
WriteChar                       external EXP
WriteLine                       external
WriteLineCRNL                   external
_CE_RST_BANK                    external
_RAMSTART                       external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
abort                           01:065D
argumentsError                  01:0533
bit_test9                       01:080B
byteEnd                         01:04C8
changePCVal                     01:04E9
checkArgsTAL                    01:07C6
checkaddress                    01:044B
chkADR                          01:0456
chkADR1                         01:0457
chkADR2                         01:0467
chkLVL2                         01:0489
cleanInBuffer                   external EXP
cleanOutBuffer                  external EXP
commAdr1                        external
commAdr2                        external
commListLen                      E:001B
commLvl1                        external
commLvl2                        external
commParseTable                  external
commStr1                        external
commStr2                        external
command_list                    01:023D
crc16_2                         external EXP
dumpMemory                      external EXP
enableFLASH                     external
enableIC620_OE                  external
endtext                         external EXP
errNoFlash                      01:05CA
executeCommand                  01:0505
findCommandInList               01:01DA
findNextITEM                    01:01E6
getLvalue                       01:0479
gpioB                           external
gpio_in                         external
gpio_out                        external
inBuffer                        external EXP
inBufferEnd                     external EXP
initCommParseTable              01:03ED
initSIOBInterrupt               external
inputerror                      01:020A
isHex                           external EXP
makeASCIItoHEX                  01:0499
matchInList                     01:0400
memBankID                       external
nextHalfByte                    01:04A7
nextInList                      01:0206
next_line                       01:0155
noHighNib                       01:04E5
p_C_Delete                      01:06C5
p_C_Read                        01:0609
p_C_Read_SD                     00:0202
p_C_Write                       01:066D
p_FOFF                          01:078D
p_FOFF_No_Print                 01:07BB
p_FON                           01:0733
p_FON_No_Print                  01:0780
p_clearmem                      01:0575
p_cptFl                         01:06FC
p_dumpmem                       01:0569
p_eep                           01:056E
p_exe                           01:0588
p_flbank                        01:0717
p_flbank0                       01:071D
p_flse                          01:05F4
p_flwr                          01:05BF
p_go                            01:0589
p_incDecPC                      01:059A
p_load                          01:0568
p_pc                            01:056D
p_reset                         01:0554
p_srbank                        01:0704
p_srbank0                       01:070A
p_xmod                          01:05FD
paramLoopEntry                  01:0417
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external
putBank                         01:072C
putBankF                        01:0788
putDEtoScreen                   external
rfile_name                      00:01F2
rstBankID                       external
scanCommandList                 01:01D5
setFLASHBank                    external
setSRAMBank                     external
shiftIn1                        01:0807
shift_0_1                       01:07FA
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             external
skipPriorDelimit                external
sourctext1                      external EXP
sourctext2                      external EXP
src_size                        external EXP
st1g2                           external EXP
st2g1                           external EXP
steq                            external EXP
strCompare                      external EXP
subst                           external EXP
temp_finish                     01:0516
testdumpText                    01:0137
textloop                        01:080F
useFlash                        01:016A
waitForFinishedPrintout         external
writeSTRBelow                   external EXP
zero_byte                       01:01E5

Symbols by value:
0000 MONITOR_Start
0000 SD_USB_startup
000A LF
000D CR
001B commListLen
001C ITEM
001D STEND
001E LISTEND
00EE CDEL
0137 testdumpText
0155 next_line
016A useFlash
01D5 scanCommandList
01DA findCommandInList
01E5 zero_byte
01E6 findNextITEM
01F2 rfile_name
0202 p_C_Read_SD
0206 nextInList
020A inputerror
023D SDabort
023D command_list
024A MONITOR_Start0
03ED initCommParseTable
0400 matchInList
0417 paramLoopEntry
044B checkaddress
0456 chkADR
0457 chkADR1
0467 chkADR2
0479 getLvalue
0489 chkLVL2
0499 makeASCIItoHEX
04A7 nextHalfByte
04C8 byteEnd
04E5 noHighNib
04E9 changePCVal
0505 executeCommand
0516 temp_finish
0519 JPTable01
0533 argumentsError
0554 p_reset
0568 p_load
0569 p_dumpmem
056D p_pc
056E p_eep
0575 p_clearmem
0588 p_exe
0589 p_go
059A p_incDecPC
05BF p_flwr
05CA errNoFlash
05F4 p_flse
05FD p_xmod
0609 p_C_Read
065D abort
066D p_C_Write
06C5 p_C_Delete
06FC p_cptFl
0704 p_srbank
070A p_srbank0
0717 p_flbank
071D p_flbank0
072C putBank
0733 p_FON
0780 p_FON_No_Print
0788 putBankF
078D p_FOFF
07BB p_FOFF_No_Print
07C6 checkArgsTAL
07FA shift_0_1
0807 shiftIn1
080B bit_test9
080F textloop
F400 SIO_Int_Vec
F412 CTC_CH1_I_Vector
