Sections:
00: "InOutInterrupt" (0-382)


Source: "stdin"
                        	     1: 
                        	     2: 		INCLUDE "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     3: 
                        	     4: 			
                        	     5: 	ifndef ONESECTION
                        	     6: 		Section InOutInterrupt
                        	     7: 
                        	     8: 	else
                        	     9: 		section singleAssembly
                        	    10: 	endif
                        	    11: 
                        	    12: 
                        	    13: 					
                        	    14: 				
                        	    15: 		; Interrupts
                        	    16: 		; 11A    Unbuffered Input/Output Using an SIO_0          394
                        	    17: 		; 11B    Unbuffered Input/Output Using a PIO 404
                        	    18: 		; 11C    Buffered Input/Output Using an SIO_0          413
                        	    19: 		; 11D   Real-Time Clock and Calendar 425
                        	    20: 
                        	    21: 
                        	    22: ;*************************************************************************************************************
                        	    23: ;*************************************************************************************************************
                        	    24: 		; Unbuffered Input/Output
                        	    25: 		; 														I if full
                        	    26: 		; 														5. INIT: none
                        	    27: 		; 		Title                 Simple interrupt input and output using an SIO_0
                        	    28: 		; 								and single character buffers
                        	    29: 		; 		Name:                 SINTIO
                        	    30: 		; 		Purpose:       This program consists of 5 subroutines which
                        	    31: 		; 					perform-interrupt driven input and output using
                        	    32: 		; 					an SIO_0.
                        	    33: 		; 					ReadChar
                        	    34: 		; 						Read a character
                        	    35: 		; 					INST
                        	    36: 		; 						Determine input status (whether input
                        	    37: 		; 						buffer is empty)
                        	    38: 		; 					OUTCH
                        	    39: 		; 						Write a character
                        	    40: 		; 					OUTST
                        	    41: 		; 						Determine output status (whether output
                        	    42: 		; 						buffer is full)
                        	    43: 		; 					INIT
                        	    44: 		; 						Initialize SIO_0 and interrupt system
                        	    45: 		; 		Entry:         ReadChar
                        	    46: 		; 						No parameters
                        	    47: 		; 					INST
                        	    48: 		; 						No parameters
                        	    49: 		; 					OUTCH
                        	    50: 		; 						Register A = character to transmit
                        	    51: 		; 					OUTST
                        	    52: 		; 						No parameters
                        	    53: 		; 					INIT
                        	    54: 		; 						No parameters
                        	    55: 		; 		Exit:          ReadChar
                        	    56: 		; 						Register A = character
                        	    57: 		; 					INST
                        	    58: 		; 						Carry = 0 if input buffer is empty,
                        	    59: 		; 						1 if character is available
                        	    60: 		; 					OUTCH
                        	    61: 		; 						No parameters
                        	    62: 		; 					OUTST
                        	    63: 		; 						Carry = 0 if output buffer is not
                        	    64: 		; 						full, 1 if i t is full
                        	    65: 		; 					INIT
                        	    66: 		; 						No parameters
                        	    67: 		; 		Registers used: ReadChar - AF
                        	    68: 		; 						INST - AF
                        	    69: 		; 						OUTCH - AF
                        	    70: 		; 						OUTST - AF
                        	    71: 		; 						INIT - AF,BC,HL,I
                        	    72: 
                        	    73: 		; 		Time:           ReadChar
                        	    74: 		; 						72 cycles if a character is available
                        	    75: 		; 						INST
                        	    76: 		; 						27 cycles
                        	    77: 		; 							OUTCH
                        	    78: 		; 							150 cycles if output buffer is not full
                        	    79: 		; 								and output interrupt is expected
                        	    80: 		; 							OUTST
                        	    81: 		; 							27 cycles
                        	    82: 		; 							INIT
                        	    83: 		; 							618 cycles
                        	    84: 		; 							RDHDLR
                        	    85: 		; 							82 cycles
                        	    86: 		; 							WRHDLR
                        	    87: 		; 							160 cycles
                        	    88: 		; 		Size:              Program 202 bytes
                        	    89: 		; 							Data      5 bytes
                        	    90: 
                        	    91: 		; 		,SIO_0 EQUATES
                        	    92: 		; 		SIO_0 IS PROGRAMMED FOR:
                        	    93: 		; 			ASYNCHRONOUS OPERATION
                        	    94: 		; 			16 X BAUD RATE
                        	    95: 		; 			8-BIT CHARACTERS
                        	    96: 		; 		, 1 1/2 STOP BITS
                        	    97: 		; 		,ARBITRARY SIO_0 PORT ADDRESSES
                        	    98: ;**********************************************************************************************************************
                        	    99: ;**********************************************************************************************************************
                        	   100: ;
                        	   101: ;
                        	   102: ; INCH_11A:
                        	   103: ; 		CALL	INST_11A				;GET INPUT STATUS
                        	   104: ; 		JR		NC,INCH_11A				;WAIT IF NO CHARACTER AVAILABLE
                        	   105: ; 		DI							;DISABLE INTERRUPTS
                        	   106: ; 		SUB		A
                        	   107: ; 		LD		(RECDF),A			;INDICATE INPUT BUFFER EMPTY
                        	   108: ; 		LD		A,(RECDAT)			;GET CHARACTER FROM INPUT BUFFER
                        	   109: ; 		EI							;ENABLE INTERRUPTS
                        	   110: ; 		RET
                        	   111: ; 			;RETURN INPUT STATUS (CARRY = 1 IF INPUT DATA IS AVAILABLE)
                        	   112: ; INST_11A:
                        	   113: ; 		LD		A,(RECDF)			;GET DATA READY FLAG
                        	   114: ; 		RRA							;SET CARRY FROM DATA READY FLAG
                        	   115: ; 									;IF CARRY = 1, CHARACTER IS AVAILABLE
                        	   116: ; 		RET
                        	   117: ; 			;WRITE CHARACTER
                        	   118: 
                        	   119: ; OUTCH_11A:
                        	   120: ; 		PUSH	AF					;SAVE CHARACTER TO WRITE
                        	   121: ; 		;WAIT FOR CHARACTER BUFFER TO EMPTY, THEN STORE NEXT CHARACTER
                        	   122: ; WAITOOC_11A:
                        	   123: ; 		CALL	OUTST_11A				;GET OUTPUT STATUS
                        	   124: ; 		JR		C,WAITOOC_11A		;WAIT IF OUTPUT BUFFER IS FULL
                        	   125: ; 		DI							;DISABLE INTERRUPTS WHILE LOOKING AT
                        	   126: ; 									; SOFTWARE FLAGS
                        	   127: ; 		POP		AF					;GET CHARACTER
                        	   128: ; 		LD		(TRNDAT),A			;STORE CHARACTER IN OUTPUT BUFFER
                        	   129: ; 		LD		A,0FFH				;INDICATE OUTPUT BUFFER FULL
                        	   130: ; 		LD		(TRNDF),A
                        	   131: ; 		LD		A,(OutINTExpect)				;TEST OUTPUT INTERRUPT EXPECTED FLAG
                        	   132: ; 		OR		A
                        	   133: ; 		CALL	Z,OUTDAT_11A			;OUTPUT CHARACTER IMMEDIATELY IF
                        	   134: ; 									; NO OUTPUT INTERRUPT EXPECTED
                        	   135: ; 		EI                     	    ;ENABLE INTERRUPTS
                        	   136: ; 		RET
                        	   137: ; 			;OUTPUT STATUS (CARRY    =1   IF OUTPUT BUFFER IS FULL)
                        	   138: ; OUTST_11A:
                        	   139: ; 		LD		A,(TRNDF)			;GET TRANSMIT FLAG
                        	   140: ; 		RRA							;SET CARRY FROM TRANSMIT FLAG
                        	   141: ; 		RET							; CARRY = 1 IF BUFFER FULL
                        	   142: ; 		;INITIALIZE INTERRUPT SYSTEM AND SIO_0
                        	   143: ; INIT_11A:
                        	   144: ; 		DI							;DISABLE INTERRUPTS FOR INITIALIZATION
                        	   145: ; 			; INITIALIZE SOFTWARE FLAGS
                        	   146: ; 		SUB		A
                        	   147: ; 		LD		(RECDF),A			;NO INPUT DATA AVAILABLE
                        	   148: ; 		LD		(TRNDF),A			;OUTPUT BUFFER EMPTY
                        	   149: ; 		LD		(OutINTExpect),A				;NO OUTPUT INTERRUPT EXPECTED
                        	   150: ; 									; SIO_0 IS READY TO TRANSMIT INITIALLY
                        	   151: ; 			;INITIALIZE INTERRUPT VECTORS
                        	   152: ; 		LD      A,SIO_Int_Vec >> 8			;GET INTERRUPT PAGE NUMBER
                        	   153: ; 		LD      I,A				;SET INTERRUPT VECTOR IN zao
                        	   154: ; 		IM      2				;INTERRUPT MODE 2 - VECTORS IN TABLE
                        	   155: ; 								; ON INTERRUPT PAGE
                        	   156: ; 		LD		HL,RDHDLR_11A			;STORE READ VECTOR (INPUT INTERRUPT)
                        	   157: ; 		LD		(SIO_Int_Read_Vec),HL
                        	   158: ; 		LD		HL,WRHDLR_11A			;STORE WRITE VECTOR (OUTPUT INTERRUPT)
                        	   159: ; 		LD		(SIO_Int_WR_Vec),HL
                        	   160: ; 		LD		HL,EXHDLR_11A			;STORE EXTERNAL/STATUS VECTOR
                        	   161: ; 		LD		(SIO_Int_EXT_Vec),HL
                        	   162: ; 		LD		HL,REHDLR_11A			;STORE RECEIVE ERROR VECTOR
                        	   163: ; 		LD		(SIO_Int_Spec_Vec),HL
                        	   164: ; 			; INITIALIZE SIO_0
                        	   165: ; 		LD		HL,SIO_0INT			;GET BASE OF INITIALIZATION ARRAY
                        	   166: ; 		CALL	IPORTS_11A            	;INITIALIZE SIO_0
                        	   167: ; 		EI							;ENABLE INTERRUPTS
                        	   168: ; 		RET
                        	   169: 
                        	   170: ; 			;INPUT (READ) INTERRUPT HANDLER
                        	   171: ; RDHDLR_11A:
                        	   172: ; 		PUSH	AF					;SAVE AF
                        	   173: ; RD1_11A:	IN		A, (SIO_A_D)			;READ DATA FROM SIO_0
                        	   174: ; 		LD		(RECDAT), A			;SAVE DATA IN INPUT BUFFER
                        	   175: ; 		LD		A,0FFH
                        	   176: ; 		LD		(RECDF),A			;INDICATE INPUT DATA AVAILABLE
                        	   177: ; 		POP		AF					;RESTORE AF
                        	   178: ; 		EI							;REENABLE INTERRUPTS
                        	   179: ; 		RETI
                        	   180: ; 			;OUTPUT (WRITE) INTERRUPT HANDLER
                        	   181: ; WRHDLR_11A:
                        	   182: ; 		PUSH	AF
                        	   183: ; 		LD		A,(TRNDF)			;GET DATA AVAILABLE FLAG
                        	   184: ; 		RRA
                        	   185: ; 		JR		NC,NODATA_11A			;JUMP IF NO DATA TO TRANSMIT
                        	   186: ; 		CALL	OUTDAT_11A				;OUTPUT DATA TO SIO_0
                        	   187: ; 		JR		WRDONE_11A
                        	   188: 
                        	   189: ; 		; IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE.
                        	   190: ; 		; WE MUST RESET IT TO AVOID AN ENDLESS LOOP. LATER. WHEN A
                        	   191: ; 		; CHARACTER BECOMES AVAILABLE, WE NEED TO KNOW THAT AN OUTPUT
                        	   192: ; 		; INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED. THE KEY HERE
                        	   193: ; 		; IS THE OUTPUT INTERRUPT EXPECTED FLAG OlE. THIS FLAG IS
                        	   194: ; 		; CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT
                        	   195: ; 		; BEEN SERVICED. IT IS ALSO CLEARED INITIALLY SINCE THE
                        	   196: ; 		; SIO_0 STARTS OUT READY. OlE IS SET WHENEVER DATA IS ACTUALLY
                        	   197: ; 		; SENT TO THE SIO_0. THUS THE OUTPUT ROUTINE OUTCH CAN CHECK
                        	   198: ; 		; OlE TO DETERMINE WHETHER TO SEND THE DATA IMMEDIATELY
                        	   199: ; 		; OR WAIT FOR AN OUTPUT INTERRUPT.
                        	   200: ; 		; THE PROBLEM IS THAT AN.OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
                        	   201: ; 		; THE COMPUTER HAS ANYTHING TO SEND (UNLIKE AN INPUT DEVICE
                        	   202: ; 		; THAT HAS DATA WHEN IT REQUESTS SERVICE). THE OlE FLAG
                        	   203: ; 		; SOLVES THE PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING
                        	   204: ; 		; ITSELF REPEATEDLY. WHILE STILL ENSURING THE RECOGNITION OF
                        	   205: ; 		; OUTPUT INTERRUPTS.
                        	   206: ; NODATA_11A:
                        	   207: ; 		SUB		A
                        	   208: ; 		LD		(OutINTExpect),A				;DO NOT EXPECT AN INTERRUPT
                        	   209: ; 		OUT		(SIO_A_C),A			;SELECT REGISTER 0
                        	   210: ; 		LD		A,00101000B			;RESET SIO_0 TRANSMITTER INTERRUPT
                        	   211: ; 		OUT		(SIO_A_C),A
                        	   212: ; WRDONE_11A:
                        	   213: ; 		POP		AF					;RESTORE AF
                        	   214: ; 		EI
                        	   215: ; 		RETI
                        	   216: ; 			;EXTERNAL/STATUS CHANGED INTERRUPT HANDLER
                        	   217: ; EXHDLR_11A:
                        	   218: ; 		PUSH	AF
                        	   219: ; 		LD		A,00010000B			;RESET STATUS INTERRUPT
                        	   220: ; 		OUT		(SIO_A_C),A
                        	   221: ; 		EI							;DCD OR CTS CHANGED STATE, OR A BREAK
                        	   222: 
                        	   223: ; 		POP		AF					; WAS DETECTED
                        	   224: ; 		RETI						; SERVICE HERE IF NECESSARY
                        	   225: ; 			;SPECIAL RECEIVE ERROR INTERRUPT
                        	   226: ; REHDLR_11A:
                        	   227: ; 		PUSH	AF
                        	   228: ; 		LD		A,00110000B			;RESET RECEIVE ERROR INTERRUPT
                        	   229: ; 		OUT		(SIO_A_C),A
                        	   230: ; 		EI							; FRAMING ERROR OR OVERRUN ERROR
                        	   231: ; 		POP		AF					; OCCURRED
                        	   232: ; 		RETI						; SERVICE HERE IF NECESSARY
                        	   233: 
                        	   234: ; 		;*************************************
                        	   235: ; 		; ROUTINE: OUTDAT
                        	   236: ; 		;PURPOSE: SEND CHARACTER TO SIO_0
                        	   237: ; 		;ENTRY: TRNDAT = CHARACTER
                        	   238: ; 		;EXIT: NONE
                        	   239: ; 		;REGISTERS USED: AF
                        	   240: ; 		;***************************************
                        	   241: ; OUTDAT_11A:
                        	   242: ; 		LD		A,(TRNDAT)			; GET DATA FROM OUTPUT BUFFER
                        	   243: ; 		OUT		(SIO_A_D),A			; SEND DATA TO SIO_0
                        	   244: ; 		SUB		A					; INDICATE OUTPUT BUFFER EMPTY
                        	   245: ; 		LD		(TRNDF),A
                        	   246: ; 		DEC		A					; INDICATE OUTPUT INTERRUPT EXPECTED
                        	   247: ; 		LD		(OutINTExpect),A				; OlE = FF HEX
                        	   248: ; 		RET
                        	   249: 		
                        	   250: ; 		;**************************************
                        	   251: ; 		;ROUTINE: IPORTS
                        	   252: ; 		;PURPOSE: INITIALIZE 1/0 PORTS
                        	   253: ; 		;ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
                        	   254: ; 		;EXIT: DATA OUTPUT TO PORTS
                        	   255: ; 		;REGISTERS USED: AF.BC.HL
                        	   256: ; 		;************************************
                        	   257: 
                        	   258: ; IPORTS_11A:
                        	   259: ; 			;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
                        	   260: ; 			;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
                        	   261: ; 		LD		A,(HL)				;GET NUMBER OF BYTES
                        	   262: ; 		OR		A					;TEST FOR ZERO (TERMINATOR)
                        	   263: ; 		RET		Z					;RETURN IF NUMBER OF BYTES = 0
                        	   264: ; 		LD		B,A
                        	   265: ; 		INC		HL					;POINT TO PORT ADDRESS (NEXT BYTE)
                        	   266: ; 			;C = PORT ADDRESS
                        	   267: ; 			;HL = BASE ADDRESS OF OUTPUT DATA
                        	   268: ; 		LD      C,(HL)				;GET PORT ADDRESS
                        	   269: ; 		INC     HL					;POINT TO FIRST DATA VALUE (NEXT BYTE)
                        	   270: ; 			;OUTPUT DATA AND CONTINUE TO NEXT PORT
                        	   271: ; 		OTIR						;SEND DATA VALUES TO PORT
                        	   272: ; 		JR      IPORTS_11A				;CONTINUE TO NEXT PORT ENTRY
                        	   273: ; 			;SIO_0 INITIALIZATION DATA
                        	   274: ; SIO_0INT_11A:
                        	   275: ; 			;RESET CHANNEL A
                        	   276: ; 		DB		1					;OUTPUT 1 BYTE
                        	   277: ; 		DB		SIO_A_C				;DESTINATION IS CHANNEL A COMMAND/STATUS
                        	   278: ; 		DB		00011000B			;SELECT WRITE REGISTER 0
                        	   279: ; 									;BITS 2,1,0 = 0 (WRITE REGISTER 0)
                        	   280: ; 									;BITS 5.4.3 = 011 (CHANNEL RESET)
                        	   281: ; 									;BITS 7,6 = 0 (DO NOT CARE)
                        	   282: ; 			;SET INTERRUPT VECTOR AND ALLOW STATUS TO AFFECT IT
                        	   283: ; 		DB		4					;OUTPUT 2 BYTES
                        	   284: ; 		DB		SIO_B_C				;DESTINATION IS COMMAND REGISTER B
                        	   285: ; 		DB		00000010B			; SELECT WRITE REGISTER 2
                        	   286: ; 		DB		SIO_Int_Vec&0FFH			;SET INTERRUPT VECTOR FOR SIO_0
                        	   287: ; 		DB		00000001B			;SELECT WRITE REGISTER 1
                        	   288: ; 		DB		00000100B			;ALLOW STATUS TO AFFECT VECTOR
                        	   289: ; 			; INITIALIZE CHANNEL A
                        	   290: ; 		DB		8					;OUTPUT 8 BYTES
                        	   291: ; 		DB		SIO_A_C				;DESTINATION IS COMMAND REGISTER A
                        	   292: ; 			; INITIALIZE BAUD RATE CONTROL
                        	   293: ; 		DB		00010100B			;SELECT WRITE REGISTER 4
                        	   294: ; 									; RESET EXTERNAL/STATUS INTERRUPT
                        	   295: ; 		DB		01001000B			;BIT 0 = 0 (NO PARITY)
                        	   296: ; 									;BIT 1 = 0 (DON'T CARE)
                        	   297: ; 									;BITS 3.2 = 10 (1 1/2 STOP BITS)
                        	   298: ; 									;BITS 5,4 = 00 <nOWT CARE)
                        	   299: ; 									;BITS 7,6 = 01 (16 TIMES CLOCK)
                        	   300: ; 			;INITIALIZE RECEIVE CONTROL
                        	   301: ; 		DB		00000011B			;SELECT WRITE REGISTER 3
                        	   302: ; 		DB		11000001B			;BIT 0 = 1 (RECEIVE ENABLE)
                        	   303: ; 									; BITS 4,3,2,1 = 0 (DON"T CARE)
                        	   304: ; 									;BIT 5 = 0 (NO AUTO ENABLE)
                        	   305: ; 									;BIT 7,6 = 11 (RECEIVE 8 BITS/CHAR)
                        	   306: ; 			; INITIALIZE TRANSMIT CONTROL
                        	   307: ; 		DB		00000101B			;SELECT WRITE REGISTER 5
                        	   308: ; 		DB		11101010B			;BIT 0 = 0 (NO CRC ON TRANSMIT)
                        	   309: ; 									;BIT 1 = 1 (REQUEST TO SEND)
                        	   310: ; 									;BIT 2 = 0 (DON'T CARE)
                        	   311: ; 									;BIT 3 = 1 (TRANSMIT ENABLE)
                        	   312: ; 									;BIT 4 = 0 (DO NOT SEND BREAK)
                        	   313: ; 									;BITS 6,5 = 11 (TRANSMIT 8 BITS/CHAR)
                        	   314: ; 									;BIT 7 = 1 (DATA TERMINAL READY)
                        	   315: ; 		DB		00000001B			;SELECT WRITE REGISTER 1
                        	   316: ; 		DB		00011011B			;BIT 0 = 1 (EXTERNAL INTERRUPTS)
                        	   317: ; 									;BIT 1 = 1 (ENABLE TRANSMIT INTERRUPT)
                        	   318: ; 									;IBIT 2 = 0 (DO NOT CARE)
                        	   319: ; 									;BITS 4,3 = 11 (RECEIVE INTERRUPTS ON
                        	   320: ; 									; ALL CHARS, PARITY DOES NOT AFFECT
                        	   321: ; 									; VECTOR)
                        	   322: ; 									;BITS 7,6,5 = 000 (NO WAIT/READY
                        	   323: ; 									; FUNCTION)
                        	   324: 
                        	   325: ; 		DB	0						;TERMINATOR FOR INITIALIZATION ARRAY
                        	   326: ; 		; DATA SECTION
                        	   327: ; RECDAT:	DS		1					;RECEIVE DATA
                        	   328: ; RECDF: 	DS		1					;RECEIVE DATA FLAG
                        	   329: ; 									; (0 = NO DATA. FF = DATA AVAILABLE)
                        	   330: ; TRNDAT: DS		1					; TRANSMIT DATA
                        	   331: ; TRNDF: 	DS		1					;TRANSMIT DATA FLAG
                        	   332: ; 									; (0 = BUFFER EMPTY. FF = BUFFER FULL)
                        	   333: ; OutINTExpect:	DS		1					;OUTPUT INTERRUPT EXPECTED
                        	   334: ; 									; (0 = NO INTERRUPT EXPECTED,
                        	   335: ; 									; FF = INTERRUPT EXPECTED)
                        	   336: 
                        	   337: 
                        	   338: 
                        	   339: ; 		; SAMPLE EXECUTION:
                        	   340: 
                        	   341: 
                        	   342: ; 		;CHARACTER EQUATES
                        	   343: ; ESCAPE		EQU		1BH                ;ASCII ESCAPE CHARACTER
                        	   344: ; TESTCH		EQU		'A'             ;TEST CHARACTER = A
                        	   345: ; SC11A:
                        	   346: ; 		CALL	INIT_11A            ; INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   347: ; 			;SIMPLE EXAMPLE - READ AND ECHO CHARACTERS
                        	   348: ; 			;UNTIL AN ESC IS RECEIVED
                        	   349: ; LOOP_11A:
                        	   350: ; 		CALL	INCH_11A			; READ CHARACTER
                        	   351: ; 		PUSH	AF
                        	   352: ; 		CALL	OUTCH_11A			; ECHO CHARACTER
                        	   353: ; 		POP		AF
                        	   354: ; 		CP		ESCAPE			;IS CHARACTER AN ESCAPE?
                        	   355: ; 		JR		NZ,LOOP_11A			;STAY IN LOOP IF NOT
                        	   356: ; 			;AN ASYNCHRONOUS EXAMPLE
                        	   357: ; 			; OUTPUT "An TO CONSOLE CONTINUOUSLY. BUT ALSO LOOK AT
                        	   358: ; 			; INPUT SIDE. READING AND ECHOING ANY INPUT CHARACTERS
                        	   359: ; ASYNLP_11A:
                        	   360: ; 			;OUTPUT    AN "A" IF OUTPUT IS NOT BUSY
                        	   361: ; 		CALL	OUTST_11A			;IS OUTPUT BUSY?
                        	   362: ; 		JR		C,ASYNLP_11A        ;JUMP IF IT IS
                        	   363: ; 		LD		A,TESTCH
                        	   364: ; 		CALL	OUTCH_11A			;OUTPUT TEST CHARACTER
                        	   365: ; 			; CHECK INPUT PORT
                        	   366: ; 			; ECHO CHARACTER IF ONE IS AVAILABLE
                        	   367: ; 			; EXIT ON ESCAPE CHARACTER
                        	   368: ; 		CALL	INST_11A			; IS INPUT DATA AVAILABLE?
                        	   369: ; 		JR		NC,ASYNLP_11A		;JUMP IF NOT (SEND ANOTHER "A")
                        	   370: ; 		CALL	INCH_11A			;GET CHARACTER
                        	   371: ; 		CP		ESCAPE			;IS IT AN ESCAPE?
                        	   372: ; 		JR		Z,DONE_11A			;BRANCH IF IT IS
                        	   373: ; 		CALL	OUTCH_11A			;ELSE ECHO CHARACTER
                        	   374: ; 		JP		ASYNLP_11A			;AND CONTINUE
                        	   375: ; DONE_11A:
                        	   376: ; 		JP     LOOP_11A
                        	   377: 
                        	   378: 
                        	   379: 
                        	   380: ;**********************************************************************************************************************
                        	   381: ;**********************************************************************************************************************
                        	   382: 		; Unbuffered Input/Output
                        	   383: 		; 													5. INIT: none
                        	   384: 		; 		Title                Simple interrupt input and output usinQ a                zao
                        	   385: 		; 							PIa and single character buffers
                        	   386: 		; 		Name:                PINTIO
                        	   387: 		; 	Purpose:        This program consists of 5 subroutines which
                        	   388: 		; 					perform interrupt driven input and output using
                        	   389: 		; 					a Z80 PIO.
                        	   390: 		; 					INCH
                        	   391: 		; 						Read a character
                        	   392: 		; 					INST
                        	   393: 		; 						Determine input status (whether input
                        	   394: 		; 						buffer is empty)
                        	   395: 		; 					OUTCH
                        	   396: 		; 						Write a character
                        	   397: 		; 					OUTST
                        	   398: 		; 						Determine output status (whether output
                        	   399: 		; 						buffer is full)
                        	   400: 		; 					INIT
                        	   401: 		; 						Initialize PIO and interrupt system
                        	   402: 		; 	Entry:          INCH
                        	   403: 		; 						No parameters
                        	   404: 		; 					INST
                        	   405: 		; 						No parameters
                        	   406: 		; 					OUTCH
                        	   407: 		; 						Register A = character to transmit
                        	   408: 		; 					OUTST
                        	   409: 		; 						No parameters
                        	   410: 		; 					INIT
                        	   411: 		; 						No parameters
                        	   412: 		; 	Exit :          INCH
                        	   413: 		; 						Register A = character
                        	   414: 		; 					INST
                        	   415: 		; 						Carry = 0 if input buffer is empty,
                        	   416: 		; 						1 if character is available
                        	   417: 		; 					OUTCH
                        	   418: 		; 						No parameters
                        	   419: 		; 					OUTST
                        	   420: 		; 						Carry = 0 if output buffer is not
                        	   421: 		; 						full, 1 if it is full
                        	   422: 		; 					INIT
                        	   423: 		; 						No parameters
                        	   424: 		; 	Registers used: INCH
                        	   425: 		; 						A.F
                        	   426: 		; 					INST
                        	   427: 		; 						A,F
                        	   428: 		; 					OUTCH
                        	   429: 		; 						A,F
                        	   430: 		; 					OUTST
                        	   431: 		; 						A,F
                        	   432: 		; 					INIT
                        	   433: 		; 						A,F,eC,HL,I
                        	   434: 		; 		Time:               INCH
                        	   435: 		; 							72 cycles if a character is available
                        	   436: 		; 							INST
                        	   437: 		; 							27 cycles
                        	   438: 		; 							OUTCH
                        	   439: 		; 							150 cycles if output buffer is not full
                        	   440: 		; 								and output interrupt is expected
                        	   441: 		; 							OUTST
                        	   442: 		; 							27 cycles
                        	   443: 		; 							INIT
                        	   444: 		; 							377 cycles
                        	   445: 		; 							RDHDLR
                        	   446: 		; 							82 cycles
                        	   447: 		; 							WRHDLR
                        	   448: 		; 							178 cycles
                        	   449: 		; 		Size:               Program 166 bytes
                        	   450: 		; 							Data      5 bytes
                        	   451: 		; 		;PIO EQUATES
                        	   452: 		; 		; PIO IS PROGRAMMED FOR:
                        	   453: 		; 			PORT A INPUT
                        	   454: 		; 			PORT B OUTPUT
                        	   455: 		; 		;ARBITRARY PIO PORT ADDRESSES
                        	   456: ;**********************************************************************************************************************
                        	   457: ;**********************************************************************************************************************
                        	   458: 
                        	   459: 
                        	   460: ; PIOAD    EQU      90H             ;PORT A DATA
                        	   461: ; PIOAC    EQU      91H             ;PORT A CONTROL
                        	   462: ; PIOBD    EQU      92H             ;PORT B DATA
                        	   463: ; PIOBC    EQU      93H             :PORT B CONTROL
                        	   464: ; INTRPV   EQU      8000H           ;BASE OF INTERRUPT VECTORS
                        	   465: ; PIOIVA   EQU      INTRPV          ; INTERRUPT VECTOR FOR PORT A
                        	   466: ; PI0IVB   EQU      INTRPV+2        ; INTERRUPT VECTOR FOR PORT B
                        	   467: ; 		:READ CHARACTER
                        	   468: ; INCH:
                        	   469: ; 		CALL      INST              ~GET INPUT STATUS
                        	   470: ; 		JR        NC,INCH           ;WAIT IF NO CHARACTER AVAILABLE
                        	   471: ; 		Dl                          ;DISABLE INTERRUPTS
                        	   472: ; 		SUB       A
                        	   473: ; 		LD        (RECDF),A         ;INDICATE INPUT BUFFER EMPTY
                        	   474: ; 		LD        A. (RECDAT)       :OET CHARACTER FROM INPUT BUFFER
                        	   475: ; 		El                          ;REENABLE INTERRUPTS
                        	   476: ; 		RET
                        	   477: ; 		~RETURN   INPUT STATUS (CARRY    =1   IF INPUT DATA IS AVAILABLE)
                        	   478: ; INST:
                        	   479: ; 		LD        A, (RECDF)        ;GET DATA READY FLAG
                        	   480: ; 		RRA                         ;SET CARRY FROM DATA READY FLAG
                        	   481: ; 									: IF CARRY = 1, CHARACTER IS AVAILABLE
                        	   482: ; 		RET
                        	   483: ; 		; WRITE CHARACTER
                        	   484: ; OUTCH:
                        	   485: ; 		PUSH      AF                :SAVE CHARACTER TO WRITE
                        	   486: 
                        	   487: 
                        	   488: ; 		;WAIT FOR CHARACTER BUFFER TO EMPTY, THEN STORE NEXT CHARACTER
                        	   489: ; WAITOC:
                        	   490: ; 		CALL        OUTST           ;GET OUTPUT STATUS
                        	   491: ; 		JR          C, WAITOC       ;WAIT IF OUTPUT BUFFER IS FULL
                        	   492: ; 		01                          :DISABLE INTERRUPTS WHILE LOOKING AT
                        	   493: ; 									~ SOFTWARE FLAGS
                        	   494: ; 		POP         AF              :GET CHARACTER
                        	   495: ; 		LD          <TRNDAT> .A     :STORE CHARACTER IN OUTPUT BUFFER
                        	   496: ; 		LD          A.OFFH          : INDICATE OUTPUT BUFFER FULL
                        	   497: ; 		LD          <TRNDF)'A
                        	   498: ; 		LD          A,(OutINTExpect)         :TEST OUTPUT INTERRUPT EXPECTED FLAG
                        	   499: ; 		OR          A
                        	   500: ; 		CALL        Z.OUTDAT        :OUTPUT CHARACTER IMMEDIATELY IF
                        	   501: ; 									: NO OUTPUT INTERRUPT EXPECTED
                        	   502: ; 		EI                          :ENABLE INTERRUPTS
                        	   503: ; 		RET
                        	   504: ; 		,OUTPUT STATUS (CARRY = 1 IF OUTPUT BUFFER IS FULL)
                        	   505: ; OUTST:
                        	   506: ; 		LD          A. <TRNDF)      ;GET TRANSMIT FLAG
                        	   507: ; 		RRA                         ~SET CARRY FROM TRANSMIT FLAG
                        	   508: ; 		RET                         ; CARRY = 1 IF OUTPUT BUFFER FULL
                        	   509: ; 		: INITIALIZE PIO AND INTERRUPT SYSTEM
                        	   510: ; INIT:
                        	   511: ; 		DI                          :DISABLE INTERRUPTS
                        	   512: ; 		;INITIALIZE SOFTWARE FLAGS
                        	   513: ; 		SUB     A
                        	   514: ; 		LD      (RECDF>.A       ;NO INPUT DATA AVAILABLE
                        	   515: ; 		LD      (TRNDF>.A       :OUTPUT BUFFER EMPTY
                        	   516: ; 		LD      (OutINTExpect>.A         :NO OUTPUT INTERRUPT EXPECTED
                        	   517: ; 								: DEVICE IS READY INITIALLY
                        	   518: ; 		~INITIALIZE      INTERRUPT VECTORS
                        	   519: ; 		LD          A.INTRPV SHR 8 :GET HIGH BYTE OF INTERRUPT PAGE
                        	   520: ; 		LD          I.A              ;SET INTERRUPT VECTOR IN zao
                        	   521: ; 		1M          2                ; INTERRUPT MODE 2 - VECTORS IN TABLE
                        	   522: ; 									~ ON INTERRUPT PAGE
                        	   523: ; 		LD          HL.RDHDLR        ,STORE READ VECTOR (INPUT INTERRUPT)
                        	   524: ; 		LD          (PIOIVA).HL
                        	   525: ; 		LD          HL.WRHDLR        ,STORE WRITE VECTOR (OUTPUT INTERRUPT)
                        	   526: ; 		LD          (PIOIVB).HL
                        	   527: ; 		,INITIALIZE PIO
                        	   528: ; 		LD      HL.PIOINT           :BASE ADDRESS OF INITIALIZATION ARRAY
                        	   529: ; 		CALL    IPORTS              ; INITIALIZE PIO
                        	   530: ; 		EI                          , ENABLE INTERRUPTS
                        	   531: ; 		RET
                        	   532: ; 		;INPUT (READ) INTERRUPT HANDLER
                        	   533: ; RDHDLR:
                        	   534: ; 		PUSH        AF
                        	   535: ; 		IN          A.(PIOAD)       :READ DATA FROM PIO
                        	   536: ; 		LD          (RECDAT> .A     ,SAVE DATA IN INPUT BUFFER
                        	   537: ; 		LD     A,OFFH           ;INDICATE INPUT DATA AVAILABLE
                        	   538: ; 		LD     (RECDF),A
                        	   539: ; 		POP    AF
                        	   540: ; 		EI                      ;REENABLE INTERRUPTS
                        	   541: ; 		RETI
                        	   542: ; 		;OUTPUT (WRITE) INTERRUPT HANDLER
                        	   543: ; WRHDLR:
                        	   544: ; 		PUSH    AF
                        	   545: ; 		LD      A, <TRNDF)      ;GET DATA AVAILABLE FLAG
                        	   546: ; 		RRA
                        	   547: ; 		JR     NC,NODATA        ;JUMP IF NO DATA TO TRANSMIT
                        	   548: ; 		CALL   OUTDAT           ;OUTPUT DATA TO PIO
                        	   549: ; 		JR     WRDONE
                        	   550: ; 		;IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE,
                        	   551: ; 			WE MUST DISABLE IT TO AVOID AN ENDLESS LOOP. LATER, WHEN A
                        	   552: ; 			CHARACTER BECOMES AVAILABLE. WE NEED TO KNOW THAT AN OUTPUT
                        	   553: ; 			INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED. THE KEY HERE
                        	   554: ; 		; IS THE OUTPUT INTERRUPT EXPECTED FLAG OlE. THIS FLAG IS
                        	   555: ; 			CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT
                        	   556: ; 			BEEN SERVICED. IT IS ALSO CLEARED INITIALLY SINCE THE
                        	   557: ; 			OUTPUT DEVICE IS ASSUMED TO START OUT READY. OlE IS SET
                        	   558: ; 		, WHENEVER DATA IS ACTUALLY SENT TO THE PIO. THUS THE OUTPUT ROUTINE
                        	   559: ; 			OUTCH CAN CHECK OlE TO DETERMINE WHETHER TO SEND THE DATA
                        	   560: ; 		; IMMEDIATELY OR WAIT FOR AN OUTPUT INTERRUPT.
                        	   561: ; 		;THE PROBLEM IS THAT AN OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
                        	   562: ; 			THE COMPUTER HAS ANYTHING TO SEND (UNLIKE AN INPUT DEVICE
                        	   563: ; 			THAT HAS DATA WHEN IT REQUESTS SERVICE). THE OlE FLAG SOLVES
                        	   564: ; 		, THE PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING ITSELF
                        	   565: ; 			REPEATEDLY, WHILE STILL ENSURING THE RECOGNITION OF
                        	   566: ; 			OUTPUT INTERRUPTS.
                        	   567: ; NODATA:
                        	   568: ; 		SUB     A
                        	   569: ; 		LD      (OlE) .A        ; INDICATE NO OUTPUT INTERRUPT EXPECTED
                        	   570: ; 		LD      A.OOOOOOllB     ,DISABLE OUTPUT INTERRUPTS
                        	   571: ; 		OUT     (PIOBC).A
                        	   572: ; WRDONE:
                        	   573: ; 		POP     AF              ;RESTORE REGISTERS
                        	   574: ; 		EI
                        	   575: ; 		RETI
                        	   576: 
                        	   577: ; 		'*************************************
                        	   578: ; 		; ROUTINE: OUTDAT
                        	   579: ; 		; PURPOSE: SEND CHARACTER TO PIO PORT B
                        	   580: ; 		; ENTRY: TRNDAT = CHARACTER
                        	   581: ; 		,EXIT: NONE
                        	   582: ; 		;REGISTERS USED: AF
                        	   583: ; 		;***************************************
                        	   584: ; OUTDAT:
                        	   585: ; 		LD      A. <TRNDAT>     ;GET DATA FROM OUTPUT BUFFER
                        	   586: ; 		OUT     (PIOBD).A       ,SEND DATA TO PIO
                        	   587: ; 		SUB     A               ; INDICATE OUTPUT BUFFER EMPTY
                        	   588: 
                        	   589: 
                        	   590: ; 		LD       (TRNDF),A
                        	   591: ; 		DEC      A                 ;INDICATE OUTPUT INTERRUPT EXPECTED
                        	   592: ; 		LD       (OutINTExpect),A           ; OlE = FF HEX
                        	   593: ; 		LD       A,10000011B       ;ENABLE OUTPUT INTERRUPTS
                        	   594: ; 		OUT      (PIOBC).A
                        	   595: ; 		RET
                        	   596: ; 		;**************************************
                        	   597: ; 		; ROUTINE: IPORTS
                        	   598: ; 		; PURPOSE: INITIALIZE I/O PORTS
                        	   599: ; 		; ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
                        	   600: ; 		:EXIT: DATA OUTPUT TO PORTS
                        	   601: ; 		;REGISTERS USED: AF,BC,HL
                        	   602: ; 		;************************************
                        	   603: ; IPORTS:
                        	   604: ; 		;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
                        	   605: ; 		;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
                        	   606: ; 		LD      A, (HL)          ; GET NUMBER OF BYTES
                        	   607: ; 		OR      A               ;TEST FOR ZERO (TERMINATOR)
                        	   608: ; 		RET     Z               :RETURN IF NUMBER OF BYTES = 0
                        	   609: ; 		LD      B,A
                        	   610: ; 		INC     HL              ;POINT TO PORT ADDRESS (NEXT BYTE)
                        	   611: ; 		:C = PORT ADDRESS
                        	   612: ; 		;HL = BASE ADDRESS OF OUTPUT DATA
                        	   613: ; 		LD      C.(HL)          :GET PORT ADDRESS
                        	   614: ; 		INC     HL              ;POINT TO FIRST DATA VALUE (NEXT BYTE)
                        	   615: ; 		;OUTPUT DATA AND CONTINUE TO NEXT PORT
                        	   616: ; 		OTIR                    ;SEND DATA VALUES TO PORT
                        	   617: ; 		JR      IPORTS          tCONTINUE TO NEXT PORT ENTRY
                        	   618: ; 		;PIO INITIALIZATION DATA
                        	   619: ; 		t PORT A = INPUT
                        	   620: ; 		; PORT B = OUTPUT
                        	   621: ; PIOINT:
                        	   622: ; 		DB       3               ;OUTPUT 3 BYTES
                        	   623: ; 		DB       PIOAC           tDESTINATION IS PORT A CONTROL
                        	   624: ; 		DB       PIOIVA AND OFFH ;SET INTERRUPT VECTOR FOR PORT A
                        	   625: ; 		DB       10001111B       ;BITS 3,2,1,0 = 1111 (MODE SELECT)
                        	   626: ; 								; BITS 5,4 = 00 (DON"T CARE)
                        	   627: ; 								;BITS 7,6 = 01 (INPUT MODE)
                        	   628: ; 		DB       10000111B       ;BITS 3.2.1.0 = 0111 (INTERRUPT CONTROL)
                        	   629: ; 								:BITS 6.5.4 = 000 (DON'T CARE)
                        	   630: ; 								;BITS 7 = 1 (ENABLE INTERRUPTS)
                        	   631: ; 		DB       3               :OUTPUT 3 BYTES
                        	   632: ; 		DB       PIOBC           tDESTINATION IS PORT B CONTROL
                        	   633: ; 		DB       PIOIVB AND OFFH ;SET INTERRUPT VECTOR FOR PORT B
                        	   634: ; 		DB       11001111B       ;BITS 3,2,1,0 = 1111 (MODE SELECT)
                        	   635: ; 								;BITS 5,4 = 00 (DON'T CARE)
                        	   636: ; 								;BITS 7.6 = 00 (CONTROL MODE)
                        	   637: ; 		DB       00000111B       :BITS 3.2.1.0 = 0111 (INTERRUPT CONTROL)
                        	   638: ; 								:BIT 4,5,6 = 000 (DON'T CARE)
                        	   639: ; 								;BITS 7 = 0 (DISABLE INTERRUPTS)
                        	   640: 
                        	   641: ; 		DB        0               ;TERMINATOR FOR INITIALIZATION ARRAY
                        	   642: ; 		; DATA SECTION
                        	   643: ; RECDAT: DS       1                  ;RECEIVE DATA
                        	   644: ; RECDF: DS        1                  ;RECEIVE DATA FLAG
                        	   645: ; 									; (0 = NO DATA. FF      = DATA)
                        	   646: ; TRNDAT: DS          1               ;TRANSMIT DATA
                        	   647: ; TRNDF: DS           1               ;TRANSMIT DATA FLAG
                        	   648: ; 									; (0 = BUFFER EMPTY. FF = BUFFER FULL)
                        	   649: ; OlE:      DS        1               ;OUTPUT INTERRUPT EXPECTED
                        	   650: ; 									; (0 = NO INTERRUPT EXPECTED,
                        	   651: ; 									; FF = INTERRUPT EXPECTED)
                        	   652: 
                        	   653: 
                        	   654: 
                        	   655: ; 		SAMPLE EXECUTION:
                        	   656: 
                        	   657: 
                        	   658: ; 		;CHARACTER EQUATES
                        	   659: ; ESCAPE    EQU     1BH               ; ASCI I ESCAPE CHARACTER
                        	   660: ; TESTCH    EQU     ~A~               ;TEST CHARACTER = A
                        	   661: ; SCllB:
                        	   662: ; 		CALL      INIT            ; INITIALIZE PIO, INTERRUPT SYSTEM
                        	   663: ; 		;SIMPLE EXAMPLE - READ AND ECHO CHARACTERS
                        	   664: ; 		: UNTIL AN ESC IS RECEIVED
                        	   665: ; LOOP:
                        	   666: ; 		CALL      INCH            ;READ CHARACTER
                        	   667: ; 		PUSH      AF
                        	   668: ; 		CALL      OUTCH           ;ECHO CHARACTER
                        	   669: ; 		POP       AF
                        	   670: ; 		CP        ESCAPE          ;IS CHARACTER AN ESCAPE?
                        	   671: ; 		.JR      NZ,LOOP         ;STAY IN LOOP IF NOT
                        	   672: ; 		;AN ASYNCHRONOUS EXAMPLE
                        	   673: ; 		; OUTPUT "A" TO CONSOLE CONTINUOUSLY. BUT ALSO LOOK AT
                        	   674: ; 		; INPUT SIDE, READING AND ECHOING ANY INPUT CHARACTERS
                        	   675: ; ASYNLP:
                        	   676: ; 		;OUTPUT   AN "A" IF OUTPUT IS NOT BUSY
                        	   677: ; 		CALL      OUTST           ;IS OUTPUT BUSY?
                        	   678: ; 		JR        C,ASYNLP        ;JUMP IF IT IS
                        	   679: ; 		LD        A,TESTCH
                        	   680: ; 		CALL      OUTCH           ;OUTPUT TEST CHARACTER
                        	   681: ; 		;CHECK INPUT PORT
                        	   682: ; 		;ECHO CHARACTER IF ONE IS AVAILABLE
                        	   683: ; 		,EXIT ON ESCAPE CHARACTER
                        	   684: ; 		CALL    INST            ;IS INPUT DATA AVAILABLE?
                        	   685: ; 		JR      NC.ASYNLP       ;JUMP IF NOT (SEND ANOTHER "A")
                        	   686: ; 		CALL    INCH            ;GET THE CHARACTER
                        	   687: ; 		CP      ESCAPE          ;IS IT AN ESCAPE CHARACTER?
                        	   688: 
                        	   689: 
                        	   690: ; 		JR       Z.ASDONE   I JUMP IF IT IS
                        	   691: ; 		CALL     OUTCH      ;ELSE ECHO CHARACTER
                        	   692: ; 		JP       ASVNLP     ;AND CONTINUE
                        	   693: ; ASDONE:
                        	   694: ; 		JP       LOOP
                        	   695: 
                        	   696: 
                        	   697: 
                        	   698: 
                        	   699: 
                        	   700: ;****************************************************************************************************************
                        	   701: 		; Buffered Input/Output
                        	   702: 		; Using an SIO_0 (SINTB)                                                                                    11C
                        	   703: 		; 		Title              Interrupt input and output using a ZSO SIO_0 and
                        	   704: 		; 						multiple-character buffers
                        	   705: 		; 		Name:              SINTB
                        	   706: 		; 		Purpose:           This program consists of 5 subroutines which
                        	   707: 		; 						perform interrupt driven input and output using
                        	   708: 		; 						a ZSO SIO_0.
                        	   709: 		; 						ReadChar
                        	   710: 		; 							Read a character
                        	   711: 		; 						RetInpStatus
                        	   712: 		; 							Determine input status (whether input
                        	   713: 		; 							buffer is empty)
                        	   714: 		; 						WriteChar
                        	   715: 		; 							Write a character
                        	   716: 		; 						RetOutStatus
                        	   717: 		; 							Determine output status (whether output
                        	   718: 		; 							buffer is full)
                        	   719: 		; 						InitBuffers
                        	   720: 		; 							Initialize SIO_0 and interrupt system
                        	   721: 		; 		Entry:             ReadChar
                        	   722: 		; 							No parameters
                        	   723: 		; 						RetInpStatus
                        	   724: 		; 							No pat'ameters
                        	   725: 		; 						WriteChar
                        	   726: 		; 							Register A = character to transmit
                        	   727: 		; 						RetOutStatus
                        	   728: 		; 							No parameters
                        	   729: 		; 						InitBuffers
                        	   730: 		; 							No parameters
                        	   731: 		; 		Exit :          ReadChar(INCH)
                        	   732: 		; 							Register A = character
                        	   733: 		; 						RetInpStatus(INST)
                        	   734: 		; 							Carry = 0 if input buffer is empty,
                        	   735: 		; 							1 if character is available
                        	   736: 		; 						WriteChar(OUTCH)
                        	   737: 		; 							No parameters
                        	   738: 		; 						OUTST
                        	   739: 		; 							Carry = 0 if output buffer is not
                        	   740: 		; 							full. 1 if it is full
                        	   741: 		; 						InitBuffers
                        	   742: 		; 							No parameters
                        	   743: 		; 		Reqisters used: ReadChar
                        	   744: 		; 							AF,C,DE,HL
                        	   745: 		; 						RetInpStatus
                        	   746: 		; 							AF
                        	   747: 		; 						WriteChar
                        	   748: 		; 							AF,DE,HL
                        	   749: 		; 						RetOutStatus
                        	   750: 		; 							AF
                        	   751: 		; 						InitBuffers
                        	   752: 		; 							AF,BC,HL,I
                        	   753: 		; 		Time:           ReadChar
                        	   754: 		; 							Approximately 197 cycles if a character is
                        	   755: 		; 							available
                        	   756: 		; 						RetInpStatus
                        	   757: 		; 							39 cycles
                        	   758: 		; 						WriteChar
                        	   759: 		; 							Approximately 240 cycles if output buffer
                        	   760: 		; 							is not full and output interrupt is expected
                        	   761: 		; 						RetOutStatus
                        	   762: 		; 							34 cycles
                        	   763: 		; 						InitBuffers
                        	   764: 		; 							732 cycles
                        	   765: 		; 						ReadINTHandler
                        	   766: 		; 							Approximately 249 cycles
                        	   767: 		; 						WriteINTHandler
                        	   768: 		; 							Approximately 308 cycles
                        	   769: 		; 		Size:           Program 299 bytes
                        	   770: 		; 						Data     11 bytes plus size of buffers
                        	   771: 		; 		:SIO_0 EQUATES
                        	   772: 		; 			SIO_0 IS PROGRAMMED FOR:
                        	   773: 		; 			ASYNCHRONOUS OPERATION
                        	   774: 		; 			16 X BAUD RATE
                        	   775: 		; 			8-BIT CHARACTERS
                        	   776: 		; 		; 1 1/2 STOP BITS
                        	   777: ;****************************************************************************************************************
                        	   778: ;****************************************************************************************************************
                        	   779: ;****************************************************************************************************************
                        	   780: ;****************************************************************************************************************
                        	   781: ;****************************************************************************************************************
                        	   782: 
                        	   783: 		; Section IOLIB
                        	   784: 
                        	   785: 
                        	   786: 		GLOBAL 	InitBuffers,ReadChar,WriteChar, WriteLine, WriteLineCRNL, ReadLine, CRLF, puts_crlf,cleanInBuffer,cleanOutBuf
                        	   787: 		GLOBAL	S_head_tail, inBufferEnd, inBuffer, writeSTRBelow, writeSTRBelow_CRLF,waitForKey,RetInpStatus
                        	   788: 		GLOBAL	PIO_Init,CTC_Init,SIO_Init,InitInterrupt,CTC1_INT_OFF,initSIOBInterrupt
                        	   789: 		GLOBAL 	SIO_0INT,InitSIO_0Ports,ReadUSBHandler, purgeRXB, waitForFinishedPrintout, purgeRXA, purgeRXB,TX_NAK,TX_ACK,T
                        	   790: 		GLOBAL 	SIO_B_EI,SIO_B_RX_INTon,SIO_B_TXRX_INToff,SIO_B_EI,SIO_B_DI
                        	   791: 		GLOBAL 	SIO_A_EI,SIO_A_TXRX_INTon,SIO_A_TXRX_INToff,SIO_A_TX_INTon,SIO_A_RX_INTon,SIO_A_RTS_OFF,SIO_A_RTS_ON,SIO_A_DI
                        	   792: 
                        	   793: 
                        	   794: 			;ARBITRARY SIO_0 PORT ADDRESSES
                        	   795: 								; INTERRUPT VECTOR
                        	   796: 			;READ   CHARACTER
                        	   797: 		;*************************************
                        	   798: 		; ROUTINE: ReadLine
                        	   799: 		; PURPOSE: Read a line up to CR and store in (HL)
                        	   800: 		; ENTRY: HL = POINTER
                        	   801: 		;EXIT: HL = POINTER 
                        	   802: 		;      A = length of input string (Textbuf)
                        	   803: 		;REGISTERS USED: AF.DE.HL
                        	   804: 		;***************************************
                        	   805: 
                        	   806: waitForKey:
00:0000 3E0C            	   807: 		ld 		A,FF
00:0002 320000          	   808: 		ld 		(inbufferDeactivate),A
                        	   809: 
00:0005 76              	   810: 		halt		; wait for key interrupt
                        	   811: 
00:0006 3E00            	   812: 		ld 		A,00
00:0008 320000          	   813: 		ld 		(inbufferDeactivate),A
                        	   814: 
                        	   815: 
00:000B C9              	   816: 		ret
                        	   817: 
                        	   818: 
                        	   819: 
                        	   820: ReadLine:
                        	   821: R_LOOP:
00:000C CD5C00          	   822: 		call	ReadChar				;read character
00:000F F5              	   823: 		push	AF
00:0010 CDA900          	   824: 		call	WriteChar				;echo character
00:0013 F1              	   825: 		pop		AF
00:0014 FE0D            	   826: 		cp		CRChar					;is character an cr?
00:0016 20F4            	   827: 		jr		NZ,R_LOOP				;stay in loop if not
                        	   828: 
00:0018 CDA500          	   829: 		call	CRNL
                        	   830: 			; copy from inbuf to cursor buffer...
                        	   831: waitEntry:
00:001B CD7A00          	   832: 		call	S_head_tail			; save input heads and tails
                        	   833: 
                        	   834: 
00:001E 2A0000          	   835: 		ld		hl,(Comm_Ptr_list)
00:0021 ED5B0200        	   836: 		ld 		de,(Comm_Ptr_list+2)		; next item in list
00:0025 B7              	   837: 		or 		a				; clear carry
00:0026 ED52            	   838: 		SBC		hl,de 			; number of chars in string (in L)
00:0028 45              	   839: 		ld 		b,l				; store in B
                        	   840: 
                        	   841: 			; detect wraparound (hl)<(de)
00:0029 F23000          	   842: 		jp 		P,cont2			;positive result 	(hl)>(de)
00:002C 3E00            	   843: 		ld 		a,bufferSize 			; length of input buffer
00:002E 80              	   844: 		add		a,b
00:002F 47              	   845: 		ld		b,a				; correct count in B when wraparound
                        	   846: cont2:
00:0030 DD210000        	   847: 		ld	 	ix,Textbuf				; get address of text buffer
00:0034 DD7000          	   848: 		ld		(ix),B		; save length to start of str.
00:0037 DD23            	   849: 		inc 	ix			; resulting  string adr, skip byte with length
                        	   850: 
00:0039 2A0200          	   851: 		ld		hl,(Comm_Ptr_list+2)		; first string start
                        	   852: 
00:003C 110000          	   853: 		ld		DE,inBufferEnd
                        	   854: c_nextchar:
                        	   855: 			;	copy from inbuffer to Textbuf...
00:003F 7E              	   856: 		ld 		a,(hl)				; char from inbuffer
00:0040 DD7700          	   857: 		ld		(ix),a			; save char in textbuf
00:0043 23              	   858: 		inc		hl
00:0044 DD23            	   859: 		inc 	ix
                        	   860: 
                        	   861: 			; check if upper buffer adr 
00:0046 B7              	   862: 		or 		A		; clear carry
00:0047 E5              	   863: 		push 	hl	
00:0048 ED52            	   864: 		SBC		hl,de		; S and Z set  hl=de -> inBufferEnd encountered
00:004A E1              	   865: 		pop 	hl
00:004B 2003            	   866: 		jr 		NZ, cont1			; continue
                        	   867: 			; turnaround (HL) hl = inBuffer.	
00:004D 210000          	   868: 		ld 		hl,inBuffer			; hl = start of input buf
                        	   869: cont1:
00:0050 10ED            	   870: 		djnz 	c_nextchar		; count no chars.
00:0052 AF              	   871: 		xor 	a				; clear a
00:0053 DD7700          	   872: 		ld 		(ix),A			; end with 00H
00:0056 210000          	   873: 		ld		hl,Textbuf
00:0059 7E              	   874: 		ld		a,(hl)			; A = string length (num)
00:005A 23              	   875: 		inc		hl				; HL = addr to first char in string
00:005B C9              	   876: 		ret 					; string stored in textbuffer
                        	   877: 
                        	   878: ReadChar:
00:005C CD7300          	   879: 		CALL	RetInpStatus	;get input status. return. carry = 1 if data available
00:005F 30FB            	   880: 		JR		NC,ReadChar		;wait if no character available
00:0061 F3              	   881: 		DI                      ;disable interrupts
00:0062 210000          	   882: 		LD		HL,inBufCount			;reduce input buffer count by 1
00:0065 35              	   883: 		DEC		(HL)
00:0066 2A0000          	   884: 		LD		HL, (inHeadAdr)		;Get   character from head of input buffer
00:0069 4E              	   885: 		LD		C, (HL)
00:006A CDB302          	   886: 		CALL	incInPointer			;Move head pointer up 1
00:006D 220000          	   887: 		LD		(inHeadAdr) ,HL
00:0070 79              	   888: 		LD		A,C
00:0071 FB              	   889: 		EI						;Reenable interrupts
00:0072 C9              	   890: 		RET
                        	   891: 			;return input status (carry    =1   if input data is available)
                        	   892: RetInpStatus:
00:0073 3A0000          	   893: 		LD		A, (inBufCount)		;Test input buffer count
00:0076 B7              	   894: 		OR		A				;Clear carry always
00:0077 C8              	   895: 		RET		Z				; Return, carry = 0 if no data
00:0078 37              	   896: 		SCF                     ;Set carry
00:0079 C9              	   897: 		RET                     ; Return. carry = 1 if data available
                        	   898: 
                        	   899: 
                        	   900: 			; Save copies of inHeadAdr and inTailAdr to memory...
                        	   901: S_head_tail:
                        	   902: 
00:007A DD210200        	   903: 		ld 		ix,Comm_Ptr_list+2
00:007E 06FE            	   904: 		ld 		b,list_len-2
                        	   905: bmve:
00:0080 DD7E00          	   906: 		ld 		a,(ix)
00:0083 DD7702          	   907: 		ld 		(ix+2),A
00:0086 DD2B            	   908: 		dec		ix
00:0088 10F6            	   909: 		djnz 	bmve		; shift data upwards...
                        	   910: 
00:008A 2A0000          	   911: 		LD		HL, (inHeadAdr)		;GET   CHARACTER FROM HEAD OF INPUT BUFFER
00:008D 220000          	   912: 		ld 		(Comm_Ptr_list),HL
00:0090 C9              	   913: 		ret
                        	   914: 			; Write line from address in iy (until char = 00)
                        	   915: WriteLine:
                        	   916: 		; ld 		b,(iy)		; get length
00:0091 FD23            	   917: 		inc		iy			; First pos point to str length, Dont check length, skip first len byte 22.05.01
                        	   918: nxtchr:
00:0093 FD7E00          	   919: 		ld 		a,(iy)
00:0096 B7              	   920: 		or		A			; = 0 ??
00:0097 C8              	   921: 		ret 	z
00:0098 E5              	   922: 		push	hl
00:0099 CDA900          	   923: 		call	WriteChar
00:009C E1              	   924: 		pop 	hl
00:009D FD23            	   925: 		inc		iy
                        	   926: 		; djnz	nxtchr
00:009F 18F2            	   927: 		jr 		nxtchr
                        	   928: 
00:00A1 C9              	   929: 		ret					; return on maxlength
                        	   930: 			; WriteLine from address (iy) (until char = 00)and add CRLF 
                        	   931: WriteLineCRNL:
00:00A2 CD9100          	   932: 		call	WriteLine
                        	   933: 			; Entry for excl. output CRNL
                        	   934: CRNL:
                        	   935: CRLF:
00:00A5 CD1803          	   936: 		call	puts_crlf
00:00A8 C9              	   937: 		ret
                        	   938: 
                        	   939: 			;Write character
                        	   940: WriteChar:
00:00A9 C5              	   941: 		push 	BC
00:00AA D5              	   942: 		push 	DE
00:00AB E5              	   943: 		push 	HL				; save the reg  for hexdump...
00:00AC F5              	   944: 		PUSH	AF				;SAVE CHARACTER TO OUTPUT
                        	   945: 			;wait for output buffer not full, then store next character
                        	   946: WaitOutBuff:
00:00AD CDCE00          	   947: 		call	GetOutStatus			; get output status. Carry=1 if buffer full, 0 if not
00:00B0 38FB            	   948: 		jr		C,WaitOutBuff			; wait if output buffer is full
00:00B2 F3              	   949: 		di                     			; disable interrupts while looking at
                        	   950: 										; buffer, interrupt status
00:00B3 210000          	   951: 		ld		HL,OutBufCount
00:00B6 34              	   952: 		inc		(HL)					; increase output buffer count by 1
00:00B7 2A0000          	   953: 		ld		HL, (outTailAdr)		; point to next empty byte in buffer
00:00BA F1              	   954: 		pop		AF						; get character
00:00BB 77              	   955: 		ld		(HL),A					; store character at tail of buffer
00:00BC CDC102          	   956: 		call	incOutPointer			; move tail pointer up 1
00:00BF 220000          	   957: 		ld		(outTailAdr),HL
00:00C2 3A0000          	   958: 		ld		A,(OutINTExpect)		; test output interrupt expected flag
00:00C5 B7              	   959: 		or		A
00:00C6 CC9D02          	   960: 		call	Z,CharToSIO_0			; output character immediately if
                        	   961: 										; output interrupt not expected
00:00C9 E1              	   962: 		pop 	HL		
00:00CA D1              	   963: 		pop 	DE	
00:00CB C1              	   964: 		pop 	BC			
00:00CC FB              	   965: 		ei						;reenable interrupts
00:00CD C9              	   966: 		ret
                        	   967: 			;output status (carry=1 if buffer is full)
                        	   968: GetOutStatus:
00:00CE 3A0000          	   969: 		ld		A, (OutBufCount)		; get current output buffer count
00:00D1 FE00            	   970: 		cp		outBufferSize			; compare to maximum
00:00D3 3F              	   971: 		ccf						; complement carry
00:00D4 C9              	   972: 		ret						; carry = 1 if buffer full, 0 if not
                        	   973: 			; INITIALIZE SIO_0, Interrupt system
                        	   974: InitBuffers:
                        	   975: 			; initialize buffer counters and pointers.
00:00D5 97              	   976: 		sub		A					; zero A
00:00D6 320000          	   977: 		ld		(OutINTExpect),A	; indicate no output interruptS
00:00D9 320000          	   978: 		ld		(inBufCount),A		; buffer counters = 0
00:00DC 320000          	   979: 		ld		(OutBufCount),A
00:00DF CDE900          	   980: 		call	cleanInBuffer
00:00E2 CDFA00          	   981: 		call	cleanOutBuffer
00:00E5 CD0F01          	   982: 		call 	InitInterrupt		; init interrupt vectors
00:00E8 C9              	   983: 		ret
                        	   984: 
                        	   985: cleanInBuffer:
00:00E9 97              	   986: 		sub		A					; zero A
00:00EA 320000          	   987: 		ld		(inBufCount),A		; buffer counters = 0
00:00ED 320000          	   988: 		ld 		(inbufferDeactivate),A  ; clear flag for input buffer update...
00:00F0 210000          	   989: 		ld		HL,inBuffer			; all buffer pointers = base address
00:00F3 220000          	   990: 		ld		(inHeadAdr),HL
00:00F6 220000          	   991: 		ld		(inTailAdr),HL
00:00F9 C9              	   992: 		ret
                        	   993: cleanOutBuffer:
00:00FA 97              	   994: 		sub		A					; zero A
00:00FB 320000          	   995: 		ld		(OutBufCount),A
00:00FE 210000          	   996: 		ld		HL,outBuffer
00:0101 220000          	   997: 		ld		(outHeadAdr),HL
00:0104 220000          	   998: 		ld		(outTailAdr),HL
00:0107 C9              	   999: 		ret
                        	  1000: 
                        	  1001: waitForFinishedPrintout:
                        	  1002: 		;  wait for print to finish
                        	  1003: .waitmore:
00:0108 3A0000          	  1004: 		ld		A, (OutBufCount)	;get output buffer counter
00:010B B7              	  1005: 		or 		A 					;=0 ?
00:010C 20FA            	  1006: 		jr 		nz,.waitmore
00:010E C9              	  1007: 		ret
                        	  1008: 
                        	  1009: ;******************************************************************************
                        	  1010: InitInterrupt:
                        	  1011: 			;INITIALIZE INTERRUPT VECTORS (SIO_0)
                        	  1012: 			; initialize . interrupt flag
00:010F 3EF4            	  1013: 		ld		A,SIO_Int_Vec>>8		;GET HIGH BYTE OF INTERRUPT PAGE   (F400 >> 8 = F4)
00:0111 ED47            	  1014: 		ld		I,A             ;SET INTERRUPT VECTOR IN zao
00:0113 ED5E            	  1015: 		im		2               ; INTERRUPT MODE 2 - VECTORS IN TABLE
00:0115 216601          	  1016: 		ld		HL,ReadINTHandler      	 ; ON INTERRUPT PAGE
00:0118 220CF4          	  1017: 		ld		(SIO_Int_Read_Vec),HL		;STORE READ VECTOR
00:011B 219301          	  1018: 		ld		HL,WriteINTHandler
00:011E 2208F4          	  1019: 		ld		(SIO_Int_WR_Vec),HL		;STORE WRITE VECTOR
00:0121 218B02          	  1020: 		ld		HL,ExternINTHandler
00:0124 220AF4          	  1021: 		ld		(SIO_Int_EXT_Vec),HL		;STORE EXTERNAL/STATUS VECTOR
00:0127 219402          	  1022: 		ld		HL,SpecINTHandler
00:012A 220EF4          	  1023: 		ld		(SIO_Int_Spec_Vec),HL		;STORE SPECIAL RECEIVE VECTOR
00:012D 21B801          	  1024: 		ld		HL,ReadUSBHandler      	 ; ON INTERRUPT PAGE
00:0130 2204F4          	  1025: 		ld		(SIO_USB_Read_Vec),HL		;STORE READ VECTOR
                        	  1026: 		
00:0133 21C201          	  1027: 		ld 		HL,Write_USB_Handler
00:0136 2200F4          	  1028: 		ld		(SIO_USB_WR_Vec),HL		;STORE READ VECTOR
00:0139 21C601          	  1029: 		ld 		HL,Extern_B_USB_Handler
00:013C 2202F4          	  1030: 		ld 		(SIO_USB_EXT_Vec),HL
00:013F 21CA01          	  1031: 		ld 		HL,SpecINT_B_USB_Handler
00:0142 2206F4          	  1032: 		ld 		(SIO_USB_Spec_Vec),HL
                        	  1033: 		
                        	  1034: 				; INT Vectors  for the CTC 
00:0145 214103          	  1035: 		ld		HL,CTC_CH0_Interrupt_Handler
00:0148 2210F4          	  1036: 		ld		(CTC_CH0_I_Vector),HL		;STORE CTC channel 0 VECTOR
00:014B 214103          	  1037: 		ld		HL,CTC_CH1_Interrupt_Handler
00:014E 2212F4          	  1038: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:0151 215503          	  1039: 		ld		HL,CTC_CH2_Interrupt_Handler
00:0154 2214F4          	  1040: 		ld		(CTC_CH2_I_Vector),HL		;STORE CTC channel 2 VECTOR
00:0157 215503          	  1041: 		ld		HL,CTC_CH3_Interrupt_Handler
00:015A 2216F4          	  1042: 		ld		(CTC_CH3_I_Vector),HL		;STORE CTC channel 3 VECTOR
                        	  1043: 
00:015D C9              	  1044: 		ret
                        	  1045: SIO_Init:		
                        	  1046: 		;INITIALIZE I/O PORTS
00:015E 21E302          	  1047: 		ld      HL,SIO_0INT		;BASE ADDRESS OF INITIALIZATION ARRAY
00:0161 CDCF02          	  1048: 		call    InitSIO_0Ports			; INITIALIZE SIO_0
00:0164 FB              	  1049: 		ei						; ENABLE INTERRUPTS
00:0165 C9              	  1050: 		ret
                        	  1051: 
                        	  1052: 
                        	  1053: ;******************************************************************************
                        	  1054: 				;Channel A: INPUT (READ) INTERRUPT HANDLER
                        	  1055: ReadINTHandler:
00:0166 F5              	  1056: 		push	AF				;SAVE REGISTERS
00:0167 C5              	  1057: 		push	BC
00:0168 D5              	  1058: 		push	DE
00:0169 E5              	  1059: 		push   	HL
                        	  1060: 	
00:016A DB00            	  1061: 		in		A,(SIO_A_D)		; read data from SIO_0
00:016C 4F              	  1062: 		ld		C,A					; save data in register c
00:016D 3A0000          	  1063: 		ld 		a,(inbufferDeactivate)
00:0170 FE00            	  1064: 		cp 		$00 					; =0 		
00:0172 2013            	  1065: 		jr 		nz,exitRHandler
                        	  1066: 
00:0174 210000          	  1067: 		ld		HL,inBufCount		; any room in input buffer?
00:0177 7E              	  1068: 		ld		A, (HL)
00:0178 FE00            	  1069: 		cp		bufferSize
00:017A 300B            	  1070: 		jr		NC,exitRHandler		; jump if no room
00:017C 34              	  1071: 		inc		(HL)				; increment input buffer counter
00:017D 2A0000          	  1072: 		ld		HL, (inTailAdr)		; store character at tail of input buffer
00:0180 71              	  1073: 		ld		(HL),C
00:0181 CDB302          	  1074: 		call	incInPointer		; increment tail pointer
00:0184 220000          	  1075: 		ld		(inTailAdr), HL
                        	  1076: exitRHandler:
00:0187 3E00            	  1077: 		ld 		A,00
00:0189 320000          	  1078: 		ld 		(CTCdelayFlag),A 	; reset timeout flag indicate interrupt by SIOA read.
                        	  1079: 
00:018C E1              	  1080: 		pop		HL				;restore registers
00:018D D1              	  1081: 		pop		DE
00:018E C1              	  1082: 		pop		BC
00:018F F1              	  1083: 		pop		AF
00:0190 FB              	  1084: 		ei						;reenable interrupts
00:0191 ED4D            	  1085: 		reti
                        	  1086: 
                        	  1087: ;******************************************************************************
                        	  1088: 			;Channel A: output (write) interrupt handler
                        	  1089: WriteINTHandler:
00:0193 F5              	  1090: 		push	AF					;save registers
00:0194 C5              	  1091: 		push	BC
00:0195 D5              	  1092: 		push	DE
00:0196 E5              	  1093: 		push	HL
00:0197 3A0000          	  1094: 		ld		A, (OutBufCount)	;get output buffer counter
00:019A B7              	  1095: 		or		A					;test for empty buffer
00:019B 2805            	  1096: 		jr		Z,nodata			;jump if no data to transmit
00:019D CD9D02          	  1097: 		call	CharToSIO_0			;else output data
00:01A0 180A            	  1098: 		jr		wrdone
                        	  1099: 			;if an output interrupt occurs when no data is available.
                        	  1100: 			; we must disable output interrupts to avoid an endless loop.
                        	  1101: 			; when the next character is ready, it must be sent immediately
                        	  1102: 			; since no interrupt will occur. this state in which an output
                        	  1103: 			; interrupt has occurred but has not been serviced is indicated
                        	  1104: 			; by clearing ole (output interrupt expected flag).
                        	  1105: nodata:
00:01A2 97              	  1106: 		sub		A
00:01A3 320000          	  1107: 		ld		(OutINTExpect),a				;00 not expect an interrupt
00:01A6 D302            	  1108: 		out		(SIO_A_C),a			;select register 0
00:01A8 3E28            	  1109: 		ld		a,00101000b			;reset transmitter interrupt
00:01AA D302            	  1110: 		out		(SIO_A_C),a
                        	  1111: wrdone:
00:01AC 3E00            	  1112: 		ld 		A,00
00:01AE 320000          	  1113: 		ld 		(CTCdelayFlag),A 	; reset timeout flag indicate interrupt by SIOA read.
00:01B1 E1              	  1114: 		pop		HL					;restore registers
00:01B2 D1              	  1115: 		pop		DE
00:01B3 C1              	  1116: 		pop		BC
00:01B4 F1              	  1117: 		pop		AF
00:01B5 FB              	  1118: 		ei
00:01B6 ED4D            	  1119: 		reti
                        	  1120: ;******************************************************************************
                        	  1121: 
                        	  1122: 
                        	  1123: 
                        	  1124: 		; *** 	interrupt at input from HC376S
                        	  1125: ReadUSBHandler:
00:01B8 DB01            	  1126: 		in  	A,(sio_bd)		  		;read char from SIO B
00:01BA 5F              	  1127: 		ld 		E,A
                        	  1128: 	ifd 	GPIODEBUG	
                        	  1129: 		ld a,1
                        	  1130: 		out (gpio_out),A
                        	  1131: 		ld a,0
                        	  1132: 		out (gpio_out),A
                        	  1133: 	endif
                        	  1134: 	
00:01BB 7B              	  1135: 		ld a,e
00:01BC CD4902          	  1136: 		call 	purgeRXB
                        	  1137: 
                        	  1138: 		; in  	A,(CH1)
                        	  1139: 		; ld 		(TempVar8),A
                        	  1140: 		; in  	A,(CH0)
                        	  1141: 		; ld 		(TempVar7),A
                        	  1142: ; 		cp 		USB_INT_CONNECT
                        	  1143: ; 		jr  	NZ,.p2
                        	  1144: ; 		call 	writeSTRBelow_CRLF
                        	  1145: ; 		db		0,">USB_INT_CONNECT",0,0
                        	  1146: ; 		jr 		.p3
                        	  1147: ; .p2:
                        	  1148: ; 		cp 		USB_INT_DISCONNECT
                        	  1149: ; 		jr 		NZ,.p3
                        	  1150: ; 		call 	writeSTRBelow_CRLF
                        	  1151: ; 		db		0,">USB_INT_DISCONNECT",0,0
                        	  1152: .p3:
                        	  1153: 		
                        	  1154: 
00:01BF FB              	  1155: 		ei
00:01C0 ED4D            	  1156: 		reti
                        	  1157: 
                        	  1158: ;********************************************************************************************     
                        	  1159: 
                        	  1160: Write_USB_Handler:
                        	  1161: 
                        	  1162: 	ifd 	GPIODEBUG	
                        	  1163: 		ld a,20
                        	  1164: 		out (gpio_out),A
                        	  1165: 		ld a,0
                        	  1166: 		out (gpio_out),A
                        	  1167: 	endif
                        	  1168: 
00:01C2 7B              	  1169: 		ld a,e
00:01C3 FB              	  1170: 		ei
00:01C4 ED4D            	  1171: 		reti
                        	  1172: 			;external/status changed interrupt handler
                        	  1173: Extern_B_USB_Handler:
                        	  1174: 	ifd 	GPIODEBUG
                        	  1175: 		ld a,21
                        	  1176: 		out (gpio_out),A
                        	  1177: 		ld a,0
                        	  1178: 		out (gpio_out),A
                        	  1179: 	endif
00:01C6 7B              	  1180: 		ld a,e
00:01C7 FB              	  1181: 		ei							; dcd or cts line changed state. or a
00:01C8 ED4D            	  1182: 		reti						; break was detected
                        	  1183: 									; service here if necessary
                        	  1184: 			;special receive error interrupt
                        	  1185: SpecINT_B_USB_Handler:
                        	  1186: 	ifd 	GPIODEBUG
                        	  1187: 		ld a,22
                        	  1188: 		out (gpio_out),A
                        	  1189: 		ld a,0
                        	  1190: 		out (gpio_out),A
                        	  1191: 	endif
                        	  1192: 	
00:01CA 7B              	  1193: 		ld a,e
00:01CB FB              	  1194: 		ei							;framing error or overrun error occurred
00:01CC ED4D            	  1195: 		reti						; service here if necessary
                        	  1196: 
                        	  1197: ;********************************************************************************************     
                        	  1198: 
                        	  1199: SIO_A_EI:
                        	  1200: 		;enable SIO_0 channel A RX
                        	  1201: 
                        	  1202: 		; ld		a,003h			;write into WR0: select WR3
                        	  1203: 		; out		(SIO_A_C),A
                        	  1204: 		; ld		a,_Rx_Enable|_RX_8_bits|_Auto_Enable 			;RX 8bit, auto enable on, RX on
                        	  1205: 		; out		(SIO_A_C),A	Channel A RX active
                        	  1206: 
00:01CE 3E05            	  1207: 		ld		a,005h			;write into WR0: select WR5
00:01D0 D302            	  1208: 		out		(SIO_A_C),A
00:01D2 3E6A            	  1209: 		ld		a,_RTS_Enable|_Tx_Enable|_Tx_8bits_char			
00:01D4 D302            	  1210: 		out		(SIO_A_C),A	Channel A RX active
                        	  1211: 
                        	  1212: 		; ld		a,001h			;write into WR0: select WR3
                        	  1213: 		; out		(SIO_A_C),A
                        	  1214: 		; ld		a,_Tx_INT_EN|_Int_All_Rx_Char_NP		
                        	  1215: 		; out		(SIO_A_C),A	Channel A RX active
                        	  1216: 
                        	  1217: 
                        	  1218: 
00:01D6 C9              	  1219: 		RET
                        	  1220: 	
                        	  1221: SIO_A_DI:
                        	  1222: 		;disable SIO_0 channel A RX
                        	  1223: 		; ld		a,WR3			;write into WR0: select WR3
                        	  1224: 		; out		(SIO_A_C),A
                        	  1225: 		; ld		a,_RX_8_bits|_Rx_Disable			;RX 8bit, auto enable off, RX off
                        	  1226: 		; out		(SIO_A_C),A
00:01D7 3E05            	  1227: 		ld		a,005h			;write into WR0: select WR3
00:01D9 D302            	  1228: 		out		(SIO_A_C),A
00:01DB 3E60            	  1229: 		ld		a,_Tx_8bits_char			
00:01DD D302            	  1230: 		out		(SIO_A_C),A	Channel A RX active
                        	  1231: 
                        	  1232: 
                        	  1233: 		;Channel A RX inactive
00:01DF C9              	  1234: 		ret
                        	  1235: 
                        	  1236: 
                        	  1237: SIO_A_TXRX_INTon:
                        	  1238: 		;enable SIO_0 channel A RX
00:01E0 3E01            	  1239: 		ld		A,WR1							;write into WR0: select WR1
00:01E2 D302            	  1240: 		out		(SIO_A_C),A
00:01E4 3E1A            	  1241: 		ld		A,_Tx_INT_EN|_Int_All_Rx_Char_NP		 			;RX and TX interrupt on
00:01E6 D302            	  1242: 		out		(SIO_A_C),A						; Channel A RX active
00:01E8 C9              	  1243: 		RET
                        	  1244: 
                        	  1245: 
                        	  1246: 
                        	  1247: SIO_A_TXRX_INToff:
                        	  1248: 		;enable SIO_0 channel A RX
00:01E9 3E01            	  1249: 		ld		A,WR1			;write into WR0: select WR1
00:01EB D302            	  1250: 		out		(SIO_A_C),A
00:01ED 3E00            	  1251: 		ld		A,00h			;RX and TX interrupt off
00:01EF D302            	  1252: 		out		(SIO_A_C),A		;	Channel A RX 
00:01F1 C9              	  1253: 		RET
                        	  1254: 
                        	  1255: SIO_A_TX_INTon:
                        	  1256: 		;enable SIO_0 channel A RX
00:01F2 3E01            	  1257: 		ld		A,WR1							;write into WR0: select WR1
00:01F4 D302            	  1258: 		out		(SIO_A_C),A
00:01F6 3E02            	  1259: 		ld		A,_Tx_INT_EN		 			;TX interrupt on
00:01F8 D302            	  1260: 		out		(SIO_A_C),A						; Channel A TX active
00:01FA C9              	  1261: 		RET
                        	  1262: 
                        	  1263: SIO_A_RX_INTon:
                        	  1264: 		;enable SIO_0 channel A RX
00:01FB 3E01            	  1265: 		ld		A,WR1							;write into WR0: select WR1
00:01FD D302            	  1266: 		out		(SIO_A_C),A
00:01FF 3E18            	  1267: 		ld		A,_Int_All_Rx_Char_NP		 	;RX interrupt on
00:0201 D302            	  1268: 		out		(SIO_A_C),A						;Channel A RX active
00:0203 C9              	  1269: 		RET
                        	  1270: 
                        	  1271: SIO_A_RTS_OFF:
                        	  1272: 		;signaling the host go or nogo for reception
00:0204 3E05            	  1273: 		ld		a,005h			;write into WR0: select WR5
00:0206 D302            	  1274: 		out		(SIO_A_C),A
00:0208 3E68            	  1275: 		ld		a,_Tx_8bits_char|_Tx_Enable 				;TX 8bit, BREAK off, TX on, RTS inactive
00:020A 3EE8            	  1276: 		ld		a,0E8h			
00:020C D302            	  1277: 		out		(SIO_A_C),A 
00:020E C9              	  1278: 		ret 
                        	  1279: 		
                        	  1280: 		
                        	  1281: SIO_A_RTS_ON:
                        	  1282: 		; signaling the host go or nogo for reception
00:020F 3E05            	  1283: 		ld		a,005h			;write into WR0: select WR5
00:0211 D302            	  1284: 		out		(SIO_A_C),A
                        	  1285: 		; ld		a,_Tx_8bits_char|_Tx_Enable|_RTS_Enable 		;TX 8bit, BREAK off, TX on, RTS active
00:0213 3EEA            	  1286: 		ld		a,0EAh	
00:0215 D302            	  1287: 		out		(SIO_A_C),A 
00:0217 C9              	  1288: 		ret 
                        	  1289: 		
                        	  1290: 	
                        	  1291: 
                        	  1292: 
                        	  1293: SIO_B_RX_INTon:
                        	  1294: 		;enable SIO_0 channel A RX
00:0218 3E01            	  1295: 		ld		A,WR1							;write into WR0: select WR1
00:021A D303            	  1296: 		out		(sio_bc),A
00:021C 3E1C            	  1297: 		ld 		A,_Int_All_Rx_Char_NP|_Status_Vector  		;RX interrupt on
00:021E D303            	  1298: 		out		(sio_bc),A						;Channel A RX active
00:0220 C9              	  1299: 		RET
                        	  1300: 
                        	  1301: 
                        	  1302: SIO_B_TXRX_INToff:
                        	  1303: 		;enable SIO_0 channel B RX
00:0221 3E01            	  1304: 		ld		A,WR1			; write into WR0: select WR1
00:0223 D303            	  1305: 		out		(sio_bc),A
00:0225 3E00            	  1306: 		ld		A,00h			; RX and TX interrupt off
00:0227 D303            	  1307: 		out		(sio_bc),A		; Channel B RX 
00:0229 C9              	  1308: 		RET
                        	  1309: 
                        	  1310: SIO_B_EI:
                        	  1311: 		;enable SIO_0 channel B RX
00:022A 3E03            	  1312: 		ld		a,003h			;write into WR0: select WR3
00:022C D303            	  1313: 		out		(sio_bc),A
00:022E 3EC1            	  1314: 		ld		a,0C1h			;RX 8bit, auto enable off, RX on
00:0230 D303            	  1315: 		out		(sio_bc),A		; Channel A RX active
00:0232 C9              	  1316: 		RET
                        	  1317: 	
                        	  1318: 	
                        	  1319: SIO_B_DI:
                        	  1320: 		;disable SIO_0 channel B RX
00:0233 3E03            	  1321: 		ld		a,WR3			;write into WR0: select WR3
00:0235 D303            	  1322: 		out		(sio_bc),A
00:0237 3EC0            	  1323: 		ld		a,_RX_8_bits|_Rx_Disable			;RX 8bit, auto enable off, RX off
00:0239 D303            	  1324: 		out		(sio_bc),A
                        	  1325: 		;Channel A RX inactive
00:023B C9              	  1326: 		ret
                        	  1327: 
                        	  1328: 
                        	  1329: purgeRXA:
                        	  1330: 		; flushing the receive buffer
                        	  1331: 		;check for RX buffer empty
                        	  1332: 		;modifies A
00:023C 97              	  1333: 		sub		a				;clear a, write into WR0: select RR0
00:023D D302            	  1334: 		out		(SIO_A_C),A
00:023F DB02            	  1335: 		in		A,(SIO_A_C)		;read RRx
00:0241 CB47            	  1336: 		bit		0,A
00:0243 C8              	  1337: 		ret		z				;if any rx char left in rx buffer
                        	  1338: 
00:0244 DB00            	  1339: 		in		A,(SIO_A_D)		;read that char
00:0246 C33C02          	  1340: 		jp		purgeRXA		
                        	  1341: 
                        	  1342: 
                        	  1343: purgeRXB:
                        	  1344: 		; flushing the receive buffer, check for RX(B) buffer empty
                        	  1345: 		;modifies A
00:0249 97              	  1346: 		sub		a				;clear a, write into WR0: select RR0
00:024A D303            	  1347: 		out		(sio_bc),A
00:024C DB03            	  1348: 		in		A,(sio_bc)		;read RRx
00:024E CB47            	  1349: 		bit		0,A
00:0250 C8              	  1350: 		ret		z				;if any rx char left in rx buffer
                        	  1351: 
00:0251 DB01            	  1352: 		in		A,(sio_bd)		;read that char
00:0253 C33C02          	  1353: 		jp		purgeRXA		
                        	  1354: 
                        	  1355: TX_NAK:
00:0256 3E15            	  1356: 		ld 		a,NAK				;send NAK 15h to host
00:0258 D300            	  1357: 		out		(SIO_A_D),A
00:025A CD7602          	  1358: 		call	TX_EMP
00:025D C9              	  1359: 		RET
                        	  1360: 
                        	  1361: 
                        	  1362: 
                        	  1363: TX_ACK:
00:025E 3E06            	  1364: 		ld		 A,ACK				;send AK to host
00:0260 D300            	  1365: 		out		(SIO_A_D),A
00:0262 CD7602          	  1366: 		call	TX_EMP
00:0265 C9              	  1367: 		ret
                        	  1368: 
                        	  1369: 
                        	  1370: TX_C:
00:0266 3E43            	  1371: 		ld		 A,'C'				;send 'C' to host
00:0268 D300            	  1372: 		out		(SIO_A_D),A
00:026A CD7602          	  1373: 		call	TX_EMP
00:026D C9              	  1374: 		RET
                        	  1375: 
                        	  1376: TX_X:
00:026E 3E58            	  1377: 		ld		 a,'X'				;send 'C' to host
00:0270 D300            	  1378: 		out		(SIO_A_D),A
00:0272 CD7602          	  1379: 		call	TX_EMP
00:0275 C9              	  1380: 		RET
                        	  1381: 
                        	  1382: 
                        	  1383: TX_EMP:
                        	  1384: 		; ransmitting a character to host
                        	  1385: 		; check for TX buffer empty
00:0276 97              	  1386: 		sub		a				;clear a, write into WR0: select RR0
00:0277 3C              	  1387: 		inc		a				;select RR1
00:0278 D302            	  1388: 		out		(SIO_A_C),A
00:027A DB02            	  1389: 		in		A,(SIO_A_C)	;read TRx, all sent
00:027C CB47            	  1390: 		bit		0,A
00:027E CA7602          	  1391: 		jp		z,TX_EMP
00:0281 C9              	  1392: 		ret
                        	  1393: 		
                        	  1394: 					
                        	  1395: 
                        	  1396: ;********************************************************************************************     
                        	  1397: 
                        	  1398: 
                        	  1399: 				; return with A=0, Z set
                        	  1400: CTC1_INT_OFF:
00:0282 3E53            	  1401: 		ld		A,_Counter|_Rising|_Reset|_CW	
00:0284 D301            	  1402: 		out		(CH1),A			; reset and turn off interrupt CH1
00:0286 AF              	  1403: 		xor 	A 				; clear A
00:0287 320000          	  1404: 		ld 		(CTCdelayFlag),A ; reset timeout flag
00:028A C9              	  1405: 		ret							; return with A=0, Z set
                        	  1406: ;******************************************************************************
                        	  1407: 
                        	  1408: 
                        	  1409: 			;external/status changed interrupt handler
                        	  1410: ExternINTHandler:
00:028B F5              	  1411: 		push	AF
00:028C 3E10            	  1412: 		ld		A,00010000b			;reset status interrupt
                        	  1413: 
00:028E D302            	  1414: 		out		(SIO_A_C),a
00:0290 F1              	  1415: 		pop		AF
00:0291 FB              	  1416: 		ei							; dcd or cts line changed state. or a
00:0292 ED4D            	  1417: 		reti						; break was detected
                        	  1418: 									; service here if necessary
                        	  1419: 			;special receive error interrupt
                        	  1420: SpecINTHandler:
00:0294 F5              	  1421: 		push	AF
00:0295 3E30            	  1422: 		ld		A,00110000b			;reset receive error interrupt
00:0297 D302            	  1423: 		out		(SIO_A_C),a
00:0299 F1              	  1424: 		pop		AF
00:029A FB              	  1425: 		ei							;framing error or overrun error occurred
00:029B ED4D            	  1426: 		reti						; service here if necessary
                        	  1427: 
                        	  1428: 		;*************************************
                        	  1429: 		; 	routine: chartoSIO_0
                        	  1430: 		; 	purpose: send character to SIO_0
                        	  1431: 		; 	entry: none
                        	  1432: 		;	exit: none
                        	  1433: 		;	registers used: af.de.hl
                        	  1434: 		;***************************************
                        	  1435: CharToSIO_0:
00:029D 2A0000          	  1436: 		ld		HL,(outHeadAdr)
00:02A0 7E              	  1437: 		ld		A, (HL)					;get data from head of output buffer
00:02A1 D300            	  1438: 		out		(SIO_A_D),A			;output data
                        	  1439: 
                        	  1440: 
00:02A3 CDC102          	  1441: 		call	incOutPointer			; increment head pointer
00:02A6 220000          	  1442: 		ld		(outHeadAdr),HL
00:02A9 210000          	  1443: 		ld		HL,OutBufCount			;decrement output buffer count
00:02AC 35              	  1444: 		dec		(HL)
00:02AD 3EFF            	  1445: 		ld		a,0ffh
00:02AF 320000          	  1446: 		ld		(OutINTExpect),a		;expect an output interrupt
00:02B2 C9              	  1447: 		ret
                        	  1448: 
                        	  1449: 
                        	  1450: 		;*************************************
                        	  1451: 		; routine: incinpointer
                        	  1452: 		; purpose: increment pointer into input
                        	  1453: 		;			buffer with wraparound
                        	  1454: 		; entry: hl = pointer
                        	  1455: 		;exit: hl = pointer incremented with wraparound
                        	  1456: 		;registers used: af.de.hl
                        	  1457: 		;***************************************
                        	  1458: incInPointer:
00:02B3 23              	  1459: 		INC		HL					; increment pointer
00:02B4 110000          	  1460: 		LD		DE,inBufferEnd			;compare pointer. end of buffer
00:02B7 7D              	  1461: 		LD		A,L
00:02B8 BB              	  1462: 		CP		E
00:02B9 C0              	  1463: 		RET		NZ
00:02BA 7C              	  1464: 		LD		A,H
00:02BB BA              	  1465: 		CP		D
00:02BC C0              	  1466: 		RET		NZ					;return if not equal
00:02BD 210000          	  1467: 		LD		HL,inBuffer				;if pointer at end of buffer.
00:02C0 C9              	  1468: 		RET                   	  ; set it back to base address
                        	  1469: 		
                        	  1470: 		
                        	  1471: 		;*************************************
                        	  1472: 		; routine: incoutpointer
                        	  1473: 		; purpose: increment pointer into output
                        	  1474: 		;			buffer with wraparound
                        	  1475: 		; entry: HL =  pointer
                        	  1476: 		;exit: HL   =  pointer incremented with wraparound
                        	  1477: 		;registers used: AF.DE.HL
                        	  1478: 		;***************************************
                        	  1479: incOutPointer:
00:02C1 23              	  1480: 		inc		HL					; increment pointer
00:02C2 110000          	  1481: 		ld		DE,endOutBuffer			;compare pointer. end of buffer
00:02C5 7D              	  1482: 		ld		A,L
00:02C6 BB              	  1483: 		cp		E
00:02C7 C0              	  1484: 		ret		NZ
00:02C8 7C              	  1485: 		ld		A,H
00:02C9 BA              	  1486: 		cp		D
00:02CA C0              	  1487: 		ret		NZ
00:02CB 210000          	  1488: 		ld		HL,outBuffer				;if pointer at end of buffer.
00:02CE C9              	  1489: 		ret							; set it back to base address
                        	  1490: 
                        	  1491: 
                        	  1492: 		;**************************************
                        	  1493: 		; routine: initSIO_0ports
                        	  1494: 		; purpose: initialize i/o ports
                        	  1495: 		; entry: hl = base address of initialization array
                        	  1496: 		;exit: data output to ports
                        	  1497: 		;registers used: af.bc.hl
                        	  1498: 		;************************************
                        	  1499: InitSIO_0Ports:
                        	  1500: 		;get number of data bytes to send to current port
                        	  1501: 		;exit if number of bytes is o. indicating terminator
00:02CF 7E              	  1502: 		ld		A,(HL)			;get number of bytes
00:02D0 B7              	  1503: 		or		A				;test for zero (terminator)
00:02D1 C8              	  1504: 		ret		Z				;return if number of bytes = 0
00:02D2 47              	  1505: 		ld		B,A
00:02D3 23              	  1506: 		inc		HL				;point to port address (next byte)
                        	  1507: 
                        	  1508: 			;c = port address
                        	  1509: 			;hl   base address of output data
00:02D4 4E              	  1510: 		ld		C,(HL)			;get port address
00:02D5 23              	  1511: 		inc		HL				;point to first data value (next byte)
                        	  1512: 			;output data and continue to next port
00:02D6 EDB3            	  1513: 		otir					;send data values to port
00:02D8 18F5            	  1514: 		jr      InitSIO_0Ports			;continue to next port entry
                        	  1515: 		
                        	  1516: 		;SIO_0 initialization data
                        	  1517: 
                        	  1518: 		; sio_ac
                        	  1519: 		; sio_ad
                        	  1520: 		; sio_bc
                        	  1521: 		; sio_bd
                        	  1522: initSIOBInterrupt:
00:02DA 3E01            	  1523: 		ld 		A,WR1
00:02DC D303            	  1524: 		out 	(sio_bc),A
00:02DE 3E1C            	  1525: 		ld 		A,_Int_All_Rx_Char_NP|_Status_Vector
00:02E0 D303            	  1526: 		out 	(sio_bc),A					; interrupt on HC376S read
00:02E2 C9              	  1527: 		ret
                        	  1528: 	
                        	  1529: SIO_0INT:
                        	  1530: 		; Reset channel a
00:02E3 01              	  1531: 		db	1					;output 1 byte
00:02E4 02              	  1532: 		db	sio_ac			;to channel a command/status
00:02E5 18              	  1533: 		db	_Ch_Reset			;select write register 0
                        	  1534: 								;bits 2.1.0    0 (write register 0)
                        	  1535: 								;bits 5,4,3 = 011 (channel reset)
                        	  1536: 								;bits 7,6 = 0 (do not care)
00:02E6 01              	  1537: 		db	1					;output 1 byte
00:02E7 03              	  1538: 		db	sio_bc			;to channel a command/status
00:02E8 18              	  1539: 		db	_Ch_Reset			;select write register 0
                        	  1540: 
                        	  1541: 
                        	  1542: 		;sET INTERRUPT VECTOR AND ALLOW STATUS TO AFFECT IT
00:02E9 04              	  1543: 		db	4					;OUTPUT 4 BYTES
00:02EA 03              	  1544: 		db	SIO_B_C			;DESTINATION IS COMMAND REGISTER B
00:02EB 02              	  1545: 		db	WR2					;SELECT WRITE REGISTER 2
00:02EC 00              	  1546: 		db	SIO_Int_Vec&0FFH	;SET INTERRUPT VECTOR FOR SIO_0
00:02ED 01              	  1547: 		db	WR1					;SELECT WRITE REGISTER 1
00:02EE 04              	  1548: 		db	_Status_Vector		;TURN ON STATUS AFFECTS VECTOR
                        	  1549: 
                        	  1550: 		; INITIALIZE CHANNEL A
00:02EF 08              	  1551: 		db	8					;OUTPUT 8 BYTES
00:02F0 02              	  1552: 		db	SIO_A_C			;DESTINATION IS COMMAND REGISTER A
                        	  1553: 
                        	  1554: 		;iNITIALIZE BAUD RATE CONTROL
00:02F1 14              	  1555: 		db	_Reset_STAT_INT|4	;SELECT WRITE REGISTER 4 & RESET EXTERNAL/STATUS INTERRUPT
00:02F2 44              	  1556: 		db	_Stop_1_bit|_X16_Clock_mode
                        	  1557: 								;BIT 0 = 0 (NO PARITY)
                        	  1558: 								;BIT 1 = 0 (DON'T CARE)
                        	  1559: 								;BITS 3,2 = 01 (1 1/2 STOP BITS)
                        	  1560: 								; BITS 5.4 = 00 (DON-'T CARE)
                        	  1561: 								;BITS 7.6 = 10 (32 TIMES CLOCK)
                        	  1562: 	
                        	  1563: 		; INITIALIZE RECEIVE CONTROL
00:02F3 03              	  1564: 		db	WR3		;SELECT WRITE REGISTER 3
00:02F4 E1              	  1565: 		db	_Rx_Enable|_RX_8_bits|_Auto_Enable  (0xC1)
                        	  1566: 								;BIT 0 = 1 (RECEIVE ENABLE)
                        	  1567: 								; BITS 4,3,2,1 = 0 (DON-'T CARE)
                        	  1568: 								;BIT 5 = 0 (NO AUTO ENABLE)
                        	  1569: 								;BIT 7.6 = 11 (RECEIVE 8 BITS/CHAR)
                        	  1570: 		;iNITIALIZE TRANSMIT CONTROL
00:02F5 05              	  1571: 		db	WR5					;SELECT WRITE REGISTER 5
00:02F6 6A              	  1572: 		db	_RTS_Enable|_Tx_Enable|_Tx_8bits_char   (0x6A)
                        	  1573: 								;BIT 0 = 0 (NO CRC ON TRANSMIT)
                        	  1574: 								;BIT 1 = 1 (REQUEST TO SEND)
                        	  1575: 								;BIT 2 = 0 (DON'T CARE)
                        	  1576: 								;BIT 3 = 1 (TRANSMIT ENABLE)
                        	  1577: 								;BIT 4 = 0 (DO NOT SEND BREAK)
                        	  1578: 								;BITS 6.5 = 11 (TRANSMIT 8 BITS/CHAR)
                        	  1579: 								;BIT 7 = 1 (DATA TERMINAL READY)
00:02F7 01              	  1580: 		DB	WR1					;SELECT WRITE REGISTER 1
00:02F8 1A              	  1581: 		DB	_Tx_INT_EN|_Int_All_Rx_Char_NP		(0x1A)
                        	  1582: 		; DB	_Ext_INT_EN|_Tx_INT_EN|_Int_All_Rx_Char_NP|_WAIT_READY_R_T|_WAIT_READY_EN
                        	  1583: 								;BIT 0 = 1 (EXTERNAL INTERRUPTS)
                        	  1584: 								;BIT 1 = 1 (ENABLE TRANSMIT INTERRUPT)
                        	  1585: 								;BIT 2 = 0 (DO NOT CARE)
                        	  1586: 								;BITS 4. 3 = 11 (RECEIVE INTERRUPTS ON ALL CHARS. PARITY DOES NOT AFFECT VECTOR)
                        	  1587: 								;BITS 7.6.5 = 000 (NO WAIT/READY FUNCTION)
                        	  1588: 
                        	  1589: 
                        	  1590: 
                        	  1591: 		; INITIALIZE CHANNEL B
                        	  1592: 		; _____________________________
                        	  1593: 
00:02F9 08              	  1594: 		db	8					;OUTPUT 8 BYTES
00:02FA 03              	  1595: 		db	SIO_B_C			;DESTINATION IS COMMAND REGISTER B
                        	  1596: 
                        	  1597: 		;iNITIALIZE BAUD RATE CONTROL
00:02FB 14              	  1598: 		db	_Reset_STAT_INT|WR4	;SELECT WRITE REGISTER 4 & RESET EXTERNAL/STATUS INTERRUPT
00:02FC 44              	  1599: 		db	_Stop_1_bit|_X16_Clock_mode
                        	  1600: 	
                        	  1601: 		; ; INITIALIZE RECEIVE CONTROL
00:02FD 03              	  1602: 		db	WR3		;SELECT WRITE REGISTER 3
00:02FE C1              	  1603: 		db	_Rx_Enable|_RX_8_bits
                        	  1604: 		; ;iNITIALIZE TRANSMIT CONTROL
00:02FF 05              	  1605: 		db	WR5					;SELECT WRITE REGISTER 5
00:0300 68              	  1606: 		db	_Tx_Enable|_Tx_8bits_char
                        	  1607: 		; DB	_Ext_INT_EN|_Tx_INT_EN|_Int_All_Rx_Char_NP|_WAIT_READY_R_T|_WAIT_READY_EN
00:0301 01              	  1608: 		DB	WR1					;SELECT WRITE REGISTER 1
00:0302 04              	  1609: 		DB	_Status_Vector
                        	  1610: 		; DB	_Tx_INT_EN|_Int_All_Rx_Char_NP|_Status_Vector
                        	  1611: 
00:0303 00              	  1612: 		DB	0               ; END OF TABLE
                        	  1613: 		
                        	  1614: ;****************************************************************************************************************
                        	  1615: ;****************************************************************************************************************
                        	  1616: ;****************************************************************************************************************
                        	  1617: ;****************************************************************************************************************
                        	  1618: ;****************************************************************************************************************
                        	  1619: 		; DATA SECTION
                        	  1620: 		; Moved to linker script 
                        	  1621: ; inHeadAdr:	DS	2					; address of oldest character in input buffer
                        	  1622: ; inTailAdr:	DS	2					; address of newest character in input buffer
                        	  1623: ; inBufCount:	DS	1					;number of characters in input buffer 
                        	  1624: ; outHeadAdr:	DS	2					;address of oldest character in output buffer
                        	  1625: ; outTailAdr:	DS	2					;address of newest character in output buffer
                        	  1626: ; OutBufCount:	DS	1				;number of characters in output buffer
                        	  1627: ; OutINTExpect:	DS	1					;output interrupt expected
                        	  1628: ; 								; (0 = no interrupt expected.
                        	  1629: ; 								; ff = interrupt expected)
                        	  1630: 
                        	  1631: 
                        	  1632: 		; SAMPLE EXECUTION:
                        	  1633: 
                        	  1634: 
                        	  1635: 		;CHARACTER EQUATES
                        	  1636: ; ; ESCAPE	EQU     1BH					;ASCII ESCAPE CHARACTER
                        	  1637: ; ; TESTCH	EQU     'A'					;TEST CHARACTER = A
                        	  1638: ; 		global SC11C
                        	  1639: ; SC11C:
                        	  1640: ; 		CALL	InitBuffers				;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	  1641: ; 			;SIMPLE EXAMPLE - READ AND ECHO CHARACTER
                        	  1642: ; 			; UNTIL AN ESC IS RECEIVED
                        	  1643: ; LOOP:
                        	  1644: ; 		CALL	ReadChar				;READ CHARACTER
                        	  1645: ; 		PUSH	AF
                        	  1646: ; 		CALL	WriteChar				;ECHO CHARACTER
                        	  1647: ; 		POP		AF
                        	  1648: ; 		CP		ESCAPE				;IS CHARACTER AN ESCAPE?
                        	  1649: ; 		JR		NZ,LOOP				;STAY IN LOOP IF NOT
                        	  1650: ; 			;AN ASYNCHRONOUS EXAMPLE
                        	  1651: ; 			; OUTPUT "A" TO CONSOLE CONTINUOUSLY BUT ALSO LOOK AT
                        	  1652: ; 			; INPUT SIDE. READING AND ECHOING ANY INPUT CHARACTERS
                        	  1653: ; ASYNLP:
                        	  1654: ; 			;OUTPUT   AN "A" IF OUTPUT IS NOT BUSY
                        	  1655: ; 		CALL	RetOutStatus				;IS OUTPUT BUSY?
                        	  1656: ; 		JR		C,ASYNLP			;JUMP IF IT IS
                        	  1657: ; 		LD		A,TESTCH
                        	  1658: ; 		CALL	WriteChar				;OUTPUT CHARACTER
                        	  1659: ; 			;CHECK INPUT PORT
                        	  1660: ; 			;ECHO CHARACTER IF ONE IS AVAILABLE
                        	  1661: ; 			;EXIT ON ESCAPE CHARACTER
                        	  1662: ; 		CALL	RetInpStatus				;IS INPUT DATA AVAILABLE?
                        	  1663: ; 		JR		NC, ASYNLP			;JUMP I F NOT (SEND ANOTHER .. A" )
                        	  1664: ; 		CALL	ReadChar				; GET CHARACTER
                        	  1665: ; 		CP		ESCAPE				;IS IT AN ESCAPE CHARACTER?
                        	  1666: ; 		JR		Z,DONE				;BRANCH IF IT IS
                        	  1667: 
                        	  1668: 
                        	  1669: ; 		CALL	WriteChar				;ELSE ECHO CHARACTER
                        	  1670: ; 		JP		ASYNLP				;AND CONTINUE
                        	  1671: ; DONE:
                        	  1672: ; 		JP		LOOP
                        	  1673: 
                        	  1674: 
                        	  1675: ;##############################################################
                        	  1676: ; Write the null-terminated string starting after the call
                        	  1677: ; instruction invoking this subroutine to the console.
                        	  1678: ; Clobbers AF, C
                        	  1679: ;##############################################################
                        	  1680: writeSTRBelow:
00:0304 FDE3            	  1681:         ex      (sp),iy                 ; iy = @ of string to print
00:0306 CD9100          	  1682: 		call	WriteLine
00:0309 FD23            	  1683:         inc     iy                      ; point past the end of the string
00:030B FDE3            	  1684:         ex      (sp),iy
00:030D C9              	  1685:         ret
                        	  1686: 
                        	  1687: writeSTRBelow_CRLF:
00:030E FDE3            	  1688: 		ex		(sp),iy                 ; iy = @ of string to print
00:0310 CDA200          	  1689: 		call	WriteLineCRNL
00:0313 FD23            	  1690: 		inc		iy                      ; point past the end of the string
00:0315 FDE3            	  1691: 		ex		(sp),iy
00:0317 C9              	  1692: 		ret
                        	  1693: 
                        	  1694: ;##############################################################
                        	  1695: ; Print a CRLF 
                        	  1696: ; Clobbers AF, C
                        	  1697: ;##############################################################
                        	  1698: puts_crlf:
00:0318 CD0403          	  1699:         call    writeSTRBelow
00:031B 000D0A00        	  1700:         defb    '\0\r\n\0'
00:031F C9              	  1701:         ret
                        	  1702: 
                        	  1703: 
                        	  1704: 
                        	  1705: 
                        	  1706: PIO_Init:
                        	  1707: ;----------******************* PIO PORT A
00:0320 3ECF            	  1708: 		ld A, %11001111                 ;mode 3 in/out
00:0322 D301            	  1709: 		out (portA_Contr), A         ; set port A as output
00:0324 3E00            	  1710: 		ld 	A,%00000000					; msb=input lsb = output, 0-mosi, 1-clk, 2-ssel, 7-miso
00:0326 D301            	  1711: 		out (portA_Contr), A         ; set port A as 4 input/ 4 output
                        	  1712: 		; ld A, Interupt_vector&0xFF                   ; low byte of INT table
                        	  1713: 		; out (portA_Contr), A         ; PIO A interrupt vector
00:0328 3E03            	  1714: 		ld A, $03
00:032A D301            	  1715: 		out (portA_Contr), A         ; PIO A interrupt disable
                        	  1716: 		; ld a,Interupt_vector>>8      ; high byte of INT table
                        	  1717: 		; ld I,A
00:032C F3              	  1718: 		di
                        	  1719: ;----------******************* PIO PORT B
00:032D 3ECF            	  1720: 		ld A, %11001111                 ;mode 3 in/out
00:032F D303            	  1721: 		out (portB_Contr), A         ; set port B as output
00:0331 3E00            	  1722: 		ld A, $00                    ;mode 0 output 
00:0333 D303            	  1723: 		out (portB_Contr), A         ; set port B as output
00:0335 3E03            	  1724: 		ld A, $03
00:0337 D303            	  1725: 		out (portB_Contr), A         ; PIO B interrupt disable
00:0339 3E00            	  1726: 		ld a,0
00:033B 32D0F1          	  1727: 		ld (PIO_B_value),a
00:033E D302            	  1728: 		out (portB_Data), a
00:0340 C9              	  1729: 	ret
                        	  1730: 
                        	  1731: 	if DOALIGN
                        	  1732: 		align 4
                        	  1733: 	endif
                        	  1734: 
                        	  1735: 
                        	  1736: ;********************************************************************************************     
                        	  1737: ;********************************************************************************************     
                        	  1738: 
                        	  1739: 		xdef CTC_CH0_Interrupt_Handler,CTC_CH1_Interrupt_Handler,CTC_CH2_Interrupt_Handler,CTC_CH3_Interrupt_Handler
                        	  1740: 
                        	  1741: CTC_CH0_Interrupt_Handler:
                        	  1742: CTC_CH1_Interrupt_Handler:
                        	  1743: 
                        	  1744: 		; call 	TX_NAK
00:0341 CD6602          	  1745: 		call 	TX_C
00:0344 3A0000          	  1746: 		ld 		A,(TempVar1)
00:0347 3C              	  1747: 		inc 	A
00:0348 320000          	  1748: 		ld 		(TempVar1),A
                        	  1749: 
                        	  1750: 
00:034B FE10            	  1751: 		cp 		16							; Z is set 
00:034D F25503          	  1752: 		jp 		P,showtimeout				; check if loop should timeout... A>16
                        	  1753: 
                        	  1754: 		; call	Z,SetupXMODEM_TXandRX		; test if minicom has begun sending Z=0...
                        	  1755: 
00:0350 B7              	  1756: 		or 		A							; clear carry - > wait for next.
00:0351 1E0A            	  1757: 		ld 		E,CTCpulse					; ret from CTC = 0A
                        	  1758: 
00:0353 ED4D            	  1759: 		reti
                        	  1760: 
                        	  1761: ;------------------------------------------------------------------------------
                        	  1762: 
                        	  1763: 
                        	  1764: CTC_CH2_Interrupt_Handler:
                        	  1765: CTC_CH3_Interrupt_Handler:
                        	  1766: 
                        	  1767: 
                        	  1768: showtimeout:
                        	  1769: 		; call 	writeSTRBelow_CRLF
                        	  1770: 		; defb    "\0\r\n"
                        	  1771: 		; defb	"A timout on XMODEM occured !",00
00:0355 97              	  1772: 		sub  	A
00:0356 320000          	  1773: 		ld 		(TempVar1),A
00:0359 D302            	  1774: 		out 	(portB_Data),A
                        	  1775: 
00:035B 37              	  1776: 		scf								; set carry flag 
                        	  1777: 
00:035C FB              	  1778: 		ei
00:035D 1E0B            	  1779: 		ld 		E,CTCtimeout					; ret from CTC = 0B (timeout)
00:035F ED4D            	  1780: 		reti 
                        	  1781: 
                        	  1782: 
                        	  1783: 
                        	  1784: 
                        	  1785: 
                        	  1786: ;********************************************************************************************     
                        	  1787: ;********************************************************************************************     
                        	  1788: 
                        	  1789: 
                        	  1790: 
                        	  1791: CTC_Init:
                        	  1792: 
                        	  1793: 		; ------Reset all---------------
00:0361 3E03            	  1794: 		ld		A,_Reset|_CW		; reset channel
00:0363 D300            	  1795: 		out		(CH0),A
00:0365 D301            	  1796: 		out		(CH1),A
00:0367 D302            	  1797: 		out		(CH2),A
00:0369 D303            	  1798: 		out		(CH3),A
                        	  1799: 
                        	  1800: 		; ------INIT interrupt vectors for SIO /CTC---------------
00:036B 2110F4          	  1801: 		ld 		HL,CTC_CH0_I_Vector          (F410)
00:036E 7D              	  1802: 		ld  	A,L					; copy low byte
00:036F D300            	  1803: 		out 	(CH0),A
                        	  1804: 
                        	  1805: 
00:0371 3E47            	  1806: 		ld 	 	A,_Counter|_TC_Follow|_Reset|_CW
00:0373 D302            	  1807: 		out		(CH2),A
00:0375 3E02            	  1808: 		ld		A,2				; time constant defined
00:0377 D302            	  1809: 		out		(CH2),A			; and loaded into channel 2
                        	  1810: 
                        	  1811: 
                        	  1812: 		;--------init CTC3 (Unused...)----------------------------------
00:0379 3E03            	  1813: 		ld		A,00000011b		; int on, counter on, prescaler don't care, edge don't care,11000111b
00:037B D303            	  1814: 		out		(CH3),A
00:037D 3EAF            	  1815: 		ld		A,0AFh			; time constant AFh defined
00:037F D303            	  1816: 		out		(CH3),A			; and loaded into channel 3
                        	  1817: 		; ld		A,10h			; it vector defined in bit 73,bit 21 don't care, bit 0 = 0
                        	  1818: 
                        	  1819: 		; out		(CH0),A			; and loaded into channel 0
00:0381 C9              	  1820: 		ret
                        	  1821: 
                        	  1822: 		; ------INIT CTC2 Baud frequence  for  10 MHz version SIO------- 
                        	  1823: 		; 		Baud 		SIO_0,clockmode  CTCprescaler freq
                        	  1824: 		;		115200		16x				2			3,684	
                        	  1825: 		;		57600		16x				4			3,684
                        	  1826: 		;		38400		16x				6			3,684
                        	  1827: 		;		19200		16x				12			3,684
                        	  1828: 		; 		9600		16x				24			3,684
                        	  1829: 
                        	  1830: 
                        	  1831: ;********************************************************************************************     
                        	  1832: 
                        	  1833: .end
                        	  1834: 
                        	  1835: 


Symbols by name:
ACK                              E:0006
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CRChar                           E:000D
CRLF                            00:00A5 EXP
CRNL                            00:00A5
CTC1_INT_OFF                    00:0282 EXP
CTC_CH0_I_Vector                 E:F410
CTC_CH0_Interrupt_Handler       00:0341 EXP
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       00:0341 EXP
CTC_CH2_I_Vector                 E:F414
CTC_CH2_Interrupt_Handler       00:0355 EXP
CTC_CH3_I_Vector                 E:F416
CTC_CH3_Interrupt_Handler       00:0355 EXP
CTC_Init                        00:0361 EXP
CTCdelayFlag                    external
CTCpulse                         E:000A
CTCtimeout                       E:000B
CharToSIO_0                     00:029D
Comm_Ptr_list                   external
DOALIGN                          E:0000
ExternINTHandler                00:028B
Extern_B_USB_Handler            00:01C6
FF                               E:000C
GetOutStatus                    00:00CE
InitBuffers                     00:00D5 EXP
InitInterrupt                   00:010F EXP
InitSIO_0Ports                  00:02CF EXP
NAK                              E:0015
OutBufCount                     external
OutINTExpect                    external
PIO_B_value                      E:F1D0
PIO_Init                        00:0320 EXP
R_LOOP                          00:000C
ReadChar                        00:005C EXP
ReadINTHandler                  00:0166
ReadLine                        00:000C EXP
ReadUSBHandler                  00:01B8 EXP
RetInpStatus                    00:0073 EXP
SIO_0INT                        00:02E3 EXP
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        00:01D7 EXP
SIO_A_EI                        00:01CE EXP
SIO_A_RTS_OFF                   00:0204 EXP
SIO_A_RTS_ON                    00:020F EXP
SIO_A_RX_INTon                  00:01FB EXP
SIO_A_TXRX_INToff               00:01E9 EXP
SIO_A_TXRX_INTon                00:01E0 EXP
SIO_A_TX_INTon                  00:01F2 EXP
SIO_B_C                         external
SIO_B_D                         external
SIO_B_DI                        00:0233 EXP
SIO_B_EI                        00:022A EXP
SIO_B_RX_INTon                  00:0218 EXP
SIO_B_TXRX_INToff               00:0221 EXP
SIO_Init                        00:015E EXP
SIO_Int_EXT_Vec                  E:F40A
SIO_Int_Read_Vec                 E:F40C
SIO_Int_Spec_Vec                 E:F40E
SIO_Int_Vec                      E:F400
SIO_Int_WR_Vec                   E:F408
SIO_USB_EXT_Vec                  E:F402
SIO_USB_Read_Vec                 E:F404
SIO_USB_Spec_Vec                 E:F406
SIO_USB_WR_Vec                   E:F400
S_head_tail                     00:007A EXP
SpecINTHandler                  00:0294
SpecINT_B_USB_Handler           00:01CA
TX_ACK                          00:025E EXP
TX_C                            00:0266 EXP
TX_EMP                          00:0276 EXP
TX_NAK                          00:0256 EXP
TX_X                            00:026E EXP
TempVar1                        external
Textbuf                         external
WR1                              E:0001
WR2                              E:0002
WR3                              E:0003
WR4                              E:0004
WR5                              E:0005
WaitOutBuff                     00:00AD
WriteChar                       00:00A9 EXP
WriteINTHandler                 00:0193
WriteLine                       00:0091 EXP
WriteLineCRNL                   00:00A2 EXP
Write_USB_Handler               00:01C2
_Auto_Enable                     E:0020
_CW                              E:0001
_Ch_Reset                        E:0018
_Counter                         E:0040
_Int_All_Rx_Char_NP              E:0018
_RTS_Enable                      E:0002
_RX_8_bits                       E:00C0
_Reset                           E:0002
_Reset_STAT_INT                  E:0010
_Rising                          E:0010
_Rx_Disable                      E:0000
_Rx_Enable                       E:0001
_Status_Vector                   E:0004
_Stop_1_bit                      E:0004
_TC_Follow                       E:0004
_Tx_8bits_char                   E:0060
_Tx_Enable                       E:0008
_Tx_INT_EN                       E:0002
_X16_Clock_mode                  E:0040
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
bmve                            00:0080
bufferSize                      external
c_nextchar                      00:003F
cleanInBuffer                   00:00E9 EXP
cleanOutBuffer                  00:00FA EXP
cont1                           00:0050
cont2                           00:0030
endOutBuffer                    external
exitRHandler                    00:0187
gpioB                           external
gpio_in                         external
gpio_out                        external
inBufCount                      external
inBuffer                        external EXP
inBufferEnd                     external EXP
inHeadAdr                       external
inTailAdr                       external
inbufferDeactivate              external
incInPointer                    00:02B3
incOutPointer                   00:02C1
initSIOBInterrupt               00:02DA EXP
list_len                        external
nodata                          00:01A2
nxtchr                          00:0093
outBuffer                       external
outBufferSize                   external
outHeadAdr                      external
outTailAdr                      external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXA                        00:023C EXP
purgeRXB                        00:0249 EXP
puts_crlf                       00:0318 EXP
showtimeout                     00:0355
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
waitEntry                       00:001B
waitForFinishedPrintout         00:0108 EXP
waitForKey                      00:0000 EXP
wrdone                          00:01AC
writeSTRBelow                   00:0304 EXP
writeSTRBelow_CRLF              00:030E EXP

Symbols by value:
0000 DOALIGN
0000 _Rx_Disable
0000 waitForKey
0001 WR1
0001 _CW
0001 _Rx_Enable
0002 WR2
0002 _RTS_Enable
0002 _Reset
0002 _Tx_INT_EN
0003 WR3
0004 WR4
0004 _Status_Vector
0004 _Stop_1_bit
0004 _TC_Follow
0005 WR5
0006 ACK
0008 _Tx_Enable
000A CTCpulse
000B CTCtimeout
000C FF
000C R_LOOP
000C ReadLine
000D CRChar
0010 _Reset_STAT_INT
0010 _Rising
0015 NAK
0018 _Ch_Reset
0018 _Int_All_Rx_Char_NP
001B waitEntry
0020 _Auto_Enable
0030 cont2
003F c_nextchar
0040 _Counter
0040 _X16_Clock_mode
0050 cont1
005C ReadChar
0060 _Tx_8bits_char
0073 RetInpStatus
007A S_head_tail
0080 bmve
0091 WriteLine
0093 nxtchr
00A2 WriteLineCRNL
00A5 CRLF
00A5 CRNL
00A9 WriteChar
00AD WaitOutBuff
00C0 _RX_8_bits
00CE GetOutStatus
00D5 InitBuffers
00E9 cleanInBuffer
00FA cleanOutBuffer
0108 waitForFinishedPrintout
010F InitInterrupt
015E SIO_Init
0166 ReadINTHandler
0187 exitRHandler
0193 WriteINTHandler
01A2 nodata
01AC wrdone
01B8 ReadUSBHandler
01C2 Write_USB_Handler
01C6 Extern_B_USB_Handler
01CA SpecINT_B_USB_Handler
01CE SIO_A_EI
01D7 SIO_A_DI
01E0 SIO_A_TXRX_INTon
01E9 SIO_A_TXRX_INToff
01F2 SIO_A_TX_INTon
01FB SIO_A_RX_INTon
0204 SIO_A_RTS_OFF
020F SIO_A_RTS_ON
0218 SIO_B_RX_INTon
0221 SIO_B_TXRX_INToff
022A SIO_B_EI
0233 SIO_B_DI
023C purgeRXA
0249 purgeRXB
0256 TX_NAK
025E TX_ACK
0266 TX_C
026E TX_X
0276 TX_EMP
0282 CTC1_INT_OFF
028B ExternINTHandler
0294 SpecINTHandler
029D CharToSIO_0
02B3 incInPointer
02C1 incOutPointer
02CF InitSIO_0Ports
02DA initSIOBInterrupt
02E3 SIO_0INT
0304 writeSTRBelow
030E writeSTRBelow_CRLF
0318 puts_crlf
0320 PIO_Init
0341 CTC_CH0_Interrupt_Handler
0341 CTC_CH1_Interrupt_Handler
0355 CTC_CH2_Interrupt_Handler
0355 CTC_CH3_Interrupt_Handler
0355 showtimeout
0361 CTC_Init
F1D0 PIO_B_value
F400 SIO_Int_Vec
F400 SIO_USB_WR_Vec
F402 SIO_USB_EXT_Vec
F404 SIO_USB_Read_Vec
F406 SIO_USB_Spec_Vec
F408 SIO_Int_WR_Vec
F40A SIO_Int_EXT_Vec
F40C SIO_Int_Read_Vec
F40E SIO_Int_Spec_Vec
F410 CTC_CH0_I_Vector
F412 CTC_CH1_I_Vector
F414 CTC_CH2_I_Vector
F416 CTC_CH3_I_Vector
