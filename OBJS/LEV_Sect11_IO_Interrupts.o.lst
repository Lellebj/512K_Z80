Sections:
00: "Functions" (0-301)


Source: "stdin"
                        	     1: 
                        	     2: 		INCLUDE "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: 
                        	     5: ; ;Function addresses
                        	     6: ; setcursor		= $3100
                        	     7: ; writecommand	= $3180
                        	     8: ; writedata		= $3140
                        	     9: ; testBusyFlag    = $31B0
                        	    10: ; HD44780_main_init = $3000
                        	    11: stacktop: equ	0xFFF0	
                        	    12: 
                        	    13: 
                        	    14: ; PIO addressess...
                        	    15: ;******************************************
                        	    16: 	  ; _Z80PIO_Base= $00
                        	    17: portA_Contr:	equ _Z80PIO_Base + 1
                        	    18: portB_Contr:	equ _Z80PIO_Base + 3
                        	    19: portA_Data:		equ _Z80PIO_Base + 0
                        	    20: portB_Data:		equ _Z80PIO_Base + 2
                        	    21: 
                        	    22: 
                        	    23: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    24: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    25: gpioB:			equ		portB_Data
                        	    26: 
                        	    27: ; SIO_0 stuff
                        	    28: ;******************************************
                        	    29: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    30: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    31: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    32: 				;SIO_0  CHANNEL B DATA
                        	    33: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    34: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    35: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    36: 
                        	    37: sio_ac: 		equ 	SIO_A_C
                        	    38: sio_ad: 		equ 	SIO_A_D
                        	    39: sio_bc: 		equ 	SIO_B_C
                        	    40: sio_bd: 		equ 	SIO_B_D
                        	    41: 
                        	    42: Interupt_vector		= SIO_Int_Vec
                        	    43: 
                        	    44: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    45: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    46: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    47: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    48: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    49: 
                        	    50: 		
                        	    51: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    52: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    53: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    54: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    55: 
                        	    56: ;Write register 0
                        	    57: WR0 equ 0
                        	    58: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    59: _Ch_Reset		equ 3<<3			; 18
                        	    60: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    61: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    62: _Error_Reset 	equ $30				; (30)	
                        	    63: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    64: 
                        	    65: ;Write register 1
                        	    66: WR1 equ 1
                        	    67: _Ext_INT_EN			equ 1
                        	    68: _Tx_INT_EN 			equ 2
                        	    69: _Status_Vector		equ 4
                        	    70: _Rx_INT_Disable		equ 0
                        	    71: _Rx_INT_First_Char  equ $08
                        	    72: _INT_All_Rx_Char_P 	equ $10 
                        	    73: _Int_All_Rx_Char_NP	equ $18
                        	    74: _WAIT_READY_R_T 	equ $20
                        	    75: _WAIT_READY_FUNC	equ $40
                        	    76: _WAIT_READY_EN		equ $80
                        	    77: 
                        	    78: WR2 equ 2
                        	    79: 
                        	    80: ;Write register 3
                        	    81: WR3 equ 3
                        	    82: _Rx_Enable 			equ $01
                        	    83: _Rx_Disable 		equ $00
                        	    84: _Auto_Enable		equ $20
                        	    85: _RX_5_bits			equ $00
                        	    86: _RX_6_bits			equ $40
                        	    87: _RX_7_bits			equ $80
                        	    88: _RX_8_bits			equ $C0
                        	    89: 
                        	    90: ;Write register 4
                        	    91: WR4 equ 4
                        	    92: _Parity_EN			equ $01
                        	    93: _Parity_Even		equ $02
                        	    94: _Stop_1_bit			equ $04
                        	    95: _Stop_1_2_bit		equ $08
                        	    96: _Stop_2_bit			equ $0C
                        	    97: _X1_Clock_mode		equ $00
                        	    98: _X16_Clock_mode		equ $40
                        	    99: _X32_Clock_mode		equ $80
                        	   100: _X64_Clock_mode		equ $C0
                        	   101: 
                        	   102: ;Write register 5
                        	   103: WR5 equ 5
                        	   104: _RTS_Enable			equ $02
                        	   105: _Tx_Enable 			equ $08
                        	   106: _Send_Break			equ $10
                        	   107: _Tx_5bits_char		equ $00
                        	   108: _Tx_7bits_char		equ $20
                        	   109: _Tx_6bits_char		equ $40
                        	   110: _Tx_8bits_char		equ $60
                        	   111: _DTR_Enable 		equ $80
                        	   112: 
                        	   113: EOT_FOUND			equ $02
                        	   114: _err01_				equ	$08
                        	   115: _err02_				equ	$09
                        	   116: _err03_				equ	$0C
                        	   117: _err04_				equ	$0D
                        	   118: _err05_				equ	$0E
                        	   119: CTCpulse			equ $0A
                        	   120: CTCtimeout			equ $0B
                        	   121: 
                        	   122: 
                        	   123: ; CTC stuff
                        	   124: ;******************************************
                        	   125: CH0		equ 	_Z80CTC_Base	  ; = $10
                        	   126: CH1		equ 	_Z80CTC_Base+1	
                        	   127: CH2		equ 	_Z80CTC_Base+2	
                        	   128: CH3		equ 	_Z80CTC_Base+3	
                        	   129: 
                        	   130: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   131: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   132: _Timer 		equ 	$00
                        	   133: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   134: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   135: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   136: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   137: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   138: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   139: 
                        	   140: ; Interrupt vectors for CTC
                        	   141: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   142: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   143: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   144: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   145: 
                        	   146: ; Data tables  (upper EPROM/FLASH)
                        	   147: ; stack  				= $FF00
                        	   148: Heap				= $F000				; space for variable storage
                        	   149: 
                        	   150: ; variables  	(upper ram)
                        	   151: PIO_B_value:		= $F1D0
                        	   152: Result_NumToHex:	= $F1F0
                        	   153: 
                        	   154: 
                        	   155: ; _RAMSTART		= $8010	
                        	   156: ; _EETESTPROG		= $100	
                        	   157: 	
                        	   158: ; _Z80PIO_Base	= $0
                        	   159: ; _Z80CTC_Base	= $10
                        	   160: ; _Z80SIO_Base	= $20
                        	   161: ; _Z80_BankCS  	= 0x30;		/*	 30 - 3F   */
                        	   162: ; _8Bitsout 		= $40;		/*	 40 - 4F  */
                        	   163: ; _CE_RST_BANK 	= 0x50;		/*	 50 - 5F  */
                        	   164: 
                        	   165: ;*****	ALIGN command  : 00 removes all align commands
                        	   166: DOALIGN 	EQU 	00
                        	   167: 
                        	   168: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   169: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   170: CRChar:			EQU		0DH				; carrige return
                        	   171: LFChar:			EQU		0AH				; line feed
                        	   172: NUL			EQU		00
                        	   173: SOH			EQU		01
                        	   174: STX			EQU		02
                        	   175: ETX			EQU		03
                        	   176: EOT			EQU		04
                        	   177: ENQ			EQU		05
                        	   178: ACK			EQU		06
                        	   179: BEL			EQU		07
                        	   180: BS			EQU		08h
                        	   181: HT			EQU		09h
                        	   182: LF			EQU		0AH
                        	   183: VT			EQU		0BH
                        	   184: FF			EQU		0CH
                        	   185: CR			EQU		0DH
                        	   186: SO			EQU		0Eh
                        	   187: SI			EQU		0Fh
                        	   188: DLE			EQU		10h
                        	   189: DC1			EQU		11h
                        	   190: DC2			EQU		12h
                        	   191: DC3			EQU		13h
                        	   192: DC4			EQU		14h
                        	   193: NAK			EQU		15h
                        	   194: SYN			EQU		16h
                        	   195: ETB			EQU		17h
                        	   196: CAN			EQU		18h
                        	   197: EM			EQU		19h
                        	   198: SUB			EQU		1Ah
                        	   199: ESC			EQU		1Bh
                        	   200: FS			EQU		1Ch
                        	   201: GS			EQU		1Dh
                        	   202: RS			EQU		1Eh
                        	   203: US			EQU		1Fh
                        	   204: ITEM		EQU		1Ch
                        	   205: STEND		EQU		1Dh
                        	   206: LISTEND		EQU		1Eh
                        	   207: SP			EQU		20h
                        	   208: 
                        	   209: 
                        	   210: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   211: ;DATA LOCATIONS
                        	   212: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   213: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   214: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   215: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   216: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   217: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   218: 
                        	   219: ;BUFFER CONFIGURATION
                        	   220: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   221: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   222: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   223: 
                        	   224: ;BUFFER SIZES, change to suit
                        	   225: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   226: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   227: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   228: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   229: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   230: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   231: 
                        	   232: 
                        	   233: ;INTERRUPT VECTOR TABLE SETUP
                        	   234: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   235: ;There are 4 reasons the interrupt will occur:
                        	   236: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   237: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   238: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   239: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   240: ;
                        	   241: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   242: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   243: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   244: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   245: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   246: ;
                        	   247: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   248: ; -------   --  --  --  ----  --------------
                        	   249: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   250: ;    B       0   0   1   02H  External/Status Change
                        	   251: ;    B       0   1   0   04H  Receive Character Available
                        	   252: ;    B       0   1   1   06H  Special Receive Condition
                        	   253: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   254: ;    A       1   0   1   0AH  External/Status Change
                        	   255: ;    A       1   1   0   0CH  Receive Character Available
                        	   256: ;    A       1   1   1   0EH  Special Receive Condition
                        	   257: ;
                        	   258: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   259: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   260: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   261: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   262: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   263: 
                        	   264: 
                        	   265: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   266: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   267: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   268: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   269: 
                        	   270: ;****************************************************************************
                        	   271: 
                        	   272: 
                        	   273: 
                        	   274: 
                        	   275: ; Define the memory size to be used for the CP/M configuration
                        	   276: ; MEM:    equ 60
                        	   277: 
                        	   278: ; The CPM origin will be at: (MEM-7)*1024
                        	   279: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   280: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   281: 
                        	   282: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   283: 
                        	   284: 
                        	   285: 

Source: "stdin"
                        	     3: 
                        	     4: 			
                        	     5: 	ifndef ONESECTION
                        	     6: 		Section Functions
                        	     7: 
                        	     8: 	else
                        	     9: 		section singleAssembly
                        	    10: 	endif
                        	    11: 
                        	    12: 
                        	    13: 					
                        	    14: 				
                        	    15: 		; Interrupts
                        	    16: 		; 11A    Unbuffered Input/Output Using an SIO_0          394
                        	    17: 		; 11B    Unbuffered Input/Output Using a PIO 404
                        	    18: 		; 11C    Buffered Input/Output Using an SIO_0          413
                        	    19: 		; 11D   Real-Time Clock and Calendar 425
                        	    20: 
                        	    21: 
                        	    22: ;*************************************************************************************************************
                        	    23: ;*************************************************************************************************************
                        	    24: 		; Unbuffered Input/Output
                        	    25: 		; 														I if full
                        	    26: 		; 														5. INIT: none
                        	    27: 		; 		Title                 Simple interrupt input and output using an SIO_0
                        	    28: 		; 								and single character buffers
                        	    29: 		; 		Name:                 SINTIO
                        	    30: 		; 		Purpose:       This program consists of 5 subroutines which
                        	    31: 		; 					perform-interrupt driven input and output using
                        	    32: 		; 					an SIO_0.
                        	    33: 		; 					ReadChar
                        	    34: 		; 						Read a character
                        	    35: 		; 					INST
                        	    36: 		; 						Determine input status (whether input
                        	    37: 		; 						buffer is empty)
                        	    38: 		; 					OUTCH
                        	    39: 		; 						Write a character
                        	    40: 		; 					OUTST
                        	    41: 		; 						Determine output status (whether output
                        	    42: 		; 						buffer is full)
                        	    43: 		; 					INIT
                        	    44: 		; 						Initialize SIO_0 and interrupt system
                        	    45: 		; 		Entry:         ReadChar
                        	    46: 		; 						No parameters
                        	    47: 		; 					INST
                        	    48: 		; 						No parameters
                        	    49: 		; 					OUTCH
                        	    50: 		; 						Register A = character to transmit
                        	    51: 		; 					OUTST
                        	    52: 		; 						No parameters
                        	    53: 		; 					INIT
                        	    54: 		; 						No parameters
                        	    55: 		; 		Exit:          ReadChar
                        	    56: 		; 						Register A = character
                        	    57: 		; 					INST
                        	    58: 		; 						Carry = 0 if input buffer is empty,
                        	    59: 		; 						1 if character is available
                        	    60: 		; 					OUTCH
                        	    61: 		; 						No parameters
                        	    62: 		; 					OUTST
                        	    63: 		; 						Carry = 0 if output buffer is not
                        	    64: 		; 						full, 1 if i t is full
                        	    65: 		; 					INIT
                        	    66: 		; 						No parameters
                        	    67: 		; 		Registers used: ReadChar - AF
                        	    68: 		; 						INST - AF
                        	    69: 		; 						OUTCH - AF
                        	    70: 		; 						OUTST - AF
                        	    71: 		; 						INIT - AF,BC,HL,I
                        	    72: 
                        	    73: 		; 		Time:           ReadChar
                        	    74: 		; 						72 cycles if a character is available
                        	    75: 		; 						INST
                        	    76: 		; 						27 cycles
                        	    77: 		; 							OUTCH
                        	    78: 		; 							150 cycles if output buffer is not full
                        	    79: 		; 								and output interrupt is expected
                        	    80: 		; 							OUTST
                        	    81: 		; 							27 cycles
                        	    82: 		; 							INIT
                        	    83: 		; 							618 cycles
                        	    84: 		; 							RDHDLR
                        	    85: 		; 							82 cycles
                        	    86: 		; 							WRHDLR
                        	    87: 		; 							160 cycles
                        	    88: 		; 		Size:              Program 202 bytes
                        	    89: 		; 							Data      5 bytes
                        	    90: 
                        	    91: 		; 		,SIO_0 EQUATES
                        	    92: 		; 		SIO_0 IS PROGRAMMED FOR:
                        	    93: 		; 			ASYNCHRONOUS OPERATION
                        	    94: 		; 			16 X BAUD RATE
                        	    95: 		; 			8-BIT CHARACTERS
                        	    96: 		; 		, 1 1/2 STOP BITS
                        	    97: 		; 		,ARBITRARY SIO_0 PORT ADDRESSES
                        	    98: ;**********************************************************************************************************************
                        	    99: ;**********************************************************************************************************************
                        	   100: ;
                        	   101: ;
                        	   102: ; INCH_11A:
                        	   103: ; 		CALL	INST_11A				;GET INPUT STATUS
                        	   104: ; 		JR		NC,INCH_11A				;WAIT IF NO CHARACTER AVAILABLE
                        	   105: ; 		DI							;DISABLE INTERRUPTS
                        	   106: ; 		SUB		A
                        	   107: ; 		LD		(RECDF),A			;INDICATE INPUT BUFFER EMPTY
                        	   108: ; 		LD		A,(RECDAT)			;GET CHARACTER FROM INPUT BUFFER
                        	   109: ; 		EI							;ENABLE INTERRUPTS
                        	   110: ; 		RET
                        	   111: ; 			;RETURN INPUT STATUS (CARRY = 1 IF INPUT DATA IS AVAILABLE)
                        	   112: ; INST_11A:
                        	   113: ; 		LD		A,(RECDF)			;GET DATA READY FLAG
                        	   114: ; 		RRA							;SET CARRY FROM DATA READY FLAG
                        	   115: ; 									;IF CARRY = 1, CHARACTER IS AVAILABLE
                        	   116: ; 		RET
                        	   117: ; 			;WRITE CHARACTER
                        	   118: 
                        	   119: ; OUTCH_11A:
                        	   120: ; 		PUSH	AF					;SAVE CHARACTER TO WRITE
                        	   121: ; 		;WAIT FOR CHARACTER BUFFER TO EMPTY, THEN STORE NEXT CHARACTER
                        	   122: ; WAITOOC_11A:
                        	   123: ; 		CALL	OUTST_11A				;GET OUTPUT STATUS
                        	   124: ; 		JR		C,WAITOOC_11A		;WAIT IF OUTPUT BUFFER IS FULL
                        	   125: ; 		DI							;DISABLE INTERRUPTS WHILE LOOKING AT
                        	   126: ; 									; SOFTWARE FLAGS
                        	   127: ; 		POP		AF					;GET CHARACTER
                        	   128: ; 		LD		(TRNDAT),A			;STORE CHARACTER IN OUTPUT BUFFER
                        	   129: ; 		LD		A,0FFH				;INDICATE OUTPUT BUFFER FULL
                        	   130: ; 		LD		(TRNDF),A
                        	   131: ; 		LD		A,(OutINTExpect)				;TEST OUTPUT INTERRUPT EXPECTED FLAG
                        	   132: ; 		OR		A
                        	   133: ; 		CALL	Z,OUTDAT_11A			;OUTPUT CHARACTER IMMEDIATELY IF
                        	   134: ; 									; NO OUTPUT INTERRUPT EXPECTED
                        	   135: ; 		EI                     	    ;ENABLE INTERRUPTS
                        	   136: ; 		RET
                        	   137: ; 			;OUTPUT STATUS (CARRY    =1   IF OUTPUT BUFFER IS FULL)
                        	   138: ; OUTST_11A:
                        	   139: ; 		LD		A,(TRNDF)			;GET TRANSMIT FLAG
                        	   140: ; 		RRA							;SET CARRY FROM TRANSMIT FLAG
                        	   141: ; 		RET							; CARRY = 1 IF BUFFER FULL
                        	   142: ; 		;INITIALIZE INTERRUPT SYSTEM AND SIO_0
                        	   143: ; INIT_11A:
                        	   144: ; 		DI							;DISABLE INTERRUPTS FOR INITIALIZATION
                        	   145: ; 			; INITIALIZE SOFTWARE FLAGS
                        	   146: ; 		SUB		A
                        	   147: ; 		LD		(RECDF),A			;NO INPUT DATA AVAILABLE
                        	   148: ; 		LD		(TRNDF),A			;OUTPUT BUFFER EMPTY
                        	   149: ; 		LD		(OutINTExpect),A				;NO OUTPUT INTERRUPT EXPECTED
                        	   150: ; 									; SIO_0 IS READY TO TRANSMIT INITIALLY
                        	   151: ; 			;INITIALIZE INTERRUPT VECTORS
                        	   152: ; 		LD      A,SIO_Int_Vec >> 8			;GET INTERRUPT PAGE NUMBER
                        	   153: ; 		LD      I,A				;SET INTERRUPT VECTOR IN zao
                        	   154: ; 		IM      2				;INTERRUPT MODE 2 - VECTORS IN TABLE
                        	   155: ; 								; ON INTERRUPT PAGE
                        	   156: ; 		LD		HL,RDHDLR_11A			;STORE READ VECTOR (INPUT INTERRUPT)
                        	   157: ; 		LD		(SIO_Int_Read_Vec),HL
                        	   158: ; 		LD		HL,WRHDLR_11A			;STORE WRITE VECTOR (OUTPUT INTERRUPT)
                        	   159: ; 		LD		(SIO_Int_WR_Vec),HL
                        	   160: ; 		LD		HL,EXHDLR_11A			;STORE EXTERNAL/STATUS VECTOR
                        	   161: ; 		LD		(SIO_Int_EXT_Vec),HL
                        	   162: ; 		LD		HL,REHDLR_11A			;STORE RECEIVE ERROR VECTOR
                        	   163: ; 		LD		(SIO_Int_Spec_Vec),HL
                        	   164: ; 			; INITIALIZE SIO_0
                        	   165: ; 		LD		HL,SIO_0INT			;GET BASE OF INITIALIZATION ARRAY
                        	   166: ; 		CALL	IPORTS_11A            	;INITIALIZE SIO_0
                        	   167: ; 		EI							;ENABLE INTERRUPTS
                        	   168: ; 		RET
                        	   169: 
                        	   170: ; 			;INPUT (READ) INTERRUPT HANDLER
                        	   171: ; RDHDLR_11A:
                        	   172: ; 		PUSH	AF					;SAVE AF
                        	   173: ; RD1_11A:	IN		A, (SIO_A_D)			;READ DATA FROM SIO_0
                        	   174: ; 		LD		(RECDAT), A			;SAVE DATA IN INPUT BUFFER
                        	   175: ; 		LD		A,0FFH
                        	   176: ; 		LD		(RECDF),A			;INDICATE INPUT DATA AVAILABLE
                        	   177: ; 		POP		AF					;RESTORE AF
                        	   178: ; 		EI							;REENABLE INTERRUPTS
                        	   179: ; 		RETI
                        	   180: ; 			;OUTPUT (WRITE) INTERRUPT HANDLER
                        	   181: ; WRHDLR_11A:
                        	   182: ; 		PUSH	AF
                        	   183: ; 		LD		A,(TRNDF)			;GET DATA AVAILABLE FLAG
                        	   184: ; 		RRA
                        	   185: ; 		JR		NC,NODATA_11A			;JUMP IF NO DATA TO TRANSMIT
                        	   186: ; 		CALL	OUTDAT_11A				;OUTPUT DATA TO SIO_0
                        	   187: ; 		JR		WRDONE_11A
                        	   188: 
                        	   189: ; 		; IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE.
                        	   190: ; 		; WE MUST RESET IT TO AVOID AN ENDLESS LOOP. LATER. WHEN A
                        	   191: ; 		; CHARACTER BECOMES AVAILABLE, WE NEED TO KNOW THAT AN OUTPUT
                        	   192: ; 		; INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED. THE KEY HERE
                        	   193: ; 		; IS THE OUTPUT INTERRUPT EXPECTED FLAG OlE. THIS FLAG IS
                        	   194: ; 		; CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT
                        	   195: ; 		; BEEN SERVICED. IT IS ALSO CLEARED INITIALLY SINCE THE
                        	   196: ; 		; SIO_0 STARTS OUT READY. OlE IS SET WHENEVER DATA IS ACTUALLY
                        	   197: ; 		; SENT TO THE SIO_0. THUS THE OUTPUT ROUTINE OUTCH CAN CHECK
                        	   198: ; 		; OlE TO DETERMINE WHETHER TO SEND THE DATA IMMEDIATELY
                        	   199: ; 		; OR WAIT FOR AN OUTPUT INTERRUPT.
                        	   200: ; 		; THE PROBLEM IS THAT AN.OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
                        	   201: ; 		; THE COMPUTER HAS ANYTHING TO SEND (UNLIKE AN INPUT DEVICE
                        	   202: ; 		; THAT HAS DATA WHEN IT REQUESTS SERVICE). THE OlE FLAG
                        	   203: ; 		; SOLVES THE PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING
                        	   204: ; 		; ITSELF REPEATEDLY. WHILE STILL ENSURING THE RECOGNITION OF
                        	   205: ; 		; OUTPUT INTERRUPTS.
                        	   206: ; NODATA_11A:
                        	   207: ; 		SUB		A
                        	   208: ; 		LD		(OutINTExpect),A				;DO NOT EXPECT AN INTERRUPT
                        	   209: ; 		OUT		(SIO_A_C),A			;SELECT REGISTER 0
                        	   210: ; 		LD		A,00101000B			;RESET SIO_0 TRANSMITTER INTERRUPT
                        	   211: ; 		OUT		(SIO_A_C),A
                        	   212: ; WRDONE_11A:
                        	   213: ; 		POP		AF					;RESTORE AF
                        	   214: ; 		EI
                        	   215: ; 		RETI
                        	   216: ; 			;EXTERNAL/STATUS CHANGED INTERRUPT HANDLER
                        	   217: ; EXHDLR_11A:
                        	   218: ; 		PUSH	AF
                        	   219: ; 		LD		A,00010000B			;RESET STATUS INTERRUPT
                        	   220: ; 		OUT		(SIO_A_C),A
                        	   221: ; 		EI							;DCD OR CTS CHANGED STATE, OR A BREAK
                        	   222: 
                        	   223: ; 		POP		AF					; WAS DETECTED
                        	   224: ; 		RETI						; SERVICE HERE IF NECESSARY
                        	   225: ; 			;SPECIAL RECEIVE ERROR INTERRUPT
                        	   226: ; REHDLR_11A:
                        	   227: ; 		PUSH	AF
                        	   228: ; 		LD		A,00110000B			;RESET RECEIVE ERROR INTERRUPT
                        	   229: ; 		OUT		(SIO_A_C),A
                        	   230: ; 		EI							; FRAMING ERROR OR OVERRUN ERROR
                        	   231: ; 		POP		AF					; OCCURRED
                        	   232: ; 		RETI						; SERVICE HERE IF NECESSARY
                        	   233: 
                        	   234: ; 		;*************************************
                        	   235: ; 		; ROUTINE: OUTDAT
                        	   236: ; 		;PURPOSE: SEND CHARACTER TO SIO_0
                        	   237: ; 		;ENTRY: TRNDAT = CHARACTER
                        	   238: ; 		;EXIT: NONE
                        	   239: ; 		;REGISTERS USED: AF
                        	   240: ; 		;***************************************
                        	   241: ; OUTDAT_11A:
                        	   242: ; 		LD		A,(TRNDAT)			; GET DATA FROM OUTPUT BUFFER
                        	   243: ; 		OUT		(SIO_A_D),A			; SEND DATA TO SIO_0
                        	   244: ; 		SUB		A					; INDICATE OUTPUT BUFFER EMPTY
                        	   245: ; 		LD		(TRNDF),A
                        	   246: ; 		DEC		A					; INDICATE OUTPUT INTERRUPT EXPECTED
                        	   247: ; 		LD		(OutINTExpect),A				; OlE = FF HEX
                        	   248: ; 		RET
                        	   249: 		
                        	   250: ; 		;**************************************
                        	   251: ; 		;ROUTINE: IPORTS
                        	   252: ; 		;PURPOSE: INITIALIZE 1/0 PORTS
                        	   253: ; 		;ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
                        	   254: ; 		;EXIT: DATA OUTPUT TO PORTS
                        	   255: ; 		;REGISTERS USED: AF.BC.HL
                        	   256: ; 		;************************************
                        	   257: 
                        	   258: ; IPORTS_11A:
                        	   259: ; 			;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
                        	   260: ; 			;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
                        	   261: ; 		LD		A,(HL)				;GET NUMBER OF BYTES
                        	   262: ; 		OR		A					;TEST FOR ZERO (TERMINATOR)
                        	   263: ; 		RET		Z					;RETURN IF NUMBER OF BYTES = 0
                        	   264: ; 		LD		B,A
                        	   265: ; 		INC		HL					;POINT TO PORT ADDRESS (NEXT BYTE)
                        	   266: ; 			;C = PORT ADDRESS
                        	   267: ; 			;HL = BASE ADDRESS OF OUTPUT DATA
                        	   268: ; 		LD      C,(HL)				;GET PORT ADDRESS
                        	   269: ; 		INC     HL					;POINT TO FIRST DATA VALUE (NEXT BYTE)
                        	   270: ; 			;OUTPUT DATA AND CONTINUE TO NEXT PORT
                        	   271: ; 		OTIR						;SEND DATA VALUES TO PORT
                        	   272: ; 		JR      IPORTS_11A				;CONTINUE TO NEXT PORT ENTRY
                        	   273: ; 			;SIO_0 INITIALIZATION DATA
                        	   274: ; SIO_0INT_11A:
                        	   275: ; 			;RESET CHANNEL A
                        	   276: ; 		DB		1					;OUTPUT 1 BYTE
                        	   277: ; 		DB		SIO_A_C				;DESTINATION IS CHANNEL A COMMAND/STATUS
                        	   278: ; 		DB		00011000B			;SELECT WRITE REGISTER 0
                        	   279: ; 									;BITS 2,1,0 = 0 (WRITE REGISTER 0)
                        	   280: ; 									;BITS 5.4.3 = 011 (CHANNEL RESET)
                        	   281: ; 									;BITS 7,6 = 0 (DO NOT CARE)
                        	   282: ; 			;SET INTERRUPT VECTOR AND ALLOW STATUS TO AFFECT IT
                        	   283: ; 		DB		4					;OUTPUT 2 BYTES
                        	   284: ; 		DB		SIO_B_C				;DESTINATION IS COMMAND REGISTER B
                        	   285: ; 		DB		00000010B			; SELECT WRITE REGISTER 2
                        	   286: ; 		DB		SIO_Int_Vec&0FFH			;SET INTERRUPT VECTOR FOR SIO_0
                        	   287: ; 		DB		00000001B			;SELECT WRITE REGISTER 1
                        	   288: ; 		DB		00000100B			;ALLOW STATUS TO AFFECT VECTOR
                        	   289: ; 			; INITIALIZE CHANNEL A
                        	   290: ; 		DB		8					;OUTPUT 8 BYTES
                        	   291: ; 		DB		SIO_A_C				;DESTINATION IS COMMAND REGISTER A
                        	   292: ; 			; INITIALIZE BAUD RATE CONTROL
                        	   293: ; 		DB		00010100B			;SELECT WRITE REGISTER 4
                        	   294: ; 									; RESET EXTERNAL/STATUS INTERRUPT
                        	   295: ; 		DB		01001000B			;BIT 0 = 0 (NO PARITY)
                        	   296: ; 									;BIT 1 = 0 (DON'T CARE)
                        	   297: ; 									;BITS 3.2 = 10 (1 1/2 STOP BITS)
                        	   298: ; 									;BITS 5,4 = 00 <nOWT CARE)
                        	   299: ; 									;BITS 7,6 = 01 (16 TIMES CLOCK)
                        	   300: ; 			;INITIALIZE RECEIVE CONTROL
                        	   301: ; 		DB		00000011B			;SELECT WRITE REGISTER 3
                        	   302: ; 		DB		11000001B			;BIT 0 = 1 (RECEIVE ENABLE)
                        	   303: ; 									; BITS 4,3,2,1 = 0 (DON"T CARE)
                        	   304: ; 									;BIT 5 = 0 (NO AUTO ENABLE)
                        	   305: ; 									;BIT 7,6 = 11 (RECEIVE 8 BITS/CHAR)
                        	   306: ; 			; INITIALIZE TRANSMIT CONTROL
                        	   307: ; 		DB		00000101B			;SELECT WRITE REGISTER 5
                        	   308: ; 		DB		11101010B			;BIT 0 = 0 (NO CRC ON TRANSMIT)
                        	   309: ; 									;BIT 1 = 1 (REQUEST TO SEND)
                        	   310: ; 									;BIT 2 = 0 (DON'T CARE)
                        	   311: ; 									;BIT 3 = 1 (TRANSMIT ENABLE)
                        	   312: ; 									;BIT 4 = 0 (DO NOT SEND BREAK)
                        	   313: ; 									;BITS 6,5 = 11 (TRANSMIT 8 BITS/CHAR)
                        	   314: ; 									;BIT 7 = 1 (DATA TERMINAL READY)
                        	   315: ; 		DB		00000001B			;SELECT WRITE REGISTER 1
                        	   316: ; 		DB		00011011B			;BIT 0 = 1 (EXTERNAL INTERRUPTS)
                        	   317: ; 									;BIT 1 = 1 (ENABLE TRANSMIT INTERRUPT)
                        	   318: ; 									;IBIT 2 = 0 (DO NOT CARE)
                        	   319: ; 									;BITS 4,3 = 11 (RECEIVE INTERRUPTS ON
                        	   320: ; 									; ALL CHARS, PARITY DOES NOT AFFECT
                        	   321: ; 									; VECTOR)
                        	   322: ; 									;BITS 7,6,5 = 000 (NO WAIT/READY
                        	   323: ; 									; FUNCTION)
                        	   324: 
                        	   325: ; 		DB	0						;TERMINATOR FOR INITIALIZATION ARRAY
                        	   326: ; 		; DATA SECTION
                        	   327: ; RECDAT:	DS		1					;RECEIVE DATA
                        	   328: ; RECDF: 	DS		1					;RECEIVE DATA FLAG
                        	   329: ; 									; (0 = NO DATA. FF = DATA AVAILABLE)
                        	   330: ; TRNDAT: DS		1					; TRANSMIT DATA
                        	   331: ; TRNDF: 	DS		1					;TRANSMIT DATA FLAG
                        	   332: ; 									; (0 = BUFFER EMPTY. FF = BUFFER FULL)
                        	   333: ; OutINTExpect:	DS		1					;OUTPUT INTERRUPT EXPECTED
                        	   334: ; 									; (0 = NO INTERRUPT EXPECTED,
                        	   335: ; 									; FF = INTERRUPT EXPECTED)
                        	   336: 
                        	   337: 
                        	   338: 
                        	   339: ; 		; SAMPLE EXECUTION:
                        	   340: 
                        	   341: 
                        	   342: ; 		;CHARACTER EQUATES
                        	   343: ; ESCAPE		EQU		1BH                ;ASCII ESCAPE CHARACTER
                        	   344: ; TESTCH		EQU		'A'             ;TEST CHARACTER = A
                        	   345: ; SC11A:
                        	   346: ; 		CALL	INIT_11A            ; INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   347: ; 			;SIMPLE EXAMPLE - READ AND ECHO CHARACTERS
                        	   348: ; 			;UNTIL AN ESC IS RECEIVED
                        	   349: ; LOOP_11A:
                        	   350: ; 		CALL	INCH_11A			; READ CHARACTER
                        	   351: ; 		PUSH	AF
                        	   352: ; 		CALL	OUTCH_11A			; ECHO CHARACTER
                        	   353: ; 		POP		AF
                        	   354: ; 		CP		ESCAPE			;IS CHARACTER AN ESCAPE?
                        	   355: ; 		JR		NZ,LOOP_11A			;STAY IN LOOP IF NOT
                        	   356: ; 			;AN ASYNCHRONOUS EXAMPLE
                        	   357: ; 			; OUTPUT "An TO CONSOLE CONTINUOUSLY. BUT ALSO LOOK AT
                        	   358: ; 			; INPUT SIDE. READING AND ECHOING ANY INPUT CHARACTERS
                        	   359: ; ASYNLP_11A:
                        	   360: ; 			;OUTPUT    AN "A" IF OUTPUT IS NOT BUSY
                        	   361: ; 		CALL	OUTST_11A			;IS OUTPUT BUSY?
                        	   362: ; 		JR		C,ASYNLP_11A        ;JUMP IF IT IS
                        	   363: ; 		LD		A,TESTCH
                        	   364: ; 		CALL	OUTCH_11A			;OUTPUT TEST CHARACTER
                        	   365: ; 			; CHECK INPUT PORT
                        	   366: ; 			; ECHO CHARACTER IF ONE IS AVAILABLE
                        	   367: ; 			; EXIT ON ESCAPE CHARACTER
                        	   368: ; 		CALL	INST_11A			; IS INPUT DATA AVAILABLE?
                        	   369: ; 		JR		NC,ASYNLP_11A		;JUMP IF NOT (SEND ANOTHER "A")
                        	   370: ; 		CALL	INCH_11A			;GET CHARACTER
                        	   371: ; 		CP		ESCAPE			;IS IT AN ESCAPE?
                        	   372: ; 		JR		Z,DONE_11A			;BRANCH IF IT IS
                        	   373: ; 		CALL	OUTCH_11A			;ELSE ECHO CHARACTER
                        	   374: ; 		JP		ASYNLP_11A			;AND CONTINUE
                        	   375: ; DONE_11A:
                        	   376: ; 		JP     LOOP_11A
                        	   377: 
                        	   378: 
                        	   379: 
                        	   380: ;**********************************************************************************************************************
                        	   381: ;**********************************************************************************************************************
                        	   382: 		; Unbuffered Input/Output
                        	   383: 		; 													5. INIT: none
                        	   384: 		; 		Title                Simple interrupt input and output usinQ a                zao
                        	   385: 		; 							PIa and single character buffers
                        	   386: 		; 		Name:                PINTIO
                        	   387: 		; 	Purpose:        This program consists of 5 subroutines which
                        	   388: 		; 					perform interrupt driven input and output using
                        	   389: 		; 					a Z80 PIO.
                        	   390: 		; 					INCH
                        	   391: 		; 						Read a character
                        	   392: 		; 					INST
                        	   393: 		; 						Determine input status (whether input
                        	   394: 		; 						buffer is empty)
                        	   395: 		; 					OUTCH
                        	   396: 		; 						Write a character
                        	   397: 		; 					OUTST
                        	   398: 		; 						Determine output status (whether output
                        	   399: 		; 						buffer is full)
                        	   400: 		; 					INIT
                        	   401: 		; 						Initialize PIO and interrupt system
                        	   402: 		; 	Entry:          INCH
                        	   403: 		; 						No parameters
                        	   404: 		; 					INST
                        	   405: 		; 						No parameters
                        	   406: 		; 					OUTCH
                        	   407: 		; 						Register A = character to transmit
                        	   408: 		; 					OUTST
                        	   409: 		; 						No parameters
                        	   410: 		; 					INIT
                        	   411: 		; 						No parameters
                        	   412: 		; 	Exit :          INCH
                        	   413: 		; 						Register A = character
                        	   414: 		; 					INST
                        	   415: 		; 						Carry = 0 if input buffer is empty,
                        	   416: 		; 						1 if character is available
                        	   417: 		; 					OUTCH
                        	   418: 		; 						No parameters
                        	   419: 		; 					OUTST
                        	   420: 		; 						Carry = 0 if output buffer is not
                        	   421: 		; 						full, 1 if it is full
                        	   422: 		; 					INIT
                        	   423: 		; 						No parameters
                        	   424: 		; 	Registers used: INCH
                        	   425: 		; 						A.F
                        	   426: 		; 					INST
                        	   427: 		; 						A,F
                        	   428: 		; 					OUTCH
                        	   429: 		; 						A,F
                        	   430: 		; 					OUTST
                        	   431: 		; 						A,F
                        	   432: 		; 					INIT
                        	   433: 		; 						A,F,eC,HL,I
                        	   434: 		; 		Time:               INCH
                        	   435: 		; 							72 cycles if a character is available
                        	   436: 		; 							INST
                        	   437: 		; 							27 cycles
                        	   438: 		; 							OUTCH
                        	   439: 		; 							150 cycles if output buffer is not full
                        	   440: 		; 								and output interrupt is expected
                        	   441: 		; 							OUTST
                        	   442: 		; 							27 cycles
                        	   443: 		; 							INIT
                        	   444: 		; 							377 cycles
                        	   445: 		; 							RDHDLR
                        	   446: 		; 							82 cycles
                        	   447: 		; 							WRHDLR
                        	   448: 		; 							178 cycles
                        	   449: 		; 		Size:               Program 166 bytes
                        	   450: 		; 							Data      5 bytes
                        	   451: 		; 		;PIO EQUATES
                        	   452: 		; 		; PIO IS PROGRAMMED FOR:
                        	   453: 		; 			PORT A INPUT
                        	   454: 		; 			PORT B OUTPUT
                        	   455: 		; 		;ARBITRARY PIO PORT ADDRESSES
                        	   456: ;**********************************************************************************************************************
                        	   457: ;**********************************************************************************************************************
                        	   458: 
                        	   459: 
                        	   460: ; PIOAD    EQU      90H             ;PORT A DATA
                        	   461: ; PIOAC    EQU      91H             ;PORT A CONTROL
                        	   462: ; PIOBD    EQU      92H             ;PORT B DATA
                        	   463: ; PIOBC    EQU      93H             :PORT B CONTROL
                        	   464: ; INTRPV   EQU      8000H           ;BASE OF INTERRUPT VECTORS
                        	   465: ; PIOIVA   EQU      INTRPV          ; INTERRUPT VECTOR FOR PORT A
                        	   466: ; PI0IVB   EQU      INTRPV+2        ; INTERRUPT VECTOR FOR PORT B
                        	   467: ; 		:READ CHARACTER
                        	   468: ; INCH:
                        	   469: ; 		CALL      INST              ~GET INPUT STATUS
                        	   470: ; 		JR        NC,INCH           ;WAIT IF NO CHARACTER AVAILABLE
                        	   471: ; 		Dl                          ;DISABLE INTERRUPTS
                        	   472: ; 		SUB       A
                        	   473: ; 		LD        (RECDF),A         ;INDICATE INPUT BUFFER EMPTY
                        	   474: ; 		LD        A. (RECDAT)       :OET CHARACTER FROM INPUT BUFFER
                        	   475: ; 		El                          ;REENABLE INTERRUPTS
                        	   476: ; 		RET
                        	   477: ; 		~RETURN   INPUT STATUS (CARRY    =1   IF INPUT DATA IS AVAILABLE)
                        	   478: ; INST:
                        	   479: ; 		LD        A, (RECDF)        ;GET DATA READY FLAG
                        	   480: ; 		RRA                         ;SET CARRY FROM DATA READY FLAG
                        	   481: ; 									: IF CARRY = 1, CHARACTER IS AVAILABLE
                        	   482: ; 		RET
                        	   483: ; 		; WRITE CHARACTER
                        	   484: ; OUTCH:
                        	   485: ; 		PUSH      AF                :SAVE CHARACTER TO WRITE
                        	   486: 
                        	   487: 
                        	   488: ; 		;WAIT FOR CHARACTER BUFFER TO EMPTY, THEN STORE NEXT CHARACTER
                        	   489: ; WAITOC:
                        	   490: ; 		CALL        OUTST           ;GET OUTPUT STATUS
                        	   491: ; 		JR          C, WAITOC       ;WAIT IF OUTPUT BUFFER IS FULL
                        	   492: ; 		01                          :DISABLE INTERRUPTS WHILE LOOKING AT
                        	   493: ; 									~ SOFTWARE FLAGS
                        	   494: ; 		POP         AF              :GET CHARACTER
                        	   495: ; 		LD          <TRNDAT> .A     :STORE CHARACTER IN OUTPUT BUFFER
                        	   496: ; 		LD          A.OFFH          : INDICATE OUTPUT BUFFER FULL
                        	   497: ; 		LD          <TRNDF)'A
                        	   498: ; 		LD          A,(OutINTExpect)         :TEST OUTPUT INTERRUPT EXPECTED FLAG
                        	   499: ; 		OR          A
                        	   500: ; 		CALL        Z.OUTDAT        :OUTPUT CHARACTER IMMEDIATELY IF
                        	   501: ; 									: NO OUTPUT INTERRUPT EXPECTED
                        	   502: ; 		EI                          :ENABLE INTERRUPTS
                        	   503: ; 		RET
                        	   504: ; 		,OUTPUT STATUS (CARRY = 1 IF OUTPUT BUFFER IS FULL)
                        	   505: ; OUTST:
                        	   506: ; 		LD          A. <TRNDF)      ;GET TRANSMIT FLAG
                        	   507: ; 		RRA                         ~SET CARRY FROM TRANSMIT FLAG
                        	   508: ; 		RET                         ; CARRY = 1 IF OUTPUT BUFFER FULL
                        	   509: ; 		: INITIALIZE PIO AND INTERRUPT SYSTEM
                        	   510: ; INIT:
                        	   511: ; 		DI                          :DISABLE INTERRUPTS
                        	   512: ; 		;INITIALIZE SOFTWARE FLAGS
                        	   513: ; 		SUB     A
                        	   514: ; 		LD      (RECDF>.A       ;NO INPUT DATA AVAILABLE
                        	   515: ; 		LD      (TRNDF>.A       :OUTPUT BUFFER EMPTY
                        	   516: ; 		LD      (OutINTExpect>.A         :NO OUTPUT INTERRUPT EXPECTED
                        	   517: ; 								: DEVICE IS READY INITIALLY
                        	   518: ; 		~INITIALIZE      INTERRUPT VECTORS
                        	   519: ; 		LD          A.INTRPV SHR 8 :GET HIGH BYTE OF INTERRUPT PAGE
                        	   520: ; 		LD          I.A              ;SET INTERRUPT VECTOR IN zao
                        	   521: ; 		1M          2                ; INTERRUPT MODE 2 - VECTORS IN TABLE
                        	   522: ; 									~ ON INTERRUPT PAGE
                        	   523: ; 		LD          HL.RDHDLR        ,STORE READ VECTOR (INPUT INTERRUPT)
                        	   524: ; 		LD          (PIOIVA).HL
                        	   525: ; 		LD          HL.WRHDLR        ,STORE WRITE VECTOR (OUTPUT INTERRUPT)
                        	   526: ; 		LD          (PIOIVB).HL
                        	   527: ; 		,INITIALIZE PIO
                        	   528: ; 		LD      HL.PIOINT           :BASE ADDRESS OF INITIALIZATION ARRAY
                        	   529: ; 		CALL    IPORTS              ; INITIALIZE PIO
                        	   530: ; 		EI                          , ENABLE INTERRUPTS
                        	   531: ; 		RET
                        	   532: ; 		;INPUT (READ) INTERRUPT HANDLER
                        	   533: ; RDHDLR:
                        	   534: ; 		PUSH        AF
                        	   535: ; 		IN          A.(PIOAD)       :READ DATA FROM PIO
                        	   536: ; 		LD          (RECDAT> .A     ,SAVE DATA IN INPUT BUFFER
                        	   537: ; 		LD     A,OFFH           ;INDICATE INPUT DATA AVAILABLE
                        	   538: ; 		LD     (RECDF),A
                        	   539: ; 		POP    AF
                        	   540: ; 		EI                      ;REENABLE INTERRUPTS
                        	   541: ; 		RETI
                        	   542: ; 		;OUTPUT (WRITE) INTERRUPT HANDLER
                        	   543: ; WRHDLR:
                        	   544: ; 		PUSH    AF
                        	   545: ; 		LD      A, <TRNDF)      ;GET DATA AVAILABLE FLAG
                        	   546: ; 		RRA
                        	   547: ; 		JR     NC,NODATA        ;JUMP IF NO DATA TO TRANSMIT
                        	   548: ; 		CALL   OUTDAT           ;OUTPUT DATA TO PIO
                        	   549: ; 		JR     WRDONE
                        	   550: ; 		;IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE,
                        	   551: ; 			WE MUST DISABLE IT TO AVOID AN ENDLESS LOOP. LATER, WHEN A
                        	   552: ; 			CHARACTER BECOMES AVAILABLE. WE NEED TO KNOW THAT AN OUTPUT
                        	   553: ; 			INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED. THE KEY HERE
                        	   554: ; 		; IS THE OUTPUT INTERRUPT EXPECTED FLAG OlE. THIS FLAG IS
                        	   555: ; 			CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT
                        	   556: ; 			BEEN SERVICED. IT IS ALSO CLEARED INITIALLY SINCE THE
                        	   557: ; 			OUTPUT DEVICE IS ASSUMED TO START OUT READY. OlE IS SET
                        	   558: ; 		, WHENEVER DATA IS ACTUALLY SENT TO THE PIO. THUS THE OUTPUT ROUTINE
                        	   559: ; 			OUTCH CAN CHECK OlE TO DETERMINE WHETHER TO SEND THE DATA
                        	   560: ; 		; IMMEDIATELY OR WAIT FOR AN OUTPUT INTERRUPT.
                        	   561: ; 		;THE PROBLEM IS THAT AN OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
                        	   562: ; 			THE COMPUTER HAS ANYTHING TO SEND (UNLIKE AN INPUT DEVICE
                        	   563: ; 			THAT HAS DATA WHEN IT REQUESTS SERVICE). THE OlE FLAG SOLVES
                        	   564: ; 		, THE PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING ITSELF
                        	   565: ; 			REPEATEDLY, WHILE STILL ENSURING THE RECOGNITION OF
                        	   566: ; 			OUTPUT INTERRUPTS.
                        	   567: ; NODATA:
                        	   568: ; 		SUB     A
                        	   569: ; 		LD      (OlE) .A        ; INDICATE NO OUTPUT INTERRUPT EXPECTED
                        	   570: ; 		LD      A.OOOOOOllB     ,DISABLE OUTPUT INTERRUPTS
                        	   571: ; 		OUT     (PIOBC).A
                        	   572: ; WRDONE:
                        	   573: ; 		POP     AF              ;RESTORE REGISTERS
                        	   574: ; 		EI
                        	   575: ; 		RETI
                        	   576: 
                        	   577: ; 		'*************************************
                        	   578: ; 		; ROUTINE: OUTDAT
                        	   579: ; 		; PURPOSE: SEND CHARACTER TO PIO PORT B
                        	   580: ; 		; ENTRY: TRNDAT = CHARACTER
                        	   581: ; 		,EXIT: NONE
                        	   582: ; 		;REGISTERS USED: AF
                        	   583: ; 		;***************************************
                        	   584: ; OUTDAT:
                        	   585: ; 		LD      A. <TRNDAT>     ;GET DATA FROM OUTPUT BUFFER
                        	   586: ; 		OUT     (PIOBD).A       ,SEND DATA TO PIO
                        	   587: ; 		SUB     A               ; INDICATE OUTPUT BUFFER EMPTY
                        	   588: 
                        	   589: 
                        	   590: ; 		LD       (TRNDF),A
                        	   591: ; 		DEC      A                 ;INDICATE OUTPUT INTERRUPT EXPECTED
                        	   592: ; 		LD       (OutINTExpect),A           ; OlE = FF HEX
                        	   593: ; 		LD       A,10000011B       ;ENABLE OUTPUT INTERRUPTS
                        	   594: ; 		OUT      (PIOBC).A
                        	   595: ; 		RET
                        	   596: ; 		;**************************************
                        	   597: ; 		; ROUTINE: IPORTS
                        	   598: ; 		; PURPOSE: INITIALIZE I/O PORTS
                        	   599: ; 		; ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
                        	   600: ; 		:EXIT: DATA OUTPUT TO PORTS
                        	   601: ; 		;REGISTERS USED: AF,BC,HL
                        	   602: ; 		;************************************
                        	   603: ; IPORTS:
                        	   604: ; 		;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
                        	   605: ; 		;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
                        	   606: ; 		LD      A, (HL)          ; GET NUMBER OF BYTES
                        	   607: ; 		OR      A               ;TEST FOR ZERO (TERMINATOR)
                        	   608: ; 		RET     Z               :RETURN IF NUMBER OF BYTES = 0
                        	   609: ; 		LD      B,A
                        	   610: ; 		INC     HL              ;POINT TO PORT ADDRESS (NEXT BYTE)
                        	   611: ; 		:C = PORT ADDRESS
                        	   612: ; 		;HL = BASE ADDRESS OF OUTPUT DATA
                        	   613: ; 		LD      C.(HL)          :GET PORT ADDRESS
                        	   614: ; 		INC     HL              ;POINT TO FIRST DATA VALUE (NEXT BYTE)
                        	   615: ; 		;OUTPUT DATA AND CONTINUE TO NEXT PORT
                        	   616: ; 		OTIR                    ;SEND DATA VALUES TO PORT
                        	   617: ; 		JR      IPORTS          tCONTINUE TO NEXT PORT ENTRY
                        	   618: ; 		;PIO INITIALIZATION DATA
                        	   619: ; 		t PORT A = INPUT
                        	   620: ; 		; PORT B = OUTPUT
                        	   621: ; PIOINT:
                        	   622: ; 		DB       3               ;OUTPUT 3 BYTES
                        	   623: ; 		DB       PIOAC           tDESTINATION IS PORT A CONTROL
                        	   624: ; 		DB       PIOIVA AND OFFH ;SET INTERRUPT VECTOR FOR PORT A
                        	   625: ; 		DB       10001111B       ;BITS 3,2,1,0 = 1111 (MODE SELECT)
                        	   626: ; 								; BITS 5,4 = 00 (DON"T CARE)
                        	   627: ; 								;BITS 7,6 = 01 (INPUT MODE)
                        	   628: ; 		DB       10000111B       ;BITS 3.2.1.0 = 0111 (INTERRUPT CONTROL)
                        	   629: ; 								:BITS 6.5.4 = 000 (DON'T CARE)
                        	   630: ; 								;BITS 7 = 1 (ENABLE INTERRUPTS)
                        	   631: ; 		DB       3               :OUTPUT 3 BYTES
                        	   632: ; 		DB       PIOBC           tDESTINATION IS PORT B CONTROL
                        	   633: ; 		DB       PIOIVB AND OFFH ;SET INTERRUPT VECTOR FOR PORT B
                        	   634: ; 		DB       11001111B       ;BITS 3,2,1,0 = 1111 (MODE SELECT)
                        	   635: ; 								;BITS 5,4 = 00 (DON'T CARE)
                        	   636: ; 								;BITS 7.6 = 00 (CONTROL MODE)
                        	   637: ; 		DB       00000111B       :BITS 3.2.1.0 = 0111 (INTERRUPT CONTROL)
                        	   638: ; 								:BIT 4,5,6 = 000 (DON'T CARE)
                        	   639: ; 								;BITS 7 = 0 (DISABLE INTERRUPTS)
                        	   640: 
                        	   641: ; 		DB        0               ;TERMINATOR FOR INITIALIZATION ARRAY
                        	   642: ; 		; DATA SECTION
                        	   643: ; RECDAT: DS       1                  ;RECEIVE DATA
                        	   644: ; RECDF: DS        1                  ;RECEIVE DATA FLAG
                        	   645: ; 									; (0 = NO DATA. FF      = DATA)
                        	   646: ; TRNDAT: DS          1               ;TRANSMIT DATA
                        	   647: ; TRNDF: DS           1               ;TRANSMIT DATA FLAG
                        	   648: ; 									; (0 = BUFFER EMPTY. FF = BUFFER FULL)
                        	   649: ; OlE:      DS        1               ;OUTPUT INTERRUPT EXPECTED
                        	   650: ; 									; (0 = NO INTERRUPT EXPECTED,
                        	   651: ; 									; FF = INTERRUPT EXPECTED)
                        	   652: 
                        	   653: 
                        	   654: 
                        	   655: ; 		SAMPLE EXECUTION:
                        	   656: 
                        	   657: 
                        	   658: ; 		;CHARACTER EQUATES
                        	   659: ; ESCAPE    EQU     1BH               ; ASCI I ESCAPE CHARACTER
                        	   660: ; TESTCH    EQU     ~A~               ;TEST CHARACTER = A
                        	   661: ; SCllB:
                        	   662: ; 		CALL      INIT            ; INITIALIZE PIO, INTERRUPT SYSTEM
                        	   663: ; 		;SIMPLE EXAMPLE - READ AND ECHO CHARACTERS
                        	   664: ; 		: UNTIL AN ESC IS RECEIVED
                        	   665: ; LOOP:
                        	   666: ; 		CALL      INCH            ;READ CHARACTER
                        	   667: ; 		PUSH      AF
                        	   668: ; 		CALL      OUTCH           ;ECHO CHARACTER
                        	   669: ; 		POP       AF
                        	   670: ; 		CP        ESCAPE          ;IS CHARACTER AN ESCAPE?
                        	   671: ; 		•.JR      NZ,LOOP         ;STAY IN LOOP IF NOT
                        	   672: ; 		;AN ASYNCHRONOUS EXAMPLE
                        	   673: ; 		; OUTPUT "A" TO CONSOLE CONTINUOUSLY. BUT ALSO LOOK AT
                        	   674: ; 		; INPUT SIDE, READING AND ECHOING ANY INPUT CHARACTERS
                        	   675: ; ASYNLP:
                        	   676: ; 		;OUTPUT   AN "A" IF OUTPUT IS NOT BUSY
                        	   677: ; 		CALL      OUTST           ;IS OUTPUT BUSY?
                        	   678: ; 		JR        C,ASYNLP        ;JUMP IF IT IS
                        	   679: ; 		LD        A,TESTCH
                        	   680: ; 		CALL      OUTCH           ;OUTPUT TEST CHARACTER
                        	   681: ; 		;CHECK INPUT PORT
                        	   682: ; 		;ECHO CHARACTER IF ONE IS AVAILABLE
                        	   683: ; 		,EXIT ON ESCAPE CHARACTER
                        	   684: ; 		CALL    INST            ;IS INPUT DATA AVAILABLE?
                        	   685: ; 		JR      NC.ASYNLP       ;JUMP IF NOT (SEND ANOTHER "A")
                        	   686: ; 		CALL    INCH            ;GET THE CHARACTER
                        	   687: ; 		CP      ESCAPE          ;IS IT AN ESCAPE CHARACTER?
                        	   688: 
                        	   689: 
                        	   690: ; 		JR       Z.ASDONE   I JUMP IF IT IS
                        	   691: ; 		CALL     OUTCH      ;ELSE ECHO CHARACTER
                        	   692: ; 		JP       ASVNLP     ;AND CONTINUE
                        	   693: ; ASDONE:
                        	   694: ; 		JP       LOOP
                        	   695: 
                        	   696: 
                        	   697: 
                        	   698: 
                        	   699: 
                        	   700: ;****************************************************************************************************************
                        	   701: 		; Buffered Input/Output
                        	   702: 		; Using an SIO_0 (SINTB)                                                                                    11C
                        	   703: 		; 		Title              Interrupt input and output using a ZSO SIO_0 and
                        	   704: 		; 						multiple-character buffers
                        	   705: 		; 		Name:              SINTB
                        	   706: 		; 		Purpose:           This program consists of 5 subroutines which
                        	   707: 		; 						perform interrupt driven input and output using
                        	   708: 		; 						a ZSO SIO_0.
                        	   709: 		; 						ReadChar
                        	   710: 		; 							Read a character
                        	   711: 		; 						RetInpStatus
                        	   712: 		; 							Determine input status (whether input
                        	   713: 		; 							buffer is empty)
                        	   714: 		; 						WriteChar
                        	   715: 		; 							Write a character
                        	   716: 		; 						RetOutStatus
                        	   717: 		; 							Determine output status (whether output
                        	   718: 		; 							buffer is full)
                        	   719: 		; 						InitBuffers
                        	   720: 		; 							Initialize SIO_0 and interrupt system
                        	   721: 		; 		Entry:             ReadChar
                        	   722: 		; 							No parameters
                        	   723: 		; 						RetInpStatus
                        	   724: 		; 							No pat'ameters
                        	   725: 		; 						WriteChar
                        	   726: 		; 							Register A = character to transmit
                        	   727: 		; 						RetOutStatus
                        	   728: 		; 							No parameters
                        	   729: 		; 						InitBuffers
                        	   730: 		; 							No parameters
                        	   731: 		; 		Exit :          ReadChar(INCH)
                        	   732: 		; 							Register A = character
                        	   733: 		; 						RetInpStatus(INST)
                        	   734: 		; 							Carry = 0 if input buffer is empty,
                        	   735: 		; 							1 if character is available
                        	   736: 		; 						WriteChar(OUTCH)
                        	   737: 		; 							No parameters
                        	   738: 		; 						OUTST
                        	   739: 		; 							Carry = 0 if output buffer is not
                        	   740: 		; 							full. 1 if it is full
                        	   741: 		; 						InitBuffers
                        	   742: 		; 							No parameters
                        	   743: 		; 		Reqisters used: ReadChar
                        	   744: 		; 							AF,C,DE,HL
                        	   745: 		; 						RetInpStatus
                        	   746: 		; 							AF
                        	   747: 		; 						WriteChar
                        	   748: 		; 							AF,DE,HL
                        	   749: 		; 						RetOutStatus
                        	   750: 		; 							AF
                        	   751: 		; 						InitBuffers
                        	   752: 		; 							AF,BC,HL,I
                        	   753: 		; 		Time:           ReadChar
                        	   754: 		; 							Approximately 197 cycles if a character is
                        	   755: 		; 							available
                        	   756: 		; 						RetInpStatus
                        	   757: 		; 							39 cycles
                        	   758: 		; 						WriteChar
                        	   759: 		; 							Approximately 240 cycles if output buffer
                        	   760: 		; 							is not full and output interrupt is expected
                        	   761: 		; 						RetOutStatus
                        	   762: 		; 							34 cycles
                        	   763: 		; 						InitBuffers
                        	   764: 		; 							732 cycles
                        	   765: 		; 						ReadINTHandler
                        	   766: 		; 							Approximately 249 cycles
                        	   767: 		; 						WriteINTHandler
                        	   768: 		; 							Approximately 308 cycles
                        	   769: 		; 		Size:           Program 299 bytes
                        	   770: 		; 						Data     11 bytes plus size of buffers
                        	   771: 		; 		:SIO_0 EQUATES
                        	   772: 		; 			SIO_0 IS PROGRAMMED FOR:
                        	   773: 		; 			ASYNCHRONOUS OPERATION
                        	   774: 		; 			16 X BAUD RATE
                        	   775: 		; 			8-BIT CHARACTERS
                        	   776: 		; 		; 1 1/2 STOP BITS
                        	   777: ;****************************************************************************************************************
                        	   778: ;****************************************************************************************************************
                        	   779: ;****************************************************************************************************************
                        	   780: ;****************************************************************************************************************
                        	   781: ;****************************************************************************************************************
                        	   782: 
                        	   783: 		; Section IOLIB
                        	   784: 
                        	   785: 
                        	   786: 		GLOBAL 	InitBuffers,ReadChar,WriteChar, WriteLine, WriteLineCRNL, ReadLine, CRLF, puts_crlf,cleanInBuffer,cleanOutBuf
                        	   787: 		GLOBAL	S_head_tail, inBufferEnd, inBuffer, writeSTRBelow, writeSTRBelow_CRLF,waitForKey,RetInpStatus
                        	   788: 		GLOBAL	PIO_Init,CTC_Init,SIO_Init,InitInterrupt,CTC1_INT_OFF,initSIOBInterrupt
                        	   789: 		GLOBAL 	SIO_0INT,InitSIO_0Ports,ReadUSBHandler, purgeRXB
                        	   790: 		GLOBAL 	SIO_B_EI,SIO_B_RX_INTon,SIO_B_TXRX_INToff,SIO_B_EI,SIO_B_DI
                        	   791: 
                        	   792: 
                        	   793: 			;ARBITRARY SIO_0 PORT ADDRESSES
                        	   794: 								; INTERRUPT VECTOR
                        	   795: 			;READ   CHARACTER
                        	   796: 		;*************************************
                        	   797: 		; ROUTINE: ReadLine
                        	   798: 		; PURPOSE: Read a line up to CR and store in (HL)
                        	   799: 		; ENTRY: HL = POINTER
                        	   800: 		;EXIT: HL = POINTER 
                        	   801: 		;      A = length of input string (Textbuf)
                        	   802: 		;REGISTERS USED: AF.DE.HL
                        	   803: 		;***************************************
                        	   804: 
                        	   805: waitForKey:
00:0000 3E0C            	   806: 		ld 		A,FF
00:0002 320000          	   807: 		ld 		(inbufferDeactivate),A
                        	   808: 
00:0005 76              	   809: 		halt		; wait for key interrupt
                        	   810: 
00:0006 3E00            	   811: 		ld 		A,00
00:0008 320000          	   812: 		ld 		(inbufferDeactivate),A
                        	   813: 
                        	   814: 
00:000B C9              	   815: 		ret
                        	   816: 
                        	   817: 
                        	   818: 
                        	   819: ReadLine:
                        	   820: R_LOOP:
00:000C CD5C00          	   821: 		call	ReadChar				;read character
00:000F F5              	   822: 		push	AF
00:0010 CDA900          	   823: 		call	WriteChar				;echo character
00:0013 F1              	   824: 		pop		AF
00:0014 FE0D            	   825: 		cp		CRChar					;is character an cr?
00:0016 20F4            	   826: 		jr		NZ,R_LOOP				;stay in loop if not
                        	   827: 
00:0018 CDA500          	   828: 		call	CRNL
                        	   829: 			; copy from inbuf to cursor buffer...
                        	   830: waitEntry:
00:001B CD7A00          	   831: 		call	S_head_tail			; save input heads and tails
                        	   832: 
                        	   833: 
00:001E 2A0000          	   834: 		ld		hl,(Comm_Ptr_list)
00:0021 ED5B0200        	   835: 		ld 		de,(Comm_Ptr_list+2)		; next item in list
00:0025 B7              	   836: 		or 		a				; clear carry
00:0026 ED52            	   837: 		SBC		hl,de 			; number of chars in string (in L)
00:0028 45              	   838: 		ld 		b,l				; store in B
                        	   839: 
                        	   840: 			; detect wraparound (hl)<(de)
00:0029 F23000          	   841: 		jp 		P,cont2			;positive result 	(hl)>(de)
00:002C 3E00            	   842: 		ld 		a,bufferSize 			; length of input buffer
00:002E 80              	   843: 		add		a,b
00:002F 47              	   844: 		ld		b,a				; correct count in B when wraparound
                        	   845: cont2:
00:0030 DD210000        	   846: 		ld	 	ix,Textbuf				; get address of text buffer
00:0034 DD7000          	   847: 		ld		(ix),B		; save length to start of str.
00:0037 DD23            	   848: 		inc 	ix			; resulting  string adr, skip byte with length
                        	   849: 
00:0039 2A0200          	   850: 		ld		hl,(Comm_Ptr_list+2)		; first string start
                        	   851: 
00:003C 110000          	   852: 		ld		DE,inBufferEnd
                        	   853: c_nextchar:
                        	   854: 			;	copy from inbuffer to Textbuf...
00:003F 7E              	   855: 		ld 		a,(hl)				; char from inbuffer
00:0040 DD7700          	   856: 		ld		(ix),a			; save char in textbuf
00:0043 23              	   857: 		inc		hl
00:0044 DD23            	   858: 		inc 	ix
                        	   859: 
                        	   860: 			; check if upper buffer adr 
00:0046 B7              	   861: 		or 		A		; clear carry
00:0047 E5              	   862: 		push 	hl	
00:0048 ED52            	   863: 		SBC		hl,de		; S and Z set  hl=de -> inBufferEnd encountered
00:004A E1              	   864: 		pop 	hl
00:004B 2003            	   865: 		jr 		NZ, cont1			; continue
                        	   866: 			; turnaround (HL) hl = inBuffer.	
00:004D 210000          	   867: 		ld 		hl,inBuffer			; hl = start of input buf
                        	   868: cont1:
00:0050 10ED            	   869: 		djnz 	c_nextchar		; count no chars.
00:0052 AF              	   870: 		xor 	a				; clear a
00:0053 DD7700          	   871: 		ld 		(ix),A			; end with 00H
00:0056 210000          	   872: 		ld		hl,Textbuf
00:0059 7E              	   873: 		ld		a,(hl)			; A = string length (num)
00:005A 23              	   874: 		inc		hl				; HL = addr to first char in string
00:005B C9              	   875: 		ret 					; string stored in textbuffer
                        	   876: 
                        	   877: ReadChar:
00:005C CD7300          	   878: 		CALL	RetInpStatus	;get input status. return. carry = 1 if data available
00:005F 30FB            	   879: 		JR		NC,ReadChar		;wait if no character available
00:0061 F3              	   880: 		DI                      ;disable interrupts
00:0062 210000          	   881: 		LD		HL,inBufCount			;reduce input buffer count by 1
00:0065 35              	   882: 		DEC		(HL)
00:0066 2A0000          	   883: 		LD		HL, (inHeadAdr)		;Get   character from head of input buffer
00:0069 4E              	   884: 		LD		C, (HL)
00:006A CD3C02          	   885: 		CALL	incInPointer			;Move head pointer up 1
00:006D 220000          	   886: 		LD		(inHeadAdr) ,HL
00:0070 79              	   887: 		LD		A,C
00:0071 FB              	   888: 		EI						;Reenable interrupts
00:0072 C9              	   889: 		RET
                        	   890: 			;return input status (carry    =1   if input data is available)
                        	   891: RetInpStatus:
00:0073 3A0000          	   892: 		LD		A, (inBufCount)		;Test input buffer count
00:0076 B7              	   893: 		OR		A				;Clear carry always
00:0077 C8              	   894: 		RET		Z				; Return, carry = 0 if no data
00:0078 37              	   895: 		SCF                     ;Set carry
00:0079 C9              	   896: 		RET                     ; Return. carry = 1 if data available
                        	   897: 
                        	   898: 
                        	   899: 			; Save copies of inHeadAdr and inTailAdr to memory...
                        	   900: S_head_tail:
                        	   901: 
00:007A DD210200        	   902: 		ld 		ix,Comm_Ptr_list+2
00:007E 06FE            	   903: 		ld 		b,list_len-2
                        	   904: bmve:
00:0080 DD7E00          	   905: 		ld 		a,(ix)
00:0083 DD7702          	   906: 		ld 		(ix+2),A
00:0086 DD2B            	   907: 		dec		ix
00:0088 10F6            	   908: 		djnz 	bmve		; shift data upwards...
                        	   909: 
00:008A 2A0000          	   910: 		LD		HL, (inHeadAdr)		;GET   CHARACTER FROM HEAD OF INPUT BUFFER
00:008D 220000          	   911: 		ld 		(Comm_Ptr_list),HL
00:0090 C9              	   912: 		ret
                        	   913: 			; Write line from address in iy (until char = 00)
                        	   914: WriteLine:
                        	   915: 		; ld 		b,(iy)		; get length
00:0091 FD23            	   916: 		inc		iy			; First pos point to str length, Dont check length, skip first len byte 22.05.01
                        	   917: nxtchr:
00:0093 FD7E00          	   918: 		ld 		a,(iy)
00:0096 B7              	   919: 		or		A			; = 0 ??
00:0097 C8              	   920: 		ret 	z
00:0098 E5              	   921: 		push	hl
00:0099 CDA900          	   922: 		call	WriteChar
00:009C E1              	   923: 		pop 	hl
00:009D FD23            	   924: 		inc		iy
                        	   925: 		; djnz	nxtchr
00:009F 18F2            	   926: 		jr 		nxtchr
                        	   927: 
00:00A1 C9              	   928: 		ret					; return on maxlength
                        	   929: 			; WriteLine from address (iy) (until char = 00)and add CRLF 
                        	   930: WriteLineCRNL:
00:00A2 CD9100          	   931: 		call	WriteLine
                        	   932: 			; Entry for excl. output CRNL
                        	   933: CRNL:
                        	   934: CRLF:
00:00A5 CDA102          	   935: 		call	puts_crlf
00:00A8 C9              	   936: 		ret
                        	   937: 
                        	   938: 			;Write character
                        	   939: WriteChar:
00:00A9 C5              	   940: 		push 	BC
00:00AA D5              	   941: 		push 	DE
00:00AB E5              	   942: 		push 	HL				; save the reg  for hexdump...
00:00AC F5              	   943: 		PUSH	AF				;SAVE CHARACTER TO OUTPUT
                        	   944: 			;wait for output buffer not full, then store next character
                        	   945: WaitOutBuff:
00:00AD CDCE00          	   946: 		call	GetOutStatus			; get output status. Carry=1 if buffer full, 0 if not
00:00B0 38FB            	   947: 		jr		C,WaitOutBuff			; wait if output buffer is full
00:00B2 F3              	   948: 		di                     			; disable interrupts while looking at
                        	   949: 										; buffer, interrupt status
00:00B3 210000          	   950: 		ld		HL,OutBufCount
00:00B6 34              	   951: 		inc		(HL)					; increase output buffer count by 1
00:00B7 2A0000          	   952: 		ld		HL, (outTailAdr)		; point to next empty byte in buffer
00:00BA F1              	   953: 		pop		AF						; get character
00:00BB 77              	   954: 		ld		(HL),A					; store character at tail of buffer
00:00BC CD4A02          	   955: 		call	incOutPointer			; move tail pointer up 1
00:00BF 220000          	   956: 		ld		(outTailAdr),HL
00:00C2 3A0000          	   957: 		ld		A,(OutINTExpect)		; test output interrupt expected flag
00:00C5 B7              	   958: 		or		A
00:00C6 CC2602          	   959: 		call	Z,CharToSIO_0			; output character immediately if
                        	   960: 										; output interrupt not expected
00:00C9 E1              	   961: 		pop 	HL		
00:00CA D1              	   962: 		pop 	DE	
00:00CB C1              	   963: 		pop 	BC			
00:00CC FB              	   964: 		ei						;reenable interrupts
00:00CD C9              	   965: 		ret
                        	   966: 			;output status (carry=1 if buffer is full)
                        	   967: GetOutStatus:
00:00CE 3A0000          	   968: 		ld		A, (OutBufCount)		; get current output buffer count
00:00D1 FE00            	   969: 		cp		outBufferSize			; compare to maximum
00:00D3 3F              	   970: 		ccf						; complement carry
00:00D4 C9              	   971: 		ret						; carry = 1 if buffer full, 0 if not
                        	   972: 			; INITIALIZE SIO_0, Interrupt system
                        	   973: InitBuffers:
                        	   974: 			; initialize buffer counters and pointers.
00:00D5 97              	   975: 		sub		A					; zero A
00:00D6 320000          	   976: 		ld		(OutINTExpect),A	; indicate no output interruptS
00:00D9 320000          	   977: 		ld		(inBufCount),A		; buffer counters = 0
00:00DC 320000          	   978: 		ld		(OutBufCount),A
00:00DF CDE900          	   979: 		call	cleanInBuffer
00:00E2 CDFA00          	   980: 		call	cleanOutBuffer
00:00E5 CD0801          	   981: 		call 	InitInterrupt		; init interrupt vectors
00:00E8 C9              	   982: 		ret
                        	   983: 
                        	   984: cleanInBuffer:
00:00E9 97              	   985: 		sub		A					; zero A
00:00EA 320000          	   986: 		ld		(inBufCount),A		; buffer counters = 0
00:00ED 320000          	   987: 		ld 		(inbufferDeactivate),A  ; clear flag for input buffer update...
00:00F0 210000          	   988: 		ld		HL,inBuffer			; all buffer pointers = base address
00:00F3 220000          	   989: 		ld		(inHeadAdr),HL
00:00F6 220000          	   990: 		ld		(inTailAdr),HL
00:00F9 C9              	   991: 		ret
                        	   992: cleanOutBuffer:
00:00FA 97              	   993: 		sub		A					; zero A
00:00FB 320000          	   994: 		ld		(OutBufCount),A
00:00FE 210000          	   995: 		ld		HL,outBuffer
00:0101 220000          	   996: 		ld		(outHeadAdr),HL
00:0104 220000          	   997: 		ld		(outTailAdr),HL
00:0107 C9              	   998: 		ret
                        	   999: 
                        	  1000: ;******************************************************************************
                        	  1001: InitInterrupt:
                        	  1002: 			;INITIALIZE INTERRUPT VECTORS (SIO_0)
                        	  1003: 			; initialize . interrupt flag
00:0108 3EF4            	  1004: 		ld		A,SIO_Int_Vec>>8		;GET HIGH BYTE OF INTERRUPT PAGE   (F400 >> 8 = F4)
00:010A ED47            	  1005: 		ld		I,A             ;SET INTERRUPT VECTOR IN zao
00:010C ED5E            	  1006: 		im		2               ; INTERRUPT MODE 2 - VECTORS IN TABLE
00:010E 215F01          	  1007: 		ld		HL,ReadINTHandler      	 ; ON INTERRUPT PAGE
00:0111 220CF4          	  1008: 		ld		(SIO_Int_Read_Vec),HL		;STORE READ VECTOR
00:0114 218701          	  1009: 		ld		HL,WriteINTHandler
00:0117 2208F4          	  1010: 		ld		(SIO_Int_WR_Vec),HL		;STORE WRITE VECTOR
00:011A 211402          	  1011: 		ld		HL,ExternINTHandler
00:011D 220AF4          	  1012: 		ld		(SIO_Int_EXT_Vec),HL		;STORE EXTERNAL/STATUS VECTOR
00:0120 211D02          	  1013: 		ld		HL,SpecINTHandler
00:0123 220EF4          	  1014: 		ld		(SIO_Int_Spec_Vec),HL		;STORE SPECIAL RECEIVE VECTOR
00:0126 21A701          	  1015: 		ld		HL,ReadUSBHandler      	 ; ON INTERRUPT PAGE
00:0129 2204F4          	  1016: 		ld		(SIO_USB_Read_Vec),HL		;STORE READ VECTOR
                        	  1017: 		
00:012C 21C301          	  1018: 		ld 		HL,Write_USB_Handler
00:012F 2200F4          	  1019: 		ld		(SIO_USB_WR_Vec),HL		;STORE READ VECTOR
00:0132 21CF01          	  1020: 		ld 		HL,Extern_B_USB_Handler
00:0135 2202F4          	  1021: 		ld 		(SIO_USB_EXT_Vec),HL
00:0138 21DB01          	  1022: 		ld 		HL,SpecINT_B_USB_Handler
00:013B 2206F4          	  1023: 		ld 		(SIO_USB_Spec_Vec),HL
                        	  1024: 		
                        	  1025: 				; INT Vectors  for the CTC 
00:013E 21CA02          	  1026: 		ld		HL,CTC_CH0_Interrupt_Handler
00:0141 2210F4          	  1027: 		ld		(CTC_CH0_I_Vector),HL		;STORE CTC channel 0 VECTOR
00:0144 21CA02          	  1028: 		ld		HL,CTC_CH1_Interrupt_Handler
00:0147 2212F4          	  1029: 		ld		(CTC_CH1_I_Vector),HL		;STORE CTC channel 1 VECTOR
00:014A 21DE02          	  1030: 		ld		HL,CTC_CH2_Interrupt_Handler
00:014D 2214F4          	  1031: 		ld		(CTC_CH2_I_Vector),HL		;STORE CTC channel 2 VECTOR
00:0150 21DE02          	  1032: 		ld		HL,CTC_CH3_Interrupt_Handler
00:0153 2216F4          	  1033: 		ld		(CTC_CH3_I_Vector),HL		;STORE CTC channel 3 VECTOR
                        	  1034: 
00:0156 C9              	  1035: 		ret
                        	  1036: SIO_Init:		
                        	  1037: 		;INITIALIZE I/O PORTS
00:0157 216C02          	  1038: 		ld      HL,SIO_0INT		;BASE ADDRESS OF INITIALIZATION ARRAY
00:015A CD5802          	  1039: 		call    InitSIO_0Ports			; INITIALIZE SIO_0
00:015D FB              	  1040: 		ei						; ENABLE INTERRUPTS
00:015E C9              	  1041: 		ret
                        	  1042: 
                        	  1043: 
                        	  1044: ;******************************************************************************
                        	  1045: 				;Channel A: INPUT (READ) INTERRUPT HANDLER
                        	  1046: ReadINTHandler:
00:015F F5              	  1047: 		push	AF				;SAVE REGISTERS
00:0160 C5              	  1048: 		push	BC
00:0161 D5              	  1049: 		push	DE
00:0162 E5              	  1050: 		push   	HL
                        	  1051: 	
00:0163 DB00            	  1052: 		in		A,(SIO_A_D)		; read data from SIO_0
00:0165 4F              	  1053: 		ld		C,A					; save data in register c
00:0166 3A0000          	  1054: 		ld 		a,(inbufferDeactivate)
00:0169 FE00            	  1055: 		cp 		$00 					; =0 		
00:016B 2013            	  1056: 		jr 		nz,exitRHandler
                        	  1057: 
00:016D 210000          	  1058: 		ld		HL,inBufCount		; any room in input buffer?
00:0170 7E              	  1059: 		ld		A, (HL)
00:0171 FE00            	  1060: 		cp		bufferSize
00:0173 300B            	  1061: 		jr		NC,exitRHandler		; jump if no room
00:0175 34              	  1062: 		inc		(HL)				; increment input buffer counter
00:0176 2A0000          	  1063: 		ld		HL, (inTailAdr)		; store character at tail of input buffer
00:0179 71              	  1064: 		ld		(HL),C
00:017A CD3C02          	  1065: 		call	incInPointer		; increment tail pointer
00:017D 220000          	  1066: 		ld		(inTailAdr), HL
                        	  1067: exitRHandler:
00:0180 E1              	  1068: 		pop		HL				;restore registers
00:0181 D1              	  1069: 		pop		DE
00:0182 C1              	  1070: 		pop		BC
00:0183 F1              	  1071: 		pop		AF
00:0184 FB              	  1072: 		ei						;reenable interrupts
00:0185 ED4D            	  1073: 		reti
                        	  1074: 
                        	  1075: ;******************************************************************************
                        	  1076: 			;Channel A: output (write) interrupt handler
                        	  1077: WriteINTHandler:
00:0187 F5              	  1078: 		push	AF					;save registers
00:0188 C5              	  1079: 		push	BC
00:0189 D5              	  1080: 		push	DE
00:018A E5              	  1081: 		push	HL
00:018B 3A0000          	  1082: 		ld		A, (OutBufCount)	;get output buffer counter
00:018E B7              	  1083: 		or		A					;test for empty buffer
00:018F 2805            	  1084: 		jr		Z,nodata			;jump if no data to transmit
00:0191 CD2602          	  1085: 		call	CharToSIO_0			;else output data
00:0194 180A            	  1086: 		jr		wrdone
                        	  1087: 			;if an output interrupt occurs when no data is available.
                        	  1088: 			; we must disable output interrupts to avoid an endless loop.
                        	  1089: 			; when the next character is ready, it must be sent immediately
                        	  1090: 			; since no interrupt will occur. this state in which an output
                        	  1091: 			; interrupt has occurred but has not been serviced is indicated
                        	  1092: 			; by clearing ole (output interrupt expected flag).
                        	  1093: nodata:
00:0196 97              	  1094: 		sub		A
00:0197 320000          	  1095: 		ld		(OutINTExpect),a				;00 not expect an interrupt
00:019A D302            	  1096: 		out		(SIO_A_C),a			;select register 0
00:019C 3E28            	  1097: 		ld		a,00101000b			;reset transmitter interrupt
00:019E D302            	  1098: 		out		(SIO_A_C),a
                        	  1099: wrdone:
00:01A0 E1              	  1100: 		pop		HL					;restore registers
00:01A1 D1              	  1101: 		pop		DE
00:01A2 C1              	  1102: 		pop		BC
00:01A3 F1              	  1103: 		pop		AF
00:01A4 FB              	  1104: 		ei
00:01A5 ED4D            	  1105: 		reti
                        	  1106: ;******************************************************************************
                        	  1107: 
                        	  1108: 
                        	  1109: 
                        	  1110: 		; *** 	interrupt at input from HC376S
                        	  1111: ReadUSBHandler:
00:01A7 DB01            	  1112: 		in  	A,(sio_bd)		  		;read char from SIO B
00:01A9 5F              	  1113: 		ld 		E,A
                        	  1114: 
                        	  1115: 		;GPIODEBUG
00:01AA E5              	  1116: 		push HL
00:01AB 2A0000          	  1117: 		ld  HL,(TempVar4)
00:01AE 77              	  1118: 		ld  (HL),a
00:01AF 23              	  1119: 		inc HL
00:01B0 220000          	  1120: 		ld (TempVar4),HL
00:01B3 E1              	  1121: 		pop HL
                        	  1122: 
                        	  1123: 		;GPIODEBUG
00:01B4 3E01            	  1124: 		ld a,1
00:01B6 D302            	  1125: 		out (gpio_out),A
00:01B8 3E00            	  1126: 		ld a,0
00:01BA D302            	  1127: 		out (gpio_out),A
00:01BC 7B              	  1128: 		ld a,e
                        	  1129: 
00:01BD CD0000          	  1130: 		call 	purgeRXB
                        	  1131: 
                        	  1132: 		; in  	A,(CH1)
                        	  1133: 		; ld 		(TempVar8),A
                        	  1134: 		; in  	A,(CH0)
                        	  1135: 		; ld 		(TempVar7),A
                        	  1136: ; 		cp 		USB_INT_CONNECT
                        	  1137: ; 		jr  	NZ,.p2
                        	  1138: ; 		call 	writeSTRBelow_CRLF
                        	  1139: ; 		db		0,">USB_INT_CONNECT",0,0
                        	  1140: ; 		jr 		.p3
                        	  1141: ; .p2:
                        	  1142: ; 		cp 		USB_INT_DISCONNECT
                        	  1143: ; 		jr 		NZ,.p3
                        	  1144: ; 		call 	writeSTRBelow_CRLF
                        	  1145: ; 		db		0,">USB_INT_DISCONNECT",0,0
                        	  1146: .p3:
                        	  1147: 		
                        	  1148: 
00:01C0 FB              	  1149: 		ei
00:01C1 ED4D            	  1150: 		reti
                        	  1151: ;********************************************************************************************     
                        	  1152: Write_USB_Handler:
                        	  1153: 		;GPIODEBUG
00:01C3 3E14            	  1154: 		ld a,20
00:01C5 D302            	  1155: 		out (gpio_out),A
00:01C7 3E00            	  1156: 		ld a,0
00:01C9 D302            	  1157: 		out (gpio_out),A
00:01CB 7B              	  1158: 		ld a,e
                        	  1159: 
00:01CC FB              	  1160: 		ei
00:01CD ED4D            	  1161: 		reti
                        	  1162: 			;external/status changed interrupt handler
                        	  1163: Extern_B_USB_Handler:
                        	  1164: 		;GPIODEBUG
00:01CF 3E15            	  1165: 		ld a,21
00:01D1 D302            	  1166: 		out (gpio_out),A
00:01D3 3E00            	  1167: 		ld a,0
00:01D5 D302            	  1168: 		out (gpio_out),A
00:01D7 7B              	  1169: 		ld a,e
00:01D8 FB              	  1170: 		ei							; dcd or cts line changed state. or a
00:01D9 ED4D            	  1171: 		reti						; break was detected
                        	  1172: 									; service here if necessary
                        	  1173: 			;special receive error interrupt
                        	  1174: SpecINT_B_USB_Handler:
                        	  1175: 		;GPIODEBUG
00:01DB 3E16            	  1176: 		ld a,22
00:01DD D302            	  1177: 		out (gpio_out),A
00:01DF 3E00            	  1178: 		ld a,0
00:01E1 D302            	  1179: 		out (gpio_out),A
00:01E3 7B              	  1180: 		ld a,e
00:01E4 FB              	  1181: 		ei							;framing error or overrun error occurred
00:01E5 ED4D            	  1182: 		reti						; service here if necessary
                        	  1183: 
                        	  1184: 
                        	  1185: SIO_B_RX_INTon:
                        	  1186: 		;enable SIO_0 channel A RX
00:01E7 3E01            	  1187: 		ld		A,WR1							;write into WR0: select WR1
00:01E9 D303            	  1188: 		out		(sio_bc),A
00:01EB 3E1C            	  1189: 		ld 		A,_Int_All_Rx_Char_NP|_Status_Vector  		;RX interrupt on
00:01ED D303            	  1190: 		out		(sio_bc),A	Channel A RX active
00:01EF C9              	  1191: 		RET
                        	  1192: 
                        	  1193: 
                        	  1194: SIO_B_TXRX_INToff:
                        	  1195: 		;enable SIO_0 channel B RX
00:01F0 3E01            	  1196: 		ld		A,WR1			; write into WR0: select WR1
00:01F2 D303            	  1197: 		out		(sio_bc),A
00:01F4 3E00            	  1198: 		ld		A,00h			; RX and TX interrupt off
00:01F6 D303            	  1199: 		out		(sio_bc),A		; Channel B RX 
00:01F8 C9              	  1200: 		RET
                        	  1201: 
                        	  1202: SIO_B_EI:
                        	  1203: 		;enable SIO_0 channel B RX
00:01F9 3E03            	  1204: 		ld		a,003h			;write into WR0: select WR3
00:01FB D303            	  1205: 		out		(sio_bc),A
00:01FD 3EC1            	  1206: 		ld		a,0C1h			;RX 8bit, auto enable off, RX on
00:01FF D303            	  1207: 		out		(sio_bc),A	Channel A RX active
00:0201 C9              	  1208: 		RET
                        	  1209: 	
                        	  1210: 	
                        	  1211: SIO_B_DI:
                        	  1212: 		;disable SIO_0 channel B RX
00:0202 3E03            	  1213: 		ld		a,WR3			;write into WR0: select WR3
00:0204 D303            	  1214: 		out		(sio_bc),A
00:0206 3EC0            	  1215: 		ld		a,_RX_8_bits|_Rx_Disable			;RX 8bit, auto enable off, RX off
00:0208 D303            	  1216: 		out		(sio_bc),A
                        	  1217: 		;Channel A RX inactive
00:020A C9              	  1218: 		ret
                        	  1219: 
                        	  1220: 
                        	  1221: 
                        	  1222: 
                        	  1223: ;********************************************************************************************     
                        	  1224: 
                        	  1225: 
                        	  1226: 				; return with A=0, Z set
                        	  1227: CTC1_INT_OFF:
00:020B 3E53            	  1228: 		ld		A,_Counter|_Rising|_Reset|_CW	
00:020D D301            	  1229: 		out		(CH1),A			; reset and turn off interrupt CH1
00:020F AF              	  1230: 		xor 	A 				; clear A
00:0210 320000          	  1231: 		ld 		(CTCdelayFlag),A ; reset timeout flag
00:0213 C9              	  1232: 		ret							; return with A=0, Z set
                        	  1233: ;******************************************************************************
                        	  1234: 
                        	  1235: 
                        	  1236: 			;external/status changed interrupt handler
                        	  1237: ExternINTHandler:
00:0214 F5              	  1238: 		push	AF
00:0215 3E10            	  1239: 		ld		A,00010000b			;reset status interrupt
                        	  1240: 
00:0217 D302            	  1241: 		out		(SIO_A_C),a
00:0219 F1              	  1242: 		pop		AF
00:021A FB              	  1243: 		ei							; dcd or cts line changed state. or a
00:021B ED4D            	  1244: 		reti						; break was detected
                        	  1245: 									; service here if necessary
                        	  1246: 			;special receive error interrupt
                        	  1247: SpecINTHandler:
00:021D F5              	  1248: 		push	AF
00:021E 3E30            	  1249: 		ld		A,00110000b			;reset receive error interrupt
00:0220 D302            	  1250: 		out		(SIO_A_C),a
00:0222 F1              	  1251: 		pop		AF
00:0223 FB              	  1252: 		ei							;framing error or overrun error occurred
00:0224 ED4D            	  1253: 		reti						; service here if necessary
                        	  1254: 
                        	  1255: 		;*************************************
                        	  1256: 		; 	routine: chartoSIO_0
                        	  1257: 		; 	purpose: send character to SIO_0
                        	  1258: 		; 	entry: none
                        	  1259: 		;	exit: none
                        	  1260: 		;	registers used: af.de.hl
                        	  1261: 		;***************************************
                        	  1262: CharToSIO_0:
00:0226 2A0000          	  1263: 		ld		HL,(outHeadAdr)
00:0229 7E              	  1264: 		ld		A, (HL)					;get data from head of output buffer
00:022A D300            	  1265: 		out		(SIO_A_D),A			;output data
                        	  1266: 
                        	  1267: 
00:022C CD4A02          	  1268: 		call	incOutPointer			; increment head pointer
00:022F 220000          	  1269: 		ld		(outHeadAdr),HL
00:0232 210000          	  1270: 		ld		HL,OutBufCount			;decrement output buffer count
00:0235 35              	  1271: 		dec		(HL)
00:0236 3EFF            	  1272: 		ld		a,0ffh
00:0238 320000          	  1273: 		ld		(OutINTExpect),a		;expect an output interrupt
00:023B C9              	  1274: 		ret
                        	  1275: 
                        	  1276: 
                        	  1277: 		;*************************************
                        	  1278: 		; routine: incinpointer
                        	  1279: 		; purpose: increment pointer into input
                        	  1280: 		;			buffer with wraparound
                        	  1281: 		; entry: hl = pointer
                        	  1282: 		;exit: hl = pointer incremented with wraparound
                        	  1283: 		;registers used: af.de.hl
                        	  1284: 		;***************************************
                        	  1285: incInPointer:
00:023C 23              	  1286: 		INC		HL					; increment pointer
00:023D 110000          	  1287: 		LD		DE,inBufferEnd			;compare pointer. end of buffer
00:0240 7D              	  1288: 		LD		A,L
00:0241 BB              	  1289: 		CP		E
00:0242 C0              	  1290: 		RET		NZ
00:0243 7C              	  1291: 		LD		A,H
00:0244 BA              	  1292: 		CP		D
00:0245 C0              	  1293: 		RET		NZ					;return if not equal
00:0246 210000          	  1294: 		LD		HL,inBuffer				;if pointer at end of buffer.
00:0249 C9              	  1295: 		RET                   	  ; set it back to base address
                        	  1296: 		
                        	  1297: 		
                        	  1298: 		;*************************************
                        	  1299: 		; routine: incoutpointer
                        	  1300: 		; purpose: increment pointer into output
                        	  1301: 		;			buffer with wraparound
                        	  1302: 		; entry: HL =  pointer
                        	  1303: 		;exit: HL   =  pointer incremented with wraparound
                        	  1304: 		;registers used: AF.DE.HL
                        	  1305: 		;***************************************
                        	  1306: incOutPointer:
00:024A 23              	  1307: 		inc		HL					; increment pointer
00:024B 110000          	  1308: 		ld		DE,endOutBuffer			;compare pointer. end of buffer
00:024E 7D              	  1309: 		ld		A,L
00:024F BB              	  1310: 		cp		E
00:0250 C0              	  1311: 		ret		NZ
00:0251 7C              	  1312: 		ld		A,H
00:0252 BA              	  1313: 		cp		D
00:0253 C0              	  1314: 		ret		NZ
00:0254 210000          	  1315: 		ld		HL,outBuffer				;if pointer at end of buffer.
00:0257 C9              	  1316: 		ret							; set it back to base address
                        	  1317: 
                        	  1318: 
                        	  1319: 		;**************************************
                        	  1320: 		; routine: initSIO_0ports
                        	  1321: 		; purpose: initialize i/o ports
                        	  1322: 		; entry: hl = base address of initialization array
                        	  1323: 		;exit: data output to ports
                        	  1324: 		;registers used: af.bc.hl
                        	  1325: 		;************************************
                        	  1326: InitSIO_0Ports:
                        	  1327: 		;get number of data bytes to send to current port
                        	  1328: 		;exit if number of bytes is o. indicating terminator
00:0258 7E              	  1329: 		ld		A,(HL)			;get number of bytes
00:0259 B7              	  1330: 		or		A				;test for zero (terminator)
00:025A C8              	  1331: 		ret		Z				;return if number of bytes = 0
00:025B 47              	  1332: 		ld		B,A
00:025C 23              	  1333: 		inc		HL				;point to port address (next byte)
                        	  1334: 
                        	  1335: 			;c = port address
                        	  1336: 			;hl   base address of output data
00:025D 4E              	  1337: 		ld		C,(HL)			;get port address
00:025E 23              	  1338: 		inc		HL				;point to first data value (next byte)
                        	  1339: 			;output data and continue to next port
00:025F EDB3            	  1340: 		otir					;send data values to port
00:0261 18F5            	  1341: 		jr      InitSIO_0Ports			;continue to next port entry
                        	  1342: 		
                        	  1343: 		;SIO_0 initialization data
                        	  1344: 
                        	  1345: 		; sio_ac
                        	  1346: 		; sio_ad
                        	  1347: 		; sio_bc
                        	  1348: 		; sio_bd
                        	  1349: initSIOBInterrupt:
00:0263 3E01            	  1350: 		ld 		A,WR1
00:0265 D303            	  1351: 		out 	(sio_bc),A
00:0267 3E1C            	  1352: 		ld 		A,_Int_All_Rx_Char_NP|_Status_Vector
00:0269 D303            	  1353: 		out 	(sio_bc),A					; interrupt on HC376S read
00:026B C9              	  1354: 		ret
                        	  1355: 	
                        	  1356: SIO_0INT:
                        	  1357: 		; Reset channel a
00:026C 01              	  1358: 		db	1					;output 1 byte
00:026D 02              	  1359: 		db	sio_ac			;to channel a command/status
00:026E 18              	  1360: 		db	_Ch_Reset			;select write register 0
                        	  1361: 								;bits 2.1.0    0 (write register 0)
                        	  1362: 								;bits 5,4,3 = 011 (channel reset)
                        	  1363: 								;bits 7,6 = 0 (do not care)
00:026F 01              	  1364: 		db	1					;output 1 byte
00:0270 03              	  1365: 		db	sio_bc			;to channel a command/status
00:0271 18              	  1366: 		db	_Ch_Reset			;select write register 0
                        	  1367: 
                        	  1368: 
                        	  1369: 		;sET INTERRUPT VECTOR AND ALLOW STATUS TO AFFECT IT
00:0272 04              	  1370: 		db	4					;OUTPUT 4 BYTES
00:0273 03              	  1371: 		db	SIO_B_C			;DESTINATION IS COMMAND REGISTER B
00:0274 02              	  1372: 		db	WR2					;SELECT WRITE REGISTER 2
00:0275 00              	  1373: 		db	SIO_Int_Vec&0FFH	;SET INTERRUPT VECTOR FOR SIO_0
00:0276 01              	  1374: 		db	WR1					;SELECT WRITE REGISTER 1
00:0277 04              	  1375: 		db	_Status_Vector		;TURN ON STATUS AFFECTS VECTOR
                        	  1376: 
                        	  1377: 		; INITIALIZE CHANNEL A
00:0278 08              	  1378: 		db	8					;OUTPUT 8 BYTES
00:0279 02              	  1379: 		db	SIO_A_C			;DESTINATION IS COMMAND REGISTER A
                        	  1380: 
                        	  1381: 		;iNITIALIZE BAUD RATE CONTROL
00:027A 14              	  1382: 		db	_Reset_STAT_INT|4	;SELECT WRITE REGISTER 4 & RESET EXTERNAL/STATUS INTERRUPT
00:027B 44              	  1383: 		db	_Stop_1_bit|_X16_Clock_mode
                        	  1384: 								;BIT 0 = 0 (NO PARITY)
                        	  1385: 								;BIT 1 = 0 (DON'T CARE)
                        	  1386: 								;BITS 3,2 = 01 (1 1/2 STOP BITS)
                        	  1387: 								; BITS 5.4 = 00 (DON-'T CARE)
                        	  1388: 								;BITS 7.6 = 10 (32 TIMES CLOCK)
                        	  1389: 	
                        	  1390: 		; INITIALIZE RECEIVE CONTROL
00:027C 03              	  1391: 		db	WR3		;SELECT WRITE REGISTER 3
00:027D C1              	  1392: 		db	_Rx_Enable|_RX_8_bits
                        	  1393: 								;BIT 0 = 1 (RECEIVE ENABLE)
                        	  1394: 								; BITS 4,3,2,1 = 0 (DON-'T CARE)
                        	  1395: 								;BIT 5 = 0 (NO AUTO ENABLE)
                        	  1396: 								;BIT 7.6 = 11 (RECEIVE 8 BITS/CHAR)
                        	  1397: 		;iNITIALIZE TRANSMIT CONTROL
00:027E 05              	  1398: 		db	WR5					;SELECT WRITE REGISTER 5
00:027F 6A              	  1399: 		db	_RTS_Enable|_Tx_Enable|_Tx_8bits_char
                        	  1400: 								;BIT 0 = 0 (NO CRC ON TRANSMIT)
                        	  1401: 								;BIT 1 = 1 (REQUEST TO SEND)
                        	  1402: 								;BIT 2 = 0 (DON'T CARE)
                        	  1403: 								;BIT 3 = 1 (TRANSMIT ENABLE)
                        	  1404: 								;BIT 4 = 0 (DO NOT SEND BREAK)
                        	  1405: 								;BITS 6.5 = 11 (TRANSMIT 8 BITS/CHAR)
                        	  1406: 								;BIT 7 = 1 (DATA TERMINAL READY)
00:0280 01              	  1407: 		DB	WR1					;SELECT WRITE REGISTER 1
00:0281 1A              	  1408: 		DB	_Tx_INT_EN|_Int_All_Rx_Char_NP
                        	  1409: 		; DB	_Ext_INT_EN|_Tx_INT_EN|_Int_All_Rx_Char_NP|_WAIT_READY_R_T|_WAIT_READY_EN
                        	  1410: 								;BIT 0 = 1 (EXTERNAL INTERRUPTS)
                        	  1411: 								;BIT 1 = 1 (ENABLE TRANSMIT INTERRUPT)
                        	  1412: 								;BIT 2 = 0 (DO NOT CARE)
                        	  1413: 								;BITS 4. 3 = 11 (RECEIVE INTERRUPTS ON ALL CHARS. PARITY DOES NOT AFFECT VECTOR)
                        	  1414: 								;BITS 7.6.5 = 000 (NO WAIT/READY
                        	  1415: 								; FUNCTION)
                        	  1416: 
                        	  1417: 
                        	  1418: 
                        	  1419: 		; INITIALIZE CHANNEL B
00:0282 08              	  1420: 		db	8					;OUTPUT 8 BYTES
00:0283 03              	  1421: 		db	SIO_B_C			;DESTINATION IS COMMAND REGISTER B
                        	  1422: 
                        	  1423: 		;iNITIALIZE BAUD RATE CONTROL
00:0284 14              	  1424: 		db	_Reset_STAT_INT|WR4	;SELECT WRITE REGISTER 4 & RESET EXTERNAL/STATUS INTERRUPT
00:0285 44              	  1425: 		db	_Stop_1_bit|_X16_Clock_mode
                        	  1426: 	
                        	  1427: 		; ; INITIALIZE RECEIVE CONTROL
00:0286 03              	  1428: 		db	WR3		;SELECT WRITE REGISTER 3
00:0287 C1              	  1429: 		db	_Rx_Enable|_RX_8_bits
                        	  1430: 		; ;iNITIALIZE TRANSMIT CONTROL
00:0288 05              	  1431: 		db	WR5					;SELECT WRITE REGISTER 5
00:0289 68              	  1432: 		db	_Tx_Enable|_Tx_8bits_char
                        	  1433: 		; DB	_Ext_INT_EN|_Tx_INT_EN|_Int_All_Rx_Char_NP|_WAIT_READY_R_T|_WAIT_READY_EN
00:028A 01              	  1434: 		DB	WR1					;SELECT WRITE REGISTER 1
00:028B 04              	  1435: 		DB	_Status_Vector
                        	  1436: 		; DB	_Tx_INT_EN|_Int_All_Rx_Char_NP|_Status_Vector
                        	  1437: 
00:028C 00              	  1438: 		DB	0               ; END OF TABLE
                        	  1439: 		
                        	  1440: ;****************************************************************************************************************
                        	  1441: ;****************************************************************************************************************
                        	  1442: ;****************************************************************************************************************
                        	  1443: ;****************************************************************************************************************
                        	  1444: ;****************************************************************************************************************
                        	  1445: 		; DATA SECTION
                        	  1446: 		; Moved to linker script 
                        	  1447: ; inHeadAdr:	DS	2					; address of oldest character in input buffer
                        	  1448: ; inTailAdr:	DS	2					; address of newest character in input buffer
                        	  1449: ; inBufCount:	DS	1					;number of characters in input buffer 
                        	  1450: ; outHeadAdr:	DS	2					;address of oldest character in output buffer
                        	  1451: ; outTailAdr:	DS	2					;address of newest character in output buffer
                        	  1452: ; OutBufCount:	DS	1				;number of characters in output buffer
                        	  1453: ; OutINTExpect:	DS	1					;output interrupt expected
                        	  1454: ; 								; (0 = no interrupt expected.
                        	  1455: ; 								; ff = interrupt expected)
                        	  1456: 
                        	  1457: 
                        	  1458: 		; SAMPLE EXECUTION:
                        	  1459: 
                        	  1460: 
                        	  1461: 		;CHARACTER EQUATES
                        	  1462: ; ; ESCAPE	EQU     1BH					;ASCII ESCAPE CHARACTER
                        	  1463: ; ; TESTCH	EQU     'A'					;TEST CHARACTER = A
                        	  1464: ; 		global SC11C
                        	  1465: ; SC11C:
                        	  1466: ; 		CALL	InitBuffers				;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	  1467: ; 			;SIMPLE EXAMPLE - READ AND ECHO CHARACTER
                        	  1468: ; 			; UNTIL AN ESC IS RECEIVED
                        	  1469: ; LOOP:
                        	  1470: ; 		CALL	ReadChar				;READ CHARACTER
                        	  1471: ; 		PUSH	AF
                        	  1472: ; 		CALL	WriteChar				;ECHO CHARACTER
                        	  1473: ; 		POP		AF
                        	  1474: ; 		CP		ESCAPE				;IS CHARACTER AN ESCAPE?
                        	  1475: ; 		JR		NZ,LOOP				;STAY IN LOOP IF NOT
                        	  1476: ; 			;AN ASYNCHRONOUS EXAMPLE
                        	  1477: ; 			; OUTPUT "A" TO CONSOLE CONTINUOUSLY BUT ALSO LOOK AT
                        	  1478: ; 			; INPUT SIDE. READING AND ECHOING ANY INPUT CHARACTERS
                        	  1479: ; ASYNLP:
                        	  1480: ; 			;OUTPUT   AN "A" IF OUTPUT IS NOT BUSY
                        	  1481: ; 		CALL	RetOutStatus				;IS OUTPUT BUSY?
                        	  1482: ; 		JR		C,ASYNLP			;JUMP IF IT IS
                        	  1483: ; 		LD		A,TESTCH
                        	  1484: ; 		CALL	WriteChar				;OUTPUT CHARACTER
                        	  1485: ; 			;CHECK INPUT PORT
                        	  1486: ; 			;ECHO CHARACTER IF ONE IS AVAILABLE
                        	  1487: ; 			;EXIT ON ESCAPE CHARACTER
                        	  1488: ; 		CALL	RetInpStatus				;IS INPUT DATA AVAILABLE?
                        	  1489: ; 		JR		NC, ASYNLP			;JUMP I F NOT (SEND ANOTHER .. A" )
                        	  1490: ; 		CALL	ReadChar				; GET CHARACTER
                        	  1491: ; 		CP		ESCAPE				;IS IT AN ESCAPE CHARACTER?
                        	  1492: ; 		JR		Z,DONE				;BRANCH IF IT IS
                        	  1493: 
                        	  1494: 
                        	  1495: ; 		CALL	WriteChar				;ELSE ECHO CHARACTER
                        	  1496: ; 		JP		ASYNLP				;AND CONTINUE
                        	  1497: ; DONE:
                        	  1498: ; 		JP		LOOP
                        	  1499: 
                        	  1500: 
                        	  1501: ;##############################################################
                        	  1502: ; Write the null-terminated string starting after the call
                        	  1503: ; instruction invoking this subroutine to the console.
                        	  1504: ; Clobbers AF, C
                        	  1505: ;##############################################################
                        	  1506: writeSTRBelow:
00:028D FDE3            	  1507:         ex      (sp),iy                 ; iy = @ of string to print
00:028F CD9100          	  1508: 		call	WriteLine
00:0292 FD23            	  1509:         inc     iy                      ; point past the end of the string
00:0294 FDE3            	  1510:         ex      (sp),iy
00:0296 C9              	  1511:         ret
                        	  1512: 
                        	  1513: writeSTRBelow_CRLF:
00:0297 FDE3            	  1514: 		ex		(sp),iy                 ; iy = @ of string to print
00:0299 CDA200          	  1515: 		call	WriteLineCRNL
00:029C FD23            	  1516: 		inc		iy                      ; point past the end of the string
00:029E FDE3            	  1517: 		ex		(sp),iy
00:02A0 C9              	  1518: 		ret
                        	  1519: 
                        	  1520: ;##############################################################
                        	  1521: ; Print a CRLF 
                        	  1522: ; Clobbers AF, C
                        	  1523: ;##############################################################
                        	  1524: puts_crlf:
00:02A1 CD8D02          	  1525:         call    writeSTRBelow
00:02A4 000D0A00        	  1526:         defb    '\0\r\n\0'
00:02A8 C9              	  1527:         ret
                        	  1528: 
                        	  1529: 
                        	  1530: 
                        	  1531: 
                        	  1532: PIO_Init:
                        	  1533: ;----------******************* PIO PORT A
00:02A9 3ECF            	  1534: 		ld A, %11001111                 ;mode 3 in/out
00:02AB D301            	  1535: 		out (portA_Contr), A         ; set port A as output
00:02AD 3E00            	  1536: 		ld 	A,%00000000					; msb=input lsb = output, 0-mosi, 1-clk, 2-ssel, 7-miso
00:02AF D301            	  1537: 		out (portA_Contr), A         ; set port A as 4 input/ 4 output
                        	  1538: 		; ld A, Interupt_vector&0xFF                   ; low byte of INT table
                        	  1539: 		; out (portA_Contr), A         ; PIO A interrupt vector
00:02B1 3E03            	  1540: 		ld A, $03
00:02B3 D301            	  1541: 		out (portA_Contr), A         ; PIO A interrupt disable
                        	  1542: 		; ld a,Interupt_vector>>8      ; high byte of INT table
                        	  1543: 		; ld I,A
00:02B5 F3              	  1544: 		di
                        	  1545: ;----------******************* PIO PORT B
00:02B6 3ECF            	  1546: 		ld A, %11001111                 ;mode 3 in/out
00:02B8 D303            	  1547: 		out (portB_Contr), A         ; set port B as output
00:02BA 3E00            	  1548: 		ld A, $00                    ;mode 0 output 
00:02BC D303            	  1549: 		out (portB_Contr), A         ; set port B as output
00:02BE 3E03            	  1550: 		ld A, $03
00:02C0 D303            	  1551: 		out (portB_Contr), A         ; PIO B interrupt disable
00:02C2 3E00            	  1552: 		ld a,0
00:02C4 32D0F1          	  1553: 		ld (PIO_B_value),a
00:02C7 D302            	  1554: 		out (portB_Data), a
00:02C9 C9              	  1555: 	ret
                        	  1556: 
                        	  1557: 	if DOALIGN
                        	  1558: 		align 4
                        	  1559: 	endif
                        	  1560: 
                        	  1561: 
                        	  1562: ;********************************************************************************************     
                        	  1563: ;********************************************************************************************     
                        	  1564: 
                        	  1565: 		xdef CTC_CH0_Interrupt_Handler,CTC_CH1_Interrupt_Handler,CTC_CH2_Interrupt_Handler,CTC_CH3_Interrupt_Handler
                        	  1566: 
                        	  1567: CTC_CH0_Interrupt_Handler:
                        	  1568: CTC_CH1_Interrupt_Handler:
                        	  1569: 
                        	  1570: 		; call 	TX_NAK
00:02CA CD0000          	  1571: 		call 	TX_C
00:02CD 3A0000          	  1572: 		ld 		A,(TempVar1)
00:02D0 3C              	  1573: 		inc 	A
00:02D1 320000          	  1574: 		ld 		(TempVar1),A
                        	  1575: 
                        	  1576: 
00:02D4 FE10            	  1577: 		cp 		16							; Z is set 
00:02D6 F2DE02          	  1578: 		jp 		P,showtimeout				; check if loop should timeout... A>16
                        	  1579: 
                        	  1580: 		; call	Z,SetupXMODEM_TXandRX		; test if minicom has begun sending Z=0...
                        	  1581: 
00:02D9 B7              	  1582: 		or 		A							; clear carry - > wait for next.
00:02DA 1E0A            	  1583: 		ld 		E,CTCpulse					; ret from CTC = 0A
                        	  1584: 
00:02DC ED4D            	  1585: 		reti
                        	  1586: 
                        	  1587: ;------------------------------------------------------------------------------
                        	  1588: 
                        	  1589: 
                        	  1590: CTC_CH2_Interrupt_Handler:
                        	  1591: CTC_CH3_Interrupt_Handler:
                        	  1592: 
                        	  1593: 
                        	  1594: showtimeout:
                        	  1595: 		; call 	writeSTRBelow_CRLF
                        	  1596: 		; defb    "\0\r\n"
                        	  1597: 		; defb	"A timout on XMODEM occured !",00
00:02DE 97              	  1598: 		sub  	A
00:02DF 320000          	  1599: 		ld 		(TempVar1),A
00:02E2 D302            	  1600: 		out 	(portB_Data),A
                        	  1601: 
00:02E4 37              	  1602: 		scf								; set carry flag 
                        	  1603: 
00:02E5 FB              	  1604: 		ei
00:02E6 1E0B            	  1605: 		ld 		E,CTCtimeout					; ret from CTC = 0B (timeout)
00:02E8 ED4D            	  1606: 		reti 
                        	  1607: 
                        	  1608: 
                        	  1609: 
                        	  1610: 
                        	  1611: 
                        	  1612: ;********************************************************************************************     
                        	  1613: ;********************************************************************************************     
                        	  1614: 
                        	  1615: 
                        	  1616: 
                        	  1617: CTC_Init:
                        	  1618: 
                        	  1619: 		; ------INIT interrupt vectors for SIO /CTC---------------
00:02EA 2110F4          	  1620: 		ld 		HL,CTC_CH0_I_Vector          (F410)
00:02ED 7D              	  1621: 		ld  	A,L					; copy low byte
00:02EE D300            	  1622: 		out 	(CH0),A
                        	  1623: 
                        	  1624: 		; ------INIT CTC2 Baud frequence  for  10 MHz version SIO------- 
                        	  1625: 		; 		Baud 		SIO_0,clockmode  CTCprescaler freq
                        	  1626: 		;		115200		16x				2			3,684	
                        	  1627: 		;		57600		16x				4			3,684
                        	  1628: 		;		38400		16x				6			3,684
                        	  1629: 		;		19200		16x				12			3,684
                        	  1630: 		; 		9600		16x				24			3,684
                        	  1631: 
00:02F0 3E47            	  1632: 		ld 	 	A,_Counter|_TC_Follow|_Reset|_CW
00:02F2 D302            	  1633: 		out		(CH2),A
00:02F4 3E02            	  1634: 		ld		A,2				; time constant defined
00:02F6 D302            	  1635: 		out		(CH2),A			; and loaded into channel 2
                        	  1636: 
                        	  1637: 
                        	  1638: 		;--------init CTC3 (Unused...)----------------------------------
00:02F8 3E03            	  1639: 		ld		A,00000011b		; int on, counter on, prescaler don't care, edge don't care,11000111b
00:02FA D303            	  1640: 		out		(CH3),A
00:02FC 3EAF            	  1641: 		ld		A,0AFh			; time constant AFh defined
00:02FE D303            	  1642: 		out		(CH3),A			; and loaded into channel 3
                        	  1643: 		; ld		A,10h			; it vector defined in bit 7­3,bit 2­1 don't care, bit 0 = 0
                        	  1644: 
                        	  1645: 		; out		(CH0),A			; and loaded into channel 0
00:0300 C9              	  1646: 		ret
                        	  1647: 
                        	  1648: 
                        	  1649: ;********************************************************************************************     
                        	  1650: 
                        	  1651: .end
                        	  1652: 
                        	  1653: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CRChar                           E:000D
CRLF                            00:00A5 EXP
CRNL                            00:00A5
CTC1_INT_OFF                    00:020B EXP
CTC_CH0_I_Vector                 E:F410
CTC_CH0_Interrupt_Handler       00:02CA EXP
CTC_CH1_I_Vector                 E:F412
CTC_CH1_Interrupt_Handler       00:02CA EXP
CTC_CH2_I_Vector                 E:F414
CTC_CH2_Interrupt_Handler       00:02DE EXP
CTC_CH3_I_Vector                 E:F416
CTC_CH3_Interrupt_Handler       00:02DE EXP
CTC_Init                        00:02EA EXP
CTCdelayFlag                    external
CTCpulse                         E:000A
CTCtimeout                       E:000B
CharToSIO_0                     00:0226
Comm_Ptr_list                   external
DOALIGN                          E:0000
ExternINTHandler                00:0214
Extern_B_USB_Handler            00:01CF
FF                               E:000C
GetOutStatus                    00:00CE
InitBuffers                     00:00D5 EXP
InitInterrupt                   00:0108 EXP
InitSIO_0Ports                  00:0258 EXP
OutBufCount                     external
OutINTExpect                    external
PIO_B_value                      E:F1D0
PIO_Init                        00:02A9 EXP
R_LOOP                          00:000C
ReadChar                        00:005C EXP
ReadINTHandler                  00:015F
ReadLine                        00:000C EXP
ReadUSBHandler                  00:01A7 EXP
RetInpStatus                    00:0073 EXP
SIO_0INT                        00:026C EXP
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_B_DI                        00:0202 EXP
SIO_B_EI                        00:01F9 EXP
SIO_B_RX_INTon                  00:01E7 EXP
SIO_B_TXRX_INToff               00:01F0 EXP
SIO_Init                        00:0157 EXP
SIO_Int_EXT_Vec                  E:F40A
SIO_Int_Read_Vec                 E:F40C
SIO_Int_Spec_Vec                 E:F40E
SIO_Int_Vec                      E:F400
SIO_Int_WR_Vec                   E:F408
SIO_USB_EXT_Vec                  E:F402
SIO_USB_Read_Vec                 E:F404
SIO_USB_Spec_Vec                 E:F406
SIO_USB_WR_Vec                   E:F400
S_head_tail                     00:007A EXP
SpecINTHandler                  00:021D
SpecINT_B_USB_Handler           00:01DB
TX_C                            external
TempVar1                        external
TempVar4                        external
Textbuf                         external
WR1                              E:0001
WR2                              E:0002
WR3                              E:0003
WR4                              E:0004
WR5                              E:0005
WaitOutBuff                     00:00AD
WriteChar                       00:00A9 EXP
WriteINTHandler                 00:0187
WriteLine                       00:0091 EXP
WriteLineCRNL                   00:00A2 EXP
Write_USB_Handler               00:01C3
_CW                              E:0001
_Ch_Reset                        E:0018
_Counter                         E:0040
_Int_All_Rx_Char_NP              E:0018
_RTS_Enable                      E:0002
_RX_8_bits                       E:00C0
_Reset                           E:0002
_Reset_STAT_INT                  E:0010
_Rising                          E:0010
_Rx_Disable                      E:0000
_Rx_Enable                       E:0001
_Status_Vector                   E:0004
_Stop_1_bit                      E:0004
_TC_Follow                       E:0004
_Tx_8bits_char                   E:0060
_Tx_Enable                       E:0008
_Tx_INT_EN                       E:0002
_X16_Clock_mode                  E:0040
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
bmve                            00:0080
bufferSize                      external
c_nextchar                      00:003F
cleanInBuffer                   00:00E9 EXP
cleanOutBuffer                  00:00FA EXP
cont1                           00:0050
cont2                           00:0030
endOutBuffer                    external
exitRHandler                    00:0180
gpioB                           external
gpio_in                         external
gpio_out                        external
inBufCount                      external
inBuffer                        external EXP
inBufferEnd                     external EXP
inHeadAdr                       external
inTailAdr                       external
inbufferDeactivate              external
incInPointer                    00:023C
incOutPointer                   00:024A
initSIOBInterrupt               00:0263 EXP
list_len                        external
nodata                          00:0196
nxtchr                          00:0093
outBuffer                       external
outBufferSize                   external
outHeadAdr                      external
outTailAdr                      external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXB                        external EXP
puts_crlf                       00:02A1 EXP
showtimeout                     00:02DE
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
waitEntry                       00:001B
waitForKey                      00:0000 EXP
wrdone                          00:01A0
writeSTRBelow                   00:028D EXP
writeSTRBelow_CRLF              00:0297 EXP

Symbols by value:
0000 DOALIGN
0000 _Rx_Disable
0000 waitForKey
0001 WR1
0001 _CW
0001 _Rx_Enable
0002 WR2
0002 _RTS_Enable
0002 _Reset
0002 _Tx_INT_EN
0003 WR3
0004 WR4
0004 _Status_Vector
0004 _Stop_1_bit
0004 _TC_Follow
0005 WR5
0008 _Tx_Enable
000A CTCpulse
000B CTCtimeout
000C FF
000C R_LOOP
000C ReadLine
000D CRChar
0010 _Reset_STAT_INT
0010 _Rising
0018 _Ch_Reset
0018 _Int_All_Rx_Char_NP
001B waitEntry
0030 cont2
003F c_nextchar
0040 _Counter
0040 _X16_Clock_mode
0050 cont1
005C ReadChar
0060 _Tx_8bits_char
0073 RetInpStatus
007A S_head_tail
0080 bmve
0091 WriteLine
0093 nxtchr
00A2 WriteLineCRNL
00A5 CRLF
00A5 CRNL
00A9 WriteChar
00AD WaitOutBuff
00C0 _RX_8_bits
00CE GetOutStatus
00D5 InitBuffers
00E9 cleanInBuffer
00FA cleanOutBuffer
0108 InitInterrupt
0157 SIO_Init
015F ReadINTHandler
0180 exitRHandler
0187 WriteINTHandler
0196 nodata
01A0 wrdone
01A7 ReadUSBHandler
01C3 Write_USB_Handler
01CF Extern_B_USB_Handler
01DB SpecINT_B_USB_Handler
01E7 SIO_B_RX_INTon
01F0 SIO_B_TXRX_INToff
01F9 SIO_B_EI
0202 SIO_B_DI
020B CTC1_INT_OFF
0214 ExternINTHandler
021D SpecINTHandler
0226 CharToSIO_0
023C incInPointer
024A incOutPointer
0258 InitSIO_0Ports
0263 initSIOBInterrupt
026C SIO_0INT
028D writeSTRBelow
0297 writeSTRBelow_CRLF
02A1 puts_crlf
02A9 PIO_Init
02CA CTC_CH0_Interrupt_Handler
02CA CTC_CH1_Interrupt_Handler
02DE CTC_CH2_Interrupt_Handler
02DE CTC_CH3_Interrupt_Handler
02DE showtimeout
02EA CTC_Init
F1D0 PIO_B_value
F400 SIO_Int_Vec
F400 SIO_USB_WR_Vec
F402 SIO_USB_EXT_Vec
F404 SIO_USB_Read_Vec
F406 SIO_USB_Spec_Vec
F408 SIO_Int_WR_Vec
F40A SIO_Int_EXT_Vec
F40C SIO_Int_Read_Vec
F40E SIO_Int_Spec_Vec
F410 CTC_CH0_I_Vector
F412 CTC_CH1_I_Vector
F414 CTC_CH2_I_Vector
F416 CTC_CH3_I_Vector
