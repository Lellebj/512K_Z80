Sections:
00: "Strings" (0-577)


Source: "stdin"
                        	     1: 
                        	     2: 		include "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     3: 
                        	     4: 	
                        	     5: 	ifndef ONESECTION
                        	     6: 		section	Strings	
                        	     7: 
                        	     8: 	else
                        	     9: 		section singleAssembly
                        	    10: 	endif
                        	    11: 
                        	    12: 
                        	    13: 		GLOBAL strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR,src_size,isHex,isChar,dumpMemory
                        	    14: 		xref	isDelimit
                        	    15: 		
                        	    16: 		; String Manipulation
                        	    17: 		; 8A    String Compare    288
                        	    18: 		; 8B    String Concatenation 292
                        	    19: 		; 8C    Find the Position of a Substring 297
                        	    20: 		; 8D    Copy a Substring from a String 302
                        	    21: 		; 8E    Delete a Substring from a String 308
                        	    22: 		; 8F    Insert a Substring into a String 313
                        	    23: 
                        	    24: ;****************************************************************************************************************
                        	    25: ;****************************************************************************************************************
                        	    26: 		; String Compare (StrCompare)                                                                                      8A
                        	    27: 		;     Compares two strings and sets the Carry and
                        	    28: 		;                                                         Registers Used: AF, BC, DE, HL
                        	    29: 		; Zero flags appropriately. The Zero flag is set to I
                        	    30: 		;                                                         Execution nme:
                        	    31: 		;                                                         larger.
                        	    32: 		; Examples
                        	    33: 		; I.    Data:     String 1 = OS'PRINT' (05 is the length of the   3.    Data:      String 1 = OS'PRINT' (05 is the le
                        	    34: 		;                   string)                                                          string)
                        	    35: 		;                 String 2 = 03'END' (03 is the length of the                      String 2 = 06'SYSTEM' (06 is the l
                        	    36: 		;                   string)                                                          the string)
                        	    37: 		;     Result:    Zero flag = 0 (strings are not identical)            Result:     Zero flag = 0 (strings are not iden
                        	    38: 		;                 Carry flag = 0 (string 2 is not larger than                      Carry flag = I (string 2 is larger
                        	    39: 		;                   string 1)
                        	    40: 		;                                                                 of ASCII characters. Note that the byte preceding
                        	    41: 		; 2.    Data:     String 1 = OS'PRINT' (05 is the length of the   the actual characters contains a hexadecimal
                        	    42: 		;                   string)                                       number (the length of the string), not a character.
                        	    43: 		;                 String 2 = 02'PR' (02 is the length of the      We have represented this byte as two hexadecimal
                        	    44: 		;                   string)
                        	    45: 		;                                                                 digits in front of the string. The string itself is
                        	    46: 		;     Result:    Zero flag = 0 (strings are not identical)
                        	    47: 		;                 Carry flag = 0 (string 2 is not larger than     shown surrounded by single quotation marks.
                        	    48: 		;                                           a length byte which precedes it.
                        	    49: 		;           Exit:                IF string 1 = string 2 THEN
                        	    50: 		;                                   Z=1,C=O
                        	    51: 		;                                 IF string 1 > string 2 THEN
                        	    52: 		;                                   Z=O,C=O
                        	    53: 		;                                 IF string 1 < string 2 THEN
                        	    54: 		;                                   Z=O,C=l
                        	    55: 		;           Registers used: AF,BC,DE,HL
                        	    56: 		;           Time:                91 cycles overhead plus 60 cycles per byte plus
                        	    57: 		;                                 40 cycles if strings are identical
                        	    58: 		;                                 through length of shorter
                        	    59: 		;           Size:                Program 32 bytes
                        	    60: 		;                                 Data     2 bytes
                        	    61: ;****************************************************************************************************************
                        	    62: ;****************************************************************************************************************
                        	    63: 
                        	    64: 
                        	    65: strCompare:
                        	    66: 					;determine which string is shorter
                        	    67: 					;length of shorter = number of bytes to compare
00:0000 7E              	    68: 		LD		A,(HL)				;save length of string 1
00:0001 322000          	    69: 		LD		(LENS1),A
00:0004 1A              	    70: 		LD		A, (DE)				;save length of string 2
00:0005 322100          	    71: 		LD		(LENS2),A
00:0008 BE              	    72: 		CP		(HL)				;compare to length of string 1
00:0009 3801            	    73: 		JR		C,str2ISshorter		;jump if string 2 is shorter
00:000B 7E              	    74: 		LD		A, (HL)				;else string 1 is shorter
                        	    75: 					;compare strings through length of shorter
                        	    76: str2ISshorter:
00:000C B7              	    77: 		OR		A					;test length of shorter string
00:000D 2809            	    78: 		JR		Z,cmpLength		;compare lengths ; if length is zero
                        	    79: 
00:000F 47              	    80: 		LD		B,A					;b = number of bytes to compare
00:0010 EB              	    81: 		EX		DE,HL				;de = string 1
                        	    82: 									;hl = string 2
                        	    83: cmpLoop:
00:0011 23              	    84: 		INC		HL					;increment to next bytes
00:0012 13              	    85: 		INC		DE
00:0013 1A              	    86: 		LD		A,(DE)              ;get a byte of string 1
00:0014 BE              	    87: 		CP		(HL)				;compare to byte of string 2
00:0015 C0              	    88: 		RET		NZ					;return with flags set if bytes not EQUAL
00:0016 10F9            	    89: 		DJNZ	cmpLoop				;continue through all bytes
                        	    90: 			; strings same through length of shorter
                        	    91: 			; so use lengths to set flags
                        	    92: cmpLength:
00:0018 3A2000          	    93: 		LD		A,(LENS1)			;compare lengths
00:001B 212100          	    94: 		LD		HL,LENS2
00:001E BE              	    95: 		CP		(HL)
00:001F C9              	    96: 		RET							; return with flags set or cleared
                        	    97: 		; DATA
00:0020 00              	    98: LENS1:	DS		1					;length of string 1
00:0021 00              	    99: LENS2:	DS		1					;length of string 2
                        	   100: 
                        	   101: 		; 5AMPLE EXECUTION:
                        	   102: 
                        	   103: 
                        	   104: ; SC8A:
                        	   105: ; 		LD		HL,S1				;base address of string 1
                        	   106: ; 		LD		DE,S2				;base address of string 2
                        	   107: ; 		CALL	strCompare			;compare strings
                        	   108: ; 									;comparing "string 1" and "string 2"
                        	   109: ; 									; results in string 1 less than
                        	   110: ; 									; string 2. so z=o.c=1
                        	   111: ; 		JR      SC8A				;loop for another test
                        	   112: ; S1:		DB		20H					;string 1
                        	   113: ; S2:		DB		20H					;string 2
                        	   114: 
                        	   115: ;****************************************************************************************************************
                        	   116: ;****************************************************************************************************************
                        	   117: 
                        	   118: 		GLOBAL 		isDelimit,skipPriorDelimit,skipCharsUntilDelim
                        	   119: 
                        	   120: 
                        	   121: delimChars:
00:0022 205F262F232C3D  	   122: 		db   ' _&/#,=',CR,0,0	
00:0029 0D
00:002A 00
00:002B 00
                        	   123: 				; 		isDelimit(S)  is char in (HL) any of the delimiters specified ? =>Z, else ~Z
                        	   124: 				; 		if char in (HL) is '0' ->  set C, else NC
                        	   125: 				; 		Parameters returned; HL - Address of char
                        	   126: 	
                        	   127: 
                        	   128: isDelimit:
00:002C D5              	   129: 		push 	DE
                        	   130: 				; HL points to string, DE points to delimiters
00:002D 112200          	   131: 		ld 		DE,delimChars
00:0030 7E              	   132: 		ld 		a,(HL) 			; char from string
00:0031 B7              	   133: 		or 		a 				; is a (DE) = 0 ?
00:0032 280E            	   134: 		jr 		z,exitZero
                        	   135: 
                        	   136: nxtdelim:
                        	   137: 
00:0034 1A              	   138: 		ld 		A,(DE)			; actual delimiter
00:0035 BE              	   139: 		cp 		(HL)			; check present delimiter
00:0036 2806            	   140: 		jr 		z,exitDelim		; Z set
                        	   141: 
                        	   142: 
00:0038 13              	   143: 		inc  	DE				; next delimiter
00:0039 1A              	   144: 		ld  	A,(DE)
00:003A B7              	   145: 		or 		A 				; =0? 		
00:003B 20F7            	   146: 		jr 		nz,nxtdelim     ; if no -> next delimiter
00:003D 3C              	   147: 		inc 	a 				; clear Z flag
                        	   148: exitDelim:
00:003E 37              	   149: 		scf	
00:003F 3F              	   150: 		ccf						; clear Carry (Z is set if (HL) is delimiter, cleared otherwise)
00:0040 D1              	   151: 		pop 	DE
00:0041 C9              	   152: 		ret
                        	   153: 
                        	   154: exitZero:
                        	   155: 		; carry flag always cleared.
00:0042 3C              	   156: 		inc 	a 			; clear Z flag
00:0043 37              	   157: 		scf 				; set Carry-char = '0'
00:0044 D1              	   158: 		pop 	DE
00:0045 C9              	   159: 		ret
                        	   160: 
                        	   161: 
                        	   162: skipPriorDelimit:
                        	   163: 				; increase HL until non delimiter (NZ) or #0 (C) 
                        	   164: 				; HL points to acutal pos in 'Textbuf'
00:0046 23              	   165: 		inc 	HL 				; skip past string length or next char	
00:0047 CD2C00          	   166: 		call	isDelimit		;delimiters specified ? =>Z, else ~Z
                        	   167: 								;char in (HL) is '0' ->  set C, else NC
                        	   168: 
00:004A 7E              	   169: 		ld 		a,(HL)			; A = value of actl. char						
00:004B D8              	   170: 		ret 	C 				; end of string '0' or 'CR' found
                        	   171: 
00:004C C0              	   172: 		ret 	NZ 				; NZ -> (HL) points to non delimiter
00:004D 18F7            	   173: 		jr 		skipPriorDelimit
                        	   174: 
                        	   175: 
                        	   176: skipCharsUntilDelim:
                        	   177: 				; increase HL until delimiter (NZ) or #0 (Z) 
00:004F 23              	   178: 		inc 	HL 				; skip past string length or next char		
00:0050 CD2C00          	   179: 		call	isDelimit		;delimiters specified ? =>Z, else ~Z
                        	   180: 								;char in (HL) is '0' ->  set C, else NC
00:0053 7E              	   181: 		ld 		a,(HL)			; A = value of actl. char						
00:0054 D8              	   182: 		ret 	C				; end of string '0' or 'CR' found
00:0055 C8              	   183: 		ret  	Z				; Z -> (HL) points to delimiter
00:0056 18F7            	   184: 		jr 		skipCharsUntilDelim
                        	   185: 
                        	   186: 
                        	   187: ;****************************************************************************************************************
                        	   188: ;****************************************************************************************************************
                        	   189: 
                        	   190: isHex:
                        	   191: 		; ***	Check if characters are HEX ? 
                        	   192: 		; ***	from (HL)  .. 0..9,A..F -> NC  others -> C
00:0058 7E              	   193: 		ld 		A,(HL)
00:0059 D630            	   194: 		sub 	'0'
00:005B FA7700          	   195: 		jp 		M,.setCarry 		; less than '0'
00:005E FE0A            	   196: 		cp 		10						
00:0060 F26600          	   197: 		jp 		P,.checkAF			; bigger than '9'
00:0063 C37900          	   198: 		jp 		.nextChar			; char between 0..9 -> OK
                        	   199: 
                        	   200: .checkAF:
00:0066 E6DF            	   201: 		and 	~$20				; clear bit 5  ($DF) mask to Upper case
                        	   202: 
00:0068 D607            	   203: 		sub 	7		
00:006A FE0A            	   204: 		cp 		$0A
00:006C FA7700          	   205: 		jp 		M,.setCarry			; less than 'A'
00:006F FE10            	   206: 		cp 		$10		
00:0071 F27700          	   207: 		jp 		P,.setCarry			; bigger than 'F'
00:0074 C37900          	   208: 		jp		.nextChar			; char between A..F -> OK
                        	   209: .setCarry:
00:0077 37              	   210: 		scf
00:0078 C9              	   211: 		ret							; return with Carry, value in A is NOT HEX
                        	   212: .nextChar:	
00:0079 37              	   213: 		scf
00:007A 3F              	   214: 		ccf
00:007B C9              	   215: 		ret							; return without Carry, value in A is HEX
                        	   216: 
                        	   217: ;****************************************************************************************************************
                        	   218: ;****************************************************************************************************************
                        	   219: 
                        	   220: isChar:
                        	   221: 		; ***	Check if characters are Char ? 
                        	   222: 		; ***	from (HL)  $21 .. $-7E -> NC  others -> C
00:007C 7E              	   223: 		ld 		A,(HL)
00:007D FE21            	   224: 		cp	 	$21
00:007F FA8900          	   225: 		jp 		M,.setCarry 		; less than '!'
00:0082 FE7F            	   226: 		cp 		$7F						
00:0084 F28900          	   227: 		jp 		P,.setCarry			; bigger than '~'
00:0087 1804            	   228: 		jr 		.nextChar			; char between A..F -> OK
                        	   229: .setCarry:
00:0089 3E2E            	   230: 		ld 		A,'.'				; set resulting char = '.' in NOT char
00:008B 37              	   231: 		scf
00:008C C9              	   232: 		ret							; return with Carry, value in A is NOT char
                        	   233: .nextChar:	
00:008D 37              	   234: 		scf
00:008E 3F              	   235: 		ccf
00:008F C9              	   236: 		ret							; return without Carry, value in A is char
                        	   237: 
                        	   238: 
                        	   239: 
                        	   240: ;****************************************************************************************************************
                        	   241: ;****************************************************************************************************************
                        	   242: 		; String Concatenation (CONCAT)                                                                                      
                        	   243: 		; 	is
                        	   244: 		; 																with the Carry flag cleared (no errors) and string I
                        	   245: 		; Examples
                        	   246: 		; I.    Data:     Maximum length of string I = OE'6 = 1410       2.    Data:    String I = 07'JOHNSON' (07 is the len
                        	   247: 		; 				String 1= 07'JOHNSON' (07 is the length of                      the string)
                        	   248: 		; 				the string)                                                 String 2= 09',RICHARD'(09 is the length of
                        	   249: 		; 				String 2 = OS',DON' (OS is the length of the                    the string)
                        	   250: 		; 				string)                                           Result:   String 1= OE'JOHNSON, RICHA' (OE'6 =
                        	   251: 		; 	Result:    String 1= OC'JOHNSON, DON'(OC'6= 1210                            1410 is the maximum length allowed, so
                        	   252: 		; 				is the length of the combined string with                     last two characters of string 2 have been
                        	   253: 		; 				string 2 placed after string I)                               dropped)
                        	   254: 		; 				Carry = 0, since the concatenation did not                    Carry= I, since the concatenation produced
                        	   255: 		; 				produce a string exceeding the maximum                        a string longer than the maximum length.
                        	   256: 		; 				length.
                        	   257: 		; 			Title                   String Concatenation
                        	   258: 		; 			Name:                   CONCAT
                        	   259: 		; 			Purpose:                 Concatenate 2 strings into one string
                        	   260: 		; 			Entry:                  Register pair HL = Base address of string 1
                        	   261: 		; 									Register pair DE = Base address of string 2
                        	   262: 		; 									Register B = Maximum length of string 1
                        	   263: 		; 										A string is a maximum of 255 bytes long plus
                        	   264: 		; 										a length byte which precedes it.
                        	   265: 		; 			Exit:                   String 1 := string 1 concatenated with string 2
                        	   266: 		; 									If no errors then
                        	   267: 		; 										CARRY := 0
                        	   268: 		; 									else
                        	   269: 		; 										begin
                        	   270: 		; 											CARRY := 1
                        	   271: 		; 											if the concatenation makes string 1 too
                        	   272: 		; 											long, concatenate only enough of string 2
                        	   273: 		; 											to give string 1 its maximum length.
                        	   274: 		; 											if length(stringl) > maximum length then
                        	   275: 		; 											no concatenation is done
                        	   276: 		; 										end,
                        	   277: 		; 		Registers used: AF.BC.DE.HL
                        	   278: 		; 		Time:             Approximately 21 * (length of string 2) cycles
                        	   279: 		; 							plus 288 cycles overhead
                        	   280: 		; 		Size:             Program 83 bytes
                        	   281: 		; 							Data     5 bytes
                        	   282: ;****************************************************************************************************************
                        	   283: ;****************************************************************************************************************
                        	   284: 
                        	   285: 
                        	   286: 
                        	   287: CONCAT:
                        	   288: 		; DETERMINE WHERE TO START CONCATENATING
                        	   289: 		; CONCATENATION STARTS AT THE END OF STRING 1
                        	   290: 		; END OF STRING 1 = BASEl + LENGTHl + 1, WHERE
                        	   291: 		; THE EXTRA 1 MAKES UP FOR THE LENGTH BYTE
                        	   292: 		; NEW CHARACTERS COME FROM STRING 2, STARTING AT
                        	   293: 		; BASE2 + 1 (SKIPPING OVER LENGTH BYTE)
00:0090 22E300          	   294: 		LD		(S1ADR),HL		;SAVE ADDRESS OF STRING 1
00:0093 C5              	   295: 		PUSH	BC				;SAVE MAXIMUM LENGTH OF STRING 1
00:0094 7E              	   296: 		LD		A, (HL)			;SAVE LENGTH OF STRING 1
00:0095 32E500          	   297: 		LD		(S1LEN),A
00:0098 4F              	   298: 		LD		C,A				;ENDI = BASEl + LENGTHI + 1
00:0099 0600            	   299: 		LD		B,0
00:009B 09              	   300: 		ADD		HL,BC
00:009C 23              	   301: 		INC		HL				;HL = START OF CONCATENATION
00:009D 1A              	   302: 		LD		A,(DE)			;SAVE LENGTH OF STRING 2
00:009E 32E600          	   303: 		LD		(S2LEN),A
00:00A1 13              	   304: 		INC		DE				;DE = FIRST CHARACTER OF STRING 2
00:00A2 C1              	   305: 		POP		BC				; RESTORE MAX I MUM LENGTH
                        	   306: 			;DETERMINE HOW MANY CHARACTERS TO CONCATENATE
00:00A3 4F              	   307: 		LD      C,A				;ADD LENGTHS OF STRINGS
00:00A4 3AE500          	   308: 		LD      A,(S1LEN)
00:00A7 81              	   309: 		ADD     A,C
00:00A8 3805            	   310: 		JR	    C,TOOLNG		; JUMP IF SUM EXCEEDS 255
00:00AA B8              	   311: 		CP      B				;COMPARE TO MAXIMUM LENGTH
00:00AB 2817            	   312: 		JR      Z,LENOK			;JUMP IF NEW STRING IS MAX LENGTH
00:00AD 3815            	   313: 		JR      C,LENOK			; OR LESS
                        	   314: 			; COMBINED STRING IS TOO LONG
                        	   315: 			; INDICATE A STRING OVERFLOW, STRGOV := OFFH
                        	   316: 			; NUMBER OF CHARACTERS TO CONCATENATE    MAXLEN - SlLEN
                        	   317: 			; LENGTH OF STRING 1 = MAXIMUM LENGTH
                        	   318: TOOLNG:
00:00AF 3EFF            	   319: 		LD		A,0FFH			; INDICATE STRING OVERFLOW
00:00B1 32E700          	   320: 		LD		(STRGOV),A
00:00B4 3AE500          	   321: 		LD		A, (S1LEN)		;CALCULATE MAXLEN - S1LEN
00:00B7 4F              	   322: 		LD		C,A
00:00B8 78              	   323: 		LD		A,B
00:00B9 91              	   324: 		SUB		C
00:00BA D8              	   325: 		RET  	C				;EXIT IF ORIGINAL STRING TOO LONG
00:00BB 32E600          	   326: 		LD		(S2LEN),A		;CHANGE S2LEN TO MAXLEN - SlLEN
00:00BE 78              	   327: 		LD		A,B				;LENGTH OF STRING 1 = MAXIMUM
00:00BF 32E500          	   328: 		LD		(S1LEN), A
00:00C2 1807            	   329: 		JR		DOCAT			;PERFORM CONCATENATION
                        	   330: 			; RESULTING LENGTH DOES NOT EXCEED MAXIMUM
                        	   331: 			; LENGTH OF STRING 1 = SILEN + S2LEN
                        	   332: 			; INDICATE NO OVERFLOW. STRGOV := 0
                        	   333: 			; NUMBER OF CHARACTERS TO CONCATENATE = LENGTH OF STRING 2
                        	   334: LENOK:
00:00C4 32E500          	   335: 		LD		(S1LEN),A		;SAVE SUM OF LENGTHS
00:00C7 97              	   336: 		SUB		A				;INDICATE NO OVERFLOW
00:00C8 32E700          	   337: 		LD		(STRGOV),A
                        	   338: 			; CONCATENATE STRINGS BY MOVING CHARACTERS FROM STRING 2
                        	   339: 			; TO END OF STRING 1
                        	   340: DOCAT:
00:00CB 3AE600          	   341: 		LD		A,(S2LEN)		;GET NUMBER OF CHARACTERS
00:00CE B7              	   342: 		OR		A
00:00CF 2806            	   343: 		JR		Z,EXIT			;EXIT IF NOTHING TO CONCATENATE
00:00D1 4F              	   344: 		LD		C,A				;BC = NUMBER OF CHARACTERS
00:00D2 0600            	   345: 		LD		B,0
00:00D4 EB              	   346: 		EX		DE,HL			;DE = DESTINATION
                        	   347: 								;HL = SOURCE
00:00D5 EDB0            	   348: 		LDIR					;MOVE CHARACTERS
                        	   349: EXIT:
00:00D7 3AE500          	   350: 		LD      A,(S1LEN)		;ESTABLISH NEW LENGTH OF STRING    1
00:00DA 2AE300          	   351: 		LD      HL,(S1ADR)
00:00DD 77              	   352: 		LD      (HL),A
00:00DE 3AE700          	   353: 		LD      A,(STRGOV)		;CARRY = 1 IF OVERFLOW. 0 IF NOT
00:00E1 1F              	   354: 		RRA
00:00E2 C9              	   355: 		RET
                        	   356: 			;DATA
00:00E3 00              	   357: S1ADR:    DS      2				;BASE ADDRESS OF STRING 1
00:00E4 *
00:00E5 00              	   358: S1LEN:    DS      1				;LENGTH OF STRING 1
00:00E6 00              	   359: S2LEN:    DS      1				;LENGTH OF STRING 2
00:00E7 00              	   360: STRGOV:   DS      1				;STRING OVERFLOW FLAG
                        	   361: 
                        	   362: 
                        	   363: 
                        	   364: 		; SAMPLE EXECUTION:
                        	   365: 
                        	   366: 
                        	   367: ; SC8B:
                        	   368: ; 		LD      HL,S1_8B           ;HL = BASE ADDRESS OF SI
                        	   369: ; 		LD      DE,S2_8B           ;DE = BASE ADDRESS OF S2
                        	   370: ; 		LD      B,20H           ;B = MAXIMUM LENGTH OF STRING 1
                        	   371: ; 		CALL    CONCAT          ;CONCATENATE STRINGS
                        	   372: ; 		JR      SC8B            ;RESULT OF CONCATENATING
                        	   373: ; 								; "LASTNAME" AND ". FIRSTNAME"
                        	   374: ; 								;IS S1 = 13H,"LASTNAME. FIRSTNAME"
                        	   375: 
                        	   376: 
                        	   377: 
                        	   378: ;****************************************************************************************************************
                        	   379: ;****************************************************************************************************************
                        	   380: 		; Find the Position of a Substring (POS)                                                                             
                        	   381: 		; Examples
                        	   382: 		; I.    Data:      String = lD'ENTER SPEED IN MILES                      3.    Data:    String= IO'LETYI = Xl + R7'(1
                        	   383: 		; 				PER HOUR' (lD 16 = 29 10 is the length of                            the length of the string)
                        	   384: 		; 				the string)                                                        Substring = 02'R4' (02 is the length of the
                        	   385: 		; 				Substring = OS'MILES' (05 is the length of                             substring)
                        	   386: 		; 				the substring)                                           Result:   A contains 0, since the substring 'R4' does 
                        	   387: 		; 	Result:     A contains 10 16 (16 10 ), the index at which the                      appear in the string LET YI = X
                        	   388: 		; 				substring 'MILES' starts.
                        	   389: 		; 																	4.    Data:    String = 07'RESTORE' (07 is the length of
                        	   390: 		; 																						the string)
                        	   391: 		; 																					Substring = 03'RES' (03 is the length of the
                        	   392: 		; 2.    Data:      String= IB'SALES FIGURES FOR JUNE                                      substring)
                        	   393: 		; 					1981 '(IBI6 = 2710 is the length of the string)
                        	   394: 		; 																			Result:   A contains I, the index at which the substring
                        	   395: 		; 				Substring = 04'JUNE' (04 is the length of the
                        	   396: 		; 																						'RES' starts. An index of I indicates that
                        	   397: 		; 				substring)
                        	   398: 		; 																						the substring could be an abbreviation of
                        	   399: 		; 	Result:     A contains 13 16 (19 10 ), the index at which the                      the string. Interactive program
                        	   400: 		; 				substring 'JUNE' starts.                                             BASIC intepreters and word processors,
                        	   401: 		; 																						often use such abbreviations to save on
                        	   402: 		; 																						typing and storage.
                        	   403: 		; 				Title                        Find the position of a substring in a string
                        	   404: 		; 				Name:                        P~S
                        	   405: 		; 				Purpose:                     Search for the first occurrence of a substring
                        	   406: 		; 											within a string and return its starting index.
                        	   407: 		; 											If the substring is not found a 0 is returned.
                        	   408: 		; 				Entry:                       Register pair HL = Base address of string
                        	   409: 		; 											Register pair DE = Base address of substring
                        	   410: 		; 												A string is a maximum of 255 bytes long plus
                        	   411: 		; 												a length byte which precedes it.
                        	   412: 		; 				Exit:                        If the substring is found then
                        	   413: 		; 											Register A = its starting index
                        	   414: 		; 											else
                        	   415: 		; 											Register A = 0
                        	   416: 		; 				Registers used: AF,BC,DE,HL
                        	   417: 		; 				Time:                        Since the algorithm is so data-dependent,
                        	   418: 		; 						a simple formula is impossible, but the
                        	   419: 		; 						following statements are true. and a
                        	   420: 		; 						worst case is given.
                        	   421: 		; 						154 cycles overhead
                        	   422: 		; 						Each match of 1 character takes 56 cycles
                        	   423: 		; 						A mismatch takes 148 cycles
                        	   424: 		; 						Worst case timing will be when the
                        	   425: 		; 						string and substring always match
                        	   426: 		; 						except for the last character of the
                        	   427: 		; 						substring. such as
                        	   428: 		; 							string = ~AAAAAAAAAB~
                        	   429: 		; 							substring = ~AAB'
                        	   430: 		; 		Size:              Program 69 bytes
                        	   431: 		; 						Data     7 bytes
                        	   432: ;****************************************************************************************************************
                        	   433: ;****************************************************************************************************************
                        	   434: 
                        	   435: 
                        	   436: POS:
                        	   437: 			; SET UP TEMPORARIES
                        	   438: 			; EXIT IF STRING OR SUBSTRING HAS ZERO LENGTH
00:00E8 222D01          	   439: 		LD		(STRING),HL		;SAVE STRING ADDRESS
00:00EB EB              	   440: 		EX		DE,HL
00:00EC 7E              	   441: 		LD		A, (HL)			;TEST LENGTH OF SUBSTRING
00:00ED B7              	   442: 		OR		A
00:00EE 283B            	   443: 		JR		Z,NOTFND		;EXIT IF LENGTH OF SUBSTRING = 0
00:00F0 23              	   444: 		INC		HL				;MOVE PAST LENGTH BYTE OF SUBSTRING
00:00F1 222F01          	   445: 		LD		(SUBSTG),HL		;SAVE SUBSTRING ADDRESS
00:00F4 323201          	   446: 		LD		(SUBLEN),A
00:00F7 4F              	   447: 		LD		C,A				;C = SUBSTRING LENGTH
00:00F8 1A              	   448: 		LD		A, (DE)			;TEST LENGTH OF STRING
00:00F9 B7              	   449: 		OR		A
00:00FA 282F            	   450: 		JR		Z,NOTFND			;EXIT IF LENGTH OF STRING = 0
                        	   451: 			; NUMBER OF SEARCHES = STRING LENGTH - SUBSTRING LENGTH
                        	   452: 			;  + 1. AFTER THAT. NO USE SEARCHING SINCE THERE AREN'T
                        	   453: 			;  ENOUGH CHARACTERS LEFT TO HOLD SUBSTRING
                        	   454: 			; 
                        	   455: 			; IF SUBSTRING IS LONGER THAN STRING, EXIT IMMEDIATELY AND
                        	   456: 			; INDICATE SUBSTRING NOT FOUND
00:00FC 91              	   457: 		SUB		C				;A = STRING LENGTH - SUBSTRING LENGTH
00:00FD 382C            	   458: 		JR		C,NOTFND		;EXIT IF STRING SHORTER THAN SUBSTRING
00:00FF 3C              	   459: 		INC		A				;COUNT = DIFFERENCE IN LENGTHS + 1
00:0100 47              	   460: 		LD		B,A
00:0101 97              	   461: 		SUB		A				;INITIAL STARTING INDEX = 0
00:0102 323301          	   462: 		LD		(INDEX),A
                        	   463: 
                        	   464: 			; ,SEARCH UNTIL REMAINING STRING SHORTER THAN SUBSTRING
                        	   465: SLP1:
00:0105 213301          	   466: 		LD		HL,INDEX		;INCREMENT STARTING INDEX
00:0108 34              	   467: 		INC		(HL)
00:0109 213201          	   468: 		LD		HL,SUBLEN		;C = LENGTH OF SUBSTRING
00:010C 4E              	   469: 		LD		C, (HL)
00:010D 2A2D01          	   470: 		LD		HL, (STRING)	; INCREMENT TO NEXT BYTE OF STRING
00:0110 23              	   471: 		INC		HL
00:0111 222D01          	   472: 		LD		(STRING),HL		;HL = NEXT ADDRESS IN STRING
00:0114 ED5B2F01        	   473: 		LD		DE, (SUBSTG)	; DE = STARTING ADDRESS OF SUBSTRING
                        	   474: 								;C = CURRENT VALUE OF COUNT
                        	   475: 		;TRY TO MATCH SUBSTRING STARTING AT INDEX
                        	   476: 		;MATCH INVOLVES COMPARING CORRESPONDING CHARACTERS
                        	   477: 		; ONE AT A TIME
                        	   478: cmpLoop_8C:
00:0118 1A              	   479: 		LD		A, (DE)			;GET A CHARACTER OF SUBSTRING
00:0119 BE              	   480: 		CP		(HL)			;COMPARE TO CHARACTER OF STRING
00:011A 2007            	   481: 		JR		NZ,SLP2			; ,JUMP IF NOT SAME
00:011C 0D              	   482: 		DEC		C
00:011D 2808            	   483: 		JR		Z,FOUND			; ,JUMP IF SUBSTRING FOUND
00:011F 23              	   484: 		INC		HL				; PROCEED TO NEXT CHARACTERS
00:0120 13              	   485: 		INC		DE
00:0121 18F5            	   486: 		JR		cmpLoop_8C
                        	   487: 		; ARRIVE HERE IF MATCH FAILS, SUBSTRING NOT YET FOUND
                        	   488: SLP2:	
00:0123 10E0            	   489: 		DJNZ	SLP1			;TRY NEXT HIGHER INDEX IF
                        	   490: 								; ENOUGH STRING LEFT
00:0125 1804            	   491: 		JR		NOTFND			;ELSE EXIT NOT FOUND
                        	   492: 		;FOUND SUBSTRING, RETURN ITS STARTING INDEX
                        	   493: FOUND:
00:0127 3A3301          	   494: 		LD		A, (INDEX)		;SUBSTRING FOUND, A    STARTING INDEX
00:012A C9              	   495: 		RET
                        	   496: 		;COULD NOT FIND SUBSTRING, RETURN 0 AS INDEX
                        	   497: NOTFND:
00:012B 97              	   498: 		SUB		A				;SUBSTRING NOT FOUND, A = 0
00:012C C9              	   499: 		RET
                        	   500: 		;DATA
00:012D 00              	   501: STRING:		DS	2				;BASE ADDRESS OF STRING
00:012E *
00:012F 00              	   502: SUBSTG:		DS	2				;BASE ADDRESS OF SUBSTRING
00:0130 *
00:0131 00              	   503: SLEN:		DS	1				;LENGTH OF STRING
00:0132 00              	   504: SUBLEN:		DS	1				;LENGTH OF SUBSTRING
00:0133 00              	   505: INDEX:		DS	1				;CURRENT INDEX INTO STRING
                        	   506: 
                        	   507: 		; SAMPLE EXECUTION:
                        	   508: ; SC8C:
                        	   509: ; 		LD		HL,STG_8C			;HL = BASE ADDRESS OF STRING
                        	   510: ; 		LD		DE,SSTG_8C		;DE = BASE ADDRESS OF SUBSTRING
                        	   511: ; 		CALL	POS				;FIND POSITION OF SUBSTRING
                        	   512: ; 								; SEARCHING "AAAAAAAAAB" FOR "AAB"
                        	   513: ; 								; RESULTS IN REGISTER A = 8
                        	   514: ; 		JR		SC8C			;LOOP   FOR ANOTHER TEST
                        	   515: ; 			; ~TEST   DATA, CHANGE FOR OTHER VALUES
                        	   516: ; STG_8C:	DB		0AH				;LENGTH OF STRING
                        	   517: ; 		DB		"AAAAAAAAAB                       " ;32 BYTE MAX LENGTH
                        	   518: ; SSTG_8C:	DB		3H				;LENGTH OF SUBSTRING
                        	   519: ; 		DB		"AAB                              " ;32 BYTE MAX LENGTH
                        	   520: 
                        	   521: ;****************************************************************************************************************
                        	   522: ;****************************************************************************************************************
                        	   523: 		; Copy a Substring from a String (COPY)                                                                              
                        	   524: 		; 			
                        	   525: 		; length of and the Carry flag will be set to 1. If                the substring, the Carry flag is cleared.
                        	   526: 		; Examples
                        	   527: 		; I.    Data:    String= IO'LET YI = R7 + X4'                      3.    Data:    String = 16'9414 HEGENBERGER DRIVE'
                        	   528: 		; 				(10'6 = 16 10 is the length of the string)                       (16'6 = 2210 is the length of the string)
                        	   529: 		; 			Maximum length of substring = 2                                  Maximum length of substring = 10'6 = 16 10
                        	   530: 		; 			Number of bytes to copy = 2                                      Number of bytes to copy = 11'6 = 1710
                        	   531: 		; 			Starting index = 5                                               Starting index = 6
                        	   532: 		; 	Result:   Substring = 02'Y I' (2 is the length of the            Result:   Substring = IO'HEGENBERGER DRIV'
                        	   533: 		; 				substring)                                                       (10'6 = 16 10 is the length of the substring)
                        	   534: 		; 			Two bytes from the string were copied,                           Carry= I, since the number of bytes to copy
                        	   535: 		; 				starting at character #5 (that is, characters                    exceeded the maximum length of the sub-
                        	   536: 		; 				5 and 6)                                                         string.
                        	   537: 		; 			Carry = 0, since no problems occurred in
                        	   538: 		; 				forming the substring.
                        	   539: 		; 2.    Data:    String = OE'8657 POWELL ST'
                        	   540: 		; 				(OE'6 = 1410 is the length of the string)
                        	   541: 		; 			Maximum length of substring = 10'6 = 16 10
                        	   542: 		; 			Number of bytes to copy = OD'6 = 1310
                        	   543: 		; 			Starting index = 6
                        	   544: 		; 	Result:   Substring = 09'POWELL ST' (09 is the
                        	   545: 		; 				length of the substring)
                        	   546: 		; 			Carry = I, since there were not enough
                        	   547: 		; 				characters available in the string to provide
                        	   548: 		; 				the specified number of bytes to copy.
                        	   549: 		; 			Tit le                     Copy a substring from a string
                        	   550: 		; 			Name:                      COpy
                        	   551: 		; 		Purpose:             Copy a substring from a string given a starting
                        	   552: 		; 							index and the number of bytes
                        	   553: 		; 		Entry:               Register pair HL = Address of source string      ~
                        	   554: 		; 							Register pair DE = Address of destination string~
                        	   555: 		; 							Register A = Maximum length of destination
                        	   556: 		; 											string
                        	   557: 		; 							Register B = Number of bytes to copy
                        	   558: 		; 							Register C   Starting index into source string
                        	   559: 		; 										Index of 1 is first character of
                        	   560: 		; 										string
                        	   561: 		; 								A string is a maximum of 255 bytes long plus
                        	   562: 		; 								a length byte which precedes it.
                        	   563: 		; 		Exit:                Destination string := The substring from the
                        	   564: 		; 							string.
                        	   565: 		; 							if no errors then
                        	   566: 		; 								CARRY := 0
                        	   567: 		; 							else
                        	   568: 		; 								begin
                        	   569: 		; 								the following conditions cause an
                        	   570: 		; 								error and the CARRY flag = 1.
                        	   571: 		; 								if (index = 0) or (maxlen = 0) or
                        	   572: 		; 										(index> length(source then
                        	   573: 		; 									the destination string will have a zero
                        	   574: 		; 									length.
                        	   575: 		; 								if (index + count - 1) > length(source)
                        	   576: 		; 								then
                        	   577: 		; 									the destination string becomes everything
                        	   578: 		; 									from index to the end of source string.
                        	   579: 		; 								END~
                        	   580: 		; 		Registers used: AF.BC.DE.HL
                        	   581: 		; 		Time:                Approximately (21   *   count) cycles plus 237
                        	   582: 		; 							cycles overhead.
                        	   583: 		; 		Size:                Program 73 bytes
                        	   584: 		; 							Data     2 bytes
                        	   585: ;****************************************************************************************************************
                        	   586: ;****************************************************************************************************************
                        	   587: 
                        	   588: 
                        	   589: COPY:
                        	   590: 			; SAVE    MAXIMUM LENGTH OF DESTINATION STRING
00:0134 327D01          	   591: 		LD		(MAXLEN),A		;SAVE MAXIMUM LENGTH
                        	   592: 			; INITIALIZE    LENGTH OF DESTINATION STRING AND ERROR FLAG
00:0137 97              	   593: 		SUB		A
00:0138 12              	   594: 		LD		(DE),A			;LENGTH OF DESTINATION STRING = ZERO
00:0139 327E01          	   595: 		LD		(CPYERR),A		;ASSUME NO ERRORS
                        	   596: 
                        	   597: 			; IF NUMBER OF BYTES TO COPY IS O. EXIT WITH NO ERRORS
00:013C B0              	   598: 		OR		B				;TEST NUMBER OF BYTES TO COPY
00:013D C8              	   599: 		RET		Z               ;EXIT WITH NO ERRORS
                        	   600: 								; CARRY = 0
                        	   601: 			;IF MAXIMUM LENGTH IS 0, TAKE ERROR EXIT
00:013E 3A7D01          	   602: 		LD		A, (MAXLEN)		;TEST MAXIMUM LENGTH
00:0141 B7              	   603: 		OR		A
00:0142 2837            	   604: 		JR		Z,EREXIT		;ERROR EXIT IF MAX LENGTH IS 0
                        	   605: 			;IF STARTING INDEX IS ZERO, TAKE ERROR EXIT
00:0144 79              	   606: 		LD		A,C				;TEST STARTING INDEX
00:0145 B7              	   607: 		OR		A
00:0146 2833            	   608: 		JR		Z,EREXIT		;ERROR EXIT IF INDEX IS 0
                        	   609: 			;IF STARTING INDEX IS GREATER THAN LENGTH OF SOURCE
                        	   610: 			; STRING, TAKE ERROR EXIT
00:0148 7E              	   611: 		LD		A, (HL)			;GET LENGTH OF SOURCE STRING
00:0149 B9              	   612: 		CP		C				;COMPARE TO STARTING INDEX
00:014A D8              	   613: 		RET		C				;ERROR EXIT IF LENGTH LESS THAN INDEX
                        	   614: 								; CARRY = 1
                        	   615: 		; CHECK IF COPY AREA FITS IN SOURCE STRING
                        	   616: 		; OTHERWISE, COPY ONLY TO END OF STRING
                        	   617: 		; COPY AREA FITS IF STARTING INDEX + NUMBER OF
                        	   618: 		; CHARACTERS TO COPY - 1 IS LESS THAN OR EQUAL TO
                        	   619: 		; LENGTH OF SOURCE STRING
                        	   620: 		; NOTE THAT STRINGS ARE NEVER MORE THAN 255 BYTES LONG
00:014B 79              	   621: 		LD		A,C				;FORM STARTING INDEX + COpy LENGTH
00:014C 80              	   622: 		ADD		A,B
00:014D 3806            	   623: 		JR		C,RECALC		;JUMP IF SUM> 255
00:014F 3D              	   624: 		DEC		A
00:0150 BE              	   625: 		CP		(HL)
00:0151 380B            	   626: 		JR		C,CNT1OK		;JUMP IF MORE THAN ENOUGH TO COPY
00:0153 2809            	   627: 		JR		Z,CNT1OK		;JUMP IF EXACTLY ENOUGH
                        	   628: 		;CALLER ASKED FOR TOO MANY CHARACTERS. RETURN EVERYTHING
                        	   629: 		; BETWEEN INDEX AND END OF SOURCE STRING.
                        	   630: 		; SET COUNT := LENGTH(SOURCE) - INDEX + 1;
                        	   631: RECALC:
00:0155 3EFF            	   632: 		LD		A,0FFH			; INDICATE TRUNCATION OF COUNT
00:0157 327E01          	   633: 		LD		(CPYERR),A
00:015A 7E              	   634: 		LD		A, (HL)			;COUNT   = LENGTH   - INDEX +   1
00:015B 91              	   635: 		SUB		C
00:015C 3C              	   636: 		INC		A
00:015D 47              	   637: 		LD		B,A				;CHANGE NUMBER OF BYTES
                        	   638: 			; CHECK IF COUNT LESS THAN OR EQUAL TO MAXIMUM LENGTH OF
                        	   639: 			; DESTINATION STRING. IF NOT, SET COUNT TO MAXIMUM LENGTH
                        	   640: 			; IF COUNT > MAXLEN THEN
                        	   641: 			; COUNT := MAXLEN
                        	   642: CNT1OK:
00:015E 3A7D01          	   643: 		LD		A, (MAXLEN)		;IS MAX LENGTH LARGE ENOUGH?
00:0161 B8              	   644: 		CP		B
00:0162 3006            	   645: 		JR		NC,CNT2OK		; ~UMP IF IT IS
00:0164 47              	   646: 		LD		B,A				;ELSE LIMIT COPY TO MAXLEN
00:0165 3EFF            	   647: 		LD		A,0FFH			; INDICATE STRING OVERFLOW
00:0167 327E01          	   648: 		LD		(CPYERR),A
                        	   649: 			; MOVE    SUBSTRING TO DESTINATION STRING
                        	   650: CNT2OK:
00:016A 78              	   651: 		LD		A,B				;TEST    NUMBER OF BYTES TO COPY
00:016B B7              	   652: 		OR		A
00:016C 280D            	   653: 		JR		Z,EREXIT		;ERROR    EXIT IF NO BYTES TO COpy
00:016E 0600            	   654: 		LD		B,0				;START    COPYING AT STARTING INDEX
00:0170 09              	   655: 		ADD		HL,BC
00:0171 12              	   656: 		LD		(DE), A			;SET LENGTH OF DESTINATION STRING
00:0172 4F              	   657: 		LD		C,A				;RESTORE NUMBER OF BYTES
00:0173 13              	   658: 		INC		DE				;MOVE DESTINATION ADDRESS PAST
                        	   659: 								; LENGTH BYTE
00:0174 EDB0            	   660: 		LDIR					;COPY SUBSTRING
                        	   661: 
                        	   662: 			; CHECK    FOR COPY ERROR
00:0176 3A7E01          	   663: 		LD		A, (CPYERR)		;TEST    FOR ERRORS
                        	   664: OKEXIT_8D:
00:0179 B7              	   665: 		OR		A
00:017A C8              	   666: 		RET		Z               ;RETURN    WITH C = o IF NO ERRORS
                        	   667: 			; ERROR    EXIT
                        	   668: EREXIT:
00:017B 37              	   669: 		SCF						;SET    CARRY TO INDICATE AN ERROR
00:017C C9              	   670: 		RET
                        	   671: 			; DATA    SECTION
00:017D 00              	   672: MAXLEN:	DS	1					;MAXIMUM    LENGTH OF DESTINATION STRING
00:017E 00              	   673: CPYERR: DS	1					;COPY    ERROR FLAG
                        	   674: 
                        	   675: 		; SAMPLE EXECUTION:
                        	   676: ; SC8D:
                        	   677: ; 		LD		HL,SSTG_8D			;SOURCE STRING
                        	   678: ; 		LD		DE, DSTG_8D		;DESTINATION STRING
                        	   679: ; 		LD		A,(IDX_8D)
                        	   680: ; 		LD		C,A				;STARTING    INDEX FOR COPYING
                        	   681: ; 		LD		A, (CNT_8D)
                        	   682: ; 		LD		B,A				;NUMBER OF BYTES TO COPY
                        	   683: ; 		LD		A, (MXLEN_8D)		;MAXIMUM LENGTH OF SUBSTRING
                        	   684: ; 		CALL	COPY			;COPY SUBSTRING
                        	   685: ; 								;COPYING 3 CHARACTERS STARTING AT
                        	   686: ; 								;INDEX 4 FROM '12.345E+l0' GIVES '345'
                        	   687: ; 		JR		SC8D            ;LOOP FOR MORE TESTING
                        	   688: 			; DATA    SECTION
00:017F 04              	   689: IDX_8D:	DB	4					;STARTING INDEX FOR COPYING
00:0180 03              	   690: CNT_8D:	DB	3					;NUMBER OF CHARACTERS TO COPY
00:0181 20              	   691: MXLEN_8D:	DB	20H					; MAXIMUM LENGTH OF DESTINATION STRING
00:0182 0A              	   692: SSTG_8D:	DB	0AH					;LENGTH OF STRING
00:0183 31322E333435452B	   693: 		DB	"12.345E+10                     " ;32 BYTE MAX LENGTH
00:018B 3130202020202020
00:0193 2020202020202020
00:019B 20202020202020
00:01A2 00              	   694: DSTG_8D:	DB	0					;LENGTH OF SUBSTRING
00:01A3 2020202020202020	   695: 		DB  "                               " ; 32 BYTE MAX LENGTH
00:01AB 2020202020202020
00:01B3 2020202020202020
00:01BB 20202020202020
                        	   696: 
                        	   697: 
                        	   698: 
                        	   699: ;****************************************************************************************************************
                        	   700: ;****************************************************************************************************************
                        	   701: 		; Delete a Substring from a String (DELETE)                                                                          
                        	   702: 
                        	   703: 		; 		1. STRING LENGTH = 20 16 (3210)                             1. If the number of bytes to delete is 0, the
                        	   704: 		; 			STARTING INDEX = 19 16 (25 10)                        program exits with the Carry flag cleared (no errors)
                        	   705: 		; 			NUMBER OF BYTES TO DELETE = 08                        and the string unchanged.
                        	   706: 		; 		Since there are exactly eight bytes left in the string       2. If the string does not even extend to the specifi
                        	   707: 		; 	starting at index 19 16 , all the routine must do is trun-   starting index, the program exits with the Carry flag
                        	   708: 		; 	cate (that is, cut off the end of the string). This takes    set to I (indicating an error) and the string unchang
                        	   709: 		; 			21 * 0 + 224 = 224 cycles                                3. If the number of bytes to delete exceeds the
                        	   710: 		; 		2. STRING LENGTH = 40 16 (6410)                           number available, the program deletes all bytes from
                        	   711: 		; 			STARTING INDEX = 19 16 (25 10 )                       the starting index to the end of the string and exits
                        	   712: 		; 			NUMBER OF BYTES TO DELETE = 08                        with the Carry flag set to I (indicating an error).
                        	   713: 
                        	   714: 
                        	   715: 
                        	   716: 
                        	   717: 		; Entry Conditions                                                   Exit Conditions
                        	   718: 		; Base address of string in HL                                       Substring deleted from string. If no errors occu
                        	   719: 		; Number of bytes to delete in B                                     the Carry flag is cleared. If the starting index
                        	   720: 		; Starting index to delete from in C                                 or beyond the length of the string, the Carry fl
                        	   721: 		; 																is set and the string is unchanged. If the number
                        	   722: 		; 																of bytes to delete would go beyond the end ofthe
                        	   723: 		; 																string, the Carry flag is set and the characters
                        	   724: 		; 																from the starting index to the end of the string
                        	   725: 		; 																are deleted.
                        	   726: 
                        	   727: 
                        	   728: 
                        	   729: 		; Examples
                        	   730: 		; I.    Data:     String = 26'SALES FOR MARCH AND                 2.    Data:    String = 28'THE PRICE IS $3.00 ($2.0
                        	   731: 		; 				APRIL OF THIS YEAR'                                            BEFORE JUNE I)' (28 16 = 40 10 is the
                        	   732: 		; 				(26 16 = 3810 is the length of the string)                     length of the string)
                        	   733: 		; 				Number of bytes to delete = OA 16 = 1010                       Number of bytes to delete = 30 16 = 48 10
                        	   734: 		; 				Starting index to delete from = 10 16 = 16 10                  Starting index to delete from = 13 16 = 19 10
                        	   735: 		; 	Result:    String= I C 'SALES FOR MARCH OF THIS                 Result:   String = 12'THE PRICE IS $3.00' (12 16 =
                        	   736: 		; 				YEAR' (IC I6 = 28 10 is the length of the                      18 10 is the length of the string with all
                        	   737: 		; 				string with ten bytes deleted starting with                    remaining bytes deleted)
                        	   738: 		; 				the 16th character-the deleted material is                   Carry = I, since there were not as many bytes
                        	   739: 		; 				'AND APRIL')                                                   left in the string as were supposed to be
                        	   740: 		; 				Carry= 0, since no problems occurred in the                      deleted.
                        	   741: 		; 				deletion.
                        	   742: 
                        	   743: 
                        	   744: 
                        	   745: 
                        	   746: 		; 			Title:                   Delete a substring from a string
                        	   747: 		; 			Name:                    Delete
                        	   748: 
                        	   749: 
                        	   750: 
                        	   751: 		; 			Purpose:                 Delete a substring from a string given a
                        	   752: 		; 										starting index and a length
                        	   753: 		; 			Entry:                   Register pair HL = Base address of string
                        	   754: 		; 										Register B = Number of bytes to delete
                        	   755: 		; 										Register C = Starting index into the string.
                        	   756: 		; 												An index of 1 is the first character
                        	   757: 		; 										A string is a maximum of 255 bytes long plus
                        	   758: 		; 										a length byte which precedes it.
                        	   759: 		; 			Exit :                   Substring deleted.
                        	   760: 		; 										if no errors then
                        	   761: 		; 										CARRY := 0
                        	   762: 		; 										else
                        	   763: 
                        	   764: 		; 							begin
                        	   765: 		; 								the following conditions cause an
                        	   766: 		; 								error with .CARRY = 1.
                        	   767: 		; 								if (index = 0) or (index> length(string
                        	   768: 		; 								then do not change string
                        	   769: 		; 								if count is too large then
                        	   770: 		; 								delete only the characters from
                        	   771: 		; 								index to end of string
                        	   772: 
                        	   773: 		; 		Registers used: AF,BC,DE,HL
                        	   774: 		; 		Time:             Approximately 21 * (LENGTH(STRG)-INDEX-COUNT+l)
                        	   775: 		; 							plus 224 cycles overhead
                        	   776: 		; 		Size:             Program 58 bytes
                        	   777: 		; 							Data     1 bytes
                        	   778: ;****************************************************************************************************************
                        	   779: ;****************************************************************************************************************
                        	   780: 
                        	   781: 
                        	   782: 
                        	   783: DELETE:
                        	   784: 			;INITIALIZE ERROR INDICATOR (DELERR) TO 0
00:01C2 97              	   785: 		SUB		A
00:01C3 32FC01          	   786: 		LD		(DELERR),A		;ASSUME NO ERRORS
                        	   787: 			;CHECK IF COUNT AND INDEX ARE BOTH NON-ZERO
00:01C6 B0              	   788: 		OR		B				;TEST NUMBER OF BYTES TO DELETE
00:01C7 C8              	   789: 		RET		Z				;RETURN WITH CARRY = 0 (NO ERRORS) IF
                        	   790: 								; 0 BYTES TO DELETE
00:01C8 79              	   791: 		LD		A,C				;TEST STARTING INDEX
00:01C9 B7              	   792: 		OR		A
00:01CA 37              	   793: 		SCF						;CARRY = 1
00:01CB C8              	   794: 		RET		Z				;ERROR EXIT (CARRY = 1) IF
                        	   795: 			; STARTING INDEX = 0
                        	   796: 			; CHECK IF STARTING INDEX WITHIN STRING
                        	   797: 			; ERROR EXIT IF NOT
00:01CC 7E              	   798: 		LD		A, (HL)			;GET LENGTH
00:01CD B9              	   799: 		CP		C				;IS INDEX WITHIN STRING?
00:01CE D8              	   800: 		RET		C				;NO, TAKE ERROR EXIT
                        	   801: 			;BE SURE ENOUGH CHARACTERS ARE AVAILABLE
                        	   802: 			; IF NOT, DELETE ONLY TO END OF STRING
                        	   803: 			; IF INDEX + NUMBER OF CHARACTERS - 1 > LENGTH(STRING) THEN
                        	   804: 			; NUMBER OF CHARACTERS := LENGTH(STRING) - INDEX + 1
00:01CF 79              	   805: 		LD		A,C				;,GET INDEX
00:01D0 80              	   806: 		ADD		A,B				;ADD NUMBER OF CHARACTERS TO DELETE
00:01D1 380C            	   807: 		JR		C,TRUNC			;TRUNCATE IF SUM> 255
00:01D3 5F              	   808: 		LD		E,A				;SAVE SUM AS STARTING INDEX FOR MOVE
00:01D4 3D              	   809: 		DEC		A
00:01D5 BE              	   810: 		CP		(HL)			;COMPARE TO LENGTH
00:01D6 380F            	   811: 		JR		C,CNTOK			;JUMP IF ENOUGH CHARACTERS AVAILABLE
00:01D8 2805            	   812: 		JR		Z,TRUNC			;TRUNCATE BUT NO ERRORS (EXACTLY ENOUGH
                        	   813: 								;CHARACTERS)
00:01DA 3EFF            	   814: 		LD		A,0FFH			;INDICATE ERROR - NOT ENOUGH CHARACTERS
00:01DC 32FC01          	   815: 		LD		(DELERR),A		;AVAILABLE FOR DELETION
                        	   816: 			;TRUNCATE STRING - NO COMPACTING NECESSARY
                        	   817: 			; STRING LENGTH = INDEX - 1
                        	   818: TRUNC:
00:01DF 79              	   819: 		LD		A,C				;STRING LENGTH   = INDEX     - 1
00:01E0 3D              	   820: 		DEC		A
00:01E1 77              	   821: 		LD		(HL),A
00:01E2 3AFC01          	   822: 		LD		A, (DELERR)
00:01E5 1F              	   823: 		RRA						;CARRY   =0   IF NO ERRORS
00:01E6 C9              	   824: 		RET						;EXIT
                        	   825: 			;DELETE SUBSTRING BY COMPACTING
                        	   826: 			; MOVE ALL CHARACTERS ABOVE DELETED AREA DOWN
                        	   827: 			;NEW LENGTH = OLD LENGTH - NUMBER OF BYTES TO DELETE
                        	   828: CNTOK:
00:01E7 7E              	   829: 		LD		A, (HL)
00:01E8 57              	   830: 		LD		D,A				;SAVE OLD LENGTH
00:01E9 90              	   831: 		SUB		B				;SET NEW LENGTH
00:01EA 77              	   832: 		LD		(HL),A
                        	   833: 			;CALCULATE NUMBER OF CHARACTERS TO MOVE
                        	   834: 			; NUMBER = STRING LENGTH - (INDEX + NUMBER OF BYTES) + 1
00:01EB 7A              	   835: 		LD		A,D				;OET OLD LENGTH
00:01EC 93              	   836: 		SUB		E				;SUBTRACT INDEX + NUMBER OF BYTES
00:01ED 3C              	   837: 		INC		A				;A = NUMBER OF CHARACTERS TO MOVE
                        	   838: 			;CALCULATE SOURCE AND DESTINATION ADDRESSES FOR MOVE
                        	   839: 			;SOURCE = BASE + INDEX + NUMBER OF BYTES TO DELETE
                        	   840: 			;DESTINATION = BASE + INDEX
00:01EE E5              	   841: 		PUSH	HL				;SAVE STRING ADDRESS
00:01EF 0600            	   842: 		LD		B,0				;DESTINATION = BASE + INDEX
00:01F1 09              	   843: 		ADD		HL,BC
00:01F2 E3              	   844: 		EX		(SP),HL			; SOURCE = BASE + INDEX + NUMBER
00:01F3 1600            	   845: 		LD		D,0				;OF BYTES TO DELETE
00:01F5 19              	   846: 		ADD		HL,DE			;HL = SOURCE (ABOVE DELETED AREA)
00:01F6 D1              	   847: 		POP		DE				;DE = DESTINATION
00:01F7 4F              	   848: 		LD		C,A				;BC = NUMBER OF CHARACTERS TO MOVE
00:01F8 EDB0            	   849: 		LDIR					;COMPACT STRING BY MOVING DOWN
                        	   850: 		; GOOD EXIT
                        	   851: OKEXIT_8E:
00:01FA B7              	   852: 		OR		A					;CLEAR CARRY, NO ERRORS
00:01FB C9              	   853: 		RET
                        	   854: 		; DATA
00:01FC 00              	   855: DELERR: DS	1						;DELETE ERROR FLAG
                        	   856: 
                        	   857: 		; SAMPLE EXECUTION:
                        	   858: 
                        	   859: ; SC8E:
                        	   860: ; 		LD		HL,SSTG_8E 			;HL   = BASE   ADDRESS OF STRING
                        	   861: ; 		LD		A,(IDX_8E)
                        	   862: ; 		LD		C,A					;C    = STARTING INDEX FOR DELETION
                        	   863: ; 		LD		A, (CNT_8E)
                        	   864: ; 		LD		B,A					;B= NUMBER OF CHARACTERS TO DELETE
                        	   865: ; 		CALL	DELETE				;DELETE CHARACTERS
                        	   866: ; 									;DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	   867: ; 									; FROM ".JOE HANDOVER" LEAVES "HANDOVER"
                        	   868: ; 		JR		SC8E				;LOOP FOR ANOTHER TEST
                        	   869: 			; DATA SECTION
00:01FD 01              	   870: IDX_8E:	DB      1                    ;STARTING INDEX FOR DELETION
00:01FE 04              	   871: CNT_8E:	DB      4                    ;NUMBER OF CHARACTERS TO DELETE
00:01FF 0C              	   872: SSTG_8E:	DB      12                   ;LENGTH OF STRING
00:0200 2E4A4F452048414E	   873: 		DB      ".JOE HANDOVER"
00:0208 444F564552
                        	   874: 
                        	   875: 
                        	   876: 
                        	   877: ;****************************************************************************************************************
                        	   878: ;****************************************************************************************************************
                        	   879: 		; Insert a Substring into a String (INSERT)                                                                          
                        	   880: 		; 	produces a string longer than the maximum.
                        	   881: 		; 																Program Size: 90 bytes
                        	   882: 		; 	Examples
                        	   883: 		; 																Data Memory Required: One byte anywhere in
                        	   884: 		; 		1. STRING LENGTH = 20'6 (3210)                            RAM for an error flag (address INS ERR).
                        	   885: 		; 			STARTING INDEX = 19'6 (25 10 )
                        	   886: 		; 			MAXIMUM LENGTH = 30'6 (48 10 )                         Special Cases:
                        	   887: 		; 			SUBSTRING LENGTH = 06                                     I. If the length ofthe substring (the insertion) is 0,
                        	   888: 		; 		We want to insert a substring six bytes long, start-       the program exits with the Carry flag cleared (no
                        	   889: 		; 	ing at the 25th character. Since eight bytes must be         errors) and the string unchanged.
                        	   890: 		; 			2. If the starting index for the insertion is 0 (that      4. If the starting index of the insertion is beyond
                        	   891: 		; 		is, the insertion would start in the length byte), the      the end of the string, the program concatenates the
                        	   892: 		; 		program exits with the Carry flag set to I (indicating      insertion at the end of the string and indicates an
                        	   893: 		; 		an error) and the string unchanged.                         error by setting the Carry flag to I.
                        	   894: 		; 		3. If the string with the substring inserted exceeds         5. If the original length of the string exceeds its
                        	   895: 		; 		the specified maximum length, the program inserts           specified maximum length, the program exits with
                        	   896: 		; 		only enough characters to reach the maximum length.         the Carry flag set to 1 (indicating an error) and the
                        	   897: 		; 		The Carry flag is set to I to indicate that the insertion   string unchanged.
                        	   898: 		; 		has been truncated.
                        	   899: 		; Examples
                        	   900: 		; I.    Data:    String = OA'JOHN SMITH' (OA'6 = 1010 is               2.    Data:    String = OA'JOHN SMITH' (OA'6 =
                        	   901: 		; 				the length of the string)                                            the length of the string)
                        	   902: 		; 			Substring = 08'WILLIAM' (08 is the length                            Substring = OC'ROCKEFELLER' (OC'6 =
                        	   903: 		; 				of the substring)                                                     1210 is the length of the substring)
                        	   904: 		; 			Maximum length of string = 14'6 = 20 10                              Maximum length of string = 14'6 = 20 10
                        	   905: 		; 			Starting index = 06                                                  Starting index = 06
                        	   906: 		; 	Result:   String = 12'JOHN WILLIAM SMITH'                            Result:   String= 14'JOHN ROCKEFELLESMITH'
                        	   907: 		; 				(12'6 = 18 10 is the length of the string                            (14'6 = 20 10 is the length ofthe string w
                        	   908: 		; 				with the substring inserted)                                         as much of the substring inserted as the
                        	   909: 		; 			Carry = 0, since no problems occurred in the                           maximum length would allow)
                        	   910: 		; 				insertion.                                                         Carry = I, since some of the substring could
                        	   911: 		; 																					not be inserted without exceeding the maxi-
                        	   912: 		; 																					mum length of the string.
                        	   913: 		; 		Tit Ie:         Insert a substring into a string
                        	   914: 		; 		Name:           Insert
                        	   915: 		; 		Purpose:        Insert a substring into a string given a
                        	   916: 		; 						starting index
                        	   917: 		; 		Entry:          Register pair HL     Address of string
                        	   918: 		; 						Register pair DE     Address of substring to
                        	   919: 		; 												insert
                        	   920: 		; 						Register B   Maximum length of string
                        	   921: 		; 						Register C = Starting index to insert the
                        	   922: 		; 									sl.Jbstring
                        	   923: 		; 							A string is a maximum of 255 bytes long plus
                        	   924: 		; 							a length byte which precedes it.
                        	   925: 		; 		Exit:           Substring inserted into string.
                        	   926: 		; 						if no errors then
                        	   927: 		; 							CARRY = 0
                        	   928: 		; 						else
                        	   929: 		; 							begin
                        	   930: 		; 							the following conditions cause the
                        	   931: 		; 							CARRY flag to be set.
                        	   932: 		; 							if index = 0 then
                        	   933: 		; 								do not insert the substring
                        	   934: 		; 							if length(strg) > maximum length then
                        	   935: 		; 								do not insert the substring
                        	   936: 		; 							if index> length(strg) then
                        	   937: 		; 								concatenate substg onto the end of the
                        	   938: 		; 								source string
                        	   939: 		; 							if length(strg)+length(substring) > maxlen
                        	   940: 		; 								then insert only enough of the substring
                        	   941: 		; 								to reach maximum length
                        	   942: 		; 							end;
                        	   943: 		; 		Registers used: AF,BC,DE,HL
                        	   944: 		; 		Time:           Approxi'matel y
                        	   945: 		; 						21 * (LENGTH(STRG) - INDEX + 1) +
                        	   946: 		; 						21 * (LENGTH(SUBSTG  +
                        	   947: 		; 						290 cycles overhead
                        	   948: 		; 		Size:           Program 90 bytes
                        	   949: 		; 						Data     1 byte
                        	   950: ;****************************************************************************************************************
                        	   951: ;****************************************************************************************************************
                        	   952: 
                        	   953: 
                        	   954: 
                        	   955: INSERT_STR:
                        	   956: 			;INITIALIZE ERROR FLAG
00:020D 97              	   957: 		SUB		A				;ERROR FLAG    o (NO ERRORS)
00:020E 326702          	   958: 		LD		(INSERR) ,A
                        	   959: 			;GET SUBSTRING AND STRING LENGTHS
                        	   960: 			; IF LENGTH(SUBSTG) = 0 THEN EXIT BUT NO ERROR
00:0211 1A              	   961: 		LD		A, (DE)			; TEST LENGTH OF SUBSTRING
00:0212 B7              	   962: 		OR		A
00:0213 C8              	   963: 		RET		Z				;EXIT IF SUBSTRING EMPTY
                        	   964: 								; CARRY = 0 (NO ERRORS)
                        	   965: 			;IF STARTING INDEX IS ZERO, TAKE ERROR EXIT
                        	   966: IDX0:
00:0214 79              	   967: 		LD		A,C				;TEST STARTING INDEX
00:0215 B7              	   968: 		OR		A
00:0216 37              	   969: 		SCF						;ASSUME AN ERROR
00:0217 C8              	   970: 		RET		Z				;RETURN WITH ERROR IF INDEX = 0
                        	   971: 			;CHECK WHETHER INSERTION WILL MAKE STRING TOO LONG
                        	   972: 			; IF IT WILL. TRUNCATE SUBSTRING AND SET
                        	   973: 			; TRUNCATION FLAG.
                        	   974: 			; INSERTION TOO LONG IF STRING LENGTH + SUBSTRING LENGTH
                        	   975: 			; EXCEEDS MAXIMUM LENGTH. REMEMBER. STRINGS CANNOT BE
                        	   976: 			; MORE THAN 255 BYTES LONG
                        	   977: CHKLEN:
00:0218 1A              	   978: 		LD		A,(DE)			;TOTAL = STRING + SUBSTRING
00:0219 86              	   979: 		ADD		A,(HL)
00:021A 3806            	   980: 		JR		C,TRUNC_8F			;TRUNCATE SUBSTRING IF NEW LENGTH> 255
00:021C B8              	   981: 		CP		B				;COMPARE TO MAXIMUM LENGTH OF STRING
00:021D 1A              	   982: 		LD		A,(DE)			;A = LENGTH OF SUBSTRING
00:021E 380C            	   983: 		JR		C,IDXLEN		;JUMP IF TOTAL < MAX LENGTH
00:0220 280A            	   984: 		JR		Z,IDXLEN		; OR EQUAL
                        	   985: 			;SUBSTRING DOES NOT FIT. SO TRUNCATE IT
                        	   986: 			; SET ERROR FLAG TO INDICATE TRUNCATION
                        	   987: 			; LENGTH THAT FITS = MAXIMUM LENGTH - STRING LENGTH
                        	   988: TRUNC_8F:
00:0222 3EFF            	   989: 		LD		A,0FFH          ; INDICATE SUBSTRING TRUNCATED
00:0224 326702          	   990: 		LD		(INSERR), A
00:0227 78              	   991: 		LD		A,B             ;LENGTH = MAX - STRING LENGTH
00:0228 96              	   992: 		SUB		(HL)
00:0229 D8              	   993: 		RET		C               ;RETURN WITH ERROR IF STRING TOO
00:022A 37              	   994: 		SCF						; LONG INITIALLY OR ALREADY MAX
00:022B C8              	   995: 		RET		Z               ; LENGTH SO NO ROOM FOR SUBSTRING
                        	   996: 			;CHECK IF INDEX WITHIN STRING. IF NOT, CONCATENATE
                        	   997: 			; SUBSTRING ONTO END OF STRING
                        	   998: IDXLEN:
00:022C 47              	   999: 		LD		B,A				;B = LENGTH OF SUBSTRING
00:022D 7E              	  1000: 		LD		A,(HL)			;GET STRING LENGTH
00:022E B9              	  1001: 		CP	C               ;COMPARE TO INDEX
00:022F 3012            	  1002: 		JR		NC,LENOK_8F		;JUMP IF STARTING INDEX WITHIN STRING
                        	  1003: 			;INDEX NOT WITHIN STRING, SO CONCATENATE
                        	  1004: 			; NEW LENGTH OF STRING = OLD LENGTH + SUBSTRING LENGTH
00:0231 4F              	  1005: 		LD		C, A			; SAVE CURRENT STRING LENGTH
00:0232 80              	  1006: 		ADD		A, B			; ADD LENGTH OF SUBSTRING
00:0233 77              	  1007: 		LD		(HL),A			;SET NEW LENGTH OF STRING
                        	  1008: 			;SET ADDRESSES FOR CONCATENATION
                        	  1009: 			; DE = STRING ADDRESS + LENGTH(STRING) + 1
                        	  1010: 			; HL = SUBSTRING ADDRESS
00:0234 EB              	  1011: 		EX		DE,HL			;HL        SUBSTRING ADDRESS
00:0235 79              	  1012: 		LD		A,C				;DE      = END OF STRING
00:0236 3C              	  1013: 		INC		A
00:0237 83              	  1014: 		ADD		A,E
00:0238 5F              	  1015: 		LD		E,A
00:0239 3001            	  1016: 		JR		NC,IDXL1
00:023B 14              	  1017: 		INC		D
                        	  1018: IDXL1:
00:023C 3EFF            	  1019: 		LD		A,0FFH			;INDICATE INSERTION ERROR
00:023E 326702          	  1020: 		LD		(INSERR), A
00:0241 1819            	  1021: 		JR		MVESUB			;JUST MOVE, NOTHING TO OPEN UP
                        	  1022: 			; OPEN UP SPACE IN SOURCE STRING FOR SUBSTRING BY MOVING
                        	  1023: 			; CHARACTERS FROM END OF SOURCE STRING DOWN TO INDEX, UP BY
                        	  1024: 			; SIZE OF SUBSTRING.
                        	  1025: 			; A = LENGTH(STRING)
                        	  1026: LENOK_8F:
00:0243 C5              	  1027: 		PUSH    BC				;SAVE LENGTH OF SUBSTRING
00:0244 D5              	  1028: 		PUSH    DE				;,SAVE ADDRESS OF SUBSTRING
                        	  1029: 			;NEW LENGTH OF STRING   = OLD    LENGTH + SUBSTRING LENGTH
00:0245 5F              	  1030: 		LD		E,A			; DE   = STRING LENGTH
00:0246 1600            	  1031: 		LD		D,0
00:0248 80              	  1032: 		ADD		A,B
00:0249 77              	  1033: 		LD		(HL),A			;STORE NEW LENGTH OF STRING
                        	  1034: 			; CALCULATE NUMBER OF CHARACTERS TO MOVE
                        	  1035: 			; = STRING LENGTH - STARTING INDEX + 1
00:024A 7B              	  1036: 		LD		A,E				;GET ORIGINAL LENGTH OF STRING
00:024B 91              	  1037: 		SUB		C
00:024C 3C              	  1038: 		INC		A				;A     = NUMBER   OF CHARACTERS TO MOVE
                        	  1039: 			;CALCULATE ADDRESS OF LAST CHARACTER IN STRING. THIS IS
                        	  1040: 			; SOURCE ADDRESS = STRING ADDRESS + LENGTH(STRING)
00:024D 19              	  1041: 		ADD	HL,DE				;HL POINTS TO LAST CHARACTER IN STRING
00:024E 5D              	  1042: 		LD		E,L				;DE ALSO
00:024F 54              	  1043: 		LD		D,H
                        	  1044: 			;CALCULATE DESTINATION ADDRESS
                        	  1045: 			; = STRING ADDRESS + LENGTH(STRING) + LENGTH OF SUBSTRING
                        	  1046: 			;THIS MOVE MUST START AT HIGHEST ADDRESS AND WORK DOWN
                        	  1047: 			; TO AVOID OVERWRITING PART OF THE STRING
00:0250 48              	  1048: 		LD		C,B				;BC = LENGTH OF SUBSTRING
00:0251 0600            	  1049: 		LD		B,0
00:0253 09              	  1050: 		ADD		HL,BC
00:0254 EB              	  1051: 		EX		DE,HL			;HL = SOURCE ADDRESS
                        	  1052: 								;DE = DESTINATION ADDRESS
00:0255 4F              	  1053: 		LD		C,A             ;BC = NLiMBER OF CHARACTERS TO MOVE
00:0256 EDB8            	  1054: 		LDDR					;OPEN UP FOR SUBSTRING
                        	  1055: 			;RESTORE REGISTERS
00:0258 EB              	  1056: 		EX		DE,HL
00:0259 13              	  1057: 		INC		DE				;DE = ADDRESS TO MOVE STRING TO
00:025A E1              	  1058: 		POP		HL				;HL = ADDRESS OF SUBSTRING
00:025B C1              	  1059: 		POP		BC				;B = LENGTH OF SUBSTRING
                        	  1060: 			;MOVE SUBSTRING INTO OPEN AREA
                        	  1061: 			; HL = ADDRESS OF SUBSTRING
                        	  1062: 			; DE = ADDRESS TO MOVE SUBSTRING TO
                        	  1063: 			; C = LENGTH OF SUBSTRING
                        	  1064: MVESUB:
00:025C 23              	  1065: 		INC		HL				;INCREMENT PAST LENGTH BYTE OF SUBSTRING
00:025D 48              	  1066: 		LD		C,B				;BC = LENGTH OF SUBSTRING TO MOVE
00:025E 0600            	  1067: 		LD		B,0
00:0260 EDB0            	  1068: 		LDIR					;MOVE SUBSTRING INTO OPEN AREA
00:0262 3A6702          	  1069: 		LD		A, (INSERR)		;GET ERROR FLAG
00:0265 1F              	  1070: 		RRA						;IF INSERR <> 0 THEN CARRY = 1
                        	  1071: 								;TO INDICATE AN ERROR
00:0266 C9              	  1072: 		RET
                        	  1073: 			;DATA SECTION
00:0267 00              	  1074: INSERR: DS	1					;FLAG USED TO INDICATE ERROR
                        	  1075: 
                        	  1076: 		; SAMPLE EXECUTION:
                        	  1077: ; SC8F:
                        	  1078: ; 		LD		HL,STG_8F 		;HL = BASE ADDRESS OF STRING
                        	  1079: ; 		LD		DE,SSTG_8F		;DE = BASE ADDRESS OF SUBSTRING
                        	  1080: ; 		LD		A,(IDX_8F)
                        	  1081: ; 		LD		C,A				;C = STARTING INDEX FOR INSERTION
                        	  1082: ; 		LD		A,(MXLEN_8F)
                        	  1083: ; 		LD		B,A				;B = MAXIMUM LENGTH OF STRING
                        	  1084: ; 		CALL	INSERT_STR		;INSERT SUBSTRING
                        	  1085: ; 								;RESULT OF INSERTING ~-~ INTO ~123456~ AT
                        	  1086: ; 								; INDEX 1 IS ~-123456~
                        	  1087: ; 		JR		SC8F			;LOOP FOR ANOTHER TEST
                        	  1088: 			; DATA SECTION
00:0268 01              	  1089: IDX_8F:	DB	1					;STARTING INDEX FOR I NSERTI ON
00:0269 20              	  1090: MXLEN_8F:	DB	20H					;MAXIMUM LENGTH OF DESTINATION
00:026A 06              	  1091: STG_8F:	DB	06H					;LENGTH OF STRING
00:026B 3132333435362020	  1092: 		DB	"123456                                 " ;32 BYTE MAX LENGTH
00:0273 2020202020202020
00:027B 2020202020202020
00:0283 2020202020202020
00:028B 20202020202020
00:0292 01              	  1093: SSTG_8F:	DB	1					;LENGTH OF SUBSTRING
00:0293 2D20202020202020	  1094: 		DB  "-                                      " ;32 BYTE MAX LENGTH
00:029B 2020202020202020
00:02A3 2020202020202020
00:02AB 2020202020202020
00:02B3 20202020202020
                        	  1095: 
                        	  1096: ;********************************************************************************************
                        	  1097: ;********************************************************************************************	
                        	  1098: 		;		Copy the area of variables to RAM memory  (F000)
                        	  1099: Init_RAM_HEAP:
                        	  1100: 		GLOBAL	Init_RAM_HEAP
                        	  1101: 
00:02BA 110000          	  1102: 		ld		DE,SRAM_VAR_START		; defined in linker script
00:02BD 21CA02          	  1103: 		ld		hl,zero_byte
                        	  1104: 		
00:02C0 010000          	  1105: 		ld 		BC,HEAP_SIZE			; defined in linker script
                        	  1106: .cl_vars:
00:02C3 EDA0            	  1107: 		ldi							; (DE)<-(HL)
00:02C5 2B              	  1108: 		dec 	hl
00:02C6 EAC302          	  1109: 		jp		PE,.cl_vars			; 		P/V is set if BC  1  0; otherwise, it is reset.
00:02C9 C9              	  1110: 		ret
00:02CA 00              	  1111: zero_byte:	db  0
                        	  1112: ;********************************************************************************************
                        	  1113: ;***************************************************************************************************
                        	  1114: ;***************************************************************************************************
                        	  1115: 
                        	  1116: 		; 		dump memory content to screen. alt 1  dm 100  < without address>
                        	  1117: 		; 										alt 2  dm $1234,100  < with address>
                        	  1118: 
                        	  1119: 
                        	  1120: dumpMemory:
                        	  1121: 		; ***	Dump memory from either lvl1 or PCval and lvl2 or lvl1 bytes
                        	  1122: 		xref 	add_space
                        	  1123: 
                        	  1124: 		; check if lvl2 is zero  
                        	  1125: 
00:02CB 210000          	  1126: 		ld 		HL,commAdr1
00:02CE CD6103          	  1127: 		call	checkZero16 			; check if (commAdr1)=0 2 bytes -> Z 
00:02D1 2006            	  1128: 		jr 		NZ,.adrSizeTyped 		; dump memory ; address and size are typed
                        	  1129: 
                        	  1130: 		; ***	Only size typed, address from PCvalue
00:02D3 2A0000          	  1131: 		ld 		HL,(PCvalue)				; HL = start address
00:02D6 220000          	  1132: 		ld 		(commAdr1),HL 			; temp storage of PCvalue
                        	  1133: 
                        	  1134: .adrSizeTyped:
                        	  1135: 		; ***	both address and size typed
00:02D9 110000          	  1136: 		ld 		DE,commAdr1				; DE = start address
00:02DC 010000          	  1137: 		ld 		BC,commLvl1				; BC = number of bytes
                        	  1138: 
00:02DF 1A              	  1139: 		ld  	A,(DE)
00:02E0 E6F0            	  1140: 		and 	$F0 					; adjust to nearest 16 byte block
00:02E2 12              	  1141: 		ld 		(DE),A
00:02E3 ED5B0000        	  1142: 		ld 		DE,(commAdr1)			; HL = start address
                        	  1143: 
00:02E7 ED4B0000        	  1144: 		ld 		BC,(commLvl1) 			; get the size...  divide by $10
00:02EB CB38            	  1145: 		srl 	B 
00:02ED CB19            	  1146: 		RR 		C
00:02EF CB38            	  1147: 		srl 	B 
00:02F1 CB19            	  1148: 		RR 		C
00:02F3 CB38            	  1149: 		srl 	B 
00:02F5 CB19            	  1150: 		RR 		C
00:02F7 CB38            	  1151: 		srl 	B 
00:02F9 CB19            	  1152: 		RR 		C					; BC = number of lines, nearest higher 16 byte block
                        	  1153: 
                        	  1154: display_BC_bytes:
00:02FB C5              	  1155: 		push 	bc					; save the line counter
                        	  1156: 
00:02FC 216A03          	  1157: 			ld 		HL,dumpText+1		; new buffer for text output
00:02FF CD0000          	  1158: 			call	Bin2Hex16			;address in DE -> result added to (HL)-> to last 0x00. hl updatd (+4)
                        	  1159: 			
00:0302 3E3A            	  1160: 			ld  	A,':'
00:0304 77              	  1161: 			ld 		(HL),A  
00:0305 23              	  1162: 			inc 	HL
00:0306 D5              	  1163: 			push 	DE 			; store adress of first char
00:0307 AF              	  1164: 				xor 	A						; clear A
00:0308 320000          	  1165: 				ld 		(generalFlags),A 		; indicate first round , hexvalues
00:030B CD3303          	  1166: 				call 	displayBytes		; put values in buffer pointed by HL, advance HL
00:030E D1              	  1167: 			pop 	DE					; pop back address of first char.
                        	  1168: 	
00:030F 3E7C            	  1169: 			ld 		A,'|'
00:0311 77              	  1170: 					ld 		(HL),A  
00:0312 23              	  1171: 			inc 	HL
                        	  1172: 
                        	  1173: 
00:0313 3E0F            	  1174: 			ld 		A,$0F
00:0315 320000          	  1175: 			ld 		(generalFlags),A 		; indicate second round , chars
00:0318 CD3303          	  1176: 			call 	displayBytes
                        	  1177: 		
00:031B 3E7C            	  1178: 			ld 		A,'|'
00:031D 77              	  1179: 					ld 		(HL),A  
00:031E 23              	  1180: 			inc 	HL
                        	  1181: 
00:031F AF              	  1182: 			xor 	a
00:0320 77              	  1183: 			ld 		(hl),A
                        	  1184: 
00:0321 FD216903        	  1185: 			ld 		iy,dumpText
00:0325 CD0000          	  1186: 			call	WriteLineCRNL
                        	  1187: 
00:0328 C1              	  1188: 		pop 	bc						; pop back the line counter
00:0329 0B              	  1189: 		dec 	bc 						; decrease # lines...
00:032A 3E00            	  1190: 		ld  	A,0
00:032C B8              	  1191: 		cp    	B
00:032D 20CC            	  1192: 		jr 		NZ,display_BC_bytes
00:032F B9              	  1193: 		cp 		C
00:0330 20C9            	  1194: 		jr 		NZ,display_BC_bytes
                        	  1195: 
                        	  1196: 
                        	  1197: 
00:0332 C9              	  1198: 		ret
                        	  1199: 
                        	  1200: 
                        	  1201: 
                        	  1202: displayBytes:
                        	  1203: 
00:0333 0610            	  1204: 		ld 		b,$10
                        	  1205: displayLoop:
00:0335 78              	  1206: 		ld 		A,B
00:0336 C5              	  1207: 		push 	BC			; save the # byte counter
                        	  1208: 	
00:0337 FE08            	  1209: 		cp 		$08			; is B ( A-8) 8 bytes ?
00:0339 3E01            	  1210: 		ld 		A,$01
00:033B 2002            	  1211: 		jr 		NZ,.noextraSpace
00:033D C603            	  1212: 		add 	$03 	
                        	  1213: .noextraSpace:
00:033F 47              	  1214: 		ld 		B,A
00:0340 CD0000          	  1215: 		call	add_space		; add (b) spaces to (hl), advance hl	
                        	  1216: 
00:0343 3A0000          	  1217: 		ld  	A,(generalFlags)
00:0346 B7              	  1218: 		or  	A 				; check if zero ->  first round - Hex values
00:0347 280C            	  1219: 		jr  	Z,firstRound
                        	  1220: 
                        	  1221: 		; ***	print out the ascii characters.
                        	  1222: 		; ***	if val isChar	
                        	  1223: 
00:0349 EB              	  1224: 		ex 		DE,HL 				; HL -> memory bytes
00:034A CD7C00          	  1225: 		call 	isChar				; is (HL) char ? return with Carry-> value in A is always '.'
00:034D EB              	  1226: 		ex 		DE,HL				; swithch HL back to text buf dumpText		
                        	  1227: 		
00:034E 77              	  1228: 		ld 		(HL),A
00:034F 23              	  1229: 		inc 	HL
00:0350 13              	  1230: 		inc 	DE
00:0351 C1              	  1231:  		pop 	bc					; pop back the # byte counter
00:0352 10E1            	  1232: 		djnz 	displayLoop			; display (b) bytes  with spaces...
                        	  1233: 
00:0354 C9              	  1234: 		ret 
                        	  1235: 
                        	  1236: 
                        	  1237: 
                        	  1238: firstRound:		
00:0355 D5              	  1239: 		push 	DE
00:0356 1A              	  1240: 		ld		A,(DE)				; get value from memory to E..?
00:0357 5F              	  1241: 		ld 		E,A
                        	  1242: 
00:0358 CD0000          	  1243: 		call	Bin2Hex8			;result added to (HL)-> to last 0x00. hl updatd (+4)
                        	  1244: 		
00:035B D1              	  1245: 		pop 	DE
00:035C 13              	  1246: 		inc 	DE
                        	  1247: 
                        	  1248: 
00:035D C1              	  1249: 		pop 	bc					; pop back the # byte counter
00:035E 10D5            	  1250: 		djnz 	displayLoop			; display (b) bytes  with spaces...
                        	  1251: 
00:0360 C9              	  1252: 		ret 
                        	  1253: 
                        	  1254: checkZero16:
                        	  1255: 		; ***	check if (HL),(HL+1) = 0 ?		
00:0361 3E00            	  1256: 		ld 		A,00
00:0363 BE              	  1257: 		cp 		(HL)				; ix zero		
00:0364 C0              	  1258: 		ret 	NZ	
00:0365 23              	  1259: 		inc 	HL
00:0366 BE              	  1260: 		cp 		(HL)				; is zero ?	
00:0367 2B              	  1261: 		dec  	HL	
00:0368 C9              	  1262: 		ret							; return with either Z or NZ
                        	  1263: 
                        	  1264: 
                        	  1265: 
00:0369 00              	  1266: dumpText: DC	$80 '/'
00:036A *
                        	  1267: 
                        	  1268: 
                        	  1269: ;***************************************************************************************************
                        	  1270: ;***************************************************************************************************
                        	  1271: ;***************************************************************************************************
                        	  1272: 
                        	  1273: 
                        	  1274: 
                        	  1275: 
                        	  1276: 		;section 	STR_HEAP 
                        	  1277: 		;	space for string constants
                        	  1278: 		GLOBAL	DateBuf,MsgText1,st2g1,st1g2,steq,subst
                        	  1279: 		GLOBAL	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	  1280: 		xdef	Str0,Str2,Str3,Str4,Str7,sourctext1,sourctext2,endtext,src_size
                        	  1281: 		
                        	  1282: 	if DOALIGN
                        	  1283: 		align 1
                        	  1284: 	endif
                        	  1285:  	
                        	  1286: String_HEAP_Start:
00:03E9 2020323032322D31	  1287: DateBuf:		DB		"  2022-12-30_17:22   ",0,0
00:03F1 322D33305F31373A
00:03F9 3232202020
00:03FE 00
00:03FF 00
                        	  1288: 
00:0400 48656C6C6F2C2065	  1289: MsgText1:		DB		"Hello, enter command: >_",  0, 0
00:0408 6E74657220636F6D
00:0410 6D616E643A203E5F
00:0418 00
00:0419 00
                        	  1290: 
00:041A 0F              	  1291: st2g1:			DB		0x0F,"Str 2 > Str 1 !",0,0
00:041B 5374722032203E20
00:0423 53747220312021
00:042A 00
00:042B 00
00:042C 0F              	  1292: st1g2:			DB		0x0F,"Str 1 > Str 2 !",0,0
00:042D 5374722031203E20
00:0435 53747220322021
00:043C 00
00:043D 00
00:043E 0F              	  1293: steq:			DB		0x0F,"Strings Equal !",0,0
00:043F 537472696E677320
00:0447 457175616C2021
00:044E 00
00:044F 00
00:0450 04              	  1294: subst:			DB		4,"seco",0,0
00:0451 7365636F
00:0455 00
00:0456 00
                        	  1295: 
                        	  1296: 
00:0457 207C2E2E2E50432E	  1297: RegLabels1:		DB		" |...PC...|...SP...|...IX...|...IY...|",0
00:045F 2E2E7C2E2E2E5350
00:0467 2E2E2E7C2E2E2E49
00:046F 582E2E2E7C2E2E2E
00:0477 49592E2E2E7C
00:047D 00
00:047E 207C2E2E2E41462E	  1298: RegLabels2:		DB		" |...AF...|...BC...|...DE...|...HL...|",0
00:0486 2E2E7C2E2E2E4243
00:048E 2E2E2E7C2E2E2E44
00:0496 452E2E2E7C2E2E2E
00:049E 484C2E2E2E7C
00:04A4 00
00:04A5 207C2E2E2E414627	  1299: RegLabels3:		DB		" |...AF'..|...BC'..|...DE'..|...HL'..|",0
00:04AD 2E2E7C2E2E2E4243
00:04B5 272E2E7C2E2E2E44
00:04BD 45272E2E7C2E2E2E
00:04C5 484C272E2E7C
00:04CB 00
00:04CC 2053205A20582048	  1300: RegFlags:		DB		" S Z X H X P N C",0
00:04D4 20582050204E2043
00:04DC 00
                        	  1301: 
00:04DD 17              	  1302: Str0:			defb 	23,"Hello, finnally here !",0,0
00:04DE 48656C6C6F2C2066
00:04E6 696E6E616C6C7920
00:04EE 686572652021
00:04F4 00
00:04F5 00
00:04F6 17              	  1303: Str2:			defb	23,"This is the second Bank",0,0
00:04F7 5468697320697320
00:04FF 746865207365636F
00:0507 6E642042616E6B
00:050E 00
00:050F 00
00:0510 17              	  1304: Str3:			defb	23,"This is the third Bank",0,0
00:0511 5468697320697320
00:0519 7468652074686972
00:0521 642042616E6B
00:0527 00
00:0528 00
00:0529 17              	  1305: Str4:			defb	23,"This is the 4'th Bank",0,0
00:052A 5468697320697320
00:0532 7468652034277468
00:053A 2042616E6B
00:053F 00
00:0540 00
00:0541 17              	  1306: Str7:			defb	23,"This is the 7'th Bank",0,0
00:0542 5468697320697320
00:054A 7468652037277468
00:0552 2042616E6B
00:0557 00
00:0558 00
                        	  1307: 
00:0559 0A              	  1308: sourctext1:		DB		10,"First Str:",0,0
00:055A 4669727374205374
00:0562 723A
00:0564 00
00:0565 00
00:0566 0E              	  1309: sourctext2:		DB		14,"Appendix..../a",0,0	
00:0567 417070656E646978
00:056F 2E2E2E2E2F61
00:0575 00
00:0576 00
                        	  1310: 
                        	  1311: src_size:		equ		sourctext2-sourctext1
                        	  1312: 
                        	  1313: endtext:
                        	  1314: String_HEAP_end:
                        	  1315: 
                        	  1316: 
                        	  1317: 	if DOALIGN
                        	  1318: 		align 4
                        	  1319: 	endif
                        	  1320: 
                        	  1321: 
                        	  1322: 
                        	  1323: .END
                        	  1324: 


Symbols by name:
Bin2Hex16                       external
Bin2Hex8                        external
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CHKLEN                          00:0218
CNT1OK                          00:015E
CNT2OK                          00:016A
CNTOK                           00:01E7
CNT_8D                          00:0180
CNT_8E                          00:01FE
CONCAT                          00:0090 EXP
COPY                            00:0134 EXP
CPYERR                          00:017E
CR                               E:000D
DELERR                          00:01FC
DELETE                          00:01C2 EXP
DOALIGN                          E:0000
DOCAT                           00:00CB
DSTG_8D                         00:01A2
DateBuf                         00:03E9 EXP
EREXIT                          00:017B
EXIT                            00:00D7
FOUND                           00:0127
HEAP_SIZE                       external
IDX0                            00:0214
IDXL1                           00:023C
IDXLEN                          00:022C
IDX_8D                          00:017F
IDX_8E                          00:01FD
IDX_8F                          00:0268
INDEX                           00:0133
INSERR                          00:0267
INSERT_STR                      00:020D EXP
Init_RAM_HEAP                   00:02BA EXP
LENOK                           00:00C4
LENOK_8F                        00:0243
LENS1                           00:0020
LENS2                           00:0021
MAXLEN                          00:017D
MVESUB                          00:025C
MXLEN_8D                        00:0181
MXLEN_8F                        00:0269
MsgText1                        00:0400 EXP
NOTFND                          00:012B
OKEXIT_8D                       00:0179
OKEXIT_8E                       00:01FA
PCvalue                         external
POS                             00:00E8 EXP
RECALC                          00:0155
RegFlags                        00:04CC EXP
RegLabels1                      00:0457 EXP
RegLabels2                      00:047E EXP
RegLabels3                      00:04A5 EXP
S1ADR                           00:00E3
S1LEN                           00:00E5
S2LEN                           00:00E6
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Vec                      E:F400
SLEN                            00:0131
SLP1                            00:0105
SLP2                            00:0123
SRAM_VAR_START                  external
SSTG_8D                         00:0182
SSTG_8E                         00:01FF
SSTG_8F                         00:0292
STG_8F                          00:026A
STRGOV                          00:00E7
STRING                          00:012D
SUBLEN                          00:0132
SUBSTG                          00:012F
Str0                            00:04DD EXP
Str2                            00:04F6 EXP
Str3                            00:0510 EXP
Str4                            00:0529 EXP
Str7                            00:0541 EXP
String_HEAP_Start               00:03E9
String_HEAP_end                 00:0577
TOOLNG                          00:00AF
TRUNC                           00:01DF
TRUNC_8F                        00:0222
WriteLineCRNL                   external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
add_space                       external EXP
checkZero16                     00:0361
cmpLength                       00:0018
cmpLoop                         00:0011
cmpLoop_8C                      00:0118
commAdr1                        external
commLvl1                        external
delimChars                      00:0022
displayBytes                    00:0333
displayLoop                     00:0335
display_BC_bytes                00:02FB
dumpMemory                      00:02CB EXP
dumpText                        00:0369
endtext                         00:0577 EXP
exitDelim                       00:003E
exitZero                        00:0042
firstRound                      00:0355
generalFlags                    external
gpioB                           external
gpio_in                         external
gpio_out                        external
isChar                          00:007C EXP
isDelimit                       00:002C EXP
isHex                           00:0058 EXP
nxtdelim                        00:0034
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             00:004F EXP
skipPriorDelimit                00:0046 EXP
sourctext1                      00:0559 EXP
sourctext2                      00:0566 EXP
src_size                         E:000D EXP
st1g2                           00:042C EXP
st2g1                           00:041A EXP
steq                            00:043E EXP
str2ISshorter                   00:000C
strCompare                      00:0000 EXP
subst                           00:0450 EXP
zero_byte                       00:02CA

Symbols by value:
0000 DOALIGN
0000 strCompare
000C str2ISshorter
000D CR
000D src_size
0011 cmpLoop
0018 cmpLength
0020 LENS1
0021 LENS2
0022 delimChars
002C isDelimit
0034 nxtdelim
003E exitDelim
0042 exitZero
0046 skipPriorDelimit
004F skipCharsUntilDelim
0058 isHex
007C isChar
0090 CONCAT
00AF TOOLNG
00C4 LENOK
00CB DOCAT
00D7 EXIT
00E3 S1ADR
00E5 S1LEN
00E6 S2LEN
00E7 STRGOV
00E8 POS
0105 SLP1
0118 cmpLoop_8C
0123 SLP2
0127 FOUND
012B NOTFND
012D STRING
012F SUBSTG
0131 SLEN
0132 SUBLEN
0133 INDEX
0134 COPY
0155 RECALC
015E CNT1OK
016A CNT2OK
0179 OKEXIT_8D
017B EREXIT
017D MAXLEN
017E CPYERR
017F IDX_8D
0180 CNT_8D
0181 MXLEN_8D
0182 SSTG_8D
01A2 DSTG_8D
01C2 DELETE
01DF TRUNC
01E7 CNTOK
01FA OKEXIT_8E
01FC DELERR
01FD IDX_8E
01FE CNT_8E
01FF SSTG_8E
020D INSERT_STR
0214 IDX0
0218 CHKLEN
0222 TRUNC_8F
022C IDXLEN
023C IDXL1
0243 LENOK_8F
025C MVESUB
0267 INSERR
0268 IDX_8F
0269 MXLEN_8F
026A STG_8F
0292 SSTG_8F
02BA Init_RAM_HEAP
02CA zero_byte
02CB dumpMemory
02FB display_BC_bytes
0333 displayBytes
0335 displayLoop
0355 firstRound
0361 checkZero16
0369 dumpText
03E9 DateBuf
03E9 String_HEAP_Start
0400 MsgText1
041A st2g1
042C st1g2
043E steq
0450 subst
0457 RegLabels1
047E RegLabels2
04A5 RegLabels3
04CC RegFlags
04DD Str0
04F6 Str2
0510 Str3
0529 Str4
0541 Str7
0559 sourctext1
0566 sourctext2
0577 String_HEAP_end
0577 endtext
F400 SIO_Int_Vec
