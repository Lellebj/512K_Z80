Sections:
00: "Strings" (0-440)


Source: "stdin"
                        	     1: 
                        	     2: 		include "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     3: 
                        	     4: 	
                        	     5: 		section	Strings	
                        	     6: 
                        	     7: 
                        	     8: 
                        	     9: 		GLOBAL strCompare,CONCAT,POS,COPY,DELETE,INSERT_STR,src_size,isHex,isChar,dumpMemory
                        	    10: 		xref	isDelimit
                        	    11: 		
                        	    12: 		; String Manipulation
                        	    13: 		; 8A    String Compare    288
                        	    14: 		; 8B    String Concatenation 292
                        	    15: 		; 8C    Find the Position of a Substring 297
                        	    16: 		; 8D    Copy a Substring from a String 302
                        	    17: 		; 8E    Delete a Substring from a String 308
                        	    18: 		; 8F    Insert a Substring into a String 313
                        	    19: 
                        	    20: ;****************************************************************************************************************
                        	    21: ;****************************************************************************************************************
                        	    22: 		; String Compare (StrCompare)                                                                                      8A
                        	    23: 		;     Compares two strings and sets the Carry and
                        	    24: 		;                                                         Registers Used: AF, BC, DE, HL
                        	    25: 		; Zero flags appropriately. The Zero flag is set to I
                        	    26: 		;                                                         Execution nme:
                        	    27: 		;                                                         larger.
                        	    28: 		; Examples
                        	    29: 		; I.    Data:     String 1 = OS'PRINT' (05 is the length of the   3.    Data:      String 1 = OS'PRINT' (05 is the le
                        	    30: 		;                   string)                                                          string)
                        	    31: 		;                 String 2 = 03'END' (03 is the length of the                      String 2 = 06'SYSTEM' (06 is the l
                        	    32: 		;                   string)                                                          the string)
                        	    33: 		;     Result:    Zero flag = 0 (strings are not identical)            Result:     Zero flag = 0 (strings are not iden
                        	    34: 		;                 Carry flag = 0 (string 2 is not larger than                      Carry flag = I (string 2 is larger
                        	    35: 		;                   string 1)
                        	    36: 		;                                                                 of ASCII characters. Note that the byte preceding
                        	    37: 		; 2.    Data:     String 1 = OS'PRINT' (05 is the length of the   the actual characters contains a hexadecimal
                        	    38: 		;                   string)                                       number (the length of the string), not a character.
                        	    39: 		;                 String 2 = 02'PR' (02 is the length of the      We have represented this byte as two hexadecimal
                        	    40: 		;                   string)
                        	    41: 		;                                                                 digits in front of the string. The string itself is
                        	    42: 		;     Result:    Zero flag = 0 (strings are not identical)
                        	    43: 		;                 Carry flag = 0 (string 2 is not larger than     shown surrounded by single quotation marks.
                        	    44: 		;                                           a length byte which precedes it.
                        	    45: 		;           Exit:                IF string 1 = string 2 THEN
                        	    46: 		;                                   Z=1,C=O
                        	    47: 		;                                 IF string 1 > string 2 THEN
                        	    48: 		;                                   Z=O,C=O
                        	    49: 		;                                 IF string 1 < string 2 THEN
                        	    50: 		;                                   Z=O,C=l
                        	    51: 		;           Registers used: AF,BC,DE,HL
                        	    52: 		;           Time:                91 cycles overhead plus 60 cycles per byte plus
                        	    53: 		;                                 40 cycles if strings are identical
                        	    54: 		;                                 through length of shorter
                        	    55: 		;           Size:                Program 32 bytes
                        	    56: 		;                                 Data     2 bytes
                        	    57: ;****************************************************************************************************************
                        	    58: ;****************************************************************************************************************
                        	    59: 
                        	    60: 
                        	    61: strCompare:
                        	    62: 					;determine which string is shorter
                        	    63: 					;length of shorter = number of bytes to compare
00:0000 7E              	    64: 		LD		A,(HL)				;save length of string 1
00:0001 320000          	    65: 		LD		(LENS1),A
00:0004 1A              	    66: 		LD		A, (DE)				;save length of string 2
00:0005 320000          	    67: 		LD		(LENS2),A
00:0008 BE              	    68: 		CP		(HL)				;compare to length of string 1
00:0009 3801            	    69: 		JR		C,str2ISshorter		;jump if string 2 is shorter
00:000B 7E              	    70: 		LD		A, (HL)				;else string 1 is shorter
                        	    71: 					;compare strings through length of shorter
                        	    72: str2ISshorter:
00:000C B7              	    73: 		OR		A					;test length of shorter string
00:000D 2809            	    74: 		JR		Z,cmpLength		;compare lengths ; if length is zero
                        	    75: 
00:000F 47              	    76: 		LD		B,A					;b = number of bytes to compare
00:0010 EB              	    77: 		EX		DE,HL				;de = string 1
                        	    78: 									;hl = string 2
                        	    79: cmpLoop:
00:0011 23              	    80: 		INC		HL					;increment to next bytes
00:0012 13              	    81: 		INC		DE
00:0013 1A              	    82: 		LD		A,(DE)              ;get a byte of string 1
00:0014 BE              	    83: 		CP		(HL)				;compare to byte of string 2
00:0015 C0              	    84: 		RET		NZ					;return with flags set if bytes not EQUAL
00:0016 10F9            	    85: 		DJNZ	cmpLoop				;continue through all bytes
                        	    86: 			; strings same through length of shorter
                        	    87: 			; so use lengths to set flags
                        	    88: cmpLength:
00:0018 3A0000          	    89: 		LD		A,(LENS1)			;compare lengths
00:001B 210000          	    90: 		LD		HL,LENS2
00:001E BE              	    91: 		CP		(HL)
00:001F C9              	    92: 		RET							; return with flags set or cleared
                        	    93: 		; DATA
                        	    94: ; LENS1:	DS		1					;length of string 1
                        	    95: ; LENS2:	DS		1					;length of string 2
                        	    96: 
                        	    97: 		; 5AMPLE EXECUTION:
                        	    98: 
                        	    99: 
                        	   100: ; SC8A:
                        	   101: ; 		LD		HL,S1				;base address of string 1
                        	   102: ; 		LD		DE,S2				;base address of string 2
                        	   103: ; 		CALL	strCompare			;compare strings
                        	   104: ; 									;comparing "string 1" and "string 2"
                        	   105: ; 									; results in string 1 less than
                        	   106: ; 									; string 2. so z=o.c=1
                        	   107: ; 		JR      SC8A				;loop for another test
                        	   108: ; S1:		DB		20H					;string 1
                        	   109: ; S2:		DB		20H					;string 2
                        	   110: 
                        	   111: ;****************************************************************************************************************
                        	   112: ;****************************************************************************************************************
                        	   113: 
                        	   114: 		GLOBAL 		isDelimit,skipPriorDelimit,skipCharsUntilDelim
                        	   115: 
                        	   116: 
                        	   117: delimChars:
00:0020 205F262F232C3D  	   118: 		db   ' _&/#,=',CR,0,0	
00:0027 0D
00:0028 00
00:0029 00
                        	   119: 				; 		isDelimit(S)  is char in (HL) any of the delimiters specified ? =>Z, else ~Z
                        	   120: 				; 		if char in (HL) is '0' ->  set C, else NC
                        	   121: 				; 		Parameters returned; HL - Address of char
                        	   122: 	
                        	   123: 
                        	   124: isDelimit:
00:002A D5              	   125: 		push 	DE
                        	   126: 				; HL points to string, DE points to delimiters
00:002B 112000          	   127: 		ld 		DE,delimChars
00:002E 7E              	   128: 		ld 		a,(HL) 			; char from string
00:002F B7              	   129: 		or 		a 				; is a (DE) = 0 ?
00:0030 280E            	   130: 		jr 		z,exitZero
                        	   131: 
                        	   132: nxtdelim:
                        	   133: 
00:0032 1A              	   134: 		ld 		A,(DE)			; actual delimiter
00:0033 BE              	   135: 		cp 		(HL)			; check present delimiter
00:0034 2806            	   136: 		jr 		z,exitDelim		; Z set
                        	   137: 
                        	   138: 
00:0036 13              	   139: 		inc  	DE				; next delimiter
00:0037 1A              	   140: 		ld  	A,(DE)
00:0038 B7              	   141: 		or 		A 				; =0? 		
00:0039 20F7            	   142: 		jr 		nz,nxtdelim     ; if no -> next delimiter
00:003B 3C              	   143: 		inc 	a 				; clear Z flag
                        	   144: exitDelim:
00:003C 37              	   145: 		scf	
00:003D 3F              	   146: 		ccf						; clear Carry (Z is set if (HL) is delimiter, cleared otherwise)
00:003E D1              	   147: 		pop 	DE
00:003F C9              	   148: 		ret
                        	   149: 
                        	   150: exitZero:
                        	   151: 		; carry flag always cleared.
00:0040 3C              	   152: 		inc 	a 			; clear Z flag
00:0041 37              	   153: 		scf 				; set Carry-char = '0'
00:0042 D1              	   154: 		pop 	DE
00:0043 C9              	   155: 		ret
                        	   156: 
                        	   157: 
                        	   158: skipPriorDelimit:
                        	   159: 				; increase HL until non delimiter (NZ) or #0 (C) 
                        	   160: 				; HL points to acutal pos in 'Textbuf'
00:0044 23              	   161: 		inc 	HL 				; skip past string length or next char	
00:0045 CD2A00          	   162: 		call	isDelimit		;delimiters specified ? =>Z, else ~Z
                        	   163: 								;char in (HL) is '0' ->  set C, else NC
                        	   164: 
00:0048 7E              	   165: 		ld 		a,(HL)			; A = value of actl. char						
00:0049 D8              	   166: 		ret 	C 				; end of string '0' or 'CR' found
                        	   167: 
00:004A C0              	   168: 		ret 	NZ 				; NZ -> (HL) points to non delimiter
00:004B 18F7            	   169: 		jr 		skipPriorDelimit
                        	   170: 
                        	   171: 
                        	   172: skipCharsUntilDelim:
                        	   173: 				; increase HL until delimiter (NZ) or #0 (Z) 
00:004D 23              	   174: 		inc 	HL 				; skip past string length or next char		
00:004E CD2A00          	   175: 		call	isDelimit		;delimiters specified ? =>Z, else ~Z
                        	   176: 								;char in (HL) is '0' ->  set C, else NC
00:0051 7E              	   177: 		ld 		a,(HL)			; A = value of actl. char						
00:0052 D8              	   178: 		ret 	C				; end of string '0' or 'CR' found
00:0053 C8              	   179: 		ret  	Z				; Z -> (HL) points to delimiter
00:0054 18F7            	   180: 		jr 		skipCharsUntilDelim
                        	   181: 
                        	   182: 
                        	   183: ;****************************************************************************************************************
                        	   184: ;****************************************************************************************************************
                        	   185: 
                        	   186: isHex:
                        	   187: 		; ***	Check if characters are HEX ? 
                        	   188: 		; ***	from (HL)  .. 0..9,A..F -> NC  others -> C
00:0056 7E              	   189: 		ld 		A,(HL)
00:0057 D630            	   190: 		sub 	'0'
00:0059 FA7500          	   191: 		jp 		M,.setCarry 		; less than '0'
00:005C FE0A            	   192: 		cp 		10						
00:005E F26400          	   193: 		jp 		P,.checkAF			; bigger than '9'
00:0061 C37700          	   194: 		jp 		.nextChar			; char between 0..9 -> OK
                        	   195: 
                        	   196: .checkAF:
00:0064 E6DF            	   197: 		and 	~$20				; clear bit 5  ($DF) mask to Upper case
                        	   198: 
00:0066 D607            	   199: 		sub 	7		
00:0068 FE0A            	   200: 		cp 		$0A
00:006A FA7500          	   201: 		jp 		M,.setCarry			; less than 'A'
00:006D FE10            	   202: 		cp 		$10		
00:006F F27500          	   203: 		jp 		P,.setCarry			; bigger than 'F'
00:0072 C37700          	   204: 		jp		.nextChar			; char between A..F -> OK
                        	   205: .setCarry:
00:0075 37              	   206: 		scf
00:0076 C9              	   207: 		ret							; return with Carry, value in A is NOT HEX
                        	   208: .nextChar:	
00:0077 37              	   209: 		scf
00:0078 3F              	   210: 		ccf
00:0079 C9              	   211: 		ret							; return without Carry, value in A is HEX
                        	   212: 
                        	   213: ;****************************************************************************************************************
                        	   214: ;****************************************************************************************************************
                        	   215: 
                        	   216: isChar:
                        	   217: 		; ***	Check if characters are Char ? 
                        	   218: 		; ***	from (HL)  $21 .. $-7E -> NC  others -> C
00:007A 7E              	   219: 		ld 		A,(HL)
00:007B FE21            	   220: 		cp	 	$21
00:007D FA8700          	   221: 		jp 		M,.setCarry 		; less than '!'
00:0080 FE7F            	   222: 		cp 		$7F						
00:0082 F28700          	   223: 		jp 		P,.setCarry			; bigger than '~'
00:0085 1804            	   224: 		jr 		.nextChar			; char between A..F -> OK
                        	   225: .setCarry:
00:0087 3E2E            	   226: 		ld 		A,'.'				; set resulting char = '.' in NOT char
00:0089 37              	   227: 		scf
00:008A C9              	   228: 		ret							; return with Carry, value in A is NOT char
                        	   229: .nextChar:	
00:008B 37              	   230: 		scf
00:008C 3F              	   231: 		ccf
00:008D C9              	   232: 		ret							; return without Carry, value in A is char
                        	   233: 
                        	   234: 
                        	   235: 
                        	   236: ;****************************************************************************************************************
                        	   237: ;****************************************************************************************************************
                        	   238: 		; String Concatenation (CONCAT)                                                                                      
                        	   239: 		; 	is
                        	   240: 		; 																with the Carry flag cleared (no errors) and string I
                        	   241: 		; Examples
                        	   242: 		; I.    Data:     Maximum length of string I = OE'6 = 1410       2.    Data:    String I = 07'JOHNSON' (07 is the len
                        	   243: 		; 				String 1= 07'JOHNSON' (07 is the length of                      the string)
                        	   244: 		; 				the string)                                                 String 2= 09',RICHARD'(09 is the length of
                        	   245: 		; 				String 2 = OS',DON' (OS is the length of the                    the string)
                        	   246: 		; 				string)                                           Result:   String 1= OE'JOHNSON, RICHA' (OE'6 =
                        	   247: 		; 	Result:    String 1= OC'JOHNSON, DON'(OC'6= 1210                            1410 is the maximum length allowed, so
                        	   248: 		; 				is the length of the combined string with                     last two characters of string 2 have been
                        	   249: 		; 				string 2 placed after string I)                               dropped)
                        	   250: 		; 				Carry = 0, since the concatenation did not                    Carry= I, since the concatenation produced
                        	   251: 		; 				produce a string exceeding the maximum                        a string longer than the maximum length.
                        	   252: 		; 				length.
                        	   253: 		; 			Title                   String Concatenation
                        	   254: 		; 			Name:                   CONCAT
                        	   255: 		; 			Purpose:                 Concatenate 2 strings into one string
                        	   256: 		; 			Entry:                  Register pair HL = Base address of string 1
                        	   257: 		; 									Register pair DE = Base address of string 2
                        	   258: 		; 									Register B = Maximum length of string 1
                        	   259: 		; 										A string is a maximum of 255 bytes long plus
                        	   260: 		; 										a length byte which precedes it.
                        	   261: 		; 			Exit:                   String 1 := string 1 concatenated with string 2
                        	   262: 		; 									If no errors then
                        	   263: 		; 										CARRY := 0
                        	   264: 		; 									else
                        	   265: 		; 										begin
                        	   266: 		; 											CARRY := 1
                        	   267: 		; 											if the concatenation makes string 1 too
                        	   268: 		; 											long, concatenate only enough of string 2
                        	   269: 		; 											to give string 1 its maximum length.
                        	   270: 		; 											if length(stringl) > maximum length then
                        	   271: 		; 											no concatenation is done
                        	   272: 		; 										end,
                        	   273: 		; 		Registers used: AF.BC.DE.HL
                        	   274: 		; 		Time:             Approximately 21 * (length of string 2) cycles
                        	   275: 		; 							plus 288 cycles overhead
                        	   276: 		; 		Size:             Program 83 bytes
                        	   277: 		; 							Data     5 bytes
                        	   278: ;****************************************************************************************************************
                        	   279: ;****************************************************************************************************************
                        	   280: 
                        	   281: 
                        	   282: 
                        	   283: CONCAT:
                        	   284: 		; DETERMINE WHERE TO START CONCATENATING
                        	   285: 		; CONCATENATION STARTS AT THE END OF STRING 1
                        	   286: 		; END OF STRING 1 = BASEl + LENGTHl + 1, WHERE
                        	   287: 		; THE EXTRA 1 MAKES UP FOR THE LENGTH BYTE
                        	   288: 		; NEW CHARACTERS COME FROM STRING 2, STARTING AT
                        	   289: 		; BASE2 + 1 (SKIPPING OVER LENGTH BYTE)
00:008E 220000          	   290: 		LD		(S1ADR),HL		;SAVE ADDRESS OF STRING 1
00:0091 C5              	   291: 		PUSH	BC				;SAVE MAXIMUM LENGTH OF STRING 1
00:0092 7E              	   292: 		LD		A, (HL)			;SAVE LENGTH OF STRING 1
00:0093 320000          	   293: 		LD		(S1LEN),A
00:0096 4F              	   294: 		LD		C,A				;ENDI = BASEl + LENGTHI + 1
00:0097 0600            	   295: 		LD		B,0
00:0099 09              	   296: 		ADD		HL,BC
00:009A 23              	   297: 		INC		HL				;HL = START OF CONCATENATION
00:009B 1A              	   298: 		LD		A,(DE)			;SAVE LENGTH OF STRING 2
00:009C 320000          	   299: 		LD		(S2LEN),A
00:009F 13              	   300: 		INC		DE				;DE = FIRST CHARACTER OF STRING 2
00:00A0 C1              	   301: 		POP		BC				; RESTORE MAX I MUM LENGTH
                        	   302: 			;DETERMINE HOW MANY CHARACTERS TO CONCATENATE
00:00A1 4F              	   303: 		LD      C,A				;ADD LENGTHS OF STRINGS
00:00A2 3A0000          	   304: 		LD      A,(S1LEN)
00:00A5 81              	   305: 		ADD     A,C
00:00A6 3805            	   306: 		JR	    C,TOOLNG		; JUMP IF SUM EXCEEDS 255
00:00A8 B8              	   307: 		CP      B				;COMPARE TO MAXIMUM LENGTH
00:00A9 2817            	   308: 		JR      Z,LENOK			;JUMP IF NEW STRING IS MAX LENGTH
00:00AB 3815            	   309: 		JR      C,LENOK			; OR LESS
                        	   310: 			; COMBINED STRING IS TOO LONG
                        	   311: 			; INDICATE A STRING OVERFLOW, STRGOV := OFFH
                        	   312: 			; NUMBER OF CHARACTERS TO CONCATENATE    MAXLEN - SlLEN
                        	   313: 			; LENGTH OF STRING 1 = MAXIMUM LENGTH
                        	   314: TOOLNG:
00:00AD 3EFF            	   315: 		LD		A,0FFH			; INDICATE STRING OVERFLOW
00:00AF 320000          	   316: 		LD		(STRGOV),A
00:00B2 3A0000          	   317: 		LD		A, (S1LEN)		;CALCULATE MAXLEN - S1LEN
00:00B5 4F              	   318: 		LD		C,A
00:00B6 78              	   319: 		LD		A,B
00:00B7 91              	   320: 		SUB		C
00:00B8 D8              	   321: 		RET  	C				;EXIT IF ORIGINAL STRING TOO LONG
00:00B9 320000          	   322: 		LD		(S2LEN),A		;CHANGE S2LEN TO MAXLEN - SlLEN
00:00BC 78              	   323: 		LD		A,B				;LENGTH OF STRING 1 = MAXIMUM
00:00BD 320000          	   324: 		LD		(S1LEN), A
00:00C0 1807            	   325: 		JR		DOCAT			;PERFORM CONCATENATION
                        	   326: 			; RESULTING LENGTH DOES NOT EXCEED MAXIMUM
                        	   327: 			; LENGTH OF STRING 1 = SILEN + S2LEN
                        	   328: 			; INDICATE NO OVERFLOW. STRGOV := 0
                        	   329: 			; NUMBER OF CHARACTERS TO CONCATENATE = LENGTH OF STRING 2
                        	   330: LENOK:
00:00C2 320000          	   331: 		LD		(S1LEN),A		;SAVE SUM OF LENGTHS
00:00C5 97              	   332: 		SUB		A				;INDICATE NO OVERFLOW
00:00C6 320000          	   333: 		LD		(STRGOV),A
                        	   334: 			; CONCATENATE STRINGS BY MOVING CHARACTERS FROM STRING 2
                        	   335: 			; TO END OF STRING 1
                        	   336: DOCAT:
00:00C9 3A0000          	   337: 		LD		A,(S2LEN)		;GET NUMBER OF CHARACTERS
00:00CC B7              	   338: 		OR		A
00:00CD 2806            	   339: 		JR		Z,EXIT			;EXIT IF NOTHING TO CONCATENATE
00:00CF 4F              	   340: 		LD		C,A				;BC = NUMBER OF CHARACTERS
00:00D0 0600            	   341: 		LD		B,0
00:00D2 EB              	   342: 		EX		DE,HL			;DE = DESTINATION
                        	   343: 								;HL = SOURCE
00:00D3 EDB0            	   344: 		LDIR					;MOVE CHARACTERS
                        	   345: EXIT:
00:00D5 3A0000          	   346: 		LD      A,(S1LEN)		;ESTABLISH NEW LENGTH OF STRING    1
00:00D8 2A0000          	   347: 		LD      HL,(S1ADR)
00:00DB 77              	   348: 		LD      (HL),A
00:00DC 3A0000          	   349: 		LD      A,(STRGOV)		;CARRY = 1 IF OVERFLOW. 0 IF NOT
00:00DF 1F              	   350: 		RRA
00:00E0 C9              	   351: 		RET
                        	   352: 			;DATA
                        	   353: ; S1ADR:    DS      2				;BASE ADDRESS OF STRING 1
                        	   354: ; S1LEN:    DS      1				;LENGTH OF STRING 1
                        	   355: ; S2LEN:    DS      1				;LENGTH OF STRING 2
                        	   356: ; STRGOV:   DS      1				;STRING OVERFLOW FLAG
                        	   357: 
                        	   358: 
                        	   359: 
                        	   360: 		; SAMPLE EXECUTION:
                        	   361: 
                        	   362: 
                        	   363: ; SC8B:
                        	   364: ; 		LD      HL,S1_8B           ;HL = BASE ADDRESS OF SI
                        	   365: ; 		LD      DE,S2_8B           ;DE = BASE ADDRESS OF S2
                        	   366: ; 		LD      B,20H           ;B = MAXIMUM LENGTH OF STRING 1
                        	   367: ; 		CALL    CONCAT          ;CONCATENATE STRINGS
                        	   368: ; 		JR      SC8B            ;RESULT OF CONCATENATING
                        	   369: ; 								; "LASTNAME" AND ". FIRSTNAME"
                        	   370: ; 								;IS S1 = 13H,"LASTNAME. FIRSTNAME"
                        	   371: 
                        	   372: 
                        	   373: 
                        	   374: ;****************************************************************************************************************
                        	   375: ;****************************************************************************************************************
                        	   376: 		; Find the Position of a Substring (POS)                                                                             
                        	   377: 		; Examples
                        	   378: 		; I.    Data:      String = lD'ENTER SPEED IN MILES                      3.    Data:    String= IO'LETYI = Xl + R7'(1
                        	   379: 		; 				PER HOUR' (lD 16 = 29 10 is the length of                            the length of the string)
                        	   380: 		; 				the string)                                                        Substring = 02'R4' (02 is the length of the
                        	   381: 		; 				Substring = OS'MILES' (05 is the length of                             substring)
                        	   382: 		; 				the substring)                                           Result:   A contains 0, since the substring 'R4' does 
                        	   383: 		; 	Result:     A contains 10 16 (16 10 ), the index at which the                      appear in the string LET YI = X
                        	   384: 		; 				substring 'MILES' starts.
                        	   385: 		; 																	4.    Data:    String = 07'RESTORE' (07 is the length of
                        	   386: 		; 																						the string)
                        	   387: 		; 																					Substring = 03'RES' (03 is the length of the
                        	   388: 		; 2.    Data:      String= IB'SALES FIGURES FOR JUNE                                      substring)
                        	   389: 		; 					1981 '(IBI6 = 2710 is the length of the string)
                        	   390: 		; 																			Result:   A contains I, the index at which the substring
                        	   391: 		; 				Substring = 04'JUNE' (04 is the length of the
                        	   392: 		; 																						'RES' starts. An index of I indicates that
                        	   393: 		; 				substring)
                        	   394: 		; 																						the substring could be an abbreviation of
                        	   395: 		; 	Result:     A contains 13 16 (19 10 ), the index at which the                      the string. Interactive program
                        	   396: 		; 				substring 'JUNE' starts.                                             BASIC intepreters and word processors,
                        	   397: 		; 																						often use such abbreviations to save on
                        	   398: 		; 																						typing and storage.
                        	   399: 		; 				Title                        Find the position of a substring in a string
                        	   400: 		; 				Name:                        P~S
                        	   401: 		; 				Purpose:                     Search for the first occurrence of a substring
                        	   402: 		; 											within a string and return its starting index.
                        	   403: 		; 											If the substring is not found a 0 is returned.
                        	   404: 		; 				Entry:                       Register pair HL = Base address of string
                        	   405: 		; 											Register pair DE = Base address of substring
                        	   406: 		; 												A string is a maximum of 255 bytes long plus
                        	   407: 		; 												a length byte which precedes it.
                        	   408: 		; 				Exit:                        If the substring is found then
                        	   409: 		; 											Register A = its starting index
                        	   410: 		; 											else
                        	   411: 		; 											Register A = 0
                        	   412: 		; 				Registers used: AF,BC,DE,HL
                        	   413: 		; 				Time:                        Since the algorithm is so data-dependent,
                        	   414: 		; 						a simple formula is impossible, but the
                        	   415: 		; 						following statements are true. and a
                        	   416: 		; 						worst case is given.
                        	   417: 		; 						154 cycles overhead
                        	   418: 		; 						Each match of 1 character takes 56 cycles
                        	   419: 		; 						A mismatch takes 148 cycles
                        	   420: 		; 						Worst case timing will be when the
                        	   421: 		; 						string and substring always match
                        	   422: 		; 						except for the last character of the
                        	   423: 		; 						substring. such as
                        	   424: 		; 							string = ~AAAAAAAAAB~
                        	   425: 		; 							substring = ~AAB'
                        	   426: 		; 		Size:              Program 69 bytes
                        	   427: 		; 						Data     7 bytes
                        	   428: ;****************************************************************************************************************
                        	   429: ;****************************************************************************************************************
                        	   430: 
                        	   431: 
                        	   432: POS:
                        	   433: 			; SET UP TEMPORARIES
                        	   434: 			; EXIT IF STRING OR SUBSTRING HAS ZERO LENGTH
00:00E1 220000          	   435: 		LD		(STRING),HL		;SAVE STRING ADDRESS
00:00E4 EB              	   436: 		EX		DE,HL
00:00E5 7E              	   437: 		LD		A, (HL)			;TEST LENGTH OF SUBSTRING
00:00E6 B7              	   438: 		OR		A
00:00E7 283B            	   439: 		JR		Z,NOTFND		;EXIT IF LENGTH OF SUBSTRING = 0
00:00E9 23              	   440: 		INC		HL				;MOVE PAST LENGTH BYTE OF SUBSTRING
00:00EA 220000          	   441: 		LD		(SUBSTG),HL		;SAVE SUBSTRING ADDRESS
00:00ED 320000          	   442: 		LD		(SUBLEN),A
00:00F0 4F              	   443: 		LD		C,A				;C = SUBSTRING LENGTH
00:00F1 1A              	   444: 		LD		A, (DE)			;TEST LENGTH OF STRING
00:00F2 B7              	   445: 		OR		A
00:00F3 282F            	   446: 		JR		Z,NOTFND			;EXIT IF LENGTH OF STRING = 0
                        	   447: 			; NUMBER OF SEARCHES = STRING LENGTH - SUBSTRING LENGTH
                        	   448: 			;  + 1. AFTER THAT. NO USE SEARCHING SINCE THERE AREN'T
                        	   449: 			;  ENOUGH CHARACTERS LEFT TO HOLD SUBSTRING
                        	   450: 			; 
                        	   451: 			; IF SUBSTRING IS LONGER THAN STRING, EXIT IMMEDIATELY AND
                        	   452: 			; INDICATE SUBSTRING NOT FOUND
00:00F5 91              	   453: 		SUB		C				;A = STRING LENGTH - SUBSTRING LENGTH
00:00F6 382C            	   454: 		JR		C,NOTFND		;EXIT IF STRING SHORTER THAN SUBSTRING
00:00F8 3C              	   455: 		INC		A				;COUNT = DIFFERENCE IN LENGTHS + 1
00:00F9 47              	   456: 		LD		B,A
00:00FA 97              	   457: 		SUB		A				;INITIAL STARTING INDEX = 0
00:00FB 320000          	   458: 		LD		(INDEX),A
                        	   459: 
                        	   460: 			; ,SEARCH UNTIL REMAINING STRING SHORTER THAN SUBSTRING
                        	   461: SLP1:
00:00FE 210000          	   462: 		LD		HL,INDEX		;INCREMENT STARTING INDEX
00:0101 34              	   463: 		INC		(HL)
00:0102 210000          	   464: 		LD		HL,SUBLEN		;C = LENGTH OF SUBSTRING
00:0105 4E              	   465: 		LD		C, (HL)
00:0106 2A0000          	   466: 		LD		HL, (STRING)	; INCREMENT TO NEXT BYTE OF STRING
00:0109 23              	   467: 		INC		HL
00:010A 220000          	   468: 		LD		(STRING),HL		;HL = NEXT ADDRESS IN STRING
00:010D ED5B0000        	   469: 		LD		DE, (SUBSTG)	; DE = STARTING ADDRESS OF SUBSTRING
                        	   470: 								;C = CURRENT VALUE OF COUNT
                        	   471: 		;TRY TO MATCH SUBSTRING STARTING AT INDEX
                        	   472: 		;MATCH INVOLVES COMPARING CORRESPONDING CHARACTERS
                        	   473: 		; ONE AT A TIME
                        	   474: cmpLoop_8C:
00:0111 1A              	   475: 		LD		A, (DE)			;GET A CHARACTER OF SUBSTRING
00:0112 BE              	   476: 		CP		(HL)			;COMPARE TO CHARACTER OF STRING
00:0113 2007            	   477: 		JR		NZ,SLP2			; ,JUMP IF NOT SAME
00:0115 0D              	   478: 		DEC		C
00:0116 2808            	   479: 		JR		Z,FOUND			; ,JUMP IF SUBSTRING FOUND
00:0118 23              	   480: 		INC		HL				; PROCEED TO NEXT CHARACTERS
00:0119 13              	   481: 		INC		DE
00:011A 18F5            	   482: 		JR		cmpLoop_8C
                        	   483: 		; ARRIVE HERE IF MATCH FAILS, SUBSTRING NOT YET FOUND
                        	   484: SLP2:	
00:011C 10E0            	   485: 		DJNZ	SLP1			;TRY NEXT HIGHER INDEX IF
                        	   486: 								; ENOUGH STRING LEFT
00:011E 1804            	   487: 		JR		NOTFND			;ELSE EXIT NOT FOUND
                        	   488: 		;FOUND SUBSTRING, RETURN ITS STARTING INDEX
                        	   489: FOUND:
00:0120 3A0000          	   490: 		LD		A, (INDEX)		;SUBSTRING FOUND, A    STARTING INDEX
00:0123 C9              	   491: 		RET
                        	   492: 		;COULD NOT FIND SUBSTRING, RETURN 0 AS INDEX
                        	   493: NOTFND:
00:0124 97              	   494: 		SUB		A				;SUBSTRING NOT FOUND, A = 0
00:0125 C9              	   495: 		RET
                        	   496: 		;DATA
                        	   497: ; STRING:		DS	2				;BASE ADDRESS OF STRING
                        	   498: ; SUBSTG:		DS	2				;BASE ADDRESS OF SUBSTRING
                        	   499: ; SLEN:		DS	1				;LENGTH OF STRING
                        	   500: ; SUBLEN:		DS	1				;LENGTH OF SUBSTRING
                        	   501: ; INDEX:		DS	1				;CURRENT INDEX INTO STRING
                        	   502: 
                        	   503: 		; SAMPLE EXECUTION:
                        	   504: ; SC8C:
                        	   505: ; 		LD		HL,STG_8C			;HL = BASE ADDRESS OF STRING
                        	   506: ; 		LD		DE,SSTG_8C		;DE = BASE ADDRESS OF SUBSTRING
                        	   507: ; 		CALL	POS				;FIND POSITION OF SUBSTRING
                        	   508: ; 								; SEARCHING "AAAAAAAAAB" FOR "AAB"
                        	   509: ; 								; RESULTS IN REGISTER A = 8
                        	   510: ; 		JR		SC8C			;LOOP   FOR ANOTHER TEST
                        	   511: ; 			; ~TEST   DATA, CHANGE FOR OTHER VALUES
                        	   512: ; STG_8C:	DB		0AH				;LENGTH OF STRING
                        	   513: ; 		DB		"AAAAAAAAAB                       " ;32 BYTE MAX LENGTH
                        	   514: ; SSTG_8C:	DB		3H				;LENGTH OF SUBSTRING
                        	   515: ; 		DB		"AAB                              " ;32 BYTE MAX LENGTH
                        	   516: 
                        	   517: ;****************************************************************************************************************
                        	   518: ;****************************************************************************************************************
                        	   519: 		; Copy a Substring from a String (COPY)                                                                              
                        	   520: 		; 			
                        	   521: 		; length of and the Carry flag will be set to 1. If                the substring, the Carry flag is cleared.
                        	   522: 		; Examples
                        	   523: 		; I.    Data:    String= IO'LET YI = R7 + X4'                      3.    Data:    String = 16'9414 HEGENBERGER DRIVE'
                        	   524: 		; 				(10'6 = 16 10 is the length of the string)                       (16'6 = 2210 is the length of the string)
                        	   525: 		; 			Maximum length of substring = 2                                  Maximum length of substring = 10'6 = 16 10
                        	   526: 		; 			Number of bytes to copy = 2                                      Number of bytes to copy = 11'6 = 1710
                        	   527: 		; 			Starting index = 5                                               Starting index = 6
                        	   528: 		; 	Result:   Substring = 02'Y I' (2 is the length of the            Result:   Substring = IO'HEGENBERGER DRIV'
                        	   529: 		; 				substring)                                                       (10'6 = 16 10 is the length of the substring)
                        	   530: 		; 			Two bytes from the string were copied,                           Carry= I, since the number of bytes to copy
                        	   531: 		; 				starting at character #5 (that is, characters                    exceeded the maximum length of the sub-
                        	   532: 		; 				5 and 6)                                                         string.
                        	   533: 		; 			Carry = 0, since no problems occurred in
                        	   534: 		; 				forming the substring.
                        	   535: 		; 2.    Data:    String = OE'8657 POWELL ST'
                        	   536: 		; 				(OE'6 = 1410 is the length of the string)
                        	   537: 		; 			Maximum length of substring = 10'6 = 16 10
                        	   538: 		; 			Number of bytes to copy = OD'6 = 1310
                        	   539: 		; 			Starting index = 6
                        	   540: 		; 	Result:   Substring = 09'POWELL ST' (09 is the
                        	   541: 		; 				length of the substring)
                        	   542: 		; 			Carry = I, since there were not enough
                        	   543: 		; 				characters available in the string to provide
                        	   544: 		; 				the specified number of bytes to copy.
                        	   545: 		; 			Tit le                     Copy a substring from a string
                        	   546: 		; 			Name:                      COpy
                        	   547: 		; 		Purpose:             Copy a substring from a string given a starting
                        	   548: 		; 							index and the number of bytes
                        	   549: 		; 		Entry:               Register pair HL = Address of source string      ~
                        	   550: 		; 							Register pair DE = Address of destination string~
                        	   551: 		; 							Register A = Maximum length of destination
                        	   552: 		; 											string
                        	   553: 		; 							Register B = Number of bytes to copy
                        	   554: 		; 							Register C   Starting index into source string
                        	   555: 		; 										Index of 1 is first character of
                        	   556: 		; 										string
                        	   557: 		; 								A string is a maximum of 255 bytes long plus
                        	   558: 		; 								a length byte which precedes it.
                        	   559: 		; 		Exit:                Destination string := The substring from the
                        	   560: 		; 							string.
                        	   561: 		; 							if no errors then
                        	   562: 		; 								CARRY := 0
                        	   563: 		; 							else
                        	   564: 		; 								begin
                        	   565: 		; 								the following conditions cause an
                        	   566: 		; 								error and the CARRY flag = 1.
                        	   567: 		; 								if (index = 0) or (maxlen = 0) or
                        	   568: 		; 										(index> length(source then
                        	   569: 		; 									the destination string will have a zero
                        	   570: 		; 									length.
                        	   571: 		; 								if (index + count - 1) > length(source)
                        	   572: 		; 								then
                        	   573: 		; 									the destination string becomes everything
                        	   574: 		; 									from index to the end of source string.
                        	   575: 		; 								END~
                        	   576: 		; 		Registers used: AF.BC.DE.HL
                        	   577: 		; 		Time:                Approximately (21   *   count) cycles plus 237
                        	   578: 		; 							cycles overhead.
                        	   579: 		; 		Size:                Program 73 bytes
                        	   580: 		; 							Data     2 bytes
                        	   581: ;****************************************************************************************************************
                        	   582: ;****************************************************************************************************************
                        	   583: 
                        	   584: 
                        	   585: COPY:
                        	   586: 			; SAVE    MAXIMUM LENGTH OF DESTINATION STRING
00:0126 320000          	   587: 		LD		(MAXLEN),A		;SAVE MAXIMUM LENGTH
                        	   588: 			; INITIALIZE    LENGTH OF DESTINATION STRING AND ERROR FLAG
00:0129 97              	   589: 		SUB		A
00:012A 12              	   590: 		LD		(DE),A			;LENGTH OF DESTINATION STRING = ZERO
00:012B 320000          	   591: 		LD		(CPYERR),A		;ASSUME NO ERRORS
                        	   592: 
                        	   593: 			; IF NUMBER OF BYTES TO COPY IS O. EXIT WITH NO ERRORS
00:012E B0              	   594: 		OR		B				;TEST NUMBER OF BYTES TO COPY
00:012F C8              	   595: 		RET		Z               ;EXIT WITH NO ERRORS
                        	   596: 								; CARRY = 0
                        	   597: 			;IF MAXIMUM LENGTH IS 0, TAKE ERROR EXIT
00:0130 3A0000          	   598: 		LD		A, (MAXLEN)		;TEST MAXIMUM LENGTH
00:0133 B7              	   599: 		OR		A
00:0134 2837            	   600: 		JR		Z,EREXIT		;ERROR EXIT IF MAX LENGTH IS 0
                        	   601: 			;IF STARTING INDEX IS ZERO, TAKE ERROR EXIT
00:0136 79              	   602: 		LD		A,C				;TEST STARTING INDEX
00:0137 B7              	   603: 		OR		A
00:0138 2833            	   604: 		JR		Z,EREXIT		;ERROR EXIT IF INDEX IS 0
                        	   605: 			;IF STARTING INDEX IS GREATER THAN LENGTH OF SOURCE
                        	   606: 			; STRING, TAKE ERROR EXIT
00:013A 7E              	   607: 		LD		A, (HL)			;GET LENGTH OF SOURCE STRING
00:013B B9              	   608: 		CP		C				;COMPARE TO STARTING INDEX
00:013C D8              	   609: 		RET		C				;ERROR EXIT IF LENGTH LESS THAN INDEX
                        	   610: 								; CARRY = 1
                        	   611: 		; CHECK IF COPY AREA FITS IN SOURCE STRING
                        	   612: 		; OTHERWISE, COPY ONLY TO END OF STRING
                        	   613: 		; COPY AREA FITS IF STARTING INDEX + NUMBER OF
                        	   614: 		; CHARACTERS TO COPY - 1 IS LESS THAN OR EQUAL TO
                        	   615: 		; LENGTH OF SOURCE STRING
                        	   616: 		; NOTE THAT STRINGS ARE NEVER MORE THAN 255 BYTES LONG
00:013D 79              	   617: 		LD		A,C				;FORM STARTING INDEX + COpy LENGTH
00:013E 80              	   618: 		ADD		A,B
00:013F 3806            	   619: 		JR		C,RECALC		;JUMP IF SUM> 255
00:0141 3D              	   620: 		DEC		A
00:0142 BE              	   621: 		CP		(HL)
00:0143 380B            	   622: 		JR		C,CNT1OK		;JUMP IF MORE THAN ENOUGH TO COPY
00:0145 2809            	   623: 		JR		Z,CNT1OK		;JUMP IF EXACTLY ENOUGH
                        	   624: 		;CALLER ASKED FOR TOO MANY CHARACTERS. RETURN EVERYTHING
                        	   625: 		; BETWEEN INDEX AND END OF SOURCE STRING.
                        	   626: 		; SET COUNT := LENGTH(SOURCE) - INDEX + 1;
                        	   627: RECALC:
00:0147 3EFF            	   628: 		LD		A,0FFH			; INDICATE TRUNCATION OF COUNT
00:0149 320000          	   629: 		LD		(CPYERR),A
00:014C 7E              	   630: 		LD		A, (HL)			;COUNT   = LENGTH   - INDEX +   1
00:014D 91              	   631: 		SUB		C
00:014E 3C              	   632: 		INC		A
00:014F 47              	   633: 		LD		B,A				;CHANGE NUMBER OF BYTES
                        	   634: 			; CHECK IF COUNT LESS THAN OR EQUAL TO MAXIMUM LENGTH OF
                        	   635: 			; DESTINATION STRING. IF NOT, SET COUNT TO MAXIMUM LENGTH
                        	   636: 			; IF COUNT > MAXLEN THEN
                        	   637: 			; COUNT := MAXLEN
                        	   638: CNT1OK:
00:0150 3A0000          	   639: 		LD		A, (MAXLEN)		;IS MAX LENGTH LARGE ENOUGH?
00:0153 B8              	   640: 		CP		B
00:0154 3006            	   641: 		JR		NC,CNT2OK		; ~UMP IF IT IS
00:0156 47              	   642: 		LD		B,A				;ELSE LIMIT COPY TO MAXLEN
00:0157 3EFF            	   643: 		LD		A,0FFH			; INDICATE STRING OVERFLOW
00:0159 320000          	   644: 		LD		(CPYERR),A
                        	   645: 			; MOVE    SUBSTRING TO DESTINATION STRING
                        	   646: CNT2OK:
00:015C 78              	   647: 		LD		A,B				;TEST    NUMBER OF BYTES TO COPY
00:015D B7              	   648: 		OR		A
00:015E 280D            	   649: 		JR		Z,EREXIT		;ERROR    EXIT IF NO BYTES TO COpy
00:0160 0600            	   650: 		LD		B,0				;START    COPYING AT STARTING INDEX
00:0162 09              	   651: 		ADD		HL,BC
00:0163 12              	   652: 		LD		(DE), A			;SET LENGTH OF DESTINATION STRING
00:0164 4F              	   653: 		LD		C,A				;RESTORE NUMBER OF BYTES
00:0165 13              	   654: 		INC		DE				;MOVE DESTINATION ADDRESS PAST
                        	   655: 								; LENGTH BYTE
00:0166 EDB0            	   656: 		LDIR					;COPY SUBSTRING
                        	   657: 
                        	   658: 			; CHECK    FOR COPY ERROR
00:0168 3A0000          	   659: 		LD		A, (CPYERR)		;TEST    FOR ERRORS
                        	   660: OKEXIT_8D:
00:016B B7              	   661: 		OR		A
00:016C C8              	   662: 		RET		Z               ;RETURN    WITH C = o IF NO ERRORS
                        	   663: 			; ERROR    EXIT
                        	   664: EREXIT:
00:016D 37              	   665: 		SCF						;SET    CARRY TO INDICATE AN ERROR
00:016E C9              	   666: 		RET
                        	   667: 			; DATA    SECTION
                        	   668: ; MAXLEN:	DS	1					;MAXIMUM    LENGTH OF DESTINATION STRING
                        	   669: ; CPYERR: DS	1					;COPY    ERROR FLAG
                        	   670: 
                        	   671: 		; SAMPLE EXECUTION:
                        	   672: ; SC8D:
                        	   673: ; 		LD		HL,SSTG_8D			;SOURCE STRING
                        	   674: ; 		LD		DE, DSTG_8D		;DESTINATION STRING
                        	   675: ; 		LD		A,(IDX_8D)
                        	   676: ; 		LD		C,A				;STARTING    INDEX FOR COPYING
                        	   677: ; 		LD		A, (CNT_8D)
                        	   678: ; 		LD		B,A				;NUMBER OF BYTES TO COPY
                        	   679: ; 		LD		A, (MXLEN_8D)		;MAXIMUM LENGTH OF SUBSTRING
                        	   680: ; 		CALL	COPY			;COPY SUBSTRING
                        	   681: ; 								;COPYING 3 CHARACTERS STARTING AT
                        	   682: ; 								;INDEX 4 FROM '12.345E+l0' GIVES '345'
                        	   683: ; 		JR		SC8D            ;LOOP FOR MORE TESTING
                        	   684: 			; DATA    SECTION
                        	   685: ; IDX_8D:	DB	4					;STARTING INDEX FOR COPYING
                        	   686: ; CNT_8D:	DB	3					;NUMBER OF CHARACTERS TO COPY
                        	   687: ; MXLEN_8D:	DB	20H					; MAXIMUM LENGTH OF DESTINATION STRING
                        	   688: ; SSTG_8D:	DB	0AH					;LENGTH OF STRING
                        	   689: ; 		DB	"12.345E+10                     " ;32 BYTE MAX LENGTH
                        	   690: ; DSTG_8D:	DB	0					;LENGTH OF SUBSTRING
                        	   691: ; 		DB  "                               " ; 32 BYTE MAX LENGTH
                        	   692: 
                        	   693: 
                        	   694: 
                        	   695: ;****************************************************************************************************************
                        	   696: ;****************************************************************************************************************
                        	   697: 		; Delete a Substring from a String (DELETE)                                                                          
                        	   698: 
                        	   699: 		; 		1. STRING LENGTH = 20 16 (3210)                             1. If the number of bytes to delete is 0, the
                        	   700: 		; 			STARTING INDEX = 19 16 (25 10)                        program exits with the Carry flag cleared (no errors)
                        	   701: 		; 			NUMBER OF BYTES TO DELETE = 08                        and the string unchanged.
                        	   702: 		; 		Since there are exactly eight bytes left in the string       2. If the string does not even extend to the specifi
                        	   703: 		; 	starting at index 19 16 , all the routine must do is trun-   starting index, the program exits with the Carry flag
                        	   704: 		; 	cate (that is, cut off the end of the string). This takes    set to I (indicating an error) and the string unchang
                        	   705: 		; 			21 * 0 + 224 = 224 cycles                                3. If the number of bytes to delete exceeds the
                        	   706: 		; 		2. STRING LENGTH = 40 16 (6410)                           number available, the program deletes all bytes from
                        	   707: 		; 			STARTING INDEX = 19 16 (25 10 )                       the starting index to the end of the string and exits
                        	   708: 		; 			NUMBER OF BYTES TO DELETE = 08                        with the Carry flag set to I (indicating an error).
                        	   709: 
                        	   710: 
                        	   711: 
                        	   712: 
                        	   713: 		; Entry Conditions                                                   Exit Conditions
                        	   714: 		; Base address of string in HL                                       Substring deleted from string. If no errors occu
                        	   715: 		; Number of bytes to delete in B                                     the Carry flag is cleared. If the starting index
                        	   716: 		; Starting index to delete from in C                                 or beyond the length of the string, the Carry fl
                        	   717: 		; 																is set and the string is unchanged. If the number
                        	   718: 		; 																of bytes to delete would go beyond the end ofthe
                        	   719: 		; 																string, the Carry flag is set and the characters
                        	   720: 		; 																from the starting index to the end of the string
                        	   721: 		; 																are deleted.
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: 		; Examples
                        	   726: 		; I.    Data:     String = 26'SALES FOR MARCH AND                 2.    Data:    String = 28'THE PRICE IS $3.00 ($2.0
                        	   727: 		; 				APRIL OF THIS YEAR'                                            BEFORE JUNE I)' (28 16 = 40 10 is the
                        	   728: 		; 				(26 16 = 3810 is the length of the string)                     length of the string)
                        	   729: 		; 				Number of bytes to delete = OA 16 = 1010                       Number of bytes to delete = 30 16 = 48 10
                        	   730: 		; 				Starting index to delete from = 10 16 = 16 10                  Starting index to delete from = 13 16 = 19 10
                        	   731: 		; 	Result:    String= I C 'SALES FOR MARCH OF THIS                 Result:   String = 12'THE PRICE IS $3.00' (12 16 =
                        	   732: 		; 				YEAR' (IC I6 = 28 10 is the length of the                      18 10 is the length of the string with all
                        	   733: 		; 				string with ten bytes deleted starting with                    remaining bytes deleted)
                        	   734: 		; 				the 16th character-the deleted material is                   Carry = I, since there were not as many bytes
                        	   735: 		; 				'AND APRIL')                                                   left in the string as were supposed to be
                        	   736: 		; 				Carry= 0, since no problems occurred in the                      deleted.
                        	   737: 		; 				deletion.
                        	   738: 
                        	   739: 
                        	   740: 
                        	   741: 
                        	   742: 		; 			Title:                   Delete a substring from a string
                        	   743: 		; 			Name:                    Delete
                        	   744: 
                        	   745: 
                        	   746: 
                        	   747: 		; 			Purpose:                 Delete a substring from a string given a
                        	   748: 		; 										starting index and a length
                        	   749: 		; 			Entry:                   Register pair HL = Base address of string
                        	   750: 		; 										Register B = Number of bytes to delete
                        	   751: 		; 										Register C = Starting index into the string.
                        	   752: 		; 												An index of 1 is the first character
                        	   753: 		; 										A string is a maximum of 255 bytes long plus
                        	   754: 		; 										a length byte which precedes it.
                        	   755: 		; 			Exit :                   Substring deleted.
                        	   756: 		; 										if no errors then
                        	   757: 		; 										CARRY := 0
                        	   758: 		; 										else
                        	   759: 
                        	   760: 		; 							begin
                        	   761: 		; 								the following conditions cause an
                        	   762: 		; 								error with .CARRY = 1.
                        	   763: 		; 								if (index = 0) or (index> length(string
                        	   764: 		; 								then do not change string
                        	   765: 		; 								if count is too large then
                        	   766: 		; 								delete only the characters from
                        	   767: 		; 								index to end of string
                        	   768: 
                        	   769: 		; 		Registers used: AF,BC,DE,HL
                        	   770: 		; 		Time:             Approximately 21 * (LENGTH(STRG)-INDEX-COUNT+l)
                        	   771: 		; 							plus 224 cycles overhead
                        	   772: 		; 		Size:             Program 58 bytes
                        	   773: 		; 							Data     1 bytes
                        	   774: ;****************************************************************************************************************
                        	   775: ;****************************************************************************************************************
                        	   776: 
                        	   777: 
                        	   778: 
                        	   779: DELETE:
                        	   780: 			;INITIALIZE ERROR INDICATOR (DELERR) TO 0
00:016F 97              	   781: 		SUB		A
00:0170 320000          	   782: 		LD		(DELERR),A		;ASSUME NO ERRORS
                        	   783: 			;CHECK IF COUNT AND INDEX ARE BOTH NON-ZERO
00:0173 B0              	   784: 		OR		B				;TEST NUMBER OF BYTES TO DELETE
00:0174 C8              	   785: 		RET		Z				;RETURN WITH CARRY = 0 (NO ERRORS) IF
                        	   786: 								; 0 BYTES TO DELETE
00:0175 79              	   787: 		LD		A,C				;TEST STARTING INDEX
00:0176 B7              	   788: 		OR		A
00:0177 37              	   789: 		SCF						;CARRY = 1
00:0178 C8              	   790: 		RET		Z				;ERROR EXIT (CARRY = 1) IF
                        	   791: 			; STARTING INDEX = 0
                        	   792: 			; CHECK IF STARTING INDEX WITHIN STRING
                        	   793: 			; ERROR EXIT IF NOT
00:0179 7E              	   794: 		LD		A, (HL)			;GET LENGTH
00:017A B9              	   795: 		CP		C				;IS INDEX WITHIN STRING?
00:017B D8              	   796: 		RET		C				;NO, TAKE ERROR EXIT
                        	   797: 			;BE SURE ENOUGH CHARACTERS ARE AVAILABLE
                        	   798: 			; IF NOT, DELETE ONLY TO END OF STRING
                        	   799: 			; IF INDEX + NUMBER OF CHARACTERS - 1 > LENGTH(STRING) THEN
                        	   800: 			; NUMBER OF CHARACTERS := LENGTH(STRING) - INDEX + 1
00:017C 79              	   801: 		LD		A,C				;,GET INDEX
00:017D 80              	   802: 		ADD		A,B				;ADD NUMBER OF CHARACTERS TO DELETE
00:017E 380C            	   803: 		JR		C,TRUNC			;TRUNCATE IF SUM> 255
00:0180 5F              	   804: 		LD		E,A				;SAVE SUM AS STARTING INDEX FOR MOVE
00:0181 3D              	   805: 		DEC		A
00:0182 BE              	   806: 		CP		(HL)			;COMPARE TO LENGTH
00:0183 380F            	   807: 		JR		C,CNTOK			;JUMP IF ENOUGH CHARACTERS AVAILABLE
00:0185 2805            	   808: 		JR		Z,TRUNC			;TRUNCATE BUT NO ERRORS (EXACTLY ENOUGH
                        	   809: 								;CHARACTERS)
00:0187 3EFF            	   810: 		LD		A,0FFH			;INDICATE ERROR - NOT ENOUGH CHARACTERS
00:0189 320000          	   811: 		LD		(DELERR),A		;AVAILABLE FOR DELETION
                        	   812: 			;TRUNCATE STRING - NO COMPACTING NECESSARY
                        	   813: 			; STRING LENGTH = INDEX - 1
                        	   814: TRUNC:
00:018C 79              	   815: 		LD		A,C				;STRING LENGTH   = INDEX     - 1
00:018D 3D              	   816: 		DEC		A
00:018E 77              	   817: 		LD		(HL),A
00:018F 3A0000          	   818: 		LD		A, (DELERR)
00:0192 1F              	   819: 		RRA						;CARRY   =0   IF NO ERRORS
00:0193 C9              	   820: 		RET						;EXIT
                        	   821: 			;DELETE SUBSTRING BY COMPACTING
                        	   822: 			; MOVE ALL CHARACTERS ABOVE DELETED AREA DOWN
                        	   823: 			;NEW LENGTH = OLD LENGTH - NUMBER OF BYTES TO DELETE
                        	   824: CNTOK:
00:0194 7E              	   825: 		LD		A, (HL)
00:0195 57              	   826: 		LD		D,A				;SAVE OLD LENGTH
00:0196 90              	   827: 		SUB		B				;SET NEW LENGTH
00:0197 77              	   828: 		LD		(HL),A
                        	   829: 			;CALCULATE NUMBER OF CHARACTERS TO MOVE
                        	   830: 			; NUMBER = STRING LENGTH - (INDEX + NUMBER OF BYTES) + 1
00:0198 7A              	   831: 		LD		A,D				;OET OLD LENGTH
00:0199 93              	   832: 		SUB		E				;SUBTRACT INDEX + NUMBER OF BYTES
00:019A 3C              	   833: 		INC		A				;A = NUMBER OF CHARACTERS TO MOVE
                        	   834: 			;CALCULATE SOURCE AND DESTINATION ADDRESSES FOR MOVE
                        	   835: 			;SOURCE = BASE + INDEX + NUMBER OF BYTES TO DELETE
                        	   836: 			;DESTINATION = BASE + INDEX
00:019B E5              	   837: 		PUSH	HL				;SAVE STRING ADDRESS
00:019C 0600            	   838: 		LD		B,0				;DESTINATION = BASE + INDEX
00:019E 09              	   839: 		ADD		HL,BC
00:019F E3              	   840: 		EX		(SP),HL			; SOURCE = BASE + INDEX + NUMBER
00:01A0 1600            	   841: 		LD		D,0				;OF BYTES TO DELETE
00:01A2 19              	   842: 		ADD		HL,DE			;HL = SOURCE (ABOVE DELETED AREA)
00:01A3 D1              	   843: 		POP		DE				;DE = DESTINATION
00:01A4 4F              	   844: 		LD		C,A				;BC = NUMBER OF CHARACTERS TO MOVE
00:01A5 EDB0            	   845: 		LDIR					;COMPACT STRING BY MOVING DOWN
                        	   846: 		; GOOD EXIT
                        	   847: OKEXIT_8E:
00:01A7 B7              	   848: 		OR		A					;CLEAR CARRY, NO ERRORS
00:01A8 C9              	   849: 		RET
                        	   850: 		; DATA
                        	   851: ; DELERR: DS	1						;DELETE ERROR FLAG
                        	   852: 
                        	   853: 		; SAMPLE EXECUTION:
                        	   854: 
                        	   855: ; SC8E:
                        	   856: ; 		LD		HL,SSTG_8E 			;HL   = BASE   ADDRESS OF STRING
                        	   857: ; 		LD		A,(IDX_8E)
                        	   858: ; 		LD		C,A					;C    = STARTING INDEX FOR DELETION
                        	   859: ; 		LD		A, (CNT_8E)
                        	   860: ; 		LD		B,A					;B= NUMBER OF CHARACTERS TO DELETE
                        	   861: ; 		CALL	DELETE				;DELETE CHARACTERS
                        	   862: ; 									;DELETING 4 CHARACTERS STARTING AT INDEX 1
                        	   863: ; 									; FROM ".JOE HANDOVER" LEAVES "HANDOVER"
                        	   864: ; 		JR		SC8E				;LOOP FOR ANOTHER TEST
                        	   865: 			; DATA SECTION
                        	   866: ; IDX_8E:	DB      1                    ;STARTING INDEX FOR DELETION
                        	   867: ; CNT_8E:	DB      4                    ;NUMBER OF CHARACTERS TO DELETE
                        	   868: ; SSTG_8E:	DB      12                   ;LENGTH OF STRING
                        	   869: ; 		DB      ".JOE HANDOVER"
                        	   870: 
                        	   871: 
                        	   872: 
                        	   873: ;****************************************************************************************************************
                        	   874: ;****************************************************************************************************************
                        	   875: 		; Insert a Substring into a String (INSERT)                                                                          
                        	   876: 		; 	produces a string longer than the maximum.
                        	   877: 		; 																Program Size: 90 bytes
                        	   878: 		; 	Examples
                        	   879: 		; 																Data Memory Required: One byte anywhere in
                        	   880: 		; 		1. STRING LENGTH = 20'6 (3210)                            RAM for an error flag (address INS ERR).
                        	   881: 		; 			STARTING INDEX = 19'6 (25 10 )
                        	   882: 		; 			MAXIMUM LENGTH = 30'6 (48 10 )                         Special Cases:
                        	   883: 		; 			SUBSTRING LENGTH = 06                                     I. If the length ofthe substring (the insertion) is 0,
                        	   884: 		; 		We want to insert a substring six bytes long, start-       the program exits with the Carry flag cleared (no
                        	   885: 		; 	ing at the 25th character. Since eight bytes must be         errors) and the string unchanged.
                        	   886: 		; 			2. If the starting index for the insertion is 0 (that      4. If the starting index of the insertion is beyond
                        	   887: 		; 		is, the insertion would start in the length byte), the      the end of the string, the program concatenates the
                        	   888: 		; 		program exits with the Carry flag set to I (indicating      insertion at the end of the string and indicates an
                        	   889: 		; 		an error) and the string unchanged.                         error by setting the Carry flag to I.
                        	   890: 		; 		3. If the string with the substring inserted exceeds         5. If the original length of the string exceeds its
                        	   891: 		; 		the specified maximum length, the program inserts           specified maximum length, the program exits with
                        	   892: 		; 		only enough characters to reach the maximum length.         the Carry flag set to 1 (indicating an error) and the
                        	   893: 		; 		The Carry flag is set to I to indicate that the insertion   string unchanged.
                        	   894: 		; 		has been truncated.
                        	   895: 		; Examples
                        	   896: 		; I.    Data:    String = OA'JOHN SMITH' (OA'6 = 1010 is               2.    Data:    String = OA'JOHN SMITH' (OA'6 =
                        	   897: 		; 				the length of the string)                                            the length of the string)
                        	   898: 		; 			Substring = 08'WILLIAM' (08 is the length                            Substring = OC'ROCKEFELLER' (OC'6 =
                        	   899: 		; 				of the substring)                                                     1210 is the length of the substring)
                        	   900: 		; 			Maximum length of string = 14'6 = 20 10                              Maximum length of string = 14'6 = 20 10
                        	   901: 		; 			Starting index = 06                                                  Starting index = 06
                        	   902: 		; 	Result:   String = 12'JOHN WILLIAM SMITH'                            Result:   String= 14'JOHN ROCKEFELLESMITH'
                        	   903: 		; 				(12'6 = 18 10 is the length of the string                            (14'6 = 20 10 is the length ofthe string w
                        	   904: 		; 				with the substring inserted)                                         as much of the substring inserted as the
                        	   905: 		; 			Carry = 0, since no problems occurred in the                           maximum length would allow)
                        	   906: 		; 				insertion.                                                         Carry = I, since some of the substring could
                        	   907: 		; 																					not be inserted without exceeding the maxi-
                        	   908: 		; 																					mum length of the string.
                        	   909: 		; 		Tit Ie:         Insert a substring into a string
                        	   910: 		; 		Name:           Insert
                        	   911: 		; 		Purpose:        Insert a substring into a string given a
                        	   912: 		; 						starting index
                        	   913: 		; 		Entry:          Register pair HL     Address of string
                        	   914: 		; 						Register pair DE     Address of substring to
                        	   915: 		; 												insert
                        	   916: 		; 						Register B   Maximum length of string
                        	   917: 		; 						Register C = Starting index to insert the
                        	   918: 		; 									sl.Jbstring
                        	   919: 		; 							A string is a maximum of 255 bytes long plus
                        	   920: 		; 							a length byte which precedes it.
                        	   921: 		; 		Exit:           Substring inserted into string.
                        	   922: 		; 						if no errors then
                        	   923: 		; 							CARRY = 0
                        	   924: 		; 						else
                        	   925: 		; 							begin
                        	   926: 		; 							the following conditions cause the
                        	   927: 		; 							CARRY flag to be set.
                        	   928: 		; 							if index = 0 then
                        	   929: 		; 								do not insert the substring
                        	   930: 		; 							if length(strg) > maximum length then
                        	   931: 		; 								do not insert the substring
                        	   932: 		; 							if index> length(strg) then
                        	   933: 		; 								concatenate substg onto the end of the
                        	   934: 		; 								source string
                        	   935: 		; 							if length(strg)+length(substring) > maxlen
                        	   936: 		; 								then insert only enough of the substring
                        	   937: 		; 								to reach maximum length
                        	   938: 		; 							end;
                        	   939: 		; 		Registers used: AF,BC,DE,HL
                        	   940: 		; 		Time:           Approxi'matel y
                        	   941: 		; 						21 * (LENGTH(STRG) - INDEX + 1) +
                        	   942: 		; 						21 * (LENGTH(SUBSTG  +
                        	   943: 		; 						290 cycles overhead
                        	   944: 		; 		Size:           Program 90 bytes
                        	   945: 		; 						Data     1 byte
                        	   946: ;****************************************************************************************************************
                        	   947: ;****************************************************************************************************************
                        	   948: 
                        	   949: 
                        	   950: 
                        	   951: INSERT_STR:
                        	   952: 			;INITIALIZE ERROR FLAG
00:01A9 97              	   953: 		SUB		A				;ERROR FLAG    o (NO ERRORS)
00:01AA 320000          	   954: 		LD		(INSERR) ,A
                        	   955: 			;GET SUBSTRING AND STRING LENGTHS
                        	   956: 			; IF LENGTH(SUBSTG) = 0 THEN EXIT BUT NO ERROR
00:01AD 1A              	   957: 		LD		A, (DE)			; TEST LENGTH OF SUBSTRING
00:01AE B7              	   958: 		OR		A
00:01AF C8              	   959: 		RET		Z				;EXIT IF SUBSTRING EMPTY
                        	   960: 								; CARRY = 0 (NO ERRORS)
                        	   961: 			;IF STARTING INDEX IS ZERO, TAKE ERROR EXIT
                        	   962: IDX0:
00:01B0 79              	   963: 		LD		A,C				;TEST STARTING INDEX
00:01B1 B7              	   964: 		OR		A
00:01B2 37              	   965: 		SCF						;ASSUME AN ERROR
00:01B3 C8              	   966: 		RET		Z				;RETURN WITH ERROR IF INDEX = 0
                        	   967: 			;CHECK WHETHER INSERTION WILL MAKE STRING TOO LONG
                        	   968: 			; IF IT WILL. TRUNCATE SUBSTRING AND SET
                        	   969: 			; TRUNCATION FLAG.
                        	   970: 			; INSERTION TOO LONG IF STRING LENGTH + SUBSTRING LENGTH
                        	   971: 			; EXCEEDS MAXIMUM LENGTH. REMEMBER. STRINGS CANNOT BE
                        	   972: 			; MORE THAN 255 BYTES LONG
                        	   973: CHKLEN:
00:01B4 1A              	   974: 		LD		A,(DE)			;TOTAL = STRING + SUBSTRING
00:01B5 86              	   975: 		ADD		A,(HL)
00:01B6 3806            	   976: 		JR		C,TRUNC_8F			;TRUNCATE SUBSTRING IF NEW LENGTH> 255
00:01B8 B8              	   977: 		CP		B				;COMPARE TO MAXIMUM LENGTH OF STRING
00:01B9 1A              	   978: 		LD		A,(DE)			;A = LENGTH OF SUBSTRING
00:01BA 380C            	   979: 		JR		C,IDXLEN		;JUMP IF TOTAL < MAX LENGTH
00:01BC 280A            	   980: 		JR		Z,IDXLEN		; OR EQUAL
                        	   981: 			;SUBSTRING DOES NOT FIT. SO TRUNCATE IT
                        	   982: 			; SET ERROR FLAG TO INDICATE TRUNCATION
                        	   983: 			; LENGTH THAT FITS = MAXIMUM LENGTH - STRING LENGTH
                        	   984: TRUNC_8F:
00:01BE 3EFF            	   985: 		LD		A,0FFH          ; INDICATE SUBSTRING TRUNCATED
00:01C0 320000          	   986: 		LD		(INSERR), A
00:01C3 78              	   987: 		LD		A,B             ;LENGTH = MAX - STRING LENGTH
00:01C4 96              	   988: 		SUB		(HL)
00:01C5 D8              	   989: 		RET		C               ;RETURN WITH ERROR IF STRING TOO
00:01C6 37              	   990: 		SCF						; LONG INITIALLY OR ALREADY MAX
00:01C7 C8              	   991: 		RET		Z               ; LENGTH SO NO ROOM FOR SUBSTRING
                        	   992: 			;CHECK IF INDEX WITHIN STRING. IF NOT, CONCATENATE
                        	   993: 			; SUBSTRING ONTO END OF STRING
                        	   994: IDXLEN:
00:01C8 47              	   995: 		LD		B,A				;B = LENGTH OF SUBSTRING
00:01C9 7E              	   996: 		LD		A,(HL)			;GET STRING LENGTH
00:01CA B9              	   997: 		CP	C               ;COMPARE TO INDEX
00:01CB 3012            	   998: 		JR		NC,LENOK_8F		;JUMP IF STARTING INDEX WITHIN STRING
                        	   999: 			;INDEX NOT WITHIN STRING, SO CONCATENATE
                        	  1000: 			; NEW LENGTH OF STRING = OLD LENGTH + SUBSTRING LENGTH
00:01CD 4F              	  1001: 		LD		C, A			; SAVE CURRENT STRING LENGTH
00:01CE 80              	  1002: 		ADD		A, B			; ADD LENGTH OF SUBSTRING
00:01CF 77              	  1003: 		LD		(HL),A			;SET NEW LENGTH OF STRING
                        	  1004: 			;SET ADDRESSES FOR CONCATENATION
                        	  1005: 			; DE = STRING ADDRESS + LENGTH(STRING) + 1
                        	  1006: 			; HL = SUBSTRING ADDRESS
00:01D0 EB              	  1007: 		EX		DE,HL			;HL        SUBSTRING ADDRESS
00:01D1 79              	  1008: 		LD		A,C				;DE      = END OF STRING
00:01D2 3C              	  1009: 		INC		A
00:01D3 83              	  1010: 		ADD		A,E
00:01D4 5F              	  1011: 		LD		E,A
00:01D5 3001            	  1012: 		JR		NC,IDXL1
00:01D7 14              	  1013: 		INC		D
                        	  1014: IDXL1:
00:01D8 3EFF            	  1015: 		LD		A,0FFH			;INDICATE INSERTION ERROR
00:01DA 320000          	  1016: 		LD		(INSERR), A
00:01DD 1819            	  1017: 		JR		MVESUB			;JUST MOVE, NOTHING TO OPEN UP
                        	  1018: 			; OPEN UP SPACE IN SOURCE STRING FOR SUBSTRING BY MOVING
                        	  1019: 			; CHARACTERS FROM END OF SOURCE STRING DOWN TO INDEX, UP BY
                        	  1020: 			; SIZE OF SUBSTRING.
                        	  1021: 			; A = LENGTH(STRING)
                        	  1022: LENOK_8F:
00:01DF C5              	  1023: 		PUSH    BC				;SAVE LENGTH OF SUBSTRING
00:01E0 D5              	  1024: 		PUSH    DE				;,SAVE ADDRESS OF SUBSTRING
                        	  1025: 			;NEW LENGTH OF STRING   = OLD    LENGTH + SUBSTRING LENGTH
00:01E1 5F              	  1026: 		LD		E,A			; DE   = STRING LENGTH
00:01E2 1600            	  1027: 		LD		D,0
00:01E4 80              	  1028: 		ADD		A,B
00:01E5 77              	  1029: 		LD		(HL),A			;STORE NEW LENGTH OF STRING
                        	  1030: 			; CALCULATE NUMBER OF CHARACTERS TO MOVE
                        	  1031: 			; = STRING LENGTH - STARTING INDEX + 1
00:01E6 7B              	  1032: 		LD		A,E				;GET ORIGINAL LENGTH OF STRING
00:01E7 91              	  1033: 		SUB		C
00:01E8 3C              	  1034: 		INC		A				;A     = NUMBER   OF CHARACTERS TO MOVE
                        	  1035: 			;CALCULATE ADDRESS OF LAST CHARACTER IN STRING. THIS IS
                        	  1036: 			; SOURCE ADDRESS = STRING ADDRESS + LENGTH(STRING)
00:01E9 19              	  1037: 		ADD	HL,DE				;HL POINTS TO LAST CHARACTER IN STRING
00:01EA 5D              	  1038: 		LD		E,L				;DE ALSO
00:01EB 54              	  1039: 		LD		D,H
                        	  1040: 			;CALCULATE DESTINATION ADDRESS
                        	  1041: 			; = STRING ADDRESS + LENGTH(STRING) + LENGTH OF SUBSTRING
                        	  1042: 			;THIS MOVE MUST START AT HIGHEST ADDRESS AND WORK DOWN
                        	  1043: 			; TO AVOID OVERWRITING PART OF THE STRING
00:01EC 48              	  1044: 		LD		C,B				;BC = LENGTH OF SUBSTRING
00:01ED 0600            	  1045: 		LD		B,0
00:01EF 09              	  1046: 		ADD		HL,BC
00:01F0 EB              	  1047: 		EX		DE,HL			;HL = SOURCE ADDRESS
                        	  1048: 								;DE = DESTINATION ADDRESS
00:01F1 4F              	  1049: 		LD		C,A             ;BC = NLiMBER OF CHARACTERS TO MOVE
00:01F2 EDB8            	  1050: 		LDDR					;OPEN UP FOR SUBSTRING
                        	  1051: 			;RESTORE REGISTERS
00:01F4 EB              	  1052: 		EX		DE,HL
00:01F5 13              	  1053: 		INC		DE				;DE = ADDRESS TO MOVE STRING TO
00:01F6 E1              	  1054: 		POP		HL				;HL = ADDRESS OF SUBSTRING
00:01F7 C1              	  1055: 		POP		BC				;B = LENGTH OF SUBSTRING
                        	  1056: 			;MOVE SUBSTRING INTO OPEN AREA
                        	  1057: 			; HL = ADDRESS OF SUBSTRING
                        	  1058: 			; DE = ADDRESS TO MOVE SUBSTRING TO
                        	  1059: 			; C = LENGTH OF SUBSTRING
                        	  1060: MVESUB:
00:01F8 23              	  1061: 		INC		HL				;INCREMENT PAST LENGTH BYTE OF SUBSTRING
00:01F9 48              	  1062: 		LD		C,B				;BC = LENGTH OF SUBSTRING TO MOVE
00:01FA 0600            	  1063: 		LD		B,0
00:01FC EDB0            	  1064: 		LDIR					;MOVE SUBSTRING INTO OPEN AREA
00:01FE 3A0000          	  1065: 		LD		A, (INSERR)		;GET ERROR FLAG
00:0201 1F              	  1066: 		RRA						;IF INSERR <> 0 THEN CARRY = 1
                        	  1067: 								;TO INDICATE AN ERROR
00:0202 C9              	  1068: 		RET
                        	  1069: 			;DATA SECTION
                        	  1070: ; INSERR: DS	1					;FLAG USED TO INDICATE ERROR
                        	  1071: 
                        	  1072: 		; SAMPLE EXECUTION:
                        	  1073: ; SC8F:
                        	  1074: ; 		LD		HL,STG_8F 		;HL = BASE ADDRESS OF STRING
                        	  1075: ; 		LD		DE,SSTG_8F		;DE = BASE ADDRESS OF SUBSTRING
                        	  1076: ; 		LD		A,(IDX_8F)
                        	  1077: ; 		LD		C,A				;C = STARTING INDEX FOR INSERTION
                        	  1078: ; 		LD		A,(MXLEN_8F)
                        	  1079: ; 		LD		B,A				;B = MAXIMUM LENGTH OF STRING
                        	  1080: ; 		CALL	INSERT_STR		;INSERT SUBSTRING
                        	  1081: ; 								;RESULT OF INSERTING ~-~ INTO ~123456~ AT
                        	  1082: ; 								; INDEX 1 IS ~-123456~
                        	  1083: ; 		JR		SC8F			;LOOP FOR ANOTHER TEST
                        	  1084: 			; DATA SECTION
                        	  1085: ; IDX_8F:	DB	1					;STARTING INDEX FOR I NSERTI ON
                        	  1086: ; MXLEN_8F:	DB	20H					;MAXIMUM LENGTH OF DESTINATION
                        	  1087: ; STG_8F:	DB	06H					;LENGTH OF STRING
                        	  1088: ; 		DB	"123456                                 " ;32 BYTE MAX LENGTH
                        	  1089: ; SSTG_8F:	DB	1					;LENGTH OF SUBSTRING
                        	  1090: ; 		DB  "-                                      " ;32 BYTE MAX LENGTH
                        	  1091: 
                        	  1092: ;********************************************************************************************
                        	  1093: ;********************************************************************************************	
                        	  1094: 		;		Copy the area of variables to RAM memory  (F000)
                        	  1095: Init_RAM_HEAP:
                        	  1096: 		GLOBAL	Init_RAM_HEAP
                        	  1097: 
00:0203 110000          	  1098: 		ld		DE,SRAM_VAR_START		; defined in linker script
00:0206 211302          	  1099: 		ld		hl,zero_byte
                        	  1100: 		
00:0209 010000          	  1101: 		ld 		BC,HEAP_SIZE			; defined in linker script
                        	  1102: .cl_vars:
00:020C EDA0            	  1103: 		ldi							; (DE)<-(HL)
00:020E 2B              	  1104: 		dec 	hl
00:020F EA0C02          	  1105: 		jp		PE,.cl_vars			; 		P/V is set if BC  1  0; otherwise, it is reset.
00:0212 C9              	  1106: 		ret
00:0213 00              	  1107: zero_byte:	db  0
                        	  1108: ;********************************************************************************************
                        	  1109: ;***************************************************************************************************
                        	  1110: ;***************************************************************************************************
                        	  1111: 
                        	  1112: 		; 		dump memory content to screen. alt 1  dm 100  < without address>
                        	  1113: 		; 										alt 2  dm $1234,100  < with address>
                        	  1114: 
                        	  1115: 
                        	  1116: dumpMemory:
                        	  1117: 		; ***	Dump memory from either lvl1 or PCval and lvl2 or lvl1 bytes
                        	  1118: 		xref 	add_space
                        	  1119: 
                        	  1120: 		; check if lvl2 is zero  
                        	  1121: 
00:0214 210000          	  1122: 		ld 		HL,commAdr1
00:0217 CDAA02          	  1123: 		call	checkZero16 			; check if (commAdr1)=0 2 bytes -> Z 
00:021A 2006            	  1124: 		jr 		NZ,.adrSizeTyped 		; dump memory ; address and size are typed
                        	  1125: 
                        	  1126: 		; ***	Only size typed, address from PCvalue
00:021C 2A0000          	  1127: 		ld 		HL,(PCvalue)				; HL = start address
00:021F 220000          	  1128: 		ld 		(commAdr1),HL 			; temp storage of PCvalue
                        	  1129: 
                        	  1130: .adrSizeTyped:
                        	  1131: 		; ***	both address and size typed
00:0222 110000          	  1132: 		ld 		DE,commAdr1				; DE = start address
00:0225 010000          	  1133: 		ld 		BC,commLvl1				; BC = number of bytes
                        	  1134: 
00:0228 1A              	  1135: 		ld  	A,(DE)
00:0229 E6F0            	  1136: 		and 	$F0 					; adjust to nearest 16 byte block
00:022B 12              	  1137: 		ld 		(DE),A
00:022C ED5B0000        	  1138: 		ld 		DE,(commAdr1)			; HL = start address
                        	  1139: 
00:0230 ED4B0000        	  1140: 		ld 		BC,(commLvl1) 			; get the size...  divide by $10
00:0234 CB38            	  1141: 		srl 	B 
00:0236 CB19            	  1142: 		RR 		C
00:0238 CB38            	  1143: 		srl 	B 
00:023A CB19            	  1144: 		RR 		C
00:023C CB38            	  1145: 		srl 	B 
00:023E CB19            	  1146: 		RR 		C
00:0240 CB38            	  1147: 		srl 	B 
00:0242 CB19            	  1148: 		RR 		C					; BC = number of lines, nearest higher 16 byte block
                        	  1149: 
                        	  1150: display_BC_bytes:
00:0244 C5              	  1151: 		push 	bc					; save the line counter
                        	  1152: 
00:0245 210100          	  1153: 			ld 		HL,dumpText+1		; new buffer for text output
00:0248 CD0000          	  1154: 			call	Bin2Hex16			;address in DE -> result added to (HL)-> to last 0x00. hl updatd (+4)
                        	  1155: 			
00:024B 3E3A            	  1156: 			ld  	A,':'
00:024D 77              	  1157: 			ld 		(HL),A  
00:024E 23              	  1158: 			inc 	HL
00:024F D5              	  1159: 			push 	DE 			; store adress of first char
00:0250 AF              	  1160: 				xor 	A						; clear A
00:0251 320000          	  1161: 				ld 		(generalFlags),A 		; indicate first round , hexvalues
00:0254 CD7C02          	  1162: 				call 	displayBytes		; put values in buffer pointed by HL, advance HL
00:0257 D1              	  1163: 			pop 	DE					; pop back address of first char.
                        	  1164: 	
00:0258 3E7C            	  1165: 			ld 		A,'|'
00:025A 77              	  1166: 			ld 		(HL),A  
00:025B 23              	  1167: 			inc 	HL
                        	  1168: 
                        	  1169: 
00:025C 3E0F            	  1170: 			ld 		A,$0F
00:025E 320000          	  1171: 			ld 		(generalFlags),A 		; indicate second round , chars
00:0261 CD7C02          	  1172: 			call 	displayBytes
                        	  1173: 		
00:0264 3E7C            	  1174: 			ld 		A,'|'
00:0266 77              	  1175: 			ld 		(HL),A  
00:0267 23              	  1176: 			inc 	HL
                        	  1177: 
00:0268 AF              	  1178: 			xor 	a
00:0269 77              	  1179: 			ld 		(hl),A
                        	  1180: 
00:026A FD210000        	  1181: 			ld 		iy,dumpText
00:026E CD0000          	  1182: 			call	WriteLineCRNL
                        	  1183: 
00:0271 C1              	  1184: 		pop 	bc						; pop back the line counter
00:0272 0B              	  1185: 		dec 	bc 						; decrease # lines...
00:0273 3E00            	  1186: 		ld  	A,0
00:0275 B8              	  1187: 		cp    	B
00:0276 20CC            	  1188: 		jr 		NZ,display_BC_bytes
00:0278 B9              	  1189: 		cp 		C
00:0279 20C9            	  1190: 		jr 		NZ,display_BC_bytes
                        	  1191: 
                        	  1192: 
                        	  1193: 
00:027B C9              	  1194: 		ret
                        	  1195: 
                        	  1196: 
                        	  1197: 
                        	  1198: displayBytes:
                        	  1199: 
00:027C 0610            	  1200: 		ld 		b,$10
                        	  1201: displayLoop:
00:027E 78              	  1202: 		ld 		A,B
00:027F C5              	  1203: 		push 	BC			; save the # byte counter
                        	  1204: 	
00:0280 FE08            	  1205: 		cp 		$08			; is B ( A-8) 8 bytes ?
00:0282 3E01            	  1206: 		ld 		A,$01
00:0284 2002            	  1207: 		jr 		NZ,.noextraSpace
00:0286 C603            	  1208: 		add 	$03 	
                        	  1209: .noextraSpace:
00:0288 47              	  1210: 		ld 		B,A
00:0289 CD0000          	  1211: 		call	add_space		; add (b) spaces to (hl), advance hl	
                        	  1212: 
00:028C 3A0000          	  1213: 		ld  	A,(generalFlags)
00:028F B7              	  1214: 		or  	A 				; check if zero ->  first round - Hex values
00:0290 280C            	  1215: 		jr  	Z,firstRound
                        	  1216: 
                        	  1217: 		; ***	print out the ascii characters.
                        	  1218: 		; ***	if val isChar	
                        	  1219: 
00:0292 EB              	  1220: 		ex 		DE,HL 				; HL -> memory bytes
00:0293 CD7A00          	  1221: 		call 	isChar				; is (HL) char ? return with Carry-> value in A is always '.'
00:0296 EB              	  1222: 		ex 		DE,HL				; swithch HL back to text buf dumpText		
                        	  1223: 		
00:0297 77              	  1224: 		ld 		(HL),A
00:0298 23              	  1225: 		inc 	HL
00:0299 13              	  1226: 		inc 	DE
00:029A C1              	  1227:  		pop 	bc					; pop back the # byte counter
00:029B 10E1            	  1228: 		djnz 	displayLoop			; display (b) bytes  with spaces...
                        	  1229: 
00:029D C9              	  1230: 		ret 
                        	  1231: 
                        	  1232: 
                        	  1233: 
                        	  1234: firstRound:		
00:029E D5              	  1235: 		push 	DE
00:029F 1A              	  1236: 		ld		A,(DE)				; get value from memory to E..?
00:02A0 5F              	  1237: 		ld 		E,A
                        	  1238: 
00:02A1 CD0000          	  1239: 		call	Bin2Hex8			;result added to (HL)-> to last 0x00. hl updatd (+4)
                        	  1240: 		
00:02A4 D1              	  1241: 		pop 	DE
00:02A5 13              	  1242: 		inc 	DE
                        	  1243: 
                        	  1244: 
00:02A6 C1              	  1245: 		pop 	bc					; pop back the # byte counter
00:02A7 10D5            	  1246: 		djnz 	displayLoop			; display (b) bytes  with spaces...
                        	  1247: 
00:02A9 C9              	  1248: 		ret 
                        	  1249: 
                        	  1250: checkZero16:
                        	  1251: 		; ***	check if (HL),(HL+1) = 0 ?		
00:02AA 3E00            	  1252: 		ld 		A,00
00:02AC BE              	  1253: 		cp 		(HL)				; ix zero		
00:02AD C0              	  1254: 		ret 	NZ	
00:02AE 23              	  1255: 		inc 	HL
00:02AF BE              	  1256: 		cp 		(HL)				; is zero ?	
00:02B0 2B              	  1257: 		dec  	HL	
00:02B1 C9              	  1258: 		ret							; return with either Z or NZ
                        	  1259: 
                        	  1260: 
                        	  1261: 
                        	  1262: ; dumpText: DC	$80 '/'
                        	  1263: 
                        	  1264: 
                        	  1265: ;***************************************************************************************************
                        	  1266: ;***************************************************************************************************
                        	  1267: ;***************************************************************************************************
                        	  1268: 
                        	  1269: 
                        	  1270: 
                        	  1271: 
                        	  1272: 		;section 	STR_HEAP 
                        	  1273: 		;	space for string constants
                        	  1274: 		GLOBAL	DateBuf,MsgText1,st2g1,st1g2,steq,subst
                        	  1275: 		GLOBAL	RegLabels1,RegLabels2,RegLabels3,RegFlags
                        	  1276: 		xdef	Str0,Str2,Str3,Str4,Str7,sourctext1,sourctext2,endtext,src_size
                        	  1277: 		
                        	  1278: 	if DOALIGN
                        	  1279: 		align 1
                        	  1280: 	endif
                        	  1281:  	
                        	  1282: String_HEAP_Start:
00:02B2 2020323032322D31	  1283: DateBuf:		DB		"  2022-12-30_17:22   ",0,0
00:02BA 322D33305F31373A
00:02C2 3232202020
00:02C7 00
00:02C8 00
                        	  1284: 
00:02C9 48656C6C6F2C2065	  1285: MsgText1:		DB		"Hello, enter command: >_",  0, 0
00:02D1 6E74657220636F6D
00:02D9 6D616E643A203E5F
00:02E1 00
00:02E2 00
                        	  1286: 
00:02E3 0F              	  1287: st2g1:			DB		0x0F,"Str 2 > Str 1 !",0,0
00:02E4 5374722032203E20
00:02EC 53747220312021
00:02F3 00
00:02F4 00
00:02F5 0F              	  1288: st1g2:			DB		0x0F,"Str 1 > Str 2 !",0,0
00:02F6 5374722031203E20
00:02FE 53747220322021
00:0305 00
00:0306 00
00:0307 0F              	  1289: steq:			DB		0x0F,"Strings Equal !",0,0
00:0308 537472696E677320
00:0310 457175616C2021
00:0317 00
00:0318 00
00:0319 04              	  1290: subst:			DB		4,"seco",0,0
00:031A 7365636F
00:031E 00
00:031F 00
                        	  1291: 
                        	  1292: 
00:0320 207C2E2E2E50432E	  1293: RegLabels1:		DB		" |...PC...|...SP...|...IX...|...IY...|",0
00:0328 2E2E7C2E2E2E5350
00:0330 2E2E2E7C2E2E2E49
00:0338 582E2E2E7C2E2E2E
00:0340 49592E2E2E7C
00:0346 00
00:0347 207C2E2E2E41462E	  1294: RegLabels2:		DB		" |...AF...|...BC...|...DE...|...HL...|",0
00:034F 2E2E7C2E2E2E4243
00:0357 2E2E2E7C2E2E2E44
00:035F 452E2E2E7C2E2E2E
00:0367 484C2E2E2E7C
00:036D 00
00:036E 207C2E2E2E414627	  1295: RegLabels3:		DB		" |...AF'..|...BC'..|...DE'..|...HL'..|",0
00:0376 2E2E7C2E2E2E4243
00:037E 272E2E7C2E2E2E44
00:0386 45272E2E7C2E2E2E
00:038E 484C272E2E7C
00:0394 00
00:0395 2053205A20582048	  1296: RegFlags:		DB		" S Z X H X P N C",0
00:039D 20582050204E2043
00:03A5 00
                        	  1297: 
00:03A6 17              	  1298: Str0:			defb 	23,"Hello, finnally here !",0,0
00:03A7 48656C6C6F2C2066
00:03AF 696E6E616C6C7920
00:03B7 686572652021
00:03BD 00
00:03BE 00
00:03BF 17              	  1299: Str2:			defb	23,"This is the second Bank",0,0
00:03C0 5468697320697320
00:03C8 746865207365636F
00:03D0 6E642042616E6B
00:03D7 00
00:03D8 00
00:03D9 17              	  1300: Str3:			defb	23,"This is the third Bank",0,0
00:03DA 5468697320697320
00:03E2 7468652074686972
00:03EA 642042616E6B
00:03F0 00
00:03F1 00
00:03F2 17              	  1301: Str4:			defb	23,"This is the 4'th Bank",0,0
00:03F3 5468697320697320
00:03FB 7468652034277468
00:0403 2042616E6B
00:0408 00
00:0409 00
00:040A 17              	  1302: Str7:			defb	23,"This is the 7'th Bank",0,0
00:040B 5468697320697320
00:0413 7468652037277468
00:041B 2042616E6B
00:0420 00
00:0421 00
                        	  1303: 
00:0422 0A              	  1304: sourctext1:		DB		10,"First Str:",0,0
00:0423 4669727374205374
00:042B 723A
00:042D 00
00:042E 00
00:042F 0E              	  1305: sourctext2:		DB		14,"Appendix..../a",0,0	
00:0430 417070656E646978
00:0438 2E2E2E2E2F61
00:043E 00
00:043F 00
                        	  1306: 
                        	  1307: src_size:		equ		sourctext2-sourctext1
                        	  1308: 
                        	  1309: endtext:
                        	  1310: String_HEAP_end:
                        	  1311: 
                        	  1312: 
                        	  1313: 	if DOALIGN
                        	  1314: 		align 4
                        	  1315: 	endif
                        	  1316: 
                        	  1317: 
                        	  1318: 
                        	  1319: .END
                        	  1320: 


Symbols by name:
Bin2Hex16                       external
Bin2Hex8                        external
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CHKLEN                          00:01B4
CNT1OK                          00:0150
CNT2OK                          00:015C
CNTOK                           00:0194
CONCAT                          00:008E EXP
COPY                            00:0126 EXP
CPYERR                          external
CR                               E:000D
DELERR                          external
DELETE                          00:016F EXP
DOALIGN                          E:0000
DOCAT                           00:00C9
DateBuf                         00:02B2 EXP
EREXIT                          00:016D
EXIT                            00:00D5
FOUND                           00:0120
HEAP_SIZE                       external
IDX0                            00:01B0
IDXL1                           00:01D8
IDXLEN                          00:01C8
INDEX                           external
INSERR                          external
INSERT_STR                      00:01A9 EXP
Init_RAM_HEAP                   00:0203 EXP
LENOK                           00:00C2
LENOK_8F                        00:01DF
LENS1                           external
LENS2                           external
MAXLEN                          external
MVESUB                          00:01F8
MsgText1                        00:02C9 EXP
NOTFND                          00:0124
OKEXIT_8D                       00:016B
OKEXIT_8E                       00:01A7
PCvalue                         external
POS                             00:00E1 EXP
RECALC                          00:0147
RegFlags                        00:0395 EXP
RegLabels1                      00:0320 EXP
RegLabels2                      00:0347 EXP
RegLabels3                      00:036E EXP
S1ADR                           external
S1LEN                           external
S2LEN                           external
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Vec                      E:F400
SLP1                            00:00FE
SLP2                            00:011C
SRAM_VAR_START                  external
STRGOV                          external
STRING                          external
SUBLEN                          external
SUBSTG                          external
Str0                            00:03A6 EXP
Str2                            00:03BF EXP
Str3                            00:03D9 EXP
Str4                            00:03F2 EXP
Str7                            00:040A EXP
String_HEAP_Start               00:02B2
String_HEAP_end                 00:0440
TOOLNG                          00:00AD
TRUNC                           00:018C
TRUNC_8F                        00:01BE
WriteLineCRNL                   external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
add_space                       external EXP
checkZero16                     00:02AA
cmpLength                       00:0018
cmpLoop                         00:0011
cmpLoop_8C                      00:0111
commAdr1                        external
commLvl1                        external
delimChars                      00:0020
displayBytes                    00:027C
displayLoop                     00:027E
display_BC_bytes                00:0244
dumpMemory                      00:0214 EXP
dumpText                        external
endtext                         00:0440 EXP
exitDelim                       00:003C
exitZero                        00:0040
firstRound                      00:029E
generalFlags                    external
gpioB                           external
gpio_in                         external
gpio_out                        external
isChar                          00:007A EXP
isDelimit                       00:002A EXP
isHex                           00:0056 EXP
nxtdelim                        00:0032
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
skipCharsUntilDelim             00:004D EXP
skipPriorDelimit                00:0044 EXP
sourctext1                      00:0422 EXP
sourctext2                      00:042F EXP
src_size                         E:000D EXP
st1g2                           00:02F5 EXP
st2g1                           00:02E3 EXP
steq                            00:0307 EXP
str2ISshorter                   00:000C
strCompare                      00:0000 EXP
subst                           00:0319 EXP
zero_byte                       00:0213

Symbols by value:
0000 DOALIGN
0000 strCompare
000C str2ISshorter
000D CR
000D src_size
0011 cmpLoop
0018 cmpLength
0020 delimChars
002A isDelimit
0032 nxtdelim
003C exitDelim
0040 exitZero
0044 skipPriorDelimit
004D skipCharsUntilDelim
0056 isHex
007A isChar
008E CONCAT
00AD TOOLNG
00C2 LENOK
00C9 DOCAT
00D5 EXIT
00E1 POS
00FE SLP1
0111 cmpLoop_8C
011C SLP2
0120 FOUND
0124 NOTFND
0126 COPY
0147 RECALC
0150 CNT1OK
015C CNT2OK
016B OKEXIT_8D
016D EREXIT
016F DELETE
018C TRUNC
0194 CNTOK
01A7 OKEXIT_8E
01A9 INSERT_STR
01B0 IDX0
01B4 CHKLEN
01BE TRUNC_8F
01C8 IDXLEN
01D8 IDXL1
01DF LENOK_8F
01F8 MVESUB
0203 Init_RAM_HEAP
0213 zero_byte
0214 dumpMemory
0244 display_BC_bytes
027C displayBytes
027E displayLoop
029E firstRound
02AA checkZero16
02B2 DateBuf
02B2 String_HEAP_Start
02C9 MsgText1
02E3 st2g1
02F5 st1g2
0307 steq
0319 subst
0320 RegLabels1
0347 RegLabels2
036E RegLabels3
0395 RegFlags
03A6 Str0
03BF Str2
03D9 Str3
03F2 Str4
040A Str7
0422 sourctext1
042F sourctext2
0440 String_HEAP_end
0440 endtext
F400 SIO_Int_Vec
