Sections:
00: "Functions" (0-7C)


Source: "stdin"
                        	     1: 		include "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: 
                        	     5: ; ;Function addresses
                        	     6: ; setcursor		= $3100
                        	     7: ; writecommand	= $3180
                        	     8: ; writedata		= $3140
                        	     9: ; testBusyFlag    = $31B0
                        	    10: ; HD44780_main_init = $3000
                        	    11: stacktop: equ	0xFFF0	
                        	    12: 
                        	    13: 
                        	    14: ; PIO addressess...
                        	    15: ;******************************************
                        	    16: 	  ; _Z80PIO_Base= $00
                        	    17: portA_Contr:	equ _Z80PIO_Base + 1
                        	    18: portB_Contr:	equ _Z80PIO_Base + 3
                        	    19: portA_Data:		equ _Z80PIO_Base + 0
                        	    20: portB_Data:		equ _Z80PIO_Base + 2
                        	    21: 
                        	    22: 
                        	    23: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    24: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    25: gpioB:			equ		portB_Data
                        	    26: 
                        	    27: ; SIO_0 stuff
                        	    28: ;******************************************
                        	    29: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    30: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    31: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    32: 				;SIO_0  CHANNEL B DATA
                        	    33: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    34: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    35: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    36: 
                        	    37: sio_ac: 		equ 	SIO_A_C
                        	    38: sio_ad: 		equ 	SIO_A_D
                        	    39: sio_bc: 		equ 	SIO_B_C
                        	    40: sio_bd: 		equ 	SIO_B_D
                        	    41: 
                        	    42: Interupt_vector		= SIO_Int_Vec
                        	    43: 
                        	    44: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    45: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    46: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    47: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    48: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    49: 
                        	    50: 		
                        	    51: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    52: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    53: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    54: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    55: 
                        	    56: ;Write register 0
                        	    57: WR0 equ 0
                        	    58: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    59: _Ch_Reset		equ 3<<3			; 18
                        	    60: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    61: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    62: _Error_Reset 	equ $30				; (30)	
                        	    63: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    64: 
                        	    65: ;Write register 1
                        	    66: WR1 equ 1
                        	    67: _Ext_INT_EN			equ 1
                        	    68: _Tx_INT_EN 			equ 2
                        	    69: _Status_Vector		equ 4
                        	    70: _Rx_INT_Disable		equ 0
                        	    71: _Rx_INT_First_Char  equ $08
                        	    72: _INT_All_Rx_Char_P 	equ $10 
                        	    73: _Int_All_Rx_Char_NP	equ $18
                        	    74: _WAIT_READY_R_T 	equ $20
                        	    75: _WAIT_READY_FUNC	equ $40
                        	    76: _WAIT_READY_EN		equ $80
                        	    77: 
                        	    78: WR2 equ 2
                        	    79: 
                        	    80: ;Write register 3
                        	    81: WR3 equ 3
                        	    82: _Rx_Enable 			equ $01
                        	    83: _Rx_Disable 		equ $00
                        	    84: _Auto_Enable		equ $20
                        	    85: _RX_5_bits			equ $00
                        	    86: _RX_6_bits			equ $40
                        	    87: _RX_7_bits			equ $80
                        	    88: _RX_8_bits			equ $C0
                        	    89: 
                        	    90: ;Write register 4
                        	    91: WR4 equ 4
                        	    92: _Parity_EN			equ $01
                        	    93: _Parity_Even		equ $02
                        	    94: _Stop_1_bit			equ $04
                        	    95: _Stop_1_2_bit		equ $08
                        	    96: _Stop_2_bit			equ $0C
                        	    97: _X1_Clock_mode		equ $00
                        	    98: _X16_Clock_mode		equ $40
                        	    99: _X32_Clock_mode		equ $80
                        	   100: _X64_Clock_mode		equ $C0
                        	   101: 
                        	   102: ;Write register 5
                        	   103: WR5 equ 5
                        	   104: _RTS_Enable			equ $02
                        	   105: _Tx_Enable 			equ $08
                        	   106: _Send_Break			equ $10
                        	   107: _Tx_5bits_char		equ $00
                        	   108: _Tx_7bits_char		equ $20
                        	   109: _Tx_6bits_char		equ $40
                        	   110: _Tx_8bits_char		equ $60
                        	   111: _DTR_Enable 		equ $80
                        	   112: 
                        	   113: EOT_FOUND			equ $02
                        	   114: _err01_				equ	$08
                        	   115: _err02_				equ	$09
                        	   116: _err03_				equ	$0C
                        	   117: _err04_				equ	$0D
                        	   118: _err05_				equ	$0E
                        	   119: CTCpulse			equ $0A
                        	   120: CTCtimeout			equ $0B
                        	   121: 
                        	   122: 
                        	   123: ; CTC stuff
                        	   124: ;******************************************
                        	   125: CH0		equ 	_Z80CTC_Base	  ; = $10
                        	   126: CH1		equ 	_Z80CTC_Base+1	
                        	   127: CH2		equ 	_Z80CTC_Base+2	
                        	   128: CH3		equ 	_Z80CTC_Base+3	
                        	   129: 
                        	   130: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   131: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   132: _Timer 		equ 	$00
                        	   133: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   134: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   135: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   136: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   137: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   138: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   139: 
                        	   140: ; Interrupt vectors for CTC
                        	   141: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   142: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   143: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   144: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   145: 
                        	   146: ; Data tables  (upper EPROM/FLASH)
                        	   147: ; stack  				= $FF00
                        	   148: Heap				= $F000				; space for variable storage
                        	   149: 
                        	   150: ; variables  	(upper ram)
                        	   151: PIO_B_value:		= $F1D0
                        	   152: Result_NumToHex:	= $F1F0
                        	   153: 
                        	   154: 
                        	   155: ; _RAMSTART		= $8010	
                        	   156: ; _EETESTPROG		= $100	
                        	   157: 	
                        	   158: ; _Z80PIO_Base	= $0
                        	   159: ; _Z80CTC_Base	= $10
                        	   160: ; _Z80SIO_Base	= $20
                        	   161: ; _Z80_BankCS  	= 0x30;		/*	 30 - 3F   */
                        	   162: ; _8Bitsout 		= $40;		/*	 40 - 4F  */
                        	   163: ; _CE_RST_BANK 	= 0x50;		/*	 50 - 5F  */
                        	   164: 
                        	   165: ;*****	ALIGN command  : 00 removes all align commands
                        	   166: DOALIGN 	EQU 	00
                        	   167: 
                        	   168: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   169: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   170: CRChar:			EQU		0DH				; carrige return
                        	   171: LFChar:			EQU		0AH				; line feed
                        	   172: NUL			EQU		00
                        	   173: SOH			EQU		01
                        	   174: STX			EQU		02
                        	   175: ETX			EQU		03
                        	   176: EOT			EQU		04
                        	   177: ENQ			EQU		05
                        	   178: ACK			EQU		06
                        	   179: BEL			EQU		07
                        	   180: BS			EQU		08h
                        	   181: HT			EQU		09h
                        	   182: LF			EQU		0AH
                        	   183: VT			EQU		0BH
                        	   184: FF			EQU		0CH
                        	   185: CR			EQU		0DH
                        	   186: SO			EQU		0Eh
                        	   187: SI			EQU		0Fh
                        	   188: DLE			EQU		10h
                        	   189: DC1			EQU		11h
                        	   190: DC2			EQU		12h
                        	   191: DC3			EQU		13h
                        	   192: DC4			EQU		14h
                        	   193: NAK			EQU		15h
                        	   194: SYN			EQU		16h
                        	   195: ETB			EQU		17h
                        	   196: CAN			EQU		18h
                        	   197: EM			EQU		19h
                        	   198: SUB			EQU		1Ah
                        	   199: ESC			EQU		1Bh
                        	   200: FS			EQU		1Ch
                        	   201: GS			EQU		1Dh
                        	   202: RS			EQU		1Eh
                        	   203: US			EQU		1Fh
                        	   204: ITEM		EQU		1Ch
                        	   205: STEND		EQU		1Dh
                        	   206: LISTEND		EQU		1Eh
                        	   207: SP			EQU		20h
                        	   208: 
                        	   209: 
                        	   210: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   211: ;DATA LOCATIONS
                        	   212: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   213: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   214: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   215: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   216: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   217: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   218: 
                        	   219: ;BUFFER CONFIGURATION
                        	   220: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   221: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   222: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   223: 
                        	   224: ;BUFFER SIZES, change to suit
                        	   225: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   226: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   227: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   228: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   229: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   230: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   231: 
                        	   232: 
                        	   233: ;INTERRUPT VECTOR TABLE SETUP
                        	   234: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   235: ;There are 4 reasons the interrupt will occur:
                        	   236: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   237: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   238: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   239: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   240: ;
                        	   241: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   242: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   243: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   244: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   245: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   246: ;
                        	   247: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   248: ; -------   --  --  --  ----  --------------
                        	   249: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   250: ;    B       0   0   1   02H  External/Status Change
                        	   251: ;    B       0   1   0   04H  Receive Character Available
                        	   252: ;    B       0   1   1   06H  Special Receive Condition
                        	   253: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   254: ;    A       1   0   1   0AH  External/Status Change
                        	   255: ;    A       1   1   0   0CH  Receive Character Available
                        	   256: ;    A       1   1   1   0EH  Special Receive Condition
                        	   257: ;
                        	   258: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   259: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   260: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   261: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   262: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   263: 
                        	   264: 
                        	   265: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   266: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   267: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   268: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   269: 
                        	   270: ;****************************************************************************
                        	   271: 
                        	   272: 
                        	   273: 
                        	   274: 
                        	   275: ; Define the memory size to be used for the CP/M configuration
                        	   276: ; MEM:    equ 60
                        	   277: 
                        	   278: ; The CPM origin will be at: (MEM-7)*1024
                        	   279: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   280: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   281: 
                        	   282: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   283: 
                        	   284: 
                        	   285: 

Source: "stdin"
                        	     2: 
                        	     3: 	ifndef ONESECTION
                        	     4: 		section Functions
                        	     5: 	else
                        	     6: 		section singleAssembly
                        	     7: 	endif
                        	     8: 
                        	     9: 
                        	    10:         GLOBAL  Flash_WR_Test,Flash_SE_Erase
                        	    11: 		GLOBAL 	enableFLASH,enableIC620_OE,setFLASHBank,setSRAMBank,disableFLASH,disableIC620_OE
                        	    12: 
                        	    13: ;********************************************************************************************
                        	    14: ;********************************************************************************************	
                        	    15: Flash_WR_Test:
                        	    16: 
                        	    17: 		; ***	size in commLvl1
                        	    18: 		; ***	memory address in commAdr1
                        	    19: 		; ***	flash address in commAdr2
                        	    20: 		; ***	erase sectors
                        	    21: 
                        	    22: 
                        	    23: 
                        	    24: 		; erase present flash section
00:0000 ED4B0000        	    25: 		ld 		BC,(commLvl1)		; size of block
                        	    26: 
00:0004 2A0000          	    27: 		ld 		HL,(commAdr2)		; first adress in flash sector
00:0007 ED5B0000        	    28: 		ld 		DE,(commAdr1)		; first adress in memory
                        	    29: nextSector:
00:000B 7C              	    30: 		ld 		A,H
00:000C E6F0            	    31: 		and 	A,$F0 				; select high nibble
00:000E 320000          	    32: 		ld 		(TempVar4),A		; save flash adr (highest nibble)
00:0011 CD3700          	    33: 		call	Flash_SE_Erase
                        	    34: wrOneByte:
                        	    35: 		; ***	Write one byte
00:0014 CD5700          	    36: 		call	WR_sequence
00:0017 1A              	    37: 		ld 		A,(DE)				; get byte from memory
00:0018 77              	    38: 		ld		(HL),A				; set FLASH byte/address to be programmed
00:0019 CD6700          	    39: 		call	WR_toggle			; wait for toggle
00:001C 13              	    40: 		inc 	DE
00:001D 23              	    41: 		inc 	HL
                        	    42:  	; call DumpRegisters
                        	    43: 
00:001E 0B              	    44: 		dec 	BC
00:001F AF              	    45: 		xor  	A 					; A=0
00:0020 B8              	    46: 		cp 		A,B
00:0021 2005            	    47: 		jr 		NZ,checkSector
00:0023 B9              	    48: 		cp 		A,C
00:0024 2002            	    49: 		jr 		NZ,checkSector
00:0026 180E            	    50: 		jr 		finishWrite
                        	    51: checkSector:
                        	    52: 		; ***	compare highest nibblbe to detect sector change
00:0028 D5              	    53: 		push 	DE
00:0029 7C              	    54: 			ld 		A,H
00:002A E6F0            	    55: 			and 	A,$F0 				; select high nibble
00:002C 57              	    56: 			ld 		D,A 		 		; high byte of stored flash address
00:002D 3A0000          	    57: 			ld 		A,(TempVar4)
00:0030 AA              	    58: 			xor 	A,D					; check if same sector
00:0031 D1              	    59: 		pop 	DE
00:0032 20D7            	    60: 		jr 		NZ,nextSector
00:0034 18DE            	    61: 		jr 		wrOneByte
                        	    62: 
                        	    63: 
                        	    64: 
                        	    65: 		; call	enableFLASH 	;// clear '64K_SRAM' signal
                        	    66: 
                        	    67: 
                        	    68: 		; call	WR_sequence
                        	    69: 		; ld 	A,$A0
                        	    70: 		; ld	hl,$2012
                        	    71: 		; ld	(hl),A
                        	    72: 		; call	WR_toggle
                        	    73: 
                        	    74: 		; ld	A,$80
                        	    75: 		; out (_Z80_BankCS),A			;// set '64K_SRAM' signal
                        	    76: finishWrite:
00:0036 C9              	    77: 		ret
                        	    78: ;********************************************************************************************
                        	    79: ;********************************************************************************************	
                        	    80: 		; ***	erase the sector that contain the address of HL
                        	    81: Flash_SE_Erase:
                        	    82: 
00:0037 3EAA            	    83: 		ld 		A,$AA
00:0039 325555          	    84: 		ld		($5555),A
00:003C 3E55            	    85: 		ld 		A,$55
00:003E 32AA2A          	    86: 		ld		($2AAA),A
00:0041 3E80            	    87: 		ld 		A,$80
00:0043 325555          	    88: 		ld		($5555),A
00:0046 3EAA            	    89: 		ld 		A,$AA
00:0048 325555          	    90: 		ld		($5555),A
00:004B 3E55            	    91: 		ld 		A,$55
00:004D 32AA2A          	    92: 		ld		($2AAA),A
00:0050 3E30            	    93: 		ld 		A,$30
00:0052 77              	    94: 		ld		(HL),A
00:0053 CD6700          	    95: 		call	WR_toggle	; indicate end of sector erase cycle.
                        	    96: 
                        	    97: 		; ld	A,$80
                        	    98: 		; out (_Z80_BankCS),A			;// set '64K_SRAM' signal
00:0056 C9              	    99: 		ret
                        	   100: 
                        	   101: 
                        	   102: WR_sequence:
00:0057 3EAA            	   103: 		ld 		A,$AA
00:0059 325555          	   104: 		ld		($5555),A
00:005C 3E55            	   105: 		ld 		A,$55
00:005E 32AA2A          	   106: 		ld		($2AAA),A
00:0061 3EA0            	   107: 		ld 		A,$A0
00:0063 325555          	   108: 		ld		($5555),a
00:0066 C9              	   109: 		ret
                        	   110: 
                        	   111: WR_toggle:
                        	   112: 
00:0067 7E              	   113: 		ld 		A,(HL)
00:0068 C5              	   114: 		push 	BC
                        	   115: new_toggle:
00:0069 46              	   116: 			ld		B,(HL)
00:006A A8              	   117: 			xor		A,B			; A = A xor B  
00:006B E640            	   118: 			and 	A,$40		; keep bit 6 final result 0 or not
00:006D 78              	   119: 			ld 		A,B			; move (HL) to A
00:006E 20F9            	   120: 			jr		NZ,new_toggle
00:0070 C1              	   121: 		pop 	BC		
00:0071 C9              	   122: 		ret					; return if toggl finished
                        	   123: 
                        	   124: 
                        	   125: ;********************************************************************************************
                        	   126: ;********************************************************************************************	
                        	   127: 
                        	   128: 
                        	   129: disableIC620_OE:
                        	   130: 		; ***	Set IC620 pin 1 high
00:0072 3E00            	   131: 		ld A,0
00:0074 D300            	   132: 		out (_CE_RST_BANK),A			;IC620 (HC374) goes to high impedance.. all signals = GND
                        	   133: 		; ld 	A,$00					; FLASH memory is lower 32k and SRAM upper 32k
                        	   134: 		; out (_Z80_BankCS),A			; set bank register number 0 and 64K_SRAM=0	
                        	   135: 		; ld 	A,$01
                        	   136: 		; out (_CE_RST_BANK),A		; set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
00:0076 C9              	   137: 		ret
                        	   138: 
                        	   139: 
                        	   140: ;********************************************************************************************
                        	   141: ;********************************************************************************************	
                        	   142: 
                        	   143: enableIC620_OE: 
                        	   144: 		; ***	Set IC620 pin 1 low
00:0077 3E01            	   145: 		ld A,1
00:0079 D300            	   146: 		out (_CE_RST_BANK),A			;IC620 (HC374) goes to high impedance.. all signals = GND
                        	   147: 		; ld 	A,$00					; FLASH memory is lower 32k and SRAM upper 32k
                        	   148: 		; out (_Z80_BankCS),A			; set bank register number 0 and 64K_SRAM=0	
                        	   149: 		; ld 	A,$01
                        	   150: 		; out (_CE_RST_BANK),A		; set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
00:007B C9              	   151: 		ret
                        	   152: 
                        	   153: 
                        	   154: ;********************************************************************************************
                        	   155: ;********************************************************************************************	
                        	   156: 
                        	   157: 
                        	   158: 
                        	   159: .end
                        	   160: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
Flash_SE_Erase                  00:0037 EXP
Flash_WR_Test                   00:0000 EXP
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Vec                      E:F400
TempVar4                        external
WR_sequence                     00:0057
WR_toggle                       00:0067
_CE_RST_BANK                    external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
checkSector                     00:0028
commAdr1                        external
commAdr2                        external
commLvl1                        external
disableFLASH                    external EXP
disableIC620_OE                 00:0072 EXP
enableFLASH                     external EXP
enableIC620_OE                  00:0077 EXP
finishWrite                     00:0036
gpioB                           external
gpio_in                         external
gpio_out                        external
new_toggle                      00:0069
nextSector                      00:000B
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
setFLASHBank                    external EXP
setSRAMBank                     external EXP
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
wrOneByte                       00:0014

Symbols by value:
0000 Flash_WR_Test
000B nextSector
0014 wrOneByte
0028 checkSector
0036 finishWrite
0037 Flash_SE_Erase
0057 WR_sequence
0067 WR_toggle
0069 new_toggle
0072 disableIC620_OE
0077 enableIC620_OE
F400 SIO_Int_Vec
