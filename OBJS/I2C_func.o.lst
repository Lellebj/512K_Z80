Sections:
00: "I2C_Func" (0-DD)


Source: "stdin"
                        	     1: ;* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                        	     2: ;* TRIANGLE.ASM
                        	     3: ;* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                        	     4: ;* Purpose: Test of I2C bit-banging using the J1A
                        	     5: ;* Target: 705J1A
                        	     6: ;* Author: Brad Bierschenk, MMD Applications
                        	     7: ;* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                        	     8: ;* Tested using Maxim I 2 C DAC IC, MAX517
                        	     9: ;* Has a "2-wire interface" (another word for I 2 C)
                        	    10: ;*
                        	    11: ;* This code continuously sends 8-bit data to the
                        	    12: ;* Digital to Analog IC, incrementing from $00 to
                        	    13: ;* $FF, and back down again. This creates a
                        	    14: ;* triangular waveform at the output of the DAC chip.
                        	    15: ;*
                        	    16: ;* The SCL frequency is approximately 28 kHz. This is
                        	    17: ;* completely arbitrary.
                        	    18: ;* -------------------------------------------------------------
                        	    19: ;* Assembler Equates
                        	    20: ;* -------------------------------------------------------------
                        	    21: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	    22: 		Section I2C_Func
                        	    23: RAMSPACE	EQU	$C0				;RAM start address
                        	    24: ROMSPACE	EQU	$300			;EPROM start address
                        	    25: PORTA		EQU $00				;Port A
                        	    26: PORTB		EQU $01				;Port B
                        	    27: DDRA		EQU $04				;Data direction A
                        	    28: DDRB		EQU $05				;Data direction B
                        	    29: ;* -------------------------------------------------------------
                        	    30: ;* Emulated I2C lines on Port A pins
                        	    31: ;* Need a clock (SCL) and data (SDA)
                        	    32: ;* -------------------------------------------------------------
                        	    33: SCL			EQU	0				;Serial clock
                        	    34: SDA			EQU	1				;Serial data
                        	    35: DACADDR		EQU	27				;Slave address of DAC
                        	    36: ;* -------------------------------------------------------------
                        	    37: ;* RAM Variables
                        	    38: ;* -------------------------------------------------------------
                        	    39: ; ORG			RAMSPACE
00:0000 01              	    40: BitCounter: DB	1				;Used to count bits in a Tx
00:0001 01              	    41: Value:		DB	1				;Used to store data value
00:0002 01              	    42: Direction:	DB	1				;Indicates increment or	decrement
                        	    43: ;* -------------------------------------------------------------
                        	    44: ;* Start of program code
                        	    45: ;* -------------------------------------------------------------
                        	    46: ; ORG			ROMSPACE			;Start of EPROM
                        	    47: Start:
                        	    48: 		;Initialize variables
00:0003 3E00            	    49: 		ld  	A,00
00:0005 320100          	    50: 		ld 		(Value),A				;Clear all RAM variables
00:0008 320000          	    51: 		ld		(BitCounter),A		
00:000B 320200          	    52: 		ld		(Direction),A			
                        	    53: 		;Setup parallel ports
                        	    54: 
00:000E 3ECF            	    55: 		ld		A,0xCF				; set PIO B to bit mode
00:0010 320400          	    56: 		ld		(DDRA),A			;driven high to start
00:0013 D301            	    57: 		out 	(portA_Contr),A
                        	    58: 	
                        	    59: ;* -------------------------------------------------------------
                        	    60: ;* This main loop just ramps up and down the data
                        	    61: ;* value that is sent to the DAC chip.
                        	    62: ;* -------------------------------------------------------------
                        	    63: TxLoop:
00:0015 3A0200          	    64: 		LD		A,(Direction)			;Increment or decrement?
00:0018 2812            	    65: 		jr 		Z,GoUp
                        	    66: GoDown:
00:001A 3A0100          	    67: 		LD		A,(Value)				;Decrement
00:001D 2007            	    68: 		jr 		NZ,GD2					;Change direction if needed
00:001F 3E00            	    69: 		ld 		A,00
00:0021 320200          	    70: 		ld 		(Direction),A
00:0024 1817            	    71: 		jr		SendIt
                        	    72: GD2:
00:0026 210100          	    73: 		ld 		HL,Value
00:0029 35              	    74: 		DEC		(HL)				;Decrement the data value
00:002A 1811            	    75: 		jr		SendIt
                        	    76: GoUp:
00:002C 3A0100          	    77: 		LD		A,(Value)				;Increment
00:002F FEFF            	    78: 		CP		A,$FF				;Change direction if needed
00:0031 2006            	    79: 		jr 		NZ,GU2
00:0033 210200          	    80: 		ld 		HL,Direction
00:0036 34              	    81: 		inc		(HL)				;Increment the data value
00:0037 1804            	    82: 		jr		SendIt
                        	    83: GU2:
00:0039 210100          	    84: 		ld 		HL,Value
00:003C 34              	    85: 		inc		(HL)
                        	    86: 
                        	    87: ;* -------------------------------------------------------------
                        	    88: ;* Send the I 2 C transmission, including START, address,
                        	    89: ;* data, and STOP
                        	    90: ;* -------------------------------------------------------------
                        	    91: SendIt:
                        	    92: 		;START condition
00:003D CDBC00          	    93: 		call	I2CStartBit			;Give START condition
                        	    94: 
                        	    95: 		;ADDRESS byte, consists of 7-bit address + 0 as LSbit
00:0040 3E1B            	    96: 		LD		A,DACADDR			;Slave device address
00:0042 CB27            	    97: 		sla		A					;Need this to align address
00:0044 CD5A00          	    98: 		call		I2CTxByte			;Send the eight bits
                        	    99: 
                        	   100: 		;DATA bytes
00:0047 3E00            	   101: 		LD		A,$00				;$00 is command byte for DAC
00:0049 CD5A00          	   102: 		call	I2CTxByte			;Send the 8 bits
00:004C 3A0100          	   103: 		LD		A,(Value)				;Value is value to set DAC
                        	   104: 
00:004F CD5A00          	   105: 		call 	I2CTxByte			;Send it
                        	   106: 
                        	   107: 		;STOP condition
00:0052 CDC700          	   108: 		call	I2CStopBit 			;Give STOP condition
00:0055 CDD700          	   109: 		call	I2CBitDelay 		;Wait a bit
00:0058 18BB            	   110: 		jr		TxLoop				;Repeat
                        	   111: 	
                        	   112: 
                        	   113: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   114: ; I2CTxByte
                        	   115: ; Transmit the byte in Acc to the SDA pin
                        	   116: ; (Acc will not be restored on return)
                        	   117: ; Must be careful to change SDA values only while SCL is low,
                        	   118: ; otherwise a STOP or START could be implied
                        	   119: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   120: I2CTxByte:
                        	   121: 		;Initialize variable
00:005A 210000          	   122: 		ld 		HL,BitCounter
00:005D 1608            	   123: 		LD		D,$08
00:005F 56              	   124: 		ld 		D,(HL)		
                        	   125: 
                        	   126: I2CNextBit:
00:0060 CB17            	   127: 		RL		A					;Shift MSbit into Carry
00:0062 3012            	   128: 		jr		NC,SendLow 		;Send low bit or high bit
                        	   129: SendHigh:
00:0064 210000          	   130: 		ld 		HL,PORTA
00:0067 CBCE            	   131: 		SET		SDA,(HL)		;Set the data bit value
00:0069 CDD400          	   132: 		call	I2CSetupDelay 	;Give some time for data
                        	   133: setup:
00:006C 210000          	   134: 		ld 		HL,PORTA
00:006F CBC6            	   135: 		SET		SCL,(HL)		;Clock it in
00:0071 CDD400          	   136: 		call	I2CSetupDelay	;Wait a bit
00:0074 180D            	   137: 		jr		I2CTxCont		;Continue
                        	   138: 
                        	   139: SendLow:
00:0076 210000          	   140: 		ld 		HL,PORTA
00:0079 CB8E            	   141: 		res		SDA,(HL)
00:007B CDD700          	   142: 		call	I2CBitDelay
00:007E CBC6            	   143: 		SET		SCL,(HL)
00:0080 CDD700          	   144: 		call		I2CBitDelay
                        	   145: I2CTxCont:
00:0083 210000          	   146: 		ld 		HL,PORTA
00:0086 CB86            	   147: 		res		SCL,(HL)		;Restore clock to low state
00:0088 210000          	   148: 		ld 		HL,BitCounter
00:008B 35              	   149: 		DEC		(HL)		;Decrement the bit counter
00:008C 2802            	   150: 		jr 		Z,I2CAckPoll		;Last bit?
00:008E 18D0            	   151: 		jr		I2CNextBit
                        	   152: 
                        	   153: I2CAckPoll:
00:0090 210000          	   154: 		ld 		HL,PORTA
00:0093 CBCE            	   155: 		SET		SDA,(HL)
00:0095 210400          	   156: 		ld 		HL,DDRA
00:0098 CB8E            	   157: 		res		SDA,(HL)		;Set SDA as input
00:009A CDD400          	   158: 		call		I2CSetupDelay
00:009D 210000          	   159: 		ld 		HL,PORTA
00:00A0 CBC6            	   160: 		SET		SCL,(HL)		;Clock the line to get ACK
00:00A2 CDD700          	   161: 		call	I2CBitDelay
                        	   162: 		; BRSET	SDA,PORTA,I2CNoAck	;Look for ACK from slave device
00:00A5 CB4E            	   163: 		bit 	SDA,(HL)
00:00A7 2808            	   164: 		jr 		Z,I2CNoAck
                        	   165: 
00:00A9 CB86            	   166: 		res		SCL,(HL)		;Restore clock line
00:00AB 210400          	   167: 		ld 		HL,DDRA
00:00AE CBCE            	   168: 		SET		SDA,(HL)		;SDA back as output
00:00B0 C9              	   169: 		ret
                        	   170: 	
                        	   171: 		;No acknowledgment received from slave device
                        	   172: 		;Some error action can be performed here
                        	   173: 		;For now, just restore the bus
                        	   174: I2CNoAck:
00:00B1 210000          	   175: 		ld 		HL,PORTA
00:00B4 CB86            	   176: 		res		SCL,(HL)
00:00B6 210400          	   177: 		ld 		HL,DDRA
00:00B9 CBCE            	   178: 		SET		SDA,(HL)
00:00BB C9              	   179: 		ret
                        	   180: 
                        	   181: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   182: ; A START condition is defined as a falling edge
                        	   183: ; on SDA while SCL is high
                        	   184: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-
                        	   185: I2CStartBit:
00:00BC 210000          	   186: 		ld 		HL,PORTA
00:00BF CB8E            	   187: 		res		SDA,(HL)
00:00C1 CDD700          	   188: 		call	I2CBitDelay
00:00C4 CB86            	   189: 		res		SCL,(HL)
00:00C6 C9              	   190: 		ret
                        	   191: 
                        	   192: 
                        	   193: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   194: ; A STOP condition is defined as a rising edge
                        	   195: ; on SDA while SCL is high
                        	   196: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   197: I2CStopBit:
00:00C7 210000          	   198: 		ld 		HL,PORTA
00:00CA CB8E            	   199: 		res		SDA,(HL)
00:00CC CBC6            	   200: 		SET		SCL,(HL)
00:00CE CBCE            	   201: 		SET		SDA,(HL)
00:00D0 CDD700          	   202: 		call	I2CBitDelay
00:00D3 C9              	   203: 		ret
                        	   204: 
                        	   205: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                        	   206: ; Provide some data setup time to allow
                        	   207: ; SDA to stabilize in slave device
                        	   208: ; Completely arbitrary delay (10 cycles)
                        	   209: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   210: I2CSetupDelay:
00:00D4 00              	   211: 		NOP
00:00D5 00              	   212: 		NOP
00:00D6 C9              	   213: 		ret
                        	   214: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   215: ; Bit delay to provide (approximately) the desired
                        	   216: ; SCL frequency
                        	   217: ; Again, this is arbitrary (16 cycles)
                        	   218: ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                        	   219: I2CBitDelay:
00:00D7 00              	   220: 		NOP
00:00D8 00              	   221: 		NOP
00:00D9 00              	   222: 		NOP
00:00DA 00              	   223: 		NOP
00:00DB 00              	   224: 		NOP
00:00DC C9              	   225: 		ret
                        	   226: ;* -------------------------------------------------------------
                        	   227: ;* Vector Definitions
                        	   228: ;* -------------------------------------------------------------
                        	   229: 		; ORG		$07FE		;Reset vector
                        	   230: 		; FDB		Start		


Symbols by name:
BitCounter                      00:0000
CH0                             external
CH1                             external
CH2                             external
CH3                             external
DACADDR                          E:001B
DDRA                             E:0004
Direction                       00:0002
GD2                             00:0026
GU2                             00:0039
GoDown                          00:001A
GoUp                            00:002C
I2CAckPoll                      00:0090
I2CBitDelay                     00:00D7
I2CNextBit                      00:0060
I2CNoAck                        00:00B1
I2CSetupDelay                   00:00D4
I2CStartBit                     00:00BC
I2CStopBit                      00:00C7
I2CTxByte                       00:005A
I2CTxCont                       00:0083
PORTA                            E:0000
SCL                              E:0000
SDA                              E:0001
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Vec                      E:F400
SendHigh                        00:0064
SendIt                          00:003D
SendLow                         00:0076
Start                           00:0003
TxLoop                          00:0015
Value                           00:0001
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
gpioB                           external
gpio_in                         external
gpio_out                        external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
setup                           00:006C
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external

Symbols by value:
0000 BitCounter
0000 PORTA
0000 SCL
0001 SDA
0001 Value
0002 Direction
0003 Start
0004 DDRA
0015 TxLoop
001A GoDown
001B DACADDR
0026 GD2
002C GoUp
0039 GU2
003D SendIt
005A I2CTxByte
0060 I2CNextBit
0064 SendHigh
006C setup
0076 SendLow
0083 I2CTxCont
0090 I2CAckPoll
00B1 I2CNoAck
00BC I2CStartBit
00C7 I2CStopBit
00D4 I2CSetupDelay
00D7 I2CBitDelay
F400 SIO_Int_Vec
