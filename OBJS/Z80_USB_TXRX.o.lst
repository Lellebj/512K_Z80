Sections:
00: "CH376S_Support" (0-60C)


Source: "stdin"
                        	     1: ;
                        	     2: 
                        	     3: 
                        	     4: 		INCLUDE "Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     5: 
                        	     6: 
                        	     7: ;*************************************************
                        	     8: 		section 	CH376S_Support
                        	     9: 
                        	    10: ;****************************************************************
                        	    11: ;HC376S_CheckConnection
                        	    12: ;connection_fail
                        	    13: ;connection_pass
                        	    14: ;HC376S_ResetAll				$5
                        	    15: ;HC376S_CheckConnection			$6  /81
                        	    16: ;HC376S_setUSBMode				$15 $06
                        	    17: ;HC376S_setSDMode				$15 $03
                        	    18: ;HC376S_diskConnectionStatus   	$30
                        	    19: ;HC376S_USBdiskMount			$31
                        	    20: ;HC376S_setFileName				$2F $2F
                        	    21: ;HC376S_fileOpen				$32
                        	    22: ;doEnumeration
                        	    23: ;HC376S_fileClose				$36  $0/1
                        	    24: ;HC376S_fileCreate				$34
                        	    25: ;HC376S_getFileSize				$68
                        	    26: ;HC376S_fileRead				$80/$27
                        	    27: ;HC376S_fileWrite
                        	    28: ;HC376S_fileDelete
                        	    29: ;getResponseFromUSB
                        	    30: ;waitForResponse
                        	    31: ;outByte367S
                        	    32: ;CTC_Delay
                        	    33: ;CTC_delay_INT_handler
                        	    34: 
                        	    35: 
                        	    36: USB_TEXT_LABLES		equ 1		; No additional text when using USB.
                        	    37: 								; 1-low level of info; 15-high level of info
                        	    38: 
                        	    39: USB_INT_SUCCESS		equ $14
                        	    40: USB_INT_CONNECT 	equ $15
                        	    41: USB_INT_DISCONNECT 	equ $16
                        	    42: USB_INT_BUF_OVER 	equ $17
                        	    43: USB_INT_USB_READY 	equ $18
                        	    44: USB_INT_DISK_READ 	equ $1D	
                        	    45: USB_INT_DISK_WRITE 	equ $1E
                        	    46: USB_INT_DISK_ERR 	equ $1F	
                        	    47: CMD_RET_SUCCESS 	equ $51
                        	    48: CMD_RET_ABORT	 	equ $5F
                        	    49: ERR_OPEN_DIR		equ $41
                        	    50: ERR_MISS_FILE 		equ $42
                        	    51: ERR_FOUND_NAME		equ $43
                        	    52: ERR_DISK_DISCON		equ $82
                        	    53: ERR_LARGE_SECTOR	equ $84
                        	    54: ERR_TYPE_ERROR		equ $92
                        	    55: ERR_BPB_EROR		equ $A1 
                        	    56: ERR_DISK_FULL		equ $B1 
                        	    57: ERR_FDT_OVER		equ $B2
                        	    58: ERR_FILE_CLOSE		equ $B4
                        	    59: 
                        	    60: 	
                        	    61: 		xref 	delay_D0_ms,PrintD0ToScreen,SetHC376Timer
                        	    62: 		GLOBAL	getResponseFromUSB,HC376S_CheckConnection,HC376S_ResetAll,HC376S_setUSBMode,HC376S_diskConnectionStatus
                        	    63: 		GLOBAL 	HC376S_USBdiskMount,HC376S_setFileName,HC376S_fileOpen,HC376S_fileClose,HC376S_fileCreate
                        	    64: 		GLOBAL 	HC376S_getFileSize,HC376S_fileRead,HC376S_fileDelete,HC376S_fileWrite,HC376S_setSDMode
                        	    65: 		GLOBAL  delay100ms, delay20ms, delay10ms, delay5ms, delay1ms, delay100us, CTC_delay_INT_handler
                        	    66: 
                        	    67: HC376S_CheckConnection::
                        	    68: 
00:0000 11FF05          	    69: 		ld 		DE,CTC_delay_INT_handler
00:0003 ED5312F4        	    70: 		ld 		(CTC_CH1_I_Vector),DE
                        	    71: 
00:0007 CD6205          	    72: 		call 	beginUART
                        	    73: 
00:000A 1E06            	    74: 		ld 		E,$06
00:000C CD6D05          	    75: 		call 	outByte367S
                        	    76: 
00:000F 1E81            	    77: 		ld	 	E,$81					;(hspace+8)			; Testvalue $55 response $AA
00:0011 CD6D05          	    78: 		call 	outByte367S
                        	    79: 
00:0014 CDAC05          	    80: 		call 	delay20ms   			; start timout counter 20 ms
                        	    81: 
00:0017 CD5405          	    82: 		call 	waitForResponse 		; Z is set if no response from 376S, response in E
00:001A CAC803          	    83: 		jp 		Z,endtest				; branch on timeout
                        	    84: 		; ; call 	getResponseFromUSB		; get the actual data, in D0
                        	    85: 		; ; response in E
                        	    86: 
00:001D 7B              	    87: 		ld  	A,E
00:001E 0681            	    88: 		ld 		B,$81
00:0020 2F              	    89: 		cpl 
00:0021 B8              	    90: 		cp 		B 						; compare complement response with B 
00:0022 282A            	    91: 		jr 		Z,connection_pass
                        	    92: 
                        	    93: connection_fail:
                        	    94: 
00:0024 CD0000          	    95: 		call 	writeSTRBelow_CRLF
00:0027 00              	    96: 		DB 		0,">Connection to CH376S - FAILED.", 00
00:0028 3E436F6E6E656374
00:0030 696F6E20746F2043
00:0038 4833373653202D20
00:0040 4641494C45442E
00:0047 00
00:0048 CD0000          	    97: 		call 	waitForFinishedPrintout
                        	    98: 
00:004B AF              	    99: 		xor 	A
00:004C 3C              	   100: 		inc 	A
00:004D C9              	   101: 		ret		; NZ
                        	   102: 
                        	   103: connection_pass:
                        	   104: 	if (USB_TEXT_LABLES>1)
                        	   105: 		call 	writeSTRBelow_CRLF
                        	   106: 		DB 		0,">Connection to CH376S was successful.", 00
                        	   107: 		call 	waitForFinishedPrintout
                        	   108: 
                        	   109: 	endif
00:004E AF              	   110: 		xor 	A
00:004F C9              	   111: 		ret		; Z 
                        	   112:   
                        	   113: ;****************************************************************
                        	   114: 	if DOALIGN
                        	   115: 		align 4
                        	   116: 	endif
                        	   117: 
                        	   118: 
                        	   119: HC376S_ResetAll::
00:0050 11FF05          	   120: 		ld 		DE,CTC_delay_INT_handler
00:0053 ED5312F4        	   121: 		ld 		(CTC_CH1_I_Vector),DE
                        	   122: 
                        	   123: 		; call 	SIO_B_RX_INTon
                        	   124: 
00:0057 CD6205          	   125: 		call	beginUART		
                        	   126: 
00:005A 1E05            	   127: 		ld 		E,$05
00:005C CD6D05          	   128: 		call 	outByte367S
                        	   129: 		
00:005F CD8905          	   130: 		call	delay350ms    			; 350 msec
00:0062 76              	   131: 		halt	
                        	   132: 
00:0063 C9              	   133: 		ret
                        	   134: 
                        	   135: ; **###############################################################
                        	   136: 
                        	   137: ; ****************************************************************
                        	   138: 	if DOALIGN
                        	   139: 		align 4
                        	   140: 	endif
                        	   141: 
                        	   142: HC376S_setUSBMode::
                        	   143: 
00:0064 CD6205          	   144: 		call 	beginUART
                        	   145: 
00:0067 1E15            	   146: 		ld 		E,$15
00:0069 CD6D05          	   147: 		call 	outByte367S
                        	   148: 		
00:006C 1E06            	   149: 		ld 		E,$06				; Code used to enable read/write communication and monitoring of the USB stick
00:006E CD6D05          	   150: 		call 	outByte367S
                        	   151: 		
00:0071 CDAC05          	   152: 		call 	delay20ms			;delay 20 ms
                        	   153: 
00:0074 CD5405          	   154: 		call	waitForResponse	 	;test rxrdy-B
                        	   155: 	
                        	   156: 	ifd 	GPIODEBUG
                        	   157: 	ld a,2
                        	   158: 	out (gpio_out),A
                        	   159: 	ld a,0
                        	   160: 	out (gpio_out),A
                        	   161: 	endif
                        	   162: 	
00:0077 7B              	   163: 		ld 		a,e
00:0078 2812            	   164: 		jr 		Z,NoUSBpres			; no response from 'waitForResponse'
                        	   165: 		
                        	   166: 
00:007A FE51            	   167: 		cp	 	CMD_RET_SUCCESS		; 51?
00:007C C2CC00          	   168: 		jp 		NZ,someUSBerror
                        	   169: 
00:007F CDB305          	   170: 		call 	delay10ms
00:0082 CD5405          	   171: 		call 	waitForResponse				; read data in inport -> A&E
                        	   172: 
                        	   173: 	if (USB_TEXT_LABLES>2)
                        	   174: 		call 	writeSTRBelow_CRLF
                        	   175: 		db		0,">USB Mode command acknowledged !",0,0
                        	   176: 		call 	waitForFinishedPrintout
                        	   177: 	endif
00:0085 7B              	   178: 		ld 		A,E	
00:0086 FE15            	   179: 		cp	 	USB_INT_CONNECT		; 15?		; compare A & USB_INT_CONNECT
00:0088 2002            	   180: 		jr		NZ,NoUSBpres
                        	   181: 
                        	   182: 	if (USB_TEXT_LABLES>3)
                        	   183: 		call 	writeSTRBelow_CRLF
                        	   184: 		db		0,">USB is present.",0,0
                        	   185: 		call 	waitForFinishedPrintout
                        	   186: 	endif	
00:008A AF              	   187: 		xor 	A
00:008B C9              	   188: 		ret									; return with Z
                        	   189: 
                        	   190: 
                        	   191: NoUSBpres:
00:008C CD0000          	   192: 		call 	writeSTRBelow_CRLF
00:008F 00              	   193: 		db	0,">No USB is present.",0,0
00:0090 3E4E6F2055534220
00:0098 6973207072657365
00:00A0 6E742E
00:00A3 00
00:00A4 00
00:00A5 CD0000          	   194: 		call 	waitForFinishedPrintout
00:00A8 1838            	   195: 		jr 		retNZ
                        	   196: NoSDpres:
00:00AA CD0000          	   197: 		call 	writeSTRBelow_CRLF
00:00AD 00              	   198: 		db	0,">No SD card is present.",0,0
00:00AE 3E4E6F2053442063
00:00B6 6172642069732070
00:00BE 726573656E742E
00:00C5 00
00:00C6 00
00:00C7 CD0000          	   199: 		call 	waitForFinishedPrintout
00:00CA 1816            	   200: 		jr 		retNZ
                        	   201: 		
                        	   202: someUSBerror:		
00:00CC CD0000          	   203: 		call 	writeSTRBelow_CRLF
00:00CF 00              	   204: 		db		0,">CH376S error! .",0,0
00:00D0 3E43483337365320
00:00D8 6572726F7221202E
00:00E0 00
00:00E1 00
                        	   205: retNZ:
00:00E2 AF              	   206: 		xor 	A
00:00E3 3C              	   207: 		inc 	A
00:00E4 C9              	   208: 		ret		; NZ
                        	   209: 
                        	   210: ;**###############################################################
                        	   211: ;**################################################################
                        	   212: 		
                        	   213: ;****************************************************************
                        	   214: 	if DOALIGN
                        	   215: 		align 4
                        	   216: 	endif
                        	   217: 
                        	   218: HC376S_setSDMode::
                        	   219: 
00:00E5 CD6205          	   220: 		call 	beginUART
                        	   221: 
00:00E8 1E15            	   222: 		ld 		E,$15
00:00EA CD6D05          	   223: 		call 	outByte367S
                        	   224: 		
00:00ED 1E03            	   225: 		ld 		E,$03				; Code used to enable read/write communication and monitoring of the SD card
00:00EF CD6D05          	   226: 		call 	outByte367S
                        	   227: 		
00:00F2 CD9E05          	   228: 		call 	delay100ms			;delay 20 ms
                        	   229: 
00:00F5 CD5405          	   230: 		call	waitForResponse	 		;test rxrdy-B
00:00F8 2809            	   231: 		jr 		Z,norespSD			; no response from 'waitForResponse'
                        	   232: 
00:00FA FE51            	   233: 		cp	 	CMD_RET_SUCCESS  ; $51?
00:00FC 20CE            	   234: 		jr 		NZ,someUSBerror
                        	   235: 
                        	   236: 		; call 	delay100ms
                        	   237: 		; call 	waitForResponse				; read data in inport -> A&E
                        	   238: 	
                        	   239: 	; if (USB_TEXT_LABLES>4)
                        	   240: 	; 	call 	writeSTRBelow_CRLF
                        	   241: 	; 	db		0,"SD Mode command acknowledged !",0,0
                        	   242: 	; endif
00:00FE 7B              	   243: 		ld 		A,E	
00:00FF 1600            	   244: 		ld 		D,00
                        	   245: 		; cp	 	USB_INT_CONNECT				; compare A & USB_INT_CONNECT
                        	   246: 		; jp		NZ,NoSDpres
                        	   247: 
                        	   248: 	if (USB_TEXT_LABLES>5)
                        	   249: 		call 	writeSTRBelow
                        	   250: 		db		0,"SD card response OK.  Code:",0,0
                        	   251: 		call 	putDEtoScreen
                        	   252: 		call 	waitForFinishedPrintout
                        	   253: 		call	CRLF
                        	   254: 	endif
00:0101 AF              	   255: 		xor 	A
00:0102 C9              	   256: 		ret									; return with Z
                        	   257: 
                        	   258: norespSD:
00:0103 CD0000          	   259: 		call 	writeSTRBelow_CRLF
00:0106 2053442063617264	   260: 		db		" SD card no response",0,0
00:010E 206E6F2072657370
00:0116 6F6E7365
00:011A 00
00:011B 00
00:011C CD0000          	   261: 		call 	waitForFinishedPrintout
00:011F C9              	   262: 		ret
                        	   263: 
                        	   264: 
                        	   265: 
                        	   266: ;**###############################################################
                        	   267: ;**################################################################
                        	   268: 	
                        	   269: 	if DOALIGN
                        	   270: 		align 4
                        	   271: 	endif
                        	   272: 
                        	   273: HC376S_diskConnectionStatus::
                        	   274: 		; ***	Does not apply to SD card's
00:0120 CD6205          	   275: 		call 	beginUART
                        	   276: 
00:0123 1E30            	   277: 		ld 		E,$30
00:0125 CD6D05          	   278: 		call 	outByte367S
                        	   279: 
00:0128 CD9E05          	   280: 		call 	delay100ms
00:012B CD5405          	   281: 		call 	waitForResponse 			; Z is set if no response from 376S 
00:012E CAC803          	   282: 		jp 		Z,endtest					; branch on timeout
                        	   283: 											; if not : get the actual data, in A&E
00:0131 FE14            	   284: 		cp 		A,USB_INT_SUCCESS
00:0133 2001            	   285: 		jr 		NZ,.connFailed
                        	   286: 
                        	   287: 	if (USB_TEXT_LABLES>6)
                        	   288: 		call 	writeSTRBelow_CRLF
                        	   289: 		db		0,">Connection to USB OK.",0,0
                        	   290: 		call 	waitForFinishedPrintout
                        	   291: 	endif
                        	   292: 
00:0135 C9              	   293: 		ret
                        	   294: 	
                        	   295: .connFailed:
00:0136 CD0000          	   296: 		call 	writeSTRBelow_CRLF
00:0139 00              	   297: 		db		0,">Connection to USB - FAILED.",0,0
00:013A 3E436F6E6E656374
00:0142 696F6E20746F2055
00:014A 5342202D20464149
00:0152 4C45442E
00:0156 00
00:0157 00
00:0158 CD0000          	   298: 		call 	waitForFinishedPrintout
00:015B C9              	   299: 		ret
                        	   300: 
                        	   301: ;************************************************************************
                        	   302: ;************************************************************************
                        	   303: 
                        	   304: ;**######################################################################
                        	   305: ;**######################################################################
                        	   306: 
                        	   307: 	if DOALIGN
                        	   308: 		align 4
                        	   309: 	endif
                        	   310: 
                        	   311: 
                        	   312: HC376S_USBdiskMount::
                        	   313: 
00:015C CD6205          	   314: 		call 	beginUART
                        	   315: 		
00:015F 1E31            	   316: 		ld 		E,$31
00:0161 CD6D05          	   317: 		call 	outByte367S
                        	   318: 		
00:0164 CD7B05          	   319: 		call 	delay1s				; 250 msec
00:0167 CD5405          	   320: 		call 	waitForResponse 		; Z is set if no response from 376S 
00:016A CAC803          	   321: 		jp 		Z,endtest				; branch on timeout
                        	   322: 										; get the actual data, in A&E
00:016D 320000          	   323: 		ld 		(TempVar5),A
00:0170 FE14            	   324: 		cp 		USB_INT_SUCCESS		;14?
00:0172 2002            	   325: 		jr 		NZ,.connFailed
                        	   326: 	if (USB_TEXT_LABLES>7)
                        	   327: 		call 	writeSTRBelow_CRLF
                        	   328: 		db		0,">Mounted - OK.",0,0
                        	   329: 		call 	waitForFinishedPrintout
                        	   330: 	endif
00:0174 AF              	   331: 		xor 	A					; A = 0  Z set
00:0175 C9              	   332: 		ret
                        	   333: 	
                        	   334: .connFailed:
00:0176 5F              	   335: 		ld 		E,A
00:0177 1600            	   336: 		ld 		D,00
00:0179 CD0000          	   337: 		call 	writeSTRBelow
00:017C 00              	   338: 		db		0,">Failed to Mount disk.  Code:",0,0
00:017D 3E4661696C656420
00:0185 746F204D6F756E74
00:018D 206469736B2E2020
00:0195 436F64653A
00:019A 00
00:019B 00
00:019C CD0000          	   339: 		call 	putDEtoScreen
00:019F CD0000          	   340: 		call	CRLF
00:01A2 CD0000          	   341: 		call 	waitForFinishedPrintout
00:01A5 3E54            	   342: 		ld 		A,$54					; indicate mount failure A-non zero
00:01A7 3C              	   343: 		inc 	A
00:01A8 C9              	   344: 		ret
                        	   345: 
                        	   346: ;************************************************************************
                        	   347: ;************************************************************************
                        	   348: 
                        	   349: ;**######################################################################
                        	   350: ;**######################################################################
                        	   351: 	if DOALIGN
                        	   352: 		align 4
                        	   353: 	endif
                        	   354: 
                        	   355: ; rfile_name:
                        	   356: 	; db "TESTAS.TXT",0,0
                        	   357: 	; db "PROVIDE.txt",0,0
                        	   358: 	; db "TOTBIN1.TXT",0,0
                        	   359: 	even
                        	   360: HC376S_setFileName::
                        	   361: 
00:01AA CD6205          	   362: 		call 	beginUART
                        	   363: 	
00:01AD 1E2F            	   364: 		ld 		E,$2F			; char '/'
00:01AF CD6D05          	   365: 		call 	outByte367S
00:01B2 CD6D05          	   366: 		call 	outByte367S        ;// Every filename must have this byte '/'to indicate the start of the file name.
                        	   367: 
00:01B5 E5              	   368: 		push 	HL	
00:01B6 210000          	   369: 		ld 		HL,commStr1
                        	   370: 
                        	   371: .nxtchar:	
00:01B9 5E              	   372: 		ld 		E,(HL)
00:01BA 23              	   373: 		inc 	HL
00:01BB CD6D05          	   374: 		call 	outByte367S
00:01BE B7              	   375: 		or 		A  					; test if A=0  'end of string'
00:01BF 20F8            	   376: 		jr 		NZ,.nxtchar
                        	   377: 
00:01C1 E1              	   378: 		pop 	HL
                        	   379: 
00:01C2 CDA505          	   380: 		call 	delay50ms    			; 50 msec
00:01C5 76              	   381: 		halt
                        	   382: 
00:01C6 C9              	   383: 		ret 	
                        	   384: 
                        	   385: ;************************************************************************
                        	   386: ;************************************************************************
                        	   387: 
                        	   388: ;**######################################################################
                        	   389: ;**######################################################################
                        	   390: 	if DOALIGN
                        	   391: 		align 4
                        	   392: 	endif
                        	   393: 
                        	   394: 
                        	   395: HC376S_fileOpen::
                        	   396: 
                        	   397: 	
00:01C7 CD0000          	   398: 		call 	writeSTRBelow
00:01CA 3E46696C65206F70	   399: 		db		">File open : ",0,0
00:01D2 656E203A20
00:01D7 00
00:01D8 00
                        	   400: 
00:01D9 FD210000        	   401: 		ld 		IY,commStr1				;move.l 	USB_filename_ptr,A0 
00:01DD FD2B            	   402: 		dec 	IY
00:01DF CD0000          	   403: 		call 	WriteLineCRNL
00:01E2 CD0000          	   404: 		call 	waitForFinishedPrintout
                        	   405: 
00:01E5 CD6205          	   406: 		call 	beginUART
                        	   407: 	
00:01E8 1E32            	   408: 		ld 		E,$32	
00:01EA CD6D05          	   409: 		call 	outByte367S
00:01ED CD7B05          	   410: 		call 	delay1s				; 250 msec
00:01F0 CD5405          	   411: 		call 	waitForResponse 		; Z is set if no response from 376S , data in A&E
00:01F3 CAC803          	   412: 		jp		Z,endtest				; branch on timeout
                        	   413: 
                        	   414: nxtFileOpen:
                        	   415: 
00:01F6 FE14            	   416: 		cp		USB_INT_SUCCESS			; compare A with USB_INT_SUCCESS ($14)
00:01F8 282A            	   417: 		jr 		Z,.openOK
                        	   418: 
00:01FA FE1D            	   419: 		cp 		USB_INT_DISK_READ		; compare A with USB_INT_DISK_READ ($1D) - enumeration
00:01FC 2865            	   420: 		jr 		Z,doEnumeration
                        	   421: 
00:01FE FE42            	   422: 		cp		ERR_MISS_FILE			; compare A with ERR_MISS_FILE		
00:0200 2843            	   423: 		jr 		Z,openNoFileName
                        	   424: 
00:0202 CD0000          	   425: 		call 	writeSTRBelow_CRLF
00:0205 00              	   426: 		db		0,">Failed to open file.",0,0
00:0206 3E4661696C656420
00:020E 746F206F70656E20
00:0216 66696C652E
00:021B 00
00:021C 00
00:021D CD0000          	   427: 		call 	waitForFinishedPrintout
00:0220 3E65            	   428: 		ld 		A,$65					; indicate mount failure A-non zero
00:0222 3C              	   429: 		inc 	A
00:0223 C9              	   430: 		ret
                        	   431: 
                        	   432: 	
                        	   433: .openOK:
00:0224 CD0000          	   434: 		call 	writeSTRBelow
00:0227 00              	   435: 		db		0," opened successfully, ",0,0
00:0228 206F70656E656420
00:0230 7375636365737366
00:0238 756C6C792C20
00:023E 00
00:023F 00
00:0240 CD0000          	   436: 		call 	waitForFinishedPrintout
00:0243 AF              	   437: 		xor 	A						; A= 0 , Z set
00:0244 C9              	   438: 		ret
                        	   439: 
                        	   440: openNoFileName:
00:0245 CD0000          	   441: 		call 	writeSTRBelow_CRLF
00:0248 00              	   442: 		db		0,">File not found.!",0,0
00:0249 3E46696C65206E6F
00:0251 7420666F756E642E
00:0259 21
00:025A 00
00:025B 00
00:025C CD0000          	   443: 		call 	waitForFinishedPrintout
00:025F 3E76            	   444: 		ld 		A,$76					; indicate mount failure A-non zero 
00:0261 3C              	   445: 		inc 	A						; ret with NZ
00:0262 C9              	   446: 		ret
                        	   447: 
                        	   448: doEnumeration:
00:0263 FD210000        	   449: 		ld 		IY,S1x
                        	   450: 		; *** 	CMD_RD_USB_DATA0
00:0267 CD6205          	   451: 		call 	beginUART
                        	   452: 	
00:026A 1E27            	   453: 		ld 		E,$27					; CMD_RD_USB_DATA0			
00:026C CD6D05          	   454: 		call 	outByte367S				; CMD_RD_USB_DATA0
                        	   455: 
00:026F CDC105          	   456: 		call 	delay2ms
00:0272 CD5405          	   457: 		call 	waitForResponse 		; Z is set if no response from 376S 
00:0275 FD7300          	   458: 		ld 		(IY),E					;read char		 store in adressblock (HL)
00:0278 FD23            	   459: 		inc 	IY
                        	   460: 	
00:027A 7B              	   461: 		ld 		A,E				; get the actual (first byte) data -> length, in D0
00:027B 43              	   462: 		ld 		B,E 			; loop counter
                        	   463: .loop:
00:027C CDB305          	   464: 		call 	delay10ms
00:027F CD5405          	   465: 		call 	waitForResponse 		; Z is set if no response from 376S 
                        	   466: 
00:0282 FD7300          	   467: 		ld 		(IY),E					;read char		 store in adressblock (HL)
00:0285 FD23            	   468: 		inc 	IY
00:0287 10F3            	   469: 		djnz 	.loop
                        	   470: 
00:0289 CD6205          	   471: 		call 	beginUART
                        	   472: 	
00:028C 1E33            	   473: 		ld 		E,$33					; CMD_FILE_ENUM_GO	
00:028E CD6D05          	   474: 		call 	outByte367S				; CMD_RD_USB_DATA0
                        	   475: 			
00:0291 CD9005          	   476: 		call 	delay250ms
00:0294 CD5405          	   477: 		call 	waitForResponse 		; Z is set if no response from 376S 
00:0297 F5              	   478: 		push 	AF
                        	   479: 
00:0298 FD210000        	   480: 		ld 		IY,S1x 				; start of file name text
00:029C FD460C          	   481: 		ld 		B,(IY+$0C)					; UINT8	DIR_Attr;	dir(10) or file(20)
00:029F 3E00            	   482: 		ld 		A,00
00:02A1 FD770C          	   483: 		ld 		(IY+$0C),A					; string eof
                        	   484: 
00:02A4 CD0000          	   485: 		call 	WriteLine
00:02A7 CD0000          	   486: 		call    writeSTRBelow
00:02AA 00              	   487: 		db 		0,"\t",0,0
00:02AB 09
00:02AC 00
00:02AD 00
00:02AE 78              	   488: 		ld 		A,B
00:02AF FE10            	   489: 		cp 		$10 					; directory ?
00:02B1 280A            	   490: 		jr  	Z,.dDir
00:02B3 CD0000          	   491: 		call 	writeSTRBelow
00:02B6 00              	   492: 		db 		0,"\t\t",0,0
00:02B7 0909
00:02B9 00
00:02BA 00
00:02BB 180A            	   493: 		jr 		.common
                        	   494: 
00:02BD CD0000          	   495: .dDir:	call 	writeSTRBelow
00:02C0 00              	   496: 		db 		0,"Dir\t",0,0
00:02C1 44697209
00:02C5 00
00:02C6 00
                        	   497: 
                        	   498: .common:
00:02C7 FD5612          	   499: 		ld 		D,(IY+$12) 				; get size in DE
00:02CA FD5E11          	   500: 		ld 		E,(IY+$11) 				; get size in DE
00:02CD CD0000          	   501: 		call 	putDEtoScreen
00:02D0 CD0000          	   502: 		call 	CRLF
                        	   503: 
00:02D3 F1              	   504: 		pop 	AF						; retrieve last msg from HC376
00:02D4 FE42            	   505: 		cp 		ERR_MISS_FILE
00:02D6 C2F601          	   506: 		JP 		NZ,nxtFileOpen
00:02D9 CD0000          	   507: 		call 	CRLF
00:02DC 3C              	   508: 		inc		A						; reset Z -> NZ 		
00:02DD C9              	   509: 		ret 							; return with NZ
                        	   510: 
                        	   511: 
                        	   512: ;**###############################################################
                        	   513: ;**################################################################
                        	   514: 
                        	   515: 
                        	   516: ; /* FAT数据区中文件目录信息 */
                        	   517: ; typedef struct _FAT_DIR_INFO
                        	   518: ; {
                        	   519: ;    UINT8	DIR_Name[11];					/* 00H,文件名,共11字节,不足处填空格 */
                        	   520: ;    UINT8	DIR_Attr;						/* 0BH,文件属性,参考后面的说明 */
                        	   521: ;    UINT8	DIR_NTRes;						/* 0CH */
                        	   522: ;    UINT8	DIR_CrtTimeTenth;				/* 0DH,文件创建的时间,以0.1秒单位计数 */
                        	   523: ;    UINT16	DIR_CrtTime;					/* 0EH,文件创建的时间 */
                        	   524: ;    UINT16	DIR_CrtDate;					/* 10H,文件创建的日期 */
                        	   525: ;    UINT16	DIR_LstAccDate;					/* 12H,最近一次存取操作的日期 */
                        	   526: ;    UINT16	DIR_FstClusHI;					/* 14H */
                        	   527: ;    UINT16	DIR_WrtTime;					/* 16H,文件修改时间,参考前面的宏MAKE_FILE_TIME */
                        	   528: ;    UINT16	DIR_WrtDate;					/* 18H,文件修改日期,参考前面的宏MAKE_FILE_DATE */
                        	   529: ;    UINT16	DIR_FstClusLO;					/* 1AH */
                        	   530: ;    UINT32	DIR_FileSize;					/* 1CH,文件长度 */
                        	   531: ; } FAT_DIR_INFO, *P_FAT_DIR_INFO;			/* 20H */
                        	   532: 
                        	   533: ;************************************************************************
                        	   534: ;************************************************************************
                        	   535: 
                        	   536: ;**######################################################################
                        	   537: ;**######################################################################
                        	   538: 	if DOALIGN
                        	   539: 		align 4
                        	   540: 	endif
                        	   541: 
                        	   542: 
                        	   543: HC376S_fileClose::
                        	   544: 
                        	   545: 	if (USB_TEXT_LABLES>8)
                        	   546: 		call 	writeSTRBelow
                        	   547: 		db		0,">File close : ",0,0
                        	   548: 		call 	waitForFinishedPrintout
                        	   549: 	endif 
                        	   550: 
00:02DE CD6205          	   551: 		call 	beginUART
                        	   552: 	
00:02E1 1E36            	   553: 		ld 		E,$36
00:02E3 CD6D05          	   554: 		call 	outByte367S
                        	   555: 
00:02E6 1E01            	   556: 		ld 		E,01      		;closeCmd = 0x00 = close without updating file Size, 0x01 = close and update file Size
00:02E8 CD6D05          	   557: 		call 	outByte367S
                        	   558: 
00:02EB CD9E05          	   559: 		call 	delay100ms				; delay max 100 msec
00:02EE CD5405          	   560: 		call 	waitForResponse 		; Z is set if no response from 376S 
00:02F1 CAC803          	   561: 		jp 		Z,endtest				; branch on timeout
                        	   562: 
00:02F4 7B              	   563: 		ld 		A,E						; get the actual data, in A
00:02F5 FE14            	   564: 		cp		USB_INT_SUCCESS
00:02F7 2001            	   565: 		jr 		NZ,.closeFailed
                        	   566: 	
                        	   567: 	if (USB_TEXT_LABLES>9)
                        	   568: 		call 	writeSTRBelow_CRLF
                        	   569: 		db		" closed successfully..",0,0
                        	   570: 		call 	waitForFinishedPrintout
                        	   571: 	endif	
00:02F9 C9              	   572: 		ret
                        	   573: 	
                        	   574: .closeFailed:
                        	   575: 
                        	   576: 		; call 	PrintD0ToScreenHEX
00:02FA CD0000          	   577: 		call 	writeSTRBelow_CRLF
00:02FD 206661696C656420	   578: 		db		" failed to close file.",0,0
00:0305 746F20636C6F7365
00:030D 2066696C652E
00:0313 00
00:0314 00
00:0315 CD0000          	   579: 		call 	waitForFinishedPrintout
00:0318 C9              	   580: 		ret
                        	   581: 
                        	   582: ;************************************************************************
                        	   583: ;************************************************************************
                        	   584: 
                        	   585: 
                        	   586: 
                        	   587: ;**######################################################################
                        	   588: ;**######################################################################
                        	   589: 	if DOALIGN
                        	   590: 		align 4
                        	   591: 	endif
                        	   592: 
                        	   593: 		; ***	Create file; return Z if true.
                        	   594: HC376S_fileCreate::
                        	   595: 
00:0319 CD0000          	   596: 		call 	writeSTRBelow
00:031C 203E437265617465	   597: 		db		" >Create File : ",0,0
00:0324 2046696C65203A20
00:032C 00
00:032D 00
00:032E FD210000        	   598: 		ld 		IY,commStr1
00:0332 FD2B            	   599: 		dec 	IY
00:0334 CD0000          	   600: 		call 	WriteLineCRNL
                        	   601: 
00:0337 CD6205          	   602: 		call 	beginUART
                        	   603: 	
00:033A 1E34            	   604: 		ld 		E,$34					; Create File
00:033C CD6D05          	   605: 		call 	outByte367S
                        	   606: 
00:033F CD8205          	   607: 		call 	delay500ms				; delay max 100 msec
00:0342 CD5405          	   608: 		call 	waitForResponse 		; Z is set if no response from 376S 
00:0345 CAC803          	   609: 		jp 		Z,endtest				; branch on timeout
                        	   610: 
                        	   611: 				;  the actual data is in A&E
00:0348 FE14            	   612: 		cp		USB_INT_SUCCESS
00:034A 2002            	   613: 		jr 		NZ,.createFailed
                        	   614: 	
                        	   615: 	if (USB_TEXT_LABLES>10)
                        	   616: 		call 	writeSTRBelow_CRLF
                        	   617: 		db		" >File created successfully..",0,0
                        	   618: 	endif	
00:034C AF              	   619: 		xor 	A				; Z set
00:034D C9              	   620: 		ret						; Z set, setBytesRead return true
                        	   621: 
                        	   622: 	
                        	   623: .createFailed:
                        	   624: 
00:034E 5F              	   625: 		ld 		E,A
00:034F 1600            	   626: 		ld 		D,00
00:0351 CD0000          	   627: 		call 	writeSTRBelow
00:0354 203E4661696C6564	   628: 		db		" >Failed to create file..  Code:",0,0
00:035C 20746F2063726561
00:0364 74652066696C652E
00:036C 2E2020436F64653A
00:0374 00
00:0375 00
00:0376 CD0000          	   629: 		call 	putDEtoScreen
00:0379 CD0000          	   630: 		call	CRLF
00:037C 3E87            	   631: 		ld 		A,$87					; indicate mount failure A-non zero
00:037E 3C              	   632: 		inc 	A 						; indicate NZ
00:037F C9              	   633: 		ret
                        	   634: 
                        	   635: ;************************************************************************
                        	   636: ;************************************************************************
                        	   637: 
                        	   638: 
                        	   639: ;**######################################################################
                        	   640: ;**######################################################################
                        	   641: 	if DOALIGN
                        	   642: 		align 4
                        	   643: 	endif
                        	   644: 
                        	   645: 
                        	   646: HC376S_getFileSize::
                        	   647: 
00:0380 CD6205          	   648: 		call 	beginUART
                        	   649: 	
00:0383 1E0C            	   650: 		ld 		E,$0C	
00:0385 CD6D05          	   651: 		call 	outByte367S
00:0388 1E68            	   652: 		ld 		E,$68
00:038A CD6D05          	   653: 		call 	outByte367S
                        	   654: 
00:038D CD7B05          	   655: 		call 	delay1s				; delay max 200 ms
                        	   656: 
00:0390 CD5405          	   657: 		call 	waitForResponse 		; Z is set if response from 376S 
00:0393 2833            	   658: 		jr 		Z,endtest				; branch on timeout
                        	   659: 
                        	   660: 
00:0395 0603            	   661: 		ld 		B,3
00:0397 210000          	   662: 		ld 		HL,T_BUFFER  			; $D8
00:039A 77              	   663: 		ld 		(HL),A
00:039B 23              	   664: 		inc 	HL
                        	   665: 
                        	   666: .siz4:
00:039C CDB305          	   667: 		call 	delay10ms 				; delay max 10 ms
00:039F CD5405          	   668: 		call 	waitForResponse			; get the actual data, in D0
00:03A2 2824            	   669: 		jr 		Z,endtest				; branch on timeout
                        	   670: 
00:03A4 77              	   671: 		ld 		(HL),A
00:03A5 23              	   672: 		inc 	HL
00:03A6 10F4            	   673: 		djnz 	.siz4
                        	   674: 
                        	   675: .finalsize:
00:03A8 CD0000          	   676: 		call 	writeSTRBelow
00:03AB 2066696C65207369	   677: 		db		" file size : ",0,0
00:03B3 7A65203A20
00:03B8 00
00:03B9 00
00:03BA ED5B0000        	   678: 		ld 		DE,(T_BUFFER)			; filesize restrict to max 65535 bytes; only two least bytes
00:03BE CD0000          	   679: 		call 	putDEtoScreen
00:03C1 CD0000          	   680: 		call	CRLF
00:03C4 CD0000          	   681: 		call 	waitForFinishedPrintout
                        	   682: 		
00:03C7 C9              	   683: 		ret
                        	   684: 
                        	   685: ;************************************************************************
                        	   686: ;************************************************************************
                        	   687: 
                        	   688: endtest:
00:03C8 CD0000          	   689: 		call 	writeSTRBelow_CRLF
00:03CB 00              	   690: 		DB 		0,">Connection to CH376S - TIMEOUT.", 00
00:03CC 3E436F6E6E656374
00:03D4 696F6E20746F2043
00:03DC 4833373653202D20
00:03E4 54494D454F55542E
00:03EC 00
                        	   691: 
00:03ED C9              	   692: 		ret
                        	   693: 
                        	   694: ;**######################################################################
                        	   695: ;**######################################################################
                        	   696: 
                        	   697: 		; *** IN D;Z set, setBytesRead return true; return false (NZ)
                        	   698: setBytesRead::
                        	   699: 		;***		Value in D
00:03EE CD6205          	   700: 		call 	beginUART
                        	   701: 	
00:03F1 1E3A            	   702: 		ld 		E,$3A					; Byte Read	
00:03F3 CD6D05          	   703: 		call 	outByte367S
                        	   704: 	
00:03F6 5A              	   705: 		ld 		E,D						; will be $80 bytes /block
00:03F7 CD6D05          	   706: 		call 	outByte367S
                        	   707: 
00:03FA 1E00            	   708: 		ld 		E,0						; 2'nd value = 0
00:03FC CD6D05          	   709: 		call 	outByte367S
                        	   710: 
00:03FF CD9E05          	   711: 		call 	delay100ms
00:0402 CD5405          	   712: 		call 	waitForResponse 		; Z is set if no response from 376S 
                        	   713: 
00:0405 7B              	   714: 		ld 		A,E						; get the actual data, E->A
00:0406 FE1D            	   715: 		cp		USB_INT_DISK_READ		; read the CH376S message.   =1D?
                        	   716: 
                        	   717: 										; If equal to 0x1D, data is present, so return true. Will return 0x14 if no data is present.
00:0408 C9              	   718: 		ret 							; ret true ($1D) or false ($14)								
                        	   719: 
                        	   720: ;************************************************************************
                        	   721: ;************************************************************************
                        	   722: 
                        	   723: 
                        	   724: ;**######################################################################
                        	   725: ;**######################################################################
                        	   726: 
                        	   727: 		; Z set, continueRead return true, ; Z cleared -> continueRead return false(NZ)
                        	   728: continueRead:
00:0409 CD6205          	   729: 		call 	beginUART
                        	   730: 	
00:040C 1E3B            	   731: 		ld 		E,$3B					; Byte Read	
00:040E CD6D05          	   732: 		call 	outByte367S
                        	   733: 
00:0411 CD9E05          	   734: 		call 	delay100ms
00:0414 CD5405          	   735: 		call 	waitForResponse 		; Z is set if no response from 376S 
                        	   736: 
00:0417 7B              	   737: 		ld 		A,E						; get the actual data, in A&E
00:0418 FE14            	   738: 		cp		USB_INT_SUCCESS			; 14? read the CH376S message. 
                        	   739: 										; If equal to 0x1D, data is present, so return true. Will return 0x14 if no data is present.
00:041A C9              	   740: 		ret 							; ret true Z ($14), other false NZ							
                        	   741: 
                        	   742: ;************************************************************************
                        	   743: ;************************************************************************
                        	   744: 
                        	   745: 
                        	   746: ;**######################################################################
                        	   747: ;**######################################################################
                        	   748: 	if DOALIGN
                        	   749: 		align 4
                        	   750: 	endif
                        	   751: 
                        	   752: 		;***		usbrd  "TOTBIN1.TXT"  $1000
                        	   753: HC376S_fileRead::
                        	   754: 
00:041B E5              	   755: 		push  	HL
00:041C 2A0000          	   756: 		ld 		HL,(commAdr1)			; set the target address
                        	   757: 		
00:041F CD0000          	   758: 		call 	writeSTRBelow_CRLF
00:0422 2052656164696E67	   759: 		db		" Reading File !. ",0,0
00:042A 2046696C6520212E
00:0432 20
00:0433 00
00:0434 00
00:0435 CD0000          	   760: 		call 	waitForFinishedPrintout
                        	   761: 
                        	   762: .nextblock:		
00:0438 1680            	   763: 		ld 		D,$80 	 		; The maximum value is 0x80  =  128 bytes
00:043A CDEE03          	   764: 		call 	setBytesRead	; This tells the CH376S module how many bytes to read on the next reading step.
                        	   765: 								; In this example, we will read 0x80 bytes at a time. 
                        	   766: 								; Returns true (Z)if there are bytes to read, false (NZ)if there are no more bytes to read.
00:043D 201F            	   767: 		jr 		NZ,endBlockRead
                        	   768: 
00:043F CD6205          	   769: 		call 	beginUART
                        	   770: 	
00:0442 1E27            	   771: 		ld 		E,$27					; CMD_RD_USB_DATA0			
00:0444 CD6D05          	   772: 		call 	outByte367S				; CMD_RD_USB_DATA0
                        	   773: 
00:0447 CDAC05          	   774: 		call 	delay20ms
00:044A CD5405          	   775: 		call 	waitForResponse 		; Z is set if no response from 376S 
                        	   776: 	
00:044D 7B              	   777: 		ld 		A,E				; get the actual (first byte) data -> length, in E
00:044E 43              	   778: 		ld 		B,E 			; loop counter
                        	   779: .loop:
00:044F CDAC05          	   780: 		call 	delay20ms
00:0452 CD5405          	   781: 		call 	waitForResponse 		; Z is set if no response from 376S 
                        	   782: 
00:0455 73              	   783: 		ld 		(HL),E					;read char		 store in adressblock (HL)
00:0456 23              	   784: 		inc 	HL
00:0457 10F6            	   785: 		djnz 	.loop
                        	   786: 
                        	   787: .noaction:
00:0459 CD0904          	   788: 		call 	continueRead		; prepares the module for further reading. If false, stop reading.
                        	   789: 									; You need the continueRead() method if the data to be read from the USB device is greater than numBytes.
00:045C 28DA            	   790: 		jr 		Z,.nextblock 
                        	   791: 
                        	   792: endBlockRead: 	 				; setBytesRead returned false or continueRead returned false
                        	   793: 
                        	   794: 	if (USB_TEXT_LABLES>11)
                        	   795: 		call 	writeSTRBelow_CRLF
                        	   796: 		db		" No more DATA !.",0,0
                        	   797: 		call 	waitForFinishedPrintout
                        	   798: 	endif
00:045E E1              	   799: 		pop 	HL
00:045F C9              	   800: 		ret
                        	   801: 
                        	   802: ;************************************************************************
                        	   803: ;************************************************************************
                        	   804: 
                        	   805: 
                        	   806: ;**######################################################################
                        	   807: ;**######################################################################
                        	   808: 
                        	   809: 		; Z set, continueRead return true; NZ-return false(no more data)
                        	   810: setByteWrite:
                        	   811: 		;***		Value numBytes in D
00:0460 CD6205          	   812: 		call 	beginUART
                        	   813: 	
00:0463 1E3C            	   814: 		ld 		E,$3C					; Byte Read	
00:0465 CD6D05          	   815: 		call 	outByte367S
                        	   816: 
00:0468 5A              	   817: 		ld 		E,D
00:0469 CD6D05          	   818: 		call 	outByte367S
                        	   819: 
00:046C 1E00            	   820: 		ld 		E,00
00:046E CD6D05          	   821: 		call 	outByte367S
                        	   822: 
00:0471 CD7B05          	   823: 		call 	delay1s
00:0474 CD5405          	   824: 		call 	waitForResponse 		; Z is set if no response from 376S 
                        	   825: 		; jr		Z,.retfalse				; branch on timeout
                        	   826: 
                        	   827: 				;  the actual data is in A&E
00:0477 FE1E            	   828: 		cp 		USB_INT_DISK_WRITE		; check the disk write status CH376S message. 
                        	   829: 										; If equal to 0x1D, data is present, so return true. Will return 0x14 if no data is present.
00:0479 C8              	   830: 		ret 	Z 						;			; Z set, continueRead return true; NZ-return false(no more data)
                        	   831: 
                        	   832: 
                        	   833: ; .retfalse:
                        	   834: ; 		ld 		A,$98
                        	   835: ; 		inc 	A						; Z cleared -> continueRead return  NZ  return false ($14)	
                        	   836: ; 		ret
                        	   837: 
                        	   838: ;************************************************************************
                        	   839: ;************************************************************************
                        	   840: 
                        	   841: 
                        	   842: 
                        	   843: ;**######################################################################
                        	   844: ;**######################################################################
                        	   845: 	if DOALIGN
                        	   846: 		align 4
                        	   847: 	endif
                        	   848: 
                        	   849: 
                        	   850: HC376S_fileWrite::
                        	   851: 
00:047A ED5B0000        	   852: 		ld 		DE,(commLvl1) 				; actual file lenght
00:047E ED530000        	   853: 		ld 		(charLen),DE 				; save in heap
                        	   854: 
00:0482 2A0000          	   855: 		ld 		HL,(commAdr1) 				; set the target start address in HL
00:0485 EB              	   856: 		ex 		DE,HL						; DE = target start address in HL
00:0486 19              	   857: 		add		HL,DE
00:0487 220000          	   858: 		ld 		(commAdr2),HL 				; set the target end address
00:048A EB              	   859: 		ex 		DE,HL					; set the target start address in HL
                        	   860: 
00:048B CD0000          	   861: 		call 	writeSTRBelow_CRLF
00:048E 2057726974696E67	   862: 		db		" Writing to File !. ",0,0
00:0496 20746F2046696C65
00:049E 20212E20
00:04A2 00
00:04A3 00
00:04A4 118000          	   863: 		ld 		DE,$0080
00:04A7 ED530000        	   864: 		ld 		(packLen),DE
00:04AB D5              	   865: 		push 	DE
00:04AC CD8205          	   866: 		call 	delay500ms
00:04AF 76              	   867: 		halt
00:04B0 D1              	   868: 		pop 	DE
                        	   869: nextblockW:	
                        	   870: 		 
00:04B1 53              	   871: 		ld 		D,E					; only low byte used (E)
00:04B2 CD6004          	   872: 		call 	setByteWrite		; This tells the CH376S module how many bytes to write on the next step.
                        	   873: 									; In this example, 0x80 (D1) bytes will be written at a time. 
                        	   874: 									; Returns true (Z)if there are bytes to read, false (NZ)if there are no more bytes to read.
00:04B5 205B            	   875: 		jr 		NZ,endBlockWrite
                        	   876: 
00:04B7 CD6205          	   877: 		call 	beginUART
                        	   878: 
00:04BA 1E2D            	   879: 		ld 		E,$2D			;     //WR_REQ_DATA
00:04BC CD6D05          	   880: 		call 	outByte367S				; CMD_WR_USB_DATA0
                        	   881: 		
00:04BF CD7B05          	   882: 		call 	delay1s
00:04C2 CD5405          	   883: 		call 	waitForResponse		; // wait for an acknowledgement from the CH376S module
                        	   884: 				;	//WR_REQ_DATA results in byte# -> B
00:04C5 47              	   885: 		ld 		B,A
                        	   886: .loopD:
                        	   887: 		;***		B contains amount of loops   (packLen), HL points to data
                        	   888: .loop:
                        	   889: 
00:04C6 7E              	   890: 		ld 		A,(HL)
00:04C7 5F              	   891: 		ld 		E,A
00:04C8 23              	   892: 		inc 	HL
00:04C9 CD6D05          	   893: 		call 	outByte367S				;write char to buffer
00:04CC 10F8            	   894: 		djnz 	.loopD
                        	   895: 
00:04CE 220000          	   896: 		ld 		(sdWRpointer),HL		; restore file pointer for later
                        	   897: 
                        	   898: 		; call 	delay500ms
                        	   899: 		; call 	waitForResponse		; // wait for an acknowledgement from the CH376S module
                        	   900: 
                        	   901: 	; if (USB_TEXT_LABLES>13)
                        	   902: 	; 	call 	writeSTRBelow
                        	   903: 	; 	db		" Write code (normally FF and 14): ",0,0
                        	   904: 	; endif
                        	   905: ; 				; response in A&E
                        	   906: 
                        	   907: 					; code from block write(pack length)
                        	   908: 		; ld 		D,00
                        	   909: 		; call 	putDEtoScreen
                        	   910: 		; ld 		A,','
                        	   911: 		; call 	WriteChar
                        	   912: 
00:04D1 CD6205          	   913: 		call 	beginUART
                        	   914: 	
00:04D4 1E3D            	   915: 		ld 		E,$3D				; CMD_BYTE_WR_GO        
00:04D6 CD6D05          	   916: 		call 	outByte367S		
                        	   917: 
00:04D9 CD8205          	   918: 		call 	delay500ms
00:04DC CD5405          	   919: 		call 	waitForResponse		
                        	   920: 
                        	   921: 		; ld 		E,A 				; code from block write(pack length)
                        	   922: 		; ld 		D,00
                        	   923: 		; call 	putDEtoScreen
                        	   924: 		; call	CRLF
                        	   925: 
                        	   926: 		; ld 		DE,(sdWRpointer)				; code from block write(pack length)
                        	   927: 		; call 	putDEtoScreen
                        	   928: 		; call	CRLF
                        	   929: 
                        	   930: 
                        	   931: 		;****	Calculate length of next data chunk
00:04DF A7              	   932: 		and 	A						; reset carry
00:04E0 2A0000          	   933: 		ld 		HL,(sdWRpointer)		; restore file pointer for later
                        	   934: 		; 		commAdr2 - HL - packlen < 0  ? 
                        	   935: 	
00:04E3 ED5B0000        	   936: 		ld 		DE,(commAdr2)
00:04E7 EB              	   937: 		ex 		DE,HL
00:04E8 ED52            	   938: 		sbc 	HL,DE					; HL = commAdr2 - HL
00:04EA ED5B0000        	   939: 		ld 		DE,(packLen)				; DE = actl block size (packLen)
00:04EE ED52            	   940: 		sbc 	HL,DE					; HL = commAdr2 - HL - packlen
00:04F0 FAFB04          	   941: 		jp 		M,lastBlock				; lastblock < pack size ...
00:04F3 2A0000          	   942: 		ld 		HL,(sdWRpointer)		; restore file pointer for later
                        	   943: 
00:04F6 3EAA            	   944: 		ld  	a,$AA
                        	   945: 		
                        	   946: 		; call DumpRegisters
00:04F8 C3B104          	   947: 		jp 		nextblockW
                        	   948: 
                        	   949: lastBlock:
                        	   950: 		; ***	
00:04FB 19              	   951: 		add 	HL,DE 					; the last (reduced) block size -> DE [HL = commAdr2 - HL - packlen +packLen ]
00:04FC E5              	   952: 		push 	HL
00:04FD D1              	   953: 		pop 	DE						; the last (reduced) block size -> DE
00:04FE ED530000        	   954: 		ld 		(packLen),DE
00:0502 2A0000          	   955: 		ld 		HL,(sdWRpointer)		; restore file pointer for later
                        	   956: 
00:0505 3E00            	   957: 		ld 		A,00
                        	   958: 	; call DumpRegisters
                        	   959: 
00:0507 BA              	   960: 		cp 		D
                        	   961: 		; 		commAdr2 = HL  ?
00:0508 FA1205          	   962: 		jp 		M,endBlockWrite
00:050B C2B104          	   963: 		jp	 	NZ,nextblockW			; jump to nextblock if DE not zero
00:050E BB              	   964: 		cp 		E
00:050F C2B104          	   965: 		jp	 	NZ,nextblockW			; jump to nextblock if DE not zero
                        	   966: 
                        	   967: 
                        	   968: ; .W_timeout:
                        	   969: ; 	if (USB_TEXT_LABLES>14)
                        	   970: ; 		call 	immputstring
                        	   971: ; 		dc.b	">Timeout on Write File !.",CHAR_LF,CHAR_CR,0,0
                        	   972: ; 		even
                        	   973: ; 	endif
                        	   974: 
                        	   975: 
                        	   976: endBlockWrite: 	 				; setByteWrite returned false or continueRead returned false
                        	   977: 
                        	   978: 
                        	   979: 	if (USB_TEXT_LABLES>15)
                        	   980: 		call 	writeSTRBelow_CRLF
                        	   981: 		db		" No more DATA !.",0,0
                        	   982: 	endif
                        	   983: 
00:0512 C9              	   984: 		ret
                        	   985: 
                        	   986: ;************************************************************************
                        	   987: ;************************************************************************
                        	   988: 
                        	   989: 
                        	   990: 
                        	   991: 
                        	   992: ;**######################################################################
                        	   993: ;**######################################################################
                        	   994: 
                        	   995: 			; return true ->Z set;   return false with  NZ
                        	   996: HC376S_fileDelete:
                        	   997: 
00:0513 CD0000          	   998: 		call 	writeSTRBelow
00:0516 203E44656C657465	   999: 		db		" >Delete File : ",0,0
00:051E 2046696C65203A20
00:0526 00
00:0527 00
                        	  1000: 
00:0528 FD210000        	  1001: 		ld 		IY,commStr1				;move.l 	USB_filename_ptr,A0 
00:052C FD2B            	  1002: 		dec 	IY
00:052E CD0000          	  1003: 		call 	WriteLineCRNL
                        	  1004: 
                        	  1005: 
00:0531 CDAA01          	  1006: 		call 	HC376S_setFileName
                        	  1007: 
                        	  1008: 
00:0534 CD6205          	  1009: 		call 	beginUART
                        	  1010: 	
00:0537 1E35            	  1011: 		ld 		E,$35					; Delete File	
00:0539 CD6D05          	  1012: 		call 	outByte367S
                        	  1013: 
00:053C CD9E05          	  1014: 		call	delay100ms
00:053F CD5405          	  1015: 		call 	waitForResponse 		; Z is set if noresponse from 376S 
00:0542 CAC803          	  1016: 		jp 		Z,endtest				; branch on timeout
                        	  1017: 
                        	  1018: 				; get the actual data, in A&E
00:0545 FE14            	  1019: 		cp		USB_INT_SUCCESS 		; read the CH376S message. 
                        	  1020:  										; If equal to 0x1D, data is present, so return true. Will return 0x14 if no data is present.
                        	  1021: 
00:0547 C8              	  1022: 		ret 	Z					; return true ($14); Z set, continueRead return true
                        	  1023: 
                        	  1024: ; 		clr.w 	D0				; Z set
                        	  1025: ; 		rts						; return true; Z cleared -> continueRead return  NZ
                        	  1026: 
00:0548 C34502          	  1027: 		jp 		openNoFileName		; show no file found
                        	  1028: 
                        	  1029: ;************************************************************************
                        	  1030: ;************************************************************************
                        	  1031: 
                        	  1032: 		; return with no response  (Z); return with response -> NZ, result in A&E
                        	  1033: getResponseFromUSB:
00:054B DB03            	  1034: 		in 		A,(sio_bc)
00:054D CB47            	  1035: 		bit 	0,A 		 			;test rxrdy-B, bit 0
00:054F C8              	  1036: 		ret 	Z						; return (no chars available)  (Z)
                        	  1037: 						; 
                        	  1038: 		; ***	No timeout - read data.
                        	  1039: 
00:0550 DB01            	  1040: 		in  	A,(sio_bd)		  		;read char from SIO B
00:0552 5F              	  1041: 		ld 		E,A
                        	  1042: noresp:
00:0553 C9              	  1043: 		ret						; return with response -> NZ
                        	  1044: ; 
                        	  1045: delay_D0_ms:	
                        	  1046: ; 		***		time in msecs in D0
                        	  1047: 
                        	  1048: ; 		call 	SetHC376Timer
                        	  1049: 
                        	  1050: 
                        	  1051: ; 		call 	resetTimer68230
                        	  1052: ; 		call 	startTimer68230
                        	  1053: ; .timetest:
                        	  1054: ; 		call 	testTimeout				; test timer 
                        	  1055: ; 		beq 	.timetest
                        	  1056: 
                        	  1057: ; 		rts
                        	  1058: 
                        	  1059:    		;wait for a response from the CH376S. If CH376S responds, it will be true. If it times out, it will be false. 
                        	  1060: 		;Response in A&E, use CTC timeout, Z -> no response, NZ -> 376S has responded
                        	  1061: waitForResponse:  
                        	  1062: 
00:0554 FB              	  1063: 		ei
00:0555 76              	  1064: 		halt    
                        	  1065: 
00:0556 3A0000          	  1066: 		ld 		A,(CTCdelayFlag)
00:0559 FEEE            	  1067: 		cp 		CTC_TIMEOUT 						; if A=EE, Z is set, timeout (set by CTC interrupt)
00:055B C8              	  1068: 		ret 	Z							; return with Z -> timeout set
                        	  1069: 				; call 	getResponseFromUSB
                        	  1070: 				; jr 		Z,.loop
                        	  1071: 		; *** 	SIO B interrupt place data in E				; 
                        	  1072: 		; ***	No timeout - read data.
                        	  1073: 
                        	  1074: 
00:055C CD0000          	  1075: 		call	CTC1_INT_OFF			; stop CTC sending timeout's  (A=0) ;LEV_Sect11_IO_Interrupts.s
00:055F 3C              	  1076: 		inc 	A						; => NZ
00:0560 7B              	  1077: 		ld 		A,E						; no flags set.
00:0561 C9              	  1078: 		ret								; NZ set, 376S has responded
                        	  1079: 
                        	  1080: 
                        	  1081: 		; ***	send UART init code $57,$AB
                        	  1082: beginUART:
00:0562 1E57            	  1083: 		ld 	    E,$57
00:0564 CD6D05          	  1084: 		call 	outByte367S
                        	  1085: 
00:0567 1EAB            	  1086: 		ld 		E,$AB
00:0569 CD6D05          	  1087: 		call 	outByte367S
00:056C C9              	  1088: 		ret
                        	  1089: 		;***		Data in E, send byte to HC376S
                        	  1090: outByte367S:
                        	  1091: .loop: 
00:056D 97              	  1092:    		sub		a				;clear a, write into WR0: select RR0
00:056E 3C              	  1093: 		inc		a				;select RR1
00:056F D303            	  1094: 		out		(sio_bc),A
00:0571 DB03            	  1095:         in		A,(sio_bc)	    ;read TRx , set when all char are sent 'all sent' 
00:0573 CB47            	  1096:         bit		0,A
00:0575 28F6            	  1097:         jr      z,.loop
                        	  1098:     	
00:0577 7B              	  1099:         ld      A,E
00:0578 D301            	  1100:         out     (sio_bd),A      ; send actl. byte
                        	  1101: 
00:057A C9              	  1102: 		ret
                        	  1103: 
                        	  1104: 		GLOBAL		delay2s,delay1s,delay500ms,delay200ms,delay100ms,delay50ms,delay20ms,delay10ms
                        	  1105: 
                        	  1106: delay1s:	
00:057B 11FC9B          	  1107: 		ld 		DE,$9BFC		; 8MHz: $----  10MHz:  9BFC, Prescaler
00:057E 3E20            	  1108: 		ld 		A,_Prescaler
00:0580 1862            	  1109: 		jr 		CTC_Delay
                        	  1110: delay500ms:	
00:0582 11D95A          	  1111: 		ld 		DE,$5AD9		; 8MHz: $----  10MHz:  5AD9, Prescaler
00:0585 3E20            	  1112: 		ld 		A,_Prescaler
00:0587 185B            	  1113: 		jr 		CTC_Delay
                        	  1114: delay350ms:	
00:0589 11D93F          	  1115: 		ld 		DE,$3FD9		; 8MHz: $----  10MHz:  3FD9, Prescaler
00:058C 3E20            	  1116: 		ld 		A,_Prescaler
00:058E 1854            	  1117: 		jr 		CTC_Delay
                        	  1118: delay250ms:	
00:0590 11D92D          	  1119: 		ld 		DE,$2DD9		; 8MHz: $----  10MHz:  2DD9, Prescaler
00:0593 3E20            	  1120: 		ld 		A,_Prescaler
00:0595 184D            	  1121: 		jr 		CTC_Delay
                        	  1122: delay200ms:
00:0597 11BA2A          	  1123: 		ld 		DE,$2ABA		; 8MHz: $----  10MHz:  2ABA, Prescaler
00:059A 3E20            	  1124: 		ld 		A,_Prescaler
00:059C 1846            	  1125: 		jr 		CTC_Delay
                        	  1126: delay100ms:
00:059E 11FAFA          	  1127: 		ld 		DE,$FAFA		; 8MHz: $----  10MHz:  FAFA, Prescaler
00:05A1 3E00            	  1128: 		ld 		A,0
00:05A3 183F            	  1129: 		jr 		CTC_Delay
                        	  1130: delay50ms:
00:05A5 11FA7D          	  1131: 		ld 		DE,$7DFA		; 8MHz: $----  10MHz:  7DFA, Prescaler
00:05A8 3E00            	  1132: 		ld 		A,0
00:05AA 1838            	  1133: 		jr 		CTC_Delay
                        	  1134: delay20ms:
00:05AC 11FA32          	  1135: 		ld 		DE,$32FA		; 8MHz: $----  10MHz:  32FA, Prescaler
00:05AF 3E00            	  1136: 		ld 		A,0
00:05B1 1831            	  1137: 		jr 		CTC_Delay
                        	  1138: delay10ms:
00:05B3 11FA19          	  1139: 		ld 		DE,$19FA		; 8MHz: $----  10MHz:  19FA, Prescaler
00:05B6 3E00            	  1140: 		ld 		A,00
00:05B8 182A            	  1141: 		jr 		CTC_Delay
                        	  1142: delay5ms:
00:05BA 117D19          	  1143: 		ld 		DE,$197D		; 8MHz: $----  10MHz:  197D, Prescaler
00:05BD 3E00            	  1144: 		ld 		A,00
00:05BF 1823            	  1145: 		jr 		CTC_Delay
                        	  1146: delay2ms:
00:05C1 117D0A          	  1147: 		ld 		DE,$0A7D		; 8MHz: $----  10MHz:  0A7D, Prescaler
00:05C4 3E00            	  1148: 		ld 		A,00
00:05C6 181C            	  1149: 		jr 		CTC_Delay
                        	  1150: delay1ms:
00:05C8 111919          	  1151: 		ld 		DE,$1919		; 8MHz: $----  10MHz:  1919, Prescaler
00:05CB 3E00            	  1152: 		ld 		A,00
00:05CD 1815            	  1153: 		jr 		CTC_Delay
                        	  1154: delay500us:
00:05CF 112708          	  1155: 		ld 		DE,$0827		; 8MHz: $----  10MHz:  0827, Prescaler
00:05D2 3E00            	  1156: 		ld 		A,00
00:05D4 180E            	  1157: 		jr 		CTC_Delay
                        	  1158: delay200us:
00:05D6 111905          	  1159: 		ld 		DE,$0519		; 8MHz: $----  10MHz:  0519, Prescaler
00:05D9 3E00            	  1160: 		ld 		A,00
00:05DB 1807            	  1161: 		jr 		CTC_Delay
                        	  1162: delay100us:
00:05DD 118C02          	  1163: 		ld 		DE,$028C		; 8MHz: $----  10MHz:  0519, Prescaler
00:05E0 3E00            	  1164: 		ld 		A,00
00:05E2 1800            	  1165: 		jr 		CTC_Delay
                        	  1166: CTC_Delay:
                        	  1167: 		;init CH 0 and 1 as interrupt on timeout
                        	  1168: 		; A is set or cleared with _Prescaler
                        	  1169: 		; value in DE
00:05E4 F3              	  1170: 		di
00:05E5 F617            	  1171: 		or 	 	_Rising|_Timer|_TC_Follow|_Reset|_CW		; timer 14390 Hz
00:05E7 D300            	  1172: 		out		(CH0),A 		; CH0 is on hold now
00:05E9 7A              	  1173: 		ld		A,D				; time constant (prescaler; 126; 93; 6MHz -> 1 sec peroid) 232/101; 
                        	  1174: 								; time constant (prescaler; 181; 79; 14390,625 khz -> 2, sec peroid;  
00:05EA D300            	  1175: 		out		(CH0),A			; and loaded into channel 0
                        	  1176: 		
00:05EC 3ED7            	  1177: 		ld		A,_INT_EN|_Counter|_Rising|_TC_Follow|_Reset|_CW	
00:05EE D301            	  1178: 		out		(CH1),A			; CH1 counter
00:05F0 7B              	  1179: 		ld		A,E			; time constant 66 defined
00:05F1 D301            	  1180: 		out		(CH1),A			; and loaded into channel 2
00:05F3 AF              	  1181: 		xor 	A 				; clear A
00:05F4 320000          	  1182: 		ld 		(CTCdelayFlag),A ; reset timeout flag
00:05F7 FB              	  1183: 		ei
                        	  1184: 
00:05F8 C9              	  1185: 		ret
                        	  1186: 
                        	  1187: ; reset timeout flag
                        	  1188: resDelayFlag:
00:05F9 3E00            	  1189: 		ld 		A,00
00:05FB 320000          	  1190: 		ld 		(CTCdelayFlag),A ; reset timeout flag
00:05FE C9              	  1191: 		ret
                        	  1192: 
                        	  1193: 
                        	  1194: CTC_delay_INT_handler:
                        	  1195: 
00:05FF 3E52            	  1196: 		ld		A,_Counter|_Rising|_Reset	
00:0601 D301            	  1197: 		out		(CH1),A					; reset and turn off interrupt CH1
00:0603 3EEE            	  1198: 		ld		A,CTC_TIMEOUT 			; set timeout flag
00:0605 320000          	  1199: 		ld 		(CTCdelayFlag),A 		; reset timeout flag
                        	  1200: 
                        	  1201: 	ifd 	GPIODEBUG
                        	  1202: 	ld a,8
                        	  1203: 	out (gpio_out),A
                        	  1204: 	ld a,0
                        	  1205: 	out (gpio_out),A
                        	  1206: 	endif
                        	  1207: 		
00:0608 7B              	  1208: 		ld 	a,e
00:0609 FB              	  1209: 		ei
00:060A ED4D            	  1210: 		reti
                        	  1211: 
                        	  1212: 
                        	  1213: ; PrintD0ToScreenHEX:
                        	  1214: ; 		***		print D0 to sceen on one row
                        	  1215: ; 		move.w	#8,-(sp)
                        	  1216: ; 		pea		Cstr2
                        	  1217: ; 		call 	bintohexstr		; result in Cstr2
                        	  1218: ; 		lea 	Cstr2,A0 
                        	  1219: ; 		call 	putstring_cr
                        	  1220: ; 		rts
                        	  1221: 
                        	  1222: ; PrintD0ToScreenDEC:
                        	  1223: ; 		***		print D0 to sceen on one row
                        	  1224: ; 		pea		Cstr2
                        	  1225: ; 		call 	bintodecstr		; result in Cstr2
                        	  1226: ; 		lea 	Cstr2,A0 
                        	  1227: ; 		call 	putstring_cr
                        	  1228: ; 		rts
                        	  1229: 
                        	  1230: 
                        	  1231: 
                        	  1232: ;**###############################################################
                        	  1233: ;**################################################################
                        	  1234: 
                        	  1235: 		xdef 	blockstart_USB,blockend_USB
                        	  1236: 
                        	  1237: blockstart_USB:
                        	  1238: 	;***		len = BC4 ??
                        	  1239: 	; dw	$0000,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1240: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1241: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1242: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1243: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1244: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1245: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1246: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1247: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1248: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1249: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1250: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1251: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1252: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1253: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1254: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1255: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1256: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1257: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1258: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1259: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1260: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1261: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1262: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1263: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1264: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1265: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1266: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1267: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1268: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1269: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1270: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1271: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1272: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1273: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1274: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1275: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1276: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1277: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1278: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1279: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1280: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1281: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1282: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1283: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1284: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1285: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1286: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1287: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1288: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1289: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1290: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1291: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1292: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1293: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1294: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1295: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1296: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1297: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1298: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1299: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1300: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1301: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1302: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1303: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1304: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1305: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1306: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1307: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1308: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1309: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1310: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1311: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1312: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1313: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1314: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1315: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1316: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1317: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1318: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1319: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1320: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1321: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1322: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1323: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1324: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1325: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1326: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1327: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1328: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1329: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1330: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF
                        	  1331: 	; dw	$12345678,$1111,$2222,$3333,$4444,$5555,$6666,$7777
                        	  1332: 	; dw	$8888,$9999,$AAAA,$BBBB,$CCCC,$DDDD,$EEEE,$FFFF   ; 256 bytes
                        	  1333: 	; dw	$0018,$11E0,$11E1,$11E2,$11E3,$11E4,$11E5,$11E6
                        	  1334: 	; dw	$11E7,$11E8,$11E9,$11EA,$11EB,$11EC,$11ED,$11EE
                        	  1335: 	; dw	$11E0,$11E1,$11E2,$11E3,$11E4,$11E5,$11E6,$11E7
                        	  1336: blockend_USB:
                        	  1337: 
                        	  1338: 
                        	  1339: 
                        	  1340: 	end
                        	  1341: 
                        	  1342: 
                        	  1343: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CMD_RET_SUCCESS                  E:0051
CRLF                            external
CTC1_INT_OFF                    external
CTC_CH1_I_Vector                 E:F412
CTC_Delay                       00:05E4
CTC_TIMEOUT                      E:00EE
CTC_delay_INT_handler           00:05FF EXP
CTCdelayFlag                    external
DOALIGN                          E:0000
ERR_MISS_FILE                    E:0042
HC376S_CheckConnection          00:0000 EXP
HC376S_ResetAll                 00:0050 EXP
HC376S_USBdiskMount             00:015C EXP
HC376S_diskConnectionStatus     00:0120 EXP
HC376S_fileClose                00:02DE EXP
HC376S_fileCreate               00:0319 EXP
HC376S_fileDelete               00:0513 EXP
HC376S_fileOpen                 00:01C7 EXP
HC376S_fileRead                 00:041B EXP
HC376S_fileWrite                00:047A EXP
HC376S_getFileSize              00:0380 EXP
HC376S_setFileName              00:01AA EXP
HC376S_setSDMode                00:00E5 EXP
HC376S_setUSBMode               00:0064 EXP
NoSDpres                        00:00AA
NoUSBpres                       00:008C
PrintD0ToScreen                 external EXP
S1x                             external
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Vec                      E:F400
SetHC376Timer                   external EXP
T_BUFFER                        external
TempVar5                        external
USB_INT_CONNECT                  E:0015
USB_INT_DISK_READ                E:001D
USB_INT_DISK_WRITE               E:001E
USB_INT_SUCCESS                  E:0014
USB_TEXT_LABLES                  E:0001
WriteLine                       external
WriteLineCRNL                   external
_CW                              E:0001
_Counter                         E:0040
_INT_EN                          E:0080
_Prescaler                       E:0020
_Reset                           E:0002
_Rising                          E:0010
_TC_Follow                       E:0004
_Timer                           E:0000
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
beginUART                       00:0562
blockend_USB                    00:060C EXP
blockstart_USB                  00:060C EXP
charLen                         external
commAdr1                        external
commAdr2                        external
commLvl1                        external
commStr1                        external
connection_fail                 00:0024
connection_pass                 00:004E
continueRead                    00:0409
delay100ms                      00:059E EXP
delay100us                      00:05DD EXP
delay10ms                       00:05B3 EXP
delay1ms                        00:05C8 EXP
delay1s                         00:057B EXP
delay200ms                      00:0597 EXP
delay200us                      00:05D6
delay20ms                       00:05AC EXP
delay250ms                      00:0590
delay2ms                        00:05C1
delay2s                         external EXP
delay350ms                      00:0589
delay500ms                      00:0582 EXP
delay500us                      00:05CF
delay50ms                       00:05A5 EXP
delay5ms                        00:05BA EXP
delay_D0_ms                     00:0554 EXP
doEnumeration                   00:0263
endBlockRead                    00:045E
endBlockWrite                   00:0512
endtest                         00:03C8
getResponseFromUSB              00:054B EXP
gpioB                           external
gpio_in                         external
gpio_out                        external
lastBlock                       00:04FB
nextblockW                      00:04B1
noresp                          00:0553
norespSD                        00:0103
nxtFileOpen                     00:01F6
openNoFileName                  00:0245
outByte367S                     00:056D
packLen                         external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
putDEtoScreen                   external
resDelayFlag                    00:05F9
retNZ                           00:00E2
sdWRpointer                     external
setByteWrite                    00:0460
setBytesRead                    00:03EE
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
someUSBerror                    00:00CC
waitForFinishedPrintout         external
waitForResponse                 00:0554
writeSTRBelow                   external
writeSTRBelow_CRLF              external

Symbols by value:
0000 DOALIGN
0000 HC376S_CheckConnection
0000 _Timer
0001 USB_TEXT_LABLES
0001 _CW
0002 _Reset
0004 _TC_Follow
0010 _Rising
0014 USB_INT_SUCCESS
0015 USB_INT_CONNECT
001D USB_INT_DISK_READ
001E USB_INT_DISK_WRITE
0020 _Prescaler
0024 connection_fail
0040 _Counter
0042 ERR_MISS_FILE
004E connection_pass
0050 HC376S_ResetAll
0051 CMD_RET_SUCCESS
0064 HC376S_setUSBMode
0080 _INT_EN
008C NoUSBpres
00AA NoSDpres
00CC someUSBerror
00E2 retNZ
00E5 HC376S_setSDMode
00EE CTC_TIMEOUT
0103 norespSD
0120 HC376S_diskConnectionStatus
015C HC376S_USBdiskMount
01AA HC376S_setFileName
01C7 HC376S_fileOpen
01F6 nxtFileOpen
0245 openNoFileName
0263 doEnumeration
02DE HC376S_fileClose
0319 HC376S_fileCreate
0380 HC376S_getFileSize
03C8 endtest
03EE setBytesRead
0409 continueRead
041B HC376S_fileRead
045E endBlockRead
0460 setByteWrite
047A HC376S_fileWrite
04B1 nextblockW
04FB lastBlock
0512 endBlockWrite
0513 HC376S_fileDelete
054B getResponseFromUSB
0553 noresp
0554 delay_D0_ms
0554 waitForResponse
0562 beginUART
056D outByte367S
057B delay1s
0582 delay500ms
0589 delay350ms
0590 delay250ms
0597 delay200ms
059E delay100ms
05A5 delay50ms
05AC delay20ms
05B3 delay10ms
05BA delay5ms
05C1 delay2ms
05C8 delay1ms
05CF delay500us
05D6 delay200us
05DD delay100us
05E4 CTC_Delay
05F9 resDelayFlag
05FF CTC_delay_INT_handler
060C blockend_USB
060C blockstart_USB
F400 SIO_Int_Vec
F412 CTC_CH1_I_Vector
