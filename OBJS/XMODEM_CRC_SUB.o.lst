Sections:
00: "Xmodems" (0-22D)


Source: "stdin"
                        	     1: ;XMODEM_SUB.s
                        	     2: 
                        	     3: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     4:  
                        	     5: 		xdef 	RAM_Start,SetupXMODEM_TXandRX,purgeRXA,purgeRXB,TX_EMP,TX_NAK,TX_ACK,SIO_A_DI,SIO_A_EI,SIO_A_RESET
                        	     6: 		xdef 	SIO_A_RTS_OFF,SIO_A_RTS_ON,SIO_A_TXRX_INToff,SIO_A_TXon,SIO_A_RXon,SIO_A_TXRX_INTon,TX_C,TX_X
                        	     7: 		xdef 	doImportXMODEM,CRC16
                        	     8: ;********************************************************		
                        	     9: ;		Routines in order to read data via XMODEM on SIO_0 chA
                        	    10: ;********************************************************		
                        	    11: 
                        	    12: 		section Xmodems
                        	    13: RAM_Start:
                        	    14: 		; jp 		MONITOR_Start
                        	    15: 
                        	    16: ;********************************************************************************************
                        	    17: ;********************************************************************************************
                        	    18: ;********************************************************************************************
                        	    19: 
                        	    20: 
                        	    21: RX_CR:
                        	    22: 		;do something on carriage return reception here
00:0000 C30600          	    23: 		jp		EO_CH_AV
                        	    24: 
                        	    25: RX_BS:
                        	    26: 		;do something on backspace reception here
00:0003 C30600          	    27: 		jp		EO_CH_AV
                        	    28: EO_CH_AV:
00:0006 FB              	    29: 		ei						;see comments below
00:0007 CD0000          	    30: 		call	SIO_A_RTS_ON		;see comments below
00:000A F1              	    31: 		pop		AF				;restore AF
00:000B ED4D            	    32: 		Reti
                        	    33: 	
                        	    34: 
                        	    35: SPEC_RX_CONDITON:
00:000D C30000          	    36: 		jp		0000h
                        	    37: 
                        	    38: ;**************************************************************************
                        	    39: ;**				SetupXMODEM_TX and RX:									**
                        	    40: ;**************************************************************************
                        	    41: 
                        	    42: 
                        	    43: 
                        	    44: doImportXMODEM: 
00:0010 CD0000          	    45: 		call 	writeSTRBelow
00:0013 00              	    46: 		DB 		0,"Wait for XMODEM start... ",CR,LF,00
00:0014 5761697420666F72
00:001C 20584D4F44454D20
00:0024 73746172742E2E2E
00:002C 20
00:002D 0D
00:002E 0A
00:002F 00
00:0030 AF              	    47: 		xor 	A
00:0031 320000          	    48: 		ld 		(TempVar1),A				; reset badblock counter
                        	    49: 		;------------INIT CTC (2 sec timing for 'C'/NAK process----------------
                        	    50: 		;init CH 0 and 1
00:0034 3E57            	    51: 		ld 	 	A,_Counter|_Rising|_TC_Follow|_Reset|_CW
00:0036 D300            	    52: 		out		(CH0),A 		; CH0 is on hold now
00:0038 3E42            	    53: 		ld		A,$42			; time constant (prescaler; $42;$DA; 14390,625 khz -> 2, sec peroid;  
00:003A D300            	    54: 		out		(CH0),A			; and loaded into channel 0
                        	    55: 		
00:003C 3ED7            	    56: 		ld		A,_INT_EN|_Counter|_Rising|_TC_Follow|_Reset|_CW	
00:003E D301            	    57: 		out		(CH1),A			; CH1 counter
00:0040 3EDA            	    58: 		ld		A,$DA			; time constant 
00:0042 D301            	    59: 		out		(CH1),A			; and loaded into channel 2
                        	    60: 
                        	    61: 		;------------INIT SIO----------------------------------------
                        	    62: 
00:0044 21AF00          	    63: 		ld		HL,receiveBlockIn       	; ON INTERRUPT SIO_0 channel A
00:0047 220CF4          	    64: 		ld		(SIO_Int_Read_Vec),HL		;STORE READ VECTOR
                        	    65: 
00:004A 3E10            	    66: 		ld 		A,_Reset_STAT_INT|_Reset_STAT_INT	
00:004C 3E21            	    67: 		ld		A,_EN_INT_Nx_Char|WR1			;write into WR0 cmd4 and select WR1 ( enable INT on next char)
00:004E D302            	    68: 		out		(SIO_A_C),A
00:0050 3E08            	    69: 		ld		A,_Rx_INT_First_Char		;wait active, interrupt on first RX character
                        	    70: 		; ld		a,_WAIT_READY_EN|_WAIT_READY_R_T|_Rx_INT_First_Char		;wait active, interrupt on first RX character
00:0052 D302            	    71: 		out		(SIO_A_C),A		;buffer overrun is a spec RX condition
                        	    72: 
00:0054 CD0000          	    73: 		call  	purgeRXA
                        	    74: 
00:0057 2110B0          	    75: 		ld 		HL,$B010
00:005A 0E01            	    76: 		ld 		C,1					; block number
                        	    77: 
                        	    78: 
                        	    79: 
                        	    80: ;*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
                        	    81: ;*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
                        	    82: 
                        	    83: nextC:		
00:005C FB              	    84: 		ei
                        	    85: 
                        	    86: nextBlock:
00:005D 3E21            	    87: 		ld		A,_EN_INT_Nx_Char|WR1			;write into WR0 cmd4 and select WR1 ( enable INT on next char)
00:005F D302            	    88: 		out		(SIO_A_C),A
00:0061 3E08            	    89: 		ld		A,_Rx_INT_First_Char		;wait active, interrupt on first RX character
                        	    90: 		; ld		a,_WAIT_READY_EN|_WAIT_READY_R_T|_Rx_INT_First_Char		;wait active, interrupt on first RX character
00:0063 D302            	    91: 		out		(SIO_A_C),A		;buffer overrun is a spec RX condition
00:0065 FB              	    92: 		ei
                        	    93: 
                        	    94: 
00:0066 CD0000          	    95: 		call 	SIO_A_RTS_ON
                        	    96: 
00:0069 76              	    97: 		halt						;await first rx char
                        	    98: 
00:006A CD0000          	    99: 		call 	SIO_A_RTS_OFF
                        	   100: 
                        	   101: 		; ***	wait function inactive
00:006D 3E01            	   102: 		ld		a,WR1			;write into WR0: select WR1
00:006F D302            	   103: 		out		(SIO_A_C),A
00:0071 3E28            	   104: 		ld		a,_WAIT_READY_R_T|_Rx_INT_First_Char		;wait function inactive
00:0073 D302            	   105: 		out		(SIO_A_C),A
                        	   106: 
                        	   107: 		;check return code of block reception (e holds return code)
00:0075 7B              	   108: 		ld 		A,E
00:0076 D302            	   109: 		out 	(portB_Data),A
00:0078 3200B0          	   110: 		ld 		($B000),A
00:007B FE0B            	   111: 		cp		CTCtimeout					; timeout error ; no file transfer started
00:007D CA6701          	   112: 		jp		Z,timeOutErr		
                        	   113: 
00:0080 FE0A            	   114: 		cp 		CTCpulse 					; ret from CTC
00:0082 28D8            	   115: 		jr 		Z,nextC 					; one more 'C' -> goto .nextC
                        	   116: 
00:0084 FE00            	   117: 		cp		NUL							;block finished, no error
00:0086 CAA500          	   118: 		jp		Z,blockFinished
                        	   119: 
00:0089 FE02            	   120: 		cp		EOT_FOUND					;eot found (end of transmission)
00:008B CA4001          	   121: 		jp		Z,exitRecBlock
                        	   122: 
00:008E FE08            	   123: 		cp		_err01_						;Byte 1 not recognized (08)
00:0090 CA8E01          	   124: 		jp		Z,blockErrors1_3
                        	   125: 
00:0093 FE09            	   126: 		cp		_err02_						;wrong block number (09)
00:0095 CA8E01          	   127: 		jp		Z,blockErrors1_3
                        	   128: 
00:0098 FE0C            	   129: 		cp		_err03_						;wrong complement block number  (0C)
00:009A CA8E01          	   130: 		jp		Z,blockErrors1_3
                        	   131: 
00:009D FE0D            	   132: 		cp		_err04_						;chk sum error  (0D)
00:009F CAF001          	   133: 		jp		Z,checkSumErr
                        	   134: 
00:00A2 C38E01          	   135: 		jp		blockErrors1_3
                        	   136: 		
                        	   137: 
                        	   138: blockFinished:
00:00A5 CD0000          	   139: 		call	TX_ACK					;when no error
00:00A8 0C              	   140: 		inc		C						;prepare next block to receive
00:00A9 97              	   141: 		sub		A
00:00AA 320000          	   142: 		ld		(TempVar2),A			;clear bad block counter
00:00AD 18AD            	   143: 		jr 		nextC
                        	   144: 
                        	   145: ;*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
                        	   146: ;*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
                        	   147: 
                        	   148: 
                        	   149: receiveBlockIn:
                        	   150: 
                        	   151: 		; CH1 counter not send any interrupts
00:00AF CD0000          	   152: 		call 	CTC1_INT_OFF			; CH1 counter not send any interrupts
                        	   153: 
00:00B2 3E01            	   154: 		ld		A,WR1								;write into WR0 cmd4 and select WR1 
00:00B4 D302            	   155: 		out		(SIO_A_C),A
00:00B6 3EA0            	   156: 		ld		a,_WAIT_READY_EN|_WAIT_READY_R_T	;wait active, 
00:00B8 D302            	   157: 		out		(SIO_A_C),A						;buffer overrun is a spec RX condition
                        	   158: 		; ld		A,_EN_INT_Nx_Char|WR1			;write into WR0 cmd4 and select WR1 ( enable INT on next char)
                        	   159: 		; out		(SIO_A_C),A
                        	   160: 		; ; ld		A,_Rx_INT_First_Char			;wait active, interrupt on first RX character
                        	   161: 		; ld		a,_WAIT_READY_EN|_WAIT_READY_R_T|_Rx_INT_First_Char		;wait active, interrupt on first RX character
                        	   162: 		; out		(SIO_A_C),A					;buffer overrun is a spec RX condition
                        	   163: 
00:00BA 220000          	   164: 		ld 		(XBAddr),HL						; save actual block start address 
                        	   165: 
00:00BD DB00            	   166: 		in		A,(SIO_A_D)			;read RX byte into A
00:00BF 3208B0          	   167: 		ld 		($B008),A
                        	   168: checkByte01:
00:00C2 FE01            	   169: 		cp		SOH					;check for SOH
00:00C4 CAE000          	   170: 		jp		z,checkBlockNum
00:00C7 FE04            	   171: 		cp		EOT					;check for EOT
00:00C9 C2D000          	   172: 		jp		nz,Er01_
00:00CC 1E02            	   173: 		ld		e,EOT_FOUND			;eot found (end of transmission)
00:00CE ED4D            	   174: 		reti
                        	   175: 		
                        	   176: 		
                        	   177: 		; jr		.nextC
                        	   178: 
                        	   179: 		; jr		.nextC
                        	   180: 
                        	   181: 
                        	   182: Er01_:	; Byte 1 not recognized
00:00D0 1E08            	   183: 		ld		E,_err01_
00:00D2 ED4D            	   184: 		RETI
                        	   185: 
                        	   186: Er02_:	; wrong block number
00:00D4 1E09            	   187: 		ld		E,_err02_
00:00D6 ED4D            	   188: 		RETI
                        	   189: 
                        	   190: Er03_:	; wrong complement block number
00:00D8 1E0C            	   191: 		ld		E,_err03_
00:00DA ED4D            	   192: 		RETI
                        	   193: 
                        	   194: Er04_:
00:00DC 1E0D            	   195: 		ld		E,_err04_
00:00DE ED4D            	   196: 		RETI
                        	   197: 
                        	   198: 		;check block number
                        	   199: checkBlockNum:
00:00E0 DB00            	   200: 		in		A,(SIO_A_D)		;read RX byte into A	
00:00E2 3209B0          	   201: 		ld 		($B009),A
00:00E5 B9              	   202: 		cp		C					;check for match of block nr
00:00E6 C2D400          	   203: 		jp		nz,Er02_			; wrong block number (09)
                        	   204: 
                        	   205: 		;get complement of block number
00:00E9 79              	   206: 		ld		A,C					;copy block nr to expect into A
00:00EA 2F              	   207: 		CPL							;and cpl A	
00:00EB 5F              	   208: 		ld		E,A					;E holds cpl of block nr to expect
                        	   209: 
                        	   210: checkComplBlockNum:
00:00EC DB00            	   211: 		in		A,(SIO_A_D)		;read RX byte into A
00:00EE 320AB0          	   212: 		ld 		($B00A),A
00:00F1 BB              	   213: 		cp		E					;check for cpl of block nr
00:00F2 C2D800          	   214: 		jp		nz,Er03_			; wrong complement block number
                        	   215: 
                        	   216: 		;get data block
00:00F5 1600            	   217: 		ld		D,0h				;start value of checksum
00:00F7 0680            	   218: 		ld		B,80h				;defines block size 128byte
                        	   219: 
                        	   220: getBlockData:
00:00F9 DB00            	   221: 		in		A,(SIO_A_D)		;read RX byte into A
00:00FB 77              	   222: 		ld		(HL),A				;update
00:00FC 82              	   223: 		add		A,D
00:00FD 57              	   224: 		ld		D,A					;checksum in D
00:00FE 23              	   225: 		inc		HL					;dest address +1
00:00FF 78              	   226: 		ld 		A,B
00:0100 3202B0          	   227: 		ld 		($B002),A
00:0103 10F4            	   228: 		djnz	getBlockData		;loop until block finished
                        	   229: 
                        	   230: 
                        	   231: checkBlockChecksum:
                        	   232: 
00:0105 DB00            	   233: 		in		A,(SIO_A_D)		;read RX hi byte into A
00:0107 57              	   234: 		ld 		D,A
00:0108 DB00            	   235: 		in		A,(SIO_A_D)		;read RX low byte into A
00:010A 5F              	   236: 		ld 		E,A					; DE = checksum in file
00:010B ED530000        	   237: 		ld 		(XMChkSum),DE
                        	   238: 		; ***	Calculate CRC16
                        	   239: 
00:010F C5              	   240: 		push 	BC
00:0110 E5              	   241: 		push 	HL
00:0111 2A0000          	   242: 		ld 		HL,(XBAddr)			; get the block start address
00:0114 018000          	   243: 		ld 		BC,$80
                        	   244: 
00:0117 CD0902          	   245: 		call	CRC16				; result CRC in DE
00:011A ED53ACF1        	   246: 		ld 		($F1AC),DE
00:011E 2A0000          	   247: 		ld 		HL,(XMChkSum)		; get the file checksum in HL
00:0121 B7              	   248: 		or 		A 					; clear carry
00:0122 ED52            	   249: 		sbc 	HL,DE				; calc the differnce
                        	   250: 		; ***	if checksum OK the Z is set
00:0124 E1              	   251: 		pop 	HL					
00:0125 C1              	   252: 		pop  	BC					; restore  HL and BC
                        	   253: 
                        	   254: 
00:0126 2804            	   255: 		jr		z,retBlockComplete
00:0128 1E0D            	   256: 		ld		e,_err04_
00:012A ED4D            	   257: 		reti						;return with checksum error
                        	   258: retBlockComplete: 
00:012C 1E00            	   259: 		ld		E,0h
00:012E ED4D            	   260: 		reti						;return when block received completely
                        	   261: 
                        	   262: restoreSIO_0IO:
00:0130 F3              	   263: 		di
00:0131 3E53            	   264: 		ld		A,_Counter|_Rising|_Reset|_CW	
00:0133 D301            	   265: 		out		(CH1),A				; CH1 counter - disable interrupt
                        	   266: 
00:0135 CD0000          	   267: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   268: 
00:0138 CD0000          	   269: 		call 	SIO_A_TXRX_INTon
00:013B CD0000          	   270: 		call 	SIO_A_RTS_ON
00:013E FB              	   271: 		ei
00:013F C9              	   272: 		ret
                        	   273: 
                        	   274: exitRecBlock:
                        	   275: 		; ***	File transfer OK
00:0140 CD0000          	   276: 		call 	TX_ACK
00:0143 CD3001          	   277: 		call 	restoreSIO_0IO 			; get normal keyboard/screen function
00:0146 CD0000          	   278: 		call 	writeSTRBelow_CRLF
00:0149 000D0A          	   279: 		defb    "\0\r\n"
00:014C 584D4F44454D2066	   280: 		defb	"XMODEM file transfer OK !",00
00:0154 696C65207472616E
00:015C 73666572204F4B20
00:0164 21
00:0165 00
00:0166 C9              	   281: 		ret
                        	   282: 
                        	   283: 
                        	   284: 		
                        	   285: timeOutErr:
00:0167 CD3001          	   286: 		call 	restoreSIO_0IO 			; get normal keyboard/screen function
00:016A CD0000          	   287: 		call 	writeSTRBelow_CRLF
00:016D 000D0A          	   288: 		defb    "\0\r\n"
00:0170 412074696D6F7574	   289: 		defb	"A timout on XMODEM occured !",00
00:0178 206F6E20584D4F44
00:0180 454D206F63637572
00:0188 65642021
00:018C 00
00:018D C9              	   290: 		ret
                        	   291: 
                        	   292: blockErrors1_3:
00:018E CD3001          	   293: 		call 	restoreSIO_0IO 			; get normal keyboard/screen function
00:0191 CD0000          	   294: 		call 	writeSTRBelow_CRLF
00:0194 000D0A          	   295: 		defb    "\0\r\n"
00:0197 46696C6520747261	   296: 		defb	"File transfer error: Format, Block ID, ... !",00
00:019F 6E73666572206572
00:01A7 726F723A20466F72
00:01AF 6D61742C20426C6F
00:01B7 636B2049442C202E
00:01BF 2E2E2021
00:01C3 00
00:01C4 C9              	   297: 		ret
                        	   298: 
                        	   299: retry9Err:
00:01C5 CD3001          	   300: 		call 	restoreSIO_0IO 			; get normal keyboard/screen function
00:01C8 CD0000          	   301: 		call 	writeSTRBelow_CRLF
00:01CB 000D0A          	   302: 		defb    "\0\r\n"
00:01CE 584D4F44454D3A20	   303: 		defb	"XMODEM: Block retry 9 times... !",00
00:01D6 426C6F636B207265
00:01DE 7472792039207469
00:01E6 6D65732E2E2E2021
00:01EE 00
00:01EF C9              	   304: 		ret
                        	   305: 
                        	   306: 
                        	   307: 
                        	   308: ;************
                        	   309: 
                        	   310: checkSumErr: 
00:01F0 CD0000          	   311: 		call 	TX_NAK 			;on chk sum error
00:01F3 37              	   312: 		scf
00:01F4 3F              	   313: 		ccf						;clear carry flag
00:01F5 118000          	   314: 		ld		DE,0080h		;subtract 80h
00:01F8 ED52            	   315: 		sbc 	HL,DE 			;from HL, so HL is reset to block start address
                        	   316: 
00:01FA 3A0000          	   317: 		ld		A,(TempVar2)		;count bad blocks in TempVar2
00:01FD 3C              	   318: 		inc		A
00:01FE 320000          	   319: 		ld		(TempVar2),A
00:0201 FE09            	   320: 		cp		09h
00:0203 CAC501          	   321: 		jp		z,retry9Err		;abort download after 9 attempts to transfer a block
00:0206 C35D00          	   322: 		jp 		nextBlock		;repeat block reception
                        	   323: 
                        	   324: 
                        	   325: ; Calculating XMODEM CRC-16 in Z80
                        	   326: ; ================================
                        	   327: 
                        	   328: ; Calculate an XMODEM 16-bit CRC from data in memory. This code is as
                        	   329: ; tight and as fast as it can be, moving as much code out of inner
                        	   330: ; loops as possible. Can be made shorter, but slower, by replacing
                        	   331: ; JP with JR.
                        	   332: 
                        	   333: ; On entry, crc..crc+1   =  incoming CRC
                        	   334: ;           addr..addr+1 => start address of data
                        	   335: ;           num..num+1   =  number of bytes
                        	   336: ; On exit,  crc..crc+1   =  updated CRC
                        	   337: ;           addr..addr+1 => undefined
                        	   338: ;           num..num+1   =  undefined
                        	   339: 
                        	   340: ; Multiple passes over data in memory can be made to update the CRC.
                        	   341: ; For XMODEM, initial CRC must be 0. Result in DE..
                        	   342: 
                        	   343: CRC16:
00:0209 110000          	   344: 		ld 		DE,$00					; Incoming CRC
                        	   345: 		; Enter here with HL=>data, BC=count, DE=incoming CRC
                        	   346: bytelp:
00:020C C5              	   347: 		push 	BC					; Save count
00:020D 7E              	   348: 		ld 		A,(HL)				; Fetch byte from memory
                        	   349: ;		 The following code updates the CRC with the byte in A -----+
00:020E AA              	   350: 		xor 	D					; XOR byte into CRC top byte		|
00:020F 0608            	   351: 		ld 		B,8					; Prepare to rotate 8 bits			|
                        	   352: rotlp:                    ;											|
00:0211 CB23            	   353: 		sla 	E
00:0213 8F              	   354: 		adc 	A,A					; Rotate CRC						|
00:0214 D21F02          	   355: 		jp 		NC,clear			; b15 was zero						|
00:0217 57              	   356: 		ld 		D,A					; Put CRC high byte back into D		|
00:0218 7B              	   357: 		ld 		A,E
00:0219 EE21            	   358: 		xor 	$21
00:021B 5F              	   359: 		ld 		E,A					; CRC=CRC XOR $1021, XMODEM polynomic	|
00:021C 7A              	   360: 		ld 		A,D
00:021D EE10            	   361: 		xor 	$10					; And get CRC top byte back into A	|
                        	   362: clear:                    ;											|
00:021F 05              	   363: 		dec 	B	
00:0220 C21102          	   364: 		jp 		NZ,rotlp				; Loop for 8 bits					|
00:0223 57              	   365: 		ld 		D,A					; Put CRC top byte back into D		|
                        	   366: ;		 -----------------------------------------------------------+
                        	   367: 
00:0224 23              	   368: 		inc		HL					; Step to next byte
00:0225 C1              	   369: 		pop 	BC
00:0226 0B              	   370: 		dec 	BC					; num=num-1
00:0227 78              	   371: 		ld 		A,B
00:0228 B1              	   372: 		or 		C
00:0229 C20C02          	   373: 		jp 		NZ,bytelp			; Loop until num=0
                        	   374: 
00:022C C9              	   375: 		ret
                        	   376: 
                        	   377: 
                        	   378: 
                        	   379: 	;***************************************************************
                        	   380: 	;SAMPLE EXECUTION:
                        	   381: 	;***************************************************************
                        	   382: 
                        	   383: 
                        	   384: 
                        	   385: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CR                               E:000D
CRC16                           00:0209 EXP
CTC1_INT_OFF                    external
CTCpulse                         E:000A
CTCtimeout                       E:000B
EOT                              E:0004
EOT_FOUND                        E:0002
EO_CH_AV                        00:0006
Er01_                           00:00D0
Er02_                           00:00D4
Er03_                           00:00D8
Er04_                           00:00DC
InitBuffers                     external
LF                               E:000A
NUL                              E:0000
RAM_Start                       00:0000 EXP
RX_BS                           00:0003
RX_CR                           00:0000
SIO_A_C                         external
SIO_A_D                         external
SIO_A_DI                        external EXP
SIO_A_EI                        external EXP
SIO_A_RESET                     external EXP
SIO_A_RTS_OFF                   external EXP
SIO_A_RTS_ON                    external EXP
SIO_A_RXon                      external EXP
SIO_A_TXRX_INToff               external EXP
SIO_A_TXRX_INTon                external EXP
SIO_A_TXon                      external EXP
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Read_Vec                 E:F40C
SIO_Int_Vec                      E:F400
SOH                              E:0001
SPEC_RX_CONDITON                00:000D
SetupXMODEM_TXandRX             external EXP
TX_ACK                          external EXP
TX_C                            external EXP
TX_EMP                          external EXP
TX_NAK                          external EXP
TX_X                            external EXP
TempVar1                        external
TempVar2                        external
WR1                              E:0001
XBAddr                          external
XMChkSum                        external
_CW                              E:0001
_Counter                         E:0040
_EN_INT_Nx_Char                  E:0020
_INT_EN                          E:0080
_Reset                           E:0002
_Reset_STAT_INT                  E:0010
_Rising                          E:0010
_Rx_INT_First_Char               E:0008
_TC_Follow                       E:0004
_WAIT_READY_EN                   E:0080
_WAIT_READY_R_T                  E:0020
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_err01_                          E:0008
_err02_                          E:0009
_err03_                          E:000C
_err04_                          E:000D
blockErrors1_3                  00:018E
blockFinished                   00:00A5
bytelp                          00:020C
checkBlockChecksum              00:0105
checkBlockNum                   00:00E0
checkByte01                     00:00C2
checkComplBlockNum              00:00EC
checkSumErr                     00:01F0
clear                           00:021F
doImportXMODEM                  00:0010 EXP
exitRecBlock                    00:0140
getBlockData                    00:00F9
gpioB                           external
gpio_in                         external
gpio_out                        external
nextBlock                       00:005D
nextC                           00:005C
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
purgeRXA                        external EXP
purgeRXB                        external EXP
receiveBlockIn                  00:00AF
restoreSIO_0IO                  00:0130
retBlockComplete                00:012C
retry9Err                       00:01C5
rotlp                           00:0211
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
timeOutErr                      00:0167
writeSTRBelow                   external
writeSTRBelow_CRLF              external

Symbols by value:
0000 NUL
0000 RAM_Start
0000 RX_CR
0001 SOH
0001 WR1
0001 _CW
0002 EOT_FOUND
0002 _Reset
0003 RX_BS
0004 EOT
0004 _TC_Follow
0006 EO_CH_AV
0008 _Rx_INT_First_Char
0008 _err01_
0009 _err02_
000A CTCpulse
000A LF
000B CTCtimeout
000C _err03_
000D CR
000D SPEC_RX_CONDITON
000D _err04_
0010 _Reset_STAT_INT
0010 _Rising
0010 doImportXMODEM
0020 _EN_INT_Nx_Char
0020 _WAIT_READY_R_T
0040 _Counter
005C nextC
005D nextBlock
0080 _INT_EN
0080 _WAIT_READY_EN
00A5 blockFinished
00AF receiveBlockIn
00C2 checkByte01
00D0 Er01_
00D4 Er02_
00D8 Er03_
00DC Er04_
00E0 checkBlockNum
00EC checkComplBlockNum
00F9 getBlockData
0105 checkBlockChecksum
012C retBlockComplete
0130 restoreSIO_0IO
0140 exitRecBlock
0167 timeOutErr
018E blockErrors1_3
01C5 retry9Err
01F0 checkSumErr
0209 CRC16
020C bytelp
0211 rotlp
021F clear
F400 SIO_Int_Vec
F40C SIO_Int_Read_Vec
