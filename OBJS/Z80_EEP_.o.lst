Sections:
00: "FLASH_Startup" (0-5D)
01: "INT_IM1" (0-C)
02: "INIT_BODY" (0-A8)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: GPIODEBUG EQU 1
                        	     4: 
                        	     5: 		section  FLASH_Startup   	 ;FLASH mem at 0000h
                        	     6: EPS1:
                        	     7: 
                        	     8: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     9: 		xref	RAM_Start, SC5B,SC4C,SC8B, WriteLineCRNL, WriteLine, ReadLine, CRLF,DumpRegisters
                        	    10: 
                        	    11: 		xref	stacktop
                        	    12: 		global 	setFLASHBank, setSRAMBank, enableFLASH, disableFLASH, setFLASHBank
                        	    13: 
00:0000 31F0FF          	    14: 		ld		sp,stacktop
                        	    15: 		
00:0003 C30000          	    16: 		jp		setBanks
                        	    17: 		align 3
                        	    18: 		; section RST08
00:0008 C30000          	    19: 		jp	WriteLineCRNL	
                        	    20: 		align 3
                        	    21: 		; section RST10	
00:0010 C30000          	    22: 		jp 	WriteLine
                        	    23: 		align 3
                        	    24: 		; section RST18	
00:0018 C30000          	    25: 		jp	ReadLine
                        	    26: 		align 3
                        	    27: 		; section RST20	
00:0020 C30000          	    28: 		jp	CRLF
                        	    29: 		align 3
                        	    30: 		; section RST28	
00:0028 00              	    31: 		db 0,0,0
00:0029 00
00:002A 00
                        	    32: 		align 3
                        	    33: 		; section RST30	
00:0030 00              	    34: 		db 0,0,0
00:0031 00
00:0032 00
                        	    35: 		align 3
                        	    36: 		; section RST38	
                        	    37: 		;jp	DumpRegisters
00:0038 C30000          	    38: 		jp	setBanks
                        	    39: 
                        	    40: 		align 3
00:0040 202020206275696C	    41: 		defb	"    build: 2026-02-28_14:19\r\n"
00:0048 643A20323032362D
00:0050 30322D32385F3134
00:0058 3A31390D0A
                        	    42: 	
                        	    43: 
                        	    44: ;********************************************************
                        	    45: 		section  INT_IM1     ;FLASH mem at 0066h
                        	    46: ;********************************************************
                        	    47: 
01:0000 0E04            	    48: 		LD C,04		; jp PIO_A_INT
01:0002 0E04            	    49: 		LD C,04		; jp PIO_A_INT
01:0004 0E04            	    50: 		LD C,04		; jp PIO_A_INT
01:0006 1604            	    51: 		LD D,04		; jp PIO_A_INT
01:0008 ED45            	    52: 		retn		; jp PIO_A_INT
01:000A 0004            	    53: 		defw $0400          ; NMI adress table    
                        	    54: 
                        	    55: 
                        	    56: 
                        	    57: ;************************************************************************************************
                        	    58: ;************************************************************************************************
                        	    59: ;***		FLASH startup sequence (starts at $0080)
                        	    60: ;************************************************************************************************
                        	    61: ;************************************************************************************************
                        	    62: ;********************************************************
                        	    63: 		section  INIT_BODY     ;FLASH mem at 0080h
                        	    64: ;********************************************************
                        	    65: 
                        	    66: 		align 4
                        	    67: setBanks:
                        	    68: 		; ld 		A,$80					; set bit 7 - SRAM64 set
                        	    69: 		; ld 		(memBankID),A			; clear memory banks
                        	    70: 		
02:0000 CD8500          	    71: 		call 	EEPIO_Init
                        	    72: 		
                        	    73: 	ifd 	GPIODEBUG
02:0003 3E55            	    74: 		ld 		A,$55
02:0005 D302            	    75: 		out 	(gpio_out),A
                        	    76: 	endif
                        	    77: 
02:0007 AF              	    78: 		xor 	A					; A=0
02:0008 320000          	    79: 		ld 		(memBankID),A		; set memory banks #0
                        	    80: 	ifd NOFLASH
                        	    81: 		call 	disableFLASH		; NO FLASH 
                        	    82: 	else	
02:000B CD5900          	    83: 		call 	enableFLASH			; start from FLASH
                        	    84: 	endif
                        	    85: 
02:000E AF              	    86: 		xor 	A
02:000F CD3600          	    87: 		call 	setSRAMBank			; ram bank #0
                        	    88: 
                        	    89: 	ifd 	GPIODEBUG
02:0012 3E77            	    90: 		ld 		A,$77
02:0014 D302            	    91: 		out 	(gpio_out),A
                        	    92: 	endif
                        	    93: 
                        	    94: 
02:0016 CD7C00          	    95: 		call 	enableIC620_OE 		; enable the outputs.
                        	    96: 
02:0019 C30000          	    97: 		jp		SD_USB_startup
                        	    98: 	
                        	    99: ;********************************************************************************************
                        	   100: ;********************************************************************************************	
                        	   101: 		; ******   Copy data from flash $400 to $2000 to SRAM $D000
                        	   102: 		; Code in $D002-D005 = '0000' - 'AAAA': copy from flash
                        	   103: 		; Code in $D002-D005 = 'CCCC': code uploaded from xmodem/or DMA. Do not copy from flash
                        	   104: 
02:001C 2102D0          	   105: 		ld 		HL,$D002
02:001F 3E43            	   106: 		ld  	A,'C'
02:0021 010400          	   107: 		ld 		BC,04
                        	   108: 
02:0024 EDA1            	   109: .nxt:	cpi 	
02:0026 2003            	   110: 		jr 		NZ,doCopy
02:0028 EA2400          	   111: 		jp 		PE,.nxt
                        	   112: 		;JP PE means "branch if BC has not been decremented to 0."
                        	   113: 
                        	   114: 		; the code 'CCCC' is found in $D002-D005, do not copy from flashmem.
                        	   115: 		; jp		MONITOR_Start
                        	   116: 
                        	   117: doCopy:
02:002B 210004          	   118: 		ld 		HL,$400				; source
02:002E 1100D0          	   119: 		ld 		DE,$D000	 			; destination
02:0031 01F01F          	   120: 		ld 		BC,$1FF0				; 
                        	   121: 
02:0034 EDB0            	   122: 		ldir
                        	   123: 
                        	   124: 		; jp		MONITOR_Start
                        	   125: 
                        	   126: 
                        	   127: ;********************************************************************************************
                        	   128: ;********************************************************************************************	
                        	   129: setSRAMBank:
                        	   130: 		; ***	set the SRAM bank ID; Bank ID in A
                        	   131: 
02:0036 E5              	   132: 		push 	HL
02:0037 C5              	   133: 		push 	BC
02:0038 210000          	   134: 		ld 		HL,memBankID
02:003B E60F            	   135: 		and 	$0F 				; clear all bits but 0-3 in A
                        	   136: 
02:003D 47              	   137: 		ld 		B,A
02:003E 7E              	   138: 		ld 		A,(HL)				; get the actl. mem Bank ID
02:003F E6F0            	   139: 		and 	$F0  				; zero bits 0-3
02:0041 180F            	   140: 		jr 		putBank
                        	   141: 
                        	   142: ;********************************************************************************************
                        	   143: ;********************************************************************************************	
                        	   144: 
                        	   145: setFLASHBank:
                        	   146: 		; ***	set the FLASH bank ID; Bank ID in A
                        	   147: 
02:0043 E5              	   148: 		push 	HL
02:0044 C5              	   149: 		push 	BC
02:0045 210000          	   150: 		ld 		HL,memBankID
02:0048 E607            	   151: 		and 	$07 				; clear all bits but 0-2
02:004A 07              	   152: 		rlca
02:004B 07              	   153: 		rlca
02:004C 07              	   154: 		rlca
02:004D 07              	   155: 		rlca						; bank ID = bits 4-6
                        	   156: 
02:004E 47              	   157: 		ld 		B,A
02:004F 7E              	   158: 		ld 		A,(HL)				; get the actl. mem Bank ID
02:0050 E68F            	   159: 		and 	$8F  				; zero bits 4-6
                        	   160: putBank:
02:0052 B0              	   161: 		or 		B					; put new EEP bank ID in A...
02:0053 77              	   162: 		ld 		(HL),A				; store new value
02:0054 D300            	   163: 		out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
02:0056 C1              	   164: 		pop 	BC
02:0057 E1              	   165: 		pop 	HL
02:0058 C9              	   166: 		ret 
                        	   167: 
                        	   168: ;********************************************************************************************
                        	   169: ;********************************************************************************************	
                        	   170: enableFLASH:
                        	   171: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	   172: 				; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	   173: 				; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
02:0059 E5              	   174: 		push 	HL
02:005A C5              	   175: 		push 	BC
02:005B 210000          	   176: 		ld 		HL,rstBankID
02:005E CB9E            	   177: 		res 	3,(HL)				; clear bit 3 -> enable FLASH
02:0060 CB96            	   178: 		res 	2,(HL)				; temp enable reset of IC622
                        	   179: putBankF:
02:0062 7E              	   180: 		ld 		A,(HL)
02:0063 D300            	   181: 		out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
02:0065 C1              	   182: 		pop 	BC
02:0066 E1              	   183: 		pop 	HL
02:0067 C9              	   184: 		ret 
                        	   185: 		
                        	   186: ;********************************************************************************************
                        	   187: ;********************************************************************************************	
                        	   188: disableFLASH:
                        	   189: 		; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	   190: 				; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	   191: 				; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
02:0068 E5              	   192: 		push 	HL
02:0069 C5              	   193: 		push 	BC
02:006A 210000          	   194: 		ld 		HL,rstBankID
02:006D CBD6            	   195: 		set 	2,(HL) 			; temp disable reset of IC622
02:006F CBDE            	   196: 		set 	3,(HL)			; set bit 3 -> disable FLASH
02:0071 18EF            	   197: 		jr 		putBankF
                        	   198: 
                        	   199: ;********************************************************************************************
                        	   200: ;********************************************************************************************	
                        	   201: 
                        	   202: 
                        	   203: disableIC620_OE:
                        	   204: 		; ***	Set IC620 pin 1 high
02:0073 E5              	   205: 		push 	HL
02:0074 C5              	   206: 		push 	BC
02:0075 210000          	   207: 		ld 		HL,rstBankID
02:0078 CB86            	   208: 		res 	0,(HL)
02:007A 18E6            	   209: 		jr 		putBankF
                        	   210: 
                        	   211: 
                        	   212: ;********************************************************************************************
                        	   213: ;********************************************************************************************	
                        	   214: 
                        	   215: enableIC620_OE: 
                        	   216: 		; ***	Set IC620 pin 1 low
02:007C E5              	   217: 		push 	HL
02:007D C5              	   218: 		push 	BC
02:007E 210000          	   219: 		ld 		HL,rstBankID
02:0081 CBC6            	   220: 		set 	0,(HL)
02:0083 18DD            	   221: 		jr 		putBankF
                        	   222: 
                        	   223: 
                        	   224: ;********************************************************************************************
                        	   225: ;********************************************************************************************	
                        	   226: 
                        	   227: 		; out (_8Bitsout),A
                        	   228: ; 
                        	   229: EEPIO_Init:
                        	   230: ; ;----------******************* PIO PORT A
02:0085 3E0F            	   231: 		ld A, $0F                 ;mode 1 out
02:0087 D301            	   232: 		out (portA_Contr), A         ; set port A as output
                        	   233: ; 		ld A, Interupt_vector&0xFF                   ; low byte of INT table
                        	   234: ; 		out (portA_Contr), A         ; PIO A interrupt vector
02:0089 3E03            	   235: 		ld A, $03
02:008B D301            	   236: 		out (portA_Contr), A         ; PIO A interrupt disable
                        	   237: ; 		ld a,Interupt_vector>>8                   ; high byte of INT table
                        	   238: ; 		ld I,A
                        	   239: ; 		ei
                        	   240: ; ;----------******************* PIO PORT B
02:008D 3E0F            	   241:  		ld A, $0F                    ;mode 0 output 
02:008F D303            	   242:  		out (portB_Contr), A         ; set port B as output
02:0091 3E03            	   243:  		ld A, $03
02:0093 D303            	   244:  		out (portB_Contr), A         ; PIO B interrupt disable
02:0095 3E00            	   245:  		ld a,0
02:0097 32D0F1          	   246:  		ld (PIO_B_value),a
02:009A D302            	   247:  		out (portB_Data), a
02:009C C9              	   248: 	ret
                        	   249:  
                        	   250: 
                        	   251: 
                        	   252: 		
                        	   253: ; ;********************************************************		
                        	   254: ; 		section EEtestprog			; main program in sram
                        	   255: ; ;********************************************************	
                        	   256: 
                        	   257: ; 		; xdef	RDATA_END,RDATA,TB_length
                        	   258: ; hit:
                        	   259: 
                        	   260: ; 		call	EEPIO_Init
                        	   261: ; 		di
                        	   262: ; hit3:
                        	   263: ; 		LD 		A,$81
                        	   264: ; 		; out 	(_CE_RST_BANK),A
                        	   265: ; 		out 	(gpio_out),A
                        	   266: 
                        	   267: 
                        	   268: ; 		LD 		A,$7E
                        	   269: ; 		; out 	(_Z80_BankCS),A
                        	   270: ; 		out 	(gpio_out),A
                        	   271: 
                        	   272: ; 		ld 		ix,$8000
                        	   273: 
                        	   274: ; 		ld 		bc,$0F00
                        	   275: ; 		ld 		A,$3F
                        	   276: ; 		ld 		(IX+0),A
                        	   277: ; 		inc 	IX
                        	   278: ; .nxt1:
                        	   279: ; 		ld 		(IX+0),A
                        	   280: ; 		out 	(gpio_out),A
                        	   281: ; 		inc 	IX
                        	   282: ; 		inc 	A
                        	   283: ; 		djnz 	.nxt1			
                        	   284: 
                        	   285: ; ;***********************************
                        	   286: ; 	 	ld 		A,$1B
                        	   287: ; 		out 	(gpio_out),A
                        	   288: ; 		out 	(gpio_out),A
                        	   289: ; 	 	ld 		A,$E3
                        	   290: ; 		out 	(gpio_out),A
                        	   291: ; 		ld 		A,$0C
                        	   292: ; 		out 	(gpio_out),A
                        	   293: 		
                        	   294: ; 		ld 		A,$0F
                        	   295: ; 		out 	(gpio_out),A
                        	   296: 
                        	   297: ; 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   298: ; 			; initialize buffer counters and pointers.
                        	   299: 
                        	   300: 
                        	   301: ; 		call 	CTC_Init
                        	   302: 
                        	   303: 
                        	   304: ; 		ld 		A,$1D
                        	   305: ; 		out 	(gpio_out),A
                        	   306: ; 		ld 		A,$00
                        	   307: ; 		out 	(gpio_out),A
                        	   308: 
                        	   309: ; 		call 	SIO_Init
                        	   310: ; 		; ld      HL,SIO_0INT		;BASE ADDRESS OF INITIALIZATION ARRAY
                        	   311: ; 		; call    InitSIO_0Ports			; INITIALIZE SIO_0
                        	   312: 
                        	   313: 
                        	   314: ; 		ld 		A,$1E
                        	   315: ; 		out 	(gpio_out),A
                        	   316: 
                        	   317: ; 		; ld 		A,'#'
                        	   318: ; 		; out		(SIO_A_D),A			;output data
                        	   319: ; 		; call 	TX_EMP
                        	   320: 
                        	   321: ; 		; ld 		A,$18
                        	   322: ; 		; out 	(gpio_out),A
                        	   323: 
                        	   324: ; 		; ld 		A,'A'
                        	   325: ; 		; call  	WriteChar
                        	   326: 
                        	   327: ; 		; ld 		A,'B'
                        	   328: ; 		; call  	WriteChar
                        	   329: 
                        	   330: ; 		; ld 		A,'C'
                        	   331: ; 		; call  	WriteChar
                        	   332: ; 		; call 	CRLF
                        	   333: 
                        	   334: ; 		call 	writeSTRBelow
                        	   335: ; 		defb   	"\0\r\n"
                        	   336: ; 		defb	"##########################################################\r\n"
                        	   337: ; 		defb	"-*-*/-*/-*/-*/-*//-*/-*/-*/-*/-*/-*/**-/-*/-*/-*/-*/-*/-*/\r\n"
                        	   338: ; 		defb	"-+-+-+-+-+-+-+---++--++--++--++--++--+++-+-+-+-+-+-+-+-+-+\r\n"
                        	   339: ; 		defb	"The Z80 Board Awakened 2025\r\n"
                        	   340: ; 		defb	"    FLASH->SRAM 0xD000.\r\n"
                        	   341: ; 		defb	"    2026-02-07 .\r\n"
                        	   342: ; 		defb	"\0\0"
                        	   343: 
                        	   344: ; 		halt
                        	   345: 
                        	   346: 
                        	   347: ; ;***************************
                        	   348: ; 		halt
                        	   349: ; ;**************************
                        	   350: ; 		ld  	HL,$0402
                        	   351: 
                        	   352: ; 		call 	EEPIO_Init
                        	   353: ; 		LD 		A,$30
                        	   354: 
                        	   355: ; 		ld 		B,$40
                        	   356: ; hit2:		
                        	   357: ; 		ld 		(HL),a
                        	   358: ; 		inc 	a
                        	   359: ; 		INC 	HL
                        	   360: ; 		out 	(gpio_in),A
                        	   361: 
                        	   362: 	
                        	   363: ; 		djnz 	hit2
                        	   364: 	
                        	   365: ; 		LD 		(hl),a
                        	   366: ; 		inc 	a
                        	   367: ; 		INC 	HL
                        	   368: ; 		out 	(gpio_in),A
                        	   369: ; 		LD 		(hl),a
                        	   370: ; 		inc 	a
                        	   371: ; 		INC 	HL
                        	   372: ; 		out 	(gpio_in),A
                        	   373: ; 		LD 		(hl),a
                        	   374: ; 		inc 	a
                        	   375: ; 		INC 	HL
                        	   376: ; 		out 	(gpio_in),A
                        	   377: ; 		LD 		(hl),a
                        	   378: 
                        	   379: ; 		LD 		A,$0C
                        	   380: ; 		out 	(_CE_RST_BANK),A
                        	   381: 
                        	   382: 		
                        	   383: 
02:009D 97              	   384: TX_EMP:	sub a
02:009E 3C              	   385: 		inc a
02:009F D302            	   386: 		out (SIO_A_C),A
02:00A1 DB02            	   387: 		in 	a,(SIO_A_C)
02:00A3 CB47            	   388: 		bit 0,A
02:00A5 28F6            	   389: 		jr  z,TX_EMP
02:00A7 C9              	   390: 		ret
                        	   391: 
                        	   392: 
                        	   393: 
                        	   394: 
                        	   395: .end
                        	   396: 
                        	   397: 
                        	   398: ;************************************************************************
                        	   399: ; ShowPC_HALT:
                        	   400: ; Dump prog counter prior to HALT instr. value present in stack (pointed by SP).
                        	   401: ; uses  IX (pointer to HEX chars)
                        	   402: ;       IY (pointer at stack)
                        	   403: ;       BC ( count)
                        	   404: ; ;       HL (value for conversion to HEX)
                        	   405: ; ;       DE (positon of display 2004A)
                        	   406: 	if DOALIGN
                        	   407: 		align 8
                        	   408: 	endif
                        	   409:             
                        	   410: ; ShowPC_HALT:
                        	   411: ; 		ld (SP_value), SP	; save contents of SP
                        	   412: ; 		push AF
                        	   413: ; 		push BC
                        	   414: ; 		push DE
                        	   415: ; 		push HL
                        	   416: ; 		ld HL,(SP_value)
                        	   417: ; 		push HL				; push the SP value on the stack...
                        	   418: ; 		push IX
                        	   419: ; 		Push IY
                        	   420: 
                        	   421: 		
                        	   422: ; 		; first print the labels: adr: t_str4 - 7
                        	   423: ; 		;*****************************************
                        	   424: ; 		ld de, $0000		; row 0, col 1
                        	   425: ; 		ld IX, t_str4
                        	   426: ; nxt2:
                        	   427: ; 		call setcursor		; set cur
                        	   428: ; 		ld B, t_str5-t_str4	; all 4 rows has the same length
                        	   429: ; nxt3:
                        	   430: ; 		ld a, (ix+0)
                        	   431: ; 		inc ix
                        	   432: ; 		call writedata
                        	   433: ; 		djnz nxt3
                        	   434: 
                        	   435: ; 		inc D				;Next row
                        	   436: ; 		ld A,D
                        	   437: ; 		cp $04				; all rows printed ?
                        	   438: ; 		jr NZ, nxt2
                        	   439: 
                        	   440: 
                        	   441: ; 		; set all values, first value (SP)
                        	   442: ; 		;***************************************
                        	   443: ; 		ld iy,(SP_value)		; top of stored stack
                        	   444: ; 		ld IX,cur_pos			; table of cursor positions
                        	   445: 		
                        	   446: 		
                        	   447: ; nxt4:	ld L,(iy+0)
                        	   448: ; 		ld H,(iy+1)
                        	   449: ; 		dec IY
                        	   450: ; 		dec IY					; next value in stack
                        	   451: 
                        	   452: ; 		call Num4Hex			; convert value in HL
                        	   453: ; 		;
                        	   454: ; 		ld E,(IX+0)
                        	   455: ; 		ld D,(IX+1)			; DE - cursor pos d-row e-col
                        	   456: ; 		inc IX
                        	   457: ; 		inc IX				; IX - next cursor position adr.
                        	   458: ; 		call setcursor		; runs also 'command'
                        	   459: ; 	;
                        	   460: ; 		ld b, $04
                        	   461: ; 		push IX
                        	   462: ; 		ld IX, Result_NumToHex	; pointer to hex characters
                        	   463: ; nxt5:
                        	   464: ; 		ld a, (IX+0)
                        	   465: ; 		inc IX
                        	   466: ; 		call writedata
                        	   467: ; 		djnz nxt5
                        	   468: ; 		pop IX
                        	   469: ; 		ld a,(IX+0)				
                        	   470: ; 		cp $FF					; check if end of cursor positions
                        	   471: ; 		jr NZ, nxt4
                        	   472: 
                        	   473: ; 		; print flags Z/NZ, C/NC, PO/PE, P/M
                        	   474: ; 		;***************************************
                        	   475: ; 		ld DE, $0011
                        	   476: ; 		call setcursor
                        	   477: ; 		ld IY,(SP_value)		; IY - top of stack
                        	   478: ; 		ld A, (IY-2)
                        	   479: ; 		ld (AF_value), A
                        	   480: ; 		bit 6, (IY-2)					; test for Z flag
                        	   481: ; 		jr NZ, nx_noNZ			
                        	   482: ; 		ld A,'N'
                        	   483: ; 		call writedata
                        	   484: ; nx_noNZ:
                        	   485: ; 		ld A,'Z'
                        	   486: ; 		call writedata
                        	   487: ; 		inc D					; next row (E=$11), next flag (C)
                        	   488: ; 		call setcursor
                        	   489: ; 		;-----------------------------
                        	   490: 		
                        	   491: ; 		bit 0, (IY-2)					; test for C flag
                        	   492: ; 		jr NZ, nx_noNC			
                        	   493: ; 		ld A,'N'
                        	   494: ; 		call writedata
                        	   495: ; nx_noNC:
                        	   496: ; 		ld A,'C'
                        	   497: ; 		call writedata
                        	   498: ; 		inc D					; next row (E=$11), next flag (PE/PO)
                        	   499: ; 		call setcursor
                        	   500: ; 		;-----------------------------
                        	   501: ; 		ld A,'P'
                        	   502: ; 		call writedata
                        	   503: ; 		bit 2,(IY-2)					; test for P/V flag
                        	   504: ; 		jr Z, nx_PO			
                        	   505: ; 		ld A,'E'				;parity even (PE)
                        	   506: ; 		call writedata
                        	   507: ; 		jr nx_sign
                        	   508: ; nx_PO:
                        	   509: ; 		ld A,'O'					;parity even (PE)
                        	   510: ; 		call writedata
                        	   511: ; nx_sign:		
                        	   512: ; 		inc D					; next row (E=$11), next flag (sign)
                        	   513: ; 		call setcursor
                        	   514: ; 		;-----------------------------
                        	   515: ; 		bit 7,(IY-2)					; test for S flag S=0 positive
                        	   516: ; 		jr Z, nx_S			
                        	   517: ; 		ld A,'M'				;sign negative (Minus)
                        	   518: ; 		call writedata
                        	   519: ; 		jr nx_hlt
                        	   520: ; nx_S:
                        	   521: ; 		ld A,'P'					;sign positive (P)
                        	   522: ; 		call writedata
                        	   523: ; nx_hlt:		
                        	   524: ; 		;-----------------------------
                        	   525: 
                        	   526: ; 		halt
                        	   527: 
                        	   528: ; 		pop IY
                        	   529: ; 		pop IX
                        	   530: ; 		pop HL
                        	   531: ; 		pop HL
                        	   532: ; 		pop DE
                        	   533: ; 		pop BC
                        	   534: ; 		pop AF
                        	   535: 
                        	   536: ; 		ret
                        	   537: 
                        	   538: ; 	align 8        
                        	   539: ; */
                        	   540: 
                        	   541: ;
                        	   542: ;t_intAstr:   .ascii "PIO A INT"
                        	   543: ;************************************************************************
                        	   544: ; Hexadecimal conversion operates directly on nibbles and takes advantage of nifty DAA trick.
                        	   545: ;Input: HL = number to convert, IX = location of ASCII string
                        	   546: ;Output: ASCII string at (IX) 
                        	   547: ; Num4Hex:  	; convert 2 bytes in HL
                        	   548: ; 	push IX
                        	   549: ; 	ld ix, Result_NumToHex
                        	   550: ; 	ld	a,h
                        	   551: ; 	call	Num1
                        	   552: ; 	ld	a,h
                        	   553: ; 	call	Num2
                        	   554: ; Num2Hex:	; converts 1 byte in L
                        	   555: ; 	ld	a,l
                        	   556: ; 	call	Num1
                        	   557: ; 	ld	a,l
                        	   558: ; 	call	Num2
                        	   559: ; 	pop IX
                        	   560: ; 	ret
                        	   561: 
                        	   562: ; Num1:
                        	   563: ; 	rra
                        	   564: ; 	rra
                        	   565: ; 	rra
                        	   566: ; 	rra
                        	   567: ; Num2:
                        	   568: ; 	or	$F0
                        	   569: ; 	daa
                        	   570: ; 	add	a,$A0
                        	   571: ; 	adc	a,$40
                        	   572: 
                        	   573: ; 	ld	(ix+0),a
                        	   574: ; 	inc	ix
                        	   575: ; 	ret
                        	   576: 
                        	   577: ; inc_portB_value:
                        	   578: ; 		ld a, (PIO_B_value)
                        	   579: ; 		inc a
                        	   580: ; 		ld (PIO_B_value), a
                        	   581: ; 		out (portB_Data), a
                        	   582: ; 		ret
                        	   583: 
                        	   584: 
                        	   585: ; #code DAT_TABLE, DataTables,  $200
                        	   586: 
                        	   587: 
                        	   588: 	if DOALIGN
                        	   589: 		align 8
                        	   590: 	endif
                        	   591:             
                        	   592: ; initbytes:   .byte $01, $38, $0E, $06, $B0
                        	   593: ; t_str1:		.ascii "Z80 micro and"
                        	   594: ; t_str2:		.ascii "HD44780 display"
                        	   595: ; t_str3:		.ascii "Z8536 assist->"
                        	   596: ; t_str4:		.ascii " PC:____ AF:____    "
                        	   597: ; t_str5:		.ascii " BC:____ DE:____    "
                        	   598: ; t_str6:		.ascii " HL:____ SP:____    "
                        	   599: ; t_str7:		.ascii " IX:____ IY:____    "
                        	   600: ; t_str8:		.ascii " "
                        	   601: ; t_str9:		.ascii " "
                        	   602: ; t_string_E: equ $
                        	   603: 	if DOALIGN
                        	   604: 		align 4
                        	   605: 	endif
                        	   606: 
                        	   607: ; cur_pos: equ $
                        	   608: ; 		defw	$0004, $000C, $0104, $010C,$0204, $020C,$0304, $030C, $FFFF
                        	   609: 	if DOALIGN
                        	   610: 		align 4
                        	   611: 	endif
                        	   612: 
                        	   613: ; t_str_table: equ $
                        	   614: ; 		defw	t_str1, t_str2, t_str3, t_str4, t_str5, t_str6, t_str7, t_str8
                        	   615: 
                        	   616: 
                        	   617: ; #code INT_TABLE, Interupt_vector, $10
                        	   618: ; 		;.byte $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04
                        	   619: ; 		;.byte $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04
                        	   620: ; 		.word PIO_A_INT,PIO_A_INT,PIO_A_INT,PIO_A_INT
                        	   621: 		
                        	   622: ; 		;defw $0400          ; NMI adress table    
                        	   623: 
                        	   624: 
                        	   625: ; RTestprog:
                        	   626: ; 		;--------------------------------------------------
                        	   627: ; 		; ld A,5
                        	   628: ; 		; out (_CE_RST_BANK),A
                        	   629: ; 		; ld 	A,$00	
                        	   630: ; 		; out (_Z80_BankCS),A		// set bank register number 	
                        	   631: ; 		; ld 	A,$01
                        	   632: ; 		; out (_CE_RST_BANK),A 		// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	   633: 
                        	   634: ; 		out (_8Bitsout),A
                        	   635: 
                        	   636: ; 		ld A, $0F                 ;mode 1 out
                        	   637: ; 		out (portA_Contr), A         ; set port A as output
                        	   638: ; 		ld A,$81
                        	   639: 
                        	   640: ; tll:	
                        	   641: ; 		ld (40000),A
                        	   642: ; 		ld A,0
                        	   643: ; 		ld A,(40000)
                        	   644: 
                        	   645: ; 		out (portA_Data),A		; Data to PIO port A
                        	   646: ; 		out (_8Bitsout),A
                        	   647: ; 		;--------------------------------------------------
                        	   648: ; 		ld	DE,$8100
                        	   649: ; 		ld	HL,RDATA
                        	   650: ; 		ld 	BC,RDATA_END-RDATA
                        	   651: ; 		ldir
                        	   652: ; 	if DOALIGN
                        	   653: ; 		align 4
                        	   654: ; 	endif
                        	   655: 
                        	   656: ; RDATA:
                        	   657: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   658: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   659: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   660: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   661: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   662: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   663: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   664: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   665: ; RDATA_END:
                        	   666: ; TB_length	equ 	RDATA_END-RDATA
                        	   667: 
                        	   668: 
                        	   669: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CRLF                            external EXP
DOALIGN                          E:0000
DumpRegisters                   external EXP
EEPIO_Init                      02:0085
EPS1                            00:0000
PIO_B_value                      E:F1D0
RAM_Start                       external EXP
ReadLine                        external EXP
SC4C                            external EXP
SC5B                            external EXP
SC8B                            external EXP
SD_USB_startup                  external
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Int_Vec                      E:F400
TX_EMP                          02:009D
WriteLine                       external EXP
WriteLineCRNL                   external EXP
_CE_RST_BANK                    external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
disableFLASH                    02:0068 EXP
disableIC620_OE                 02:0073
doCopy                          02:002B
enableFLASH                     02:0059 EXP
enableIC620_OE                  02:007C
gpioB                           external
gpio_in                         external
gpio_out                        external
memBankID                       external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
putBank                         02:0052
putBankF                        02:0062
rstBankID                       external
setBanks                        02:0000
setFLASHBank                    02:0043 EXP
setSRAMBank                     02:0036 EXP
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
stacktop                         E:FFF0 EXP

Symbols by value:
0000 DOALIGN
0000 EPS1
0000 setBanks
002B doCopy
0036 setSRAMBank
0043 setFLASHBank
0052 putBank
0059 enableFLASH
0062 putBankF
0068 disableFLASH
0073 disableIC620_OE
007C enableIC620_OE
0085 EEPIO_Init
009D TX_EMP
F1D0 PIO_B_value
F400 SIO_Int_Vec
FFF0 stacktop
