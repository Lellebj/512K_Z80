Sections:
00: "FLASH_Startup" (0-43)
01: "INT_IM1" (0-C)
02: "INIT_BODY" (0-95)
03: "EEtestprog" (0-190)


Source: "stdin"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: 		section  FLASH_Startup   	 ;FLASH mem at 0000h
                        	     5: EPS1:
                        	     6: 
                        	     7: 		include 	"Z80_Params_.inc"

Source: "Z80_Params_.inc"
                        	     1: ;Z80_PLD_PCB_.asm
                        	     2: 
                        	     3: 
                        	     4: stacktop: equ	0xFFF0	
                        	     5: 
                        	     6: 
                        	     7: ; PIO addressess...
                        	     8: ;******************************************
                        	     9: 	  ; _Z80PIO_Base= $00
                        	    10: portA_Contr:	equ _Z80PIO_Base + 1
                        	    11: portB_Contr:	equ _Z80PIO_Base + 3
                        	    12: portA_Data:		equ _Z80PIO_Base + 0
                        	    13: portB_Data:		equ _Z80PIO_Base + 2
                        	    14: 
                        	    15: 
                        	    16: gpio_in:		equ     portA_Data		; GP input port (repl with PIO A)
                        	    17: gpio_out:		equ		portB_Data		; GP output port (repl with PIO A)
                        	    18: gpioB:			equ		portB_Data
                        	    19: 
                        	    20: ; SIO_0 stuff
                        	    21: ;******************************************
                        	    22: SIO_A_D:		equ	_Z80SIO_Base	  ; = $20
                        	    23: 				;SIO_0 CHANNEL A COMMANDS/STATUS
                        	    24: SIO_A_C:		equ	_Z80SIO_Base+2
                        	    25: 				;SIO_0  CHANNEL B DATA
                        	    26: SIO_B_D:		equ	_Z80SIO_Base+1
                        	    27: 				;SIO_0 CHANNEL B COMMANDS/STATUS
                        	    28: SIO_B_C:		equ	_Z80SIO_Base+3
                        	    29: 
                        	    30: sio_ac: 		equ 	SIO_A_C
                        	    31: sio_ad: 		equ 	SIO_A_D
                        	    32: sio_bc: 		equ 	SIO_B_C
                        	    33: sio_bd: 		equ 	SIO_B_D
                        	    34: 
                        	    35: Interupt_vector		= SIO_Int_Vec
                        	    36: 
                        	    37: SIO_Int_Vec		EQU     $F400				; interrupt vector 
                        	    38: SIO_Int_WR_Vec	EQU     SIO_Int_Vec+8		;sio_0 channel A write interrupt vector
                        	    39: SIO_Int_EXT_Vec	EQU     SIO_Int_Vec+10	;sio_0 channel A external/status ; interrupt vector
                        	    40: SIO_Int_Read_Vec	EQU     SIO_Int_Vec+12	;sio_0 channel A read interrupt vector
                        	    41: SIO_Int_Spec_Vec	EQU     SIO_Int_Vec+14	;sio_0 channel A special receive interrupt vector
                        	    42: 
                        	    43: 		
                        	    44: SIO_USB_WR_Vec	EQU     SIO_Int_Vec+0		;sio_0 channel B write interrupt vector
                        	    45: SIO_USB_EXT_Vec	EQU     SIO_Int_Vec+2		;sio_0 channel B external/status ; interrupt vector
                        	    46: SIO_USB_Read_Vec	EQU     SIO_Int_Vec+4		;sio_0 channel B read interrupt vector
                        	    47: SIO_USB_Spec_Vec	EQU     SIO_Int_Vec+6		;sio_0 channel B special receive interrupt vector
                        	    48: 
                        	    49: ;Write register 0
                        	    50: WR0 equ 0
                        	    51: _Reset_STAT_INT	equ 2<<3			; 10   000 0010 -> 001 0000
                        	    52: _Ch_Reset		equ 3<<3			; 18
                        	    53: _EN_INT_Nx_Char	equ $20				; (20)  000 0100  -> 010 0000
                        	    54: _Reset_TxINT_Pend equ $28			; (28)  000 0101 ->  010 1000
                        	    55: _Error_Reset 	equ $30				; (30)	
                        	    56: _Ret_F_Int		equ $38				; (38)  0000111  ->  0011 1000
                        	    57: 
                        	    58: ;Write register 1
                        	    59: WR1 equ 1
                        	    60: _Ext_INT_EN			equ 1
                        	    61: _Tx_INT_EN 			equ 2
                        	    62: _Status_Vector		equ 4
                        	    63: _Rx_INT_Disable		equ 0
                        	    64: _Rx_INT_First_Char  equ $08
                        	    65: _INT_All_Rx_Char_P 	equ $10 
                        	    66: _Int_All_Rx_Char_NP	equ $18
                        	    67: _WAIT_READY_R_T 	equ $20
                        	    68: _WAIT_READY_FUNC	equ $40
                        	    69: _WAIT_READY_EN		equ $80
                        	    70: 
                        	    71: WR2 equ 2
                        	    72: 
                        	    73: ;Write register 3
                        	    74: WR3 equ 3
                        	    75: _Rx_Enable 			equ $01
                        	    76: _Rx_Disable 		equ $00
                        	    77: _Auto_Enable		equ $20
                        	    78: _RX_5_bits			equ $00
                        	    79: _RX_6_bits			equ $40
                        	    80: _RX_7_bits			equ $80
                        	    81: _RX_8_bits			equ $C0
                        	    82: 
                        	    83: ;Write register 4
                        	    84: WR4 equ 4
                        	    85: _Parity_EN			equ $01
                        	    86: _Parity_Even		equ $02
                        	    87: _Stop_1_bit			equ $04
                        	    88: _Stop_1_2_bit		equ $08
                        	    89: _Stop_2_bit			equ $0C
                        	    90: _X1_Clock_mode		equ $00
                        	    91: _X16_Clock_mode		equ $40
                        	    92: _X32_Clock_mode		equ $80
                        	    93: _X64_Clock_mode		equ $C0
                        	    94: 
                        	    95: ;Write register 5
                        	    96: WR5 equ 5
                        	    97: _RTS_Enable			equ $02
                        	    98: _Tx_Enable 			equ $08
                        	    99: _Send_Break			equ $10
                        	   100: _Tx_5bits_char		equ $00
                        	   101: _Tx_7bits_char		equ $20
                        	   102: _Tx_6bits_char		equ $40
                        	   103: _Tx_8bits_char		equ $60
                        	   104: _DTR_Enable 		equ $80
                        	   105: 
                        	   106: EOT_FOUND			equ $02
                        	   107: _err01_				equ	$08
                        	   108: _err02_				equ	$09
                        	   109: _err03_				equ	$0C
                        	   110: _err04_				equ	$0D
                        	   111: _err05_				equ	$0E
                        	   112: CTCpulse			equ $0A
                        	   113: CTCtimeout			equ $0B
                        	   114: 
                        	   115: 
                        	   116: ; CTC stuff
                        	   117: ;******************************************
                        	   118: CH0		equ 	_Z80CTC_Base	  ; = $10, linker script
                        	   119: CH1		equ 	_Z80CTC_Base+1	
                        	   120: CH2		equ 	_Z80CTC_Base+2	
                        	   121: CH3		equ 	_Z80CTC_Base+3	
                        	   122: CTC_TIMEOUT 	equ $EE			; timeout flag
                        	   123: 
                        	   124: _INT_EN 	equ 	$80		; D7 - 1 enables interrupt
                        	   125: _Counter 	equ 	$40		; D6 - 1 Counter Mode  		0 - Timer Mode
                        	   126: _Timer 		equ 	$00
                        	   127: _Prescaler	equ 	$20		; D5 - 1 Prescaler 256		0 - Prescaler 16
                        	   128: _Rising 	equ 	$10		; D4 - 1 CLK/TRG rising		0 - CLK/TRG falling
                        	   129: _CLK_TRG_Start 	equ $08		; D3 - 1 CLK/TRG start timer  0 - automatic start during LOAD_BASE
                        	   130: _TC_Follow 	equ 	$04		; D2 - 1 time constant follows
                        	   131: _Reset 		equ 	$02		; D1 - 1 Software reset
                        	   132: _CW 		equ 	$01		; D0 - 1 Control word 		0 - Vector	
                        	   133: 
                        	   134: ; Interrupt vectors for CTC
                        	   135: CTC_CH0_I_Vector	EQU     SIO_Int_Vec+$10		;CTC channel 0 interrupt vector 
                        	   136: CTC_CH1_I_Vector	EQU     SIO_Int_Vec+$12		;CTC channel 1 interrupt vector 
                        	   137: CTC_CH2_I_Vector	EQU     SIO_Int_Vec+$14		;CTC channel 2 interrupt vector 
                        	   138: CTC_CH3_I_Vector	EQU     SIO_Int_Vec+$16		;CTC channel 3 interrupt vector 
                        	   139: 
                        	   140: ; Data tables  (upper EPROM/FLASH)
                        	   141: ; stack  				= $FF00
                        	   142: Heap				= $F000				; space for variable storage
                        	   143: 
                        	   144: ; variables  	(upper ram)
                        	   145: PIO_B_value:		= $F1D0
                        	   146: Result_NumToHex:	= $F1F0
                        	   147: 
                        	   148: 
                        	   149: ;*****	ALIGN command  : 00 removes all align commands
                        	   150: DOALIGN 	EQU 	00
                        	   151: 
                        	   152: EscChar:		EQU		1BH				;ASCII EscChar CHARACTER
                        	   153: TestChar:		EQU		'A'				;TEST CHARACTER = A
                        	   154: CRChar:			EQU		0DH				; carrige return
                        	   155: LFChar:			EQU		0AH				; line feed
                        	   156: NUL			EQU		00
                        	   157: SOH			EQU		01
                        	   158: STX			EQU		02
                        	   159: ETX			EQU		03
                        	   160: EOT			EQU		04
                        	   161: ENQ			EQU		05
                        	   162: ACK			EQU		06
                        	   163: BEL			EQU		07
                        	   164: BS			EQU		08h
                        	   165: HT			EQU		09h
                        	   166: LF			EQU		0AH
                        	   167: VT			EQU		0BH
                        	   168: FF			EQU		0CH
                        	   169: CR			EQU		0DH
                        	   170: SO			EQU		0Eh
                        	   171: SI			EQU		0Fh
                        	   172: DLE			EQU		10h
                        	   173: DC1			EQU		11h
                        	   174: DC2			EQU		12h
                        	   175: DC3			EQU		13h
                        	   176: DC4			EQU		14h
                        	   177: NAK			EQU		15h
                        	   178: SYN			EQU		16h
                        	   179: ETB			EQU		17h
                        	   180: CAN			EQU		18h
                        	   181: EM			EQU		19h
                        	   182: SUB			EQU		1Ah
                        	   183: ESC			EQU		1Bh
                        	   184: FS			EQU		1Ch
                        	   185: GS			EQU		1Dh
                        	   186: RS			EQU		1Eh
                        	   187: US			EQU		1Fh
                        	   188: ITEM		EQU		1Ch
                        	   189: STEND		EQU		1Dh
                        	   190: LISTEND		EQU		1Eh
                        	   191: SP			EQU		20h
                        	   192: CDEL		EQU 	0xEE
                        	   193: 
                        	   194: ; 	Variables in SRAM   HEAP TOP  - Moved to load script !
                        	   195: ;DATA LOCATIONS
                        	   196: ; LedScreen:		EQU     0D00H ;Byte Recieved, Atomic Flag and Buffer size for LED display      (6-bytes)
                        	   197: ; BufCnt:			EQU     0D06H ;Number of bytes active in the buffer                            (1-byte)
                        	   198: ; BufStat:		EQU     0D07H ;The state of the buffer okay (00), error (EE), auto (AA)        (1-byte)
                        	   199: ; CByteRec:		EQU     0D08H ;Current byte received from SIO_0                                  (1-byte)
                        	   200: ; AutoTransmit:	EQU     0D09H ;Flag to automatically transmit to SIO_0, or by key press FF=auto  (1-byte)
                        	   201: ; KeyPressed:		EQU     0D0AH ;Key Pressed Flag, 00-False, FF-True                             (1-byte)
                        	   202: 
                        	   203: ;BUFFER CONFIGURATION
                        	   204: ; CBufLoc:		EQU     0B00H ;Location of circular buffer
                        	   205: ; CBufHead:		EQU     0D0BH ;Pointer to the Head of the Circular buffer                      (1-byte)
                        	   206: ; CBufTail:		EQU     0D0CH ;Pointer to the Tail of the Circular buffer                      (1-byte)
                        	   207: 
                        	   208: ;BUFFER SIZES, change to suit
                        	   209: ; BUFF16:			EQU     0FH   ;16 bytes
                        	   210: ; BUFF32:			EQU     1FH   ;32 bytes
                        	   211: ; BUFF64:			EQU     3FH   ;64 bytes
                        	   212: ; BUFF128:		EQU     7FH   ;128 bytes
                        	   213: ; BUFF256:		EQU     0FFH  ;256 bytes
                        	   214: ; CBufSize:		EQU     BUFF32  ;16 bytes (Change if required)
                        	   215: 
                        	   216: 
                        	   217: ;INTERRUPT VECTOR TABLE SETUP
                        	   218: ;The interrupt will call one of these service routines depending on the type of interrupt
                        	   219: ;There are 4 reasons the interrupt will occur:
                        	   220: ; 1. Transmit Buffer Empty - Indicating that data can be sent to the SIO_0
                        	   221: ; 2. External/Status Change - Indicating a change in the modem line or break condition
                        	   222: ; 3. Receive Character Available - Indicating that data has been sent to CPU
                        	   223: ; 4. Special Receive Condition - Indicates a buffer overrun or parity error condtion has occured
                        	   224: ;
                        	   225: ;Interrupt mode 2 (IM 2), requires a 16 bit table of addresses. The High byte of the 
                        	   226: ;address is the value in the interrupt register 'I'.  The Low byte of the address is
                        	   227: ;placed on the data bus from the SIO_0 when an interrupt is triggered. The follwing table
                        	   228: ;shows what bits are set on the data bus.  This is used to index the vector table:
                        	   229: ;Note: D0, D4-7 are set via Write Register 2 (Channel B on the SIO_0).  this is set to 00H
                        	   230: ;
                        	   231: ; Channel   D3  D2  D1  Addr  Interrupt type
                        	   232: ; -------   --  --  --  ----  --------------
                        	   233: ;    B       0   0   0   00H  Transmit Buffer Empty
                        	   234: ;    B       0   0   1   02H  External/Status Change
                        	   235: ;    B       0   1   0   04H  Receive Character Available
                        	   236: ;    B       0   1   1   06H  Special Receive Condition
                        	   237: ;    A       1   0   0   08H  Transmit Buffer Empty
                        	   238: ;    A       1   0   1   0AH  External/Status Change
                        	   239: ;    A       1   1   0   0CH  Receive Character Available
                        	   240: ;    A       1   1   1   0EH  Special Receive Condition
                        	   241: ;
                        	   242: ; SIO_IntVectors:		EQU		0E00H      ;Interrupt Vector Base
                        	   243: ; SIO_WriteVector:		EQU		SIO_IntVectors+08H ;Write Interrupt Vector
                        	   244: ; SIO_ExternalVector:	EQU		SIO_IntVectors+0AH ;External Status Interrupt Vector
                        	   245: ; SIO_ReadVector:		EQU		SIO_IntVectors+0CH ;Read Interrupt Vector
                        	   246: ; SIO_SpecialVector:		EQU		SIO_IntVectors+0EH ;Special Receive Interrupt Vector
                        	   247: 
                        	   248: 
                        	   249: 	; SIO_A_D			EQU 	1CH					;SIO_0 CHANNEL A DATA
                        	   250: 	; SIO_B_D			EQU 	1EH					; SIO_0 CHANNEL B DATA
                        	   251: 	; SIO_A_C			EQU		1DH					;SIO_0 CHANNEL A COMMANDS/STATUS
                        	   252: 	; SIO_B_C			EQU		1FH					;SIO_0 CHANNEL B COMMANDS/STATUS
                        	   253: 
                        	   254: ;****************************************************************************
                        	   255: 
                        	   256: 
                        	   257: 
                        	   258: 
                        	   259: ; Define the memory size to be used for the CP/M configuration
                        	   260: ; MEM:    equ 60
                        	   261: 
                        	   262: ; The CPM origin will be at: (MEM-7)*1024
                        	   263: ; This screwy convention is due to the way that that the CP/M origin is defined.
                        	   264: ; CPM_BASE:	equ	(MEM-7)*1024
                        	   265: 
                        	   266: ; LOAD_BASE:	equ	0xc000		; where the boot loader reads the image from the SD card
                        	   267: 
                        	   268: 
                        	   269: 

Source: "stdin"
                        	     8: 		xref	RAM_Start, SC5B,SC4C,SC8B, WriteLineCRNL, WriteLine, ReadLine, CRLF,DumpRegisters
                        	     9: 
                        	    10: 		xref	stacktop
                        	    11: 		global 	setFLASHBank, setSRAMBank, enableFLASH, disableFLASH, setFLASHBank
                        	    12: 
00:0000 31F0FF          	    13: 		ld		sp,stacktop
                        	    14: 		
00:0003 C30000          	    15: 		jp 		_RAMSTART
                        	    16: 
00:0006 C30000          	    17: 		jp		setBanks
                        	    18: 		align 3
                        	    19: 		; section RST08
00:0010 C30000          	    20: 		jp	WriteLineCRNL	
                        	    21: 		align 3
                        	    22: 		; section RST10	
00:0018 C30000          	    23: 		jp 	WriteLine
                        	    24: 		align 3
                        	    25: 		; section RST18	
00:0020 C30000          	    26: 		jp	ReadLine
                        	    27: 		align 3
                        	    28: 		; section RST20	
00:0028 C30000          	    29: 		jp	CRLF
                        	    30: 		align 3
                        	    31: 		; section RST28	
00:0030 00              	    32: 		db 0,0,0
00:0031 00
00:0032 00
                        	    33: 		align 3
                        	    34: 		; section RST30	
00:0038 00              	    35: 		db 0,0,0
00:0039 00
00:003A 00
                        	    36: 		align 3
                        	    37: 		; section RST38	
00:0040 C30000          	    38: 		jp	DumpRegisters
                        	    39: 
                        	    40: 
                        	    41: ;********************************************************
                        	    42: 		section  INT_IM1     ;FLASH mem at 0066h
                        	    43: ;********************************************************
                        	    44: 
01:0000 0E04            	    45: 		LD C,04		; jp PIO_A_INT
01:0002 0E04            	    46: 		LD C,04		; jp PIO_A_INT
01:0004 0E04            	    47: 		LD C,04		; jp PIO_A_INT
01:0006 1604            	    48: 		LD D,04		; jp PIO_A_INT
01:0008 ED45            	    49: 		retn		; jp PIO_A_INT
01:000A 0004            	    50: 		defw $0400          ; NMI adress table    
                        	    51: 
                        	    52: 
                        	    53: 
                        	    54: ;************************************************************************************************
                        	    55: ;************************************************************************************************
                        	    56: ;***		FLASH startup sequence (starts at $0080)
                        	    57: ;************************************************************************************************
                        	    58: ;************************************************************************************************
                        	    59: ;********************************************************
                        	    60: 		section  INIT_BODY     ;FLASH mem at 0080h
                        	    61: ;********************************************************
                        	    62: 
                        	    63: 		align 4
                        	    64: setBanks:
                        	    65: 		; ld 		A,$80					; set bit 7 - SRAM64 set
                        	    66: 		; ld 		(memBankID),A			; clear memory banks
                        	    67: 		
02:0000 CD7D00          	    68: 		call 	EEPIO_Init
                        	    69: 		
                        	    70: 	ifd 	GPIODEBUG
                        	    71: 		ld 		A,$55
                        	    72: 		out 	(gpio_out),A
                        	    73: 	endif
                        	    74: 
02:0003 AF              	    75: 		xor 	A					; A=0
02:0004 320000          	    76: 		ld 		(memBankID),A		; set memory banks #0
                        	    77: 	ifd NOFLASH
                        	    78: 		call 	disableFLASH		; NO FLASH 
                        	    79: 	else	
02:0007 CD5100          	    80: 		call 	enableFLASH			; start from FLASH
                        	    81: 	endif
                        	    82: 
02:000A AF              	    83: 		xor 	A
02:000B CD2E00          	    84: 		call 	setSRAMBank			; ram bank #0
                        	    85: 
                        	    86: 	ifd 	GPIODEBUG
                        	    87: 		ld 		A,$77
                        	    88: 		out 	(gpio_out),A
                        	    89: 	endif
                        	    90: 
                        	    91: 
02:000E CD7400          	    92: 		call 	enableIC620_OE 		; enable the outputs.
                        	    93: 	ifd BOOTLOAD
02:0011 C30000          	    94: 		jp 		SD_USB_startup
                        	    95: 	else	
                        	    96: 		jp		MONITOR_Start
                        	    97: 	endif
                        	    98: 
                        	    99: ;********************************************************************************************
                        	   100: ;********************************************************************************************	
                        	   101: 		; ******   Copy data from flash $400 to $2000 to SRAM $D000
                        	   102: 		; Code in $D002-D005 = '0000' - 'AAAA': copy from flash
                        	   103: 		; Code in $D002-D005 = 'CCCC': code uploaded from xmodem/or DMA. Do not copy from flash
                        	   104: 
02:0014 2102D0          	   105: 		ld 		HL,$D002
02:0017 3E43            	   106: 		ld  	A,'C'
02:0019 010400          	   107: 		ld 		BC,04
                        	   108: 
02:001C EDA1            	   109: .nxt:	cpi 	
02:001E 2003            	   110: 		jr 		NZ,doCopy
02:0020 EA1C00          	   111: 		jp 		PE,.nxt
                        	   112: 		;JP PE means "branch if BC has not been decremented to 0."
                        	   113: 
                        	   114: 		; the code 'CCCC' is found in $D002-D005, do not copy from flashmem.
                        	   115: 		; jp		MONITOR_Start
                        	   116: 
                        	   117: doCopy:
02:0023 210004          	   118: 		ld 		HL,$400				; source
02:0026 1100D0          	   119: 		ld 		DE,$D000	 			; destination
02:0029 01F01F          	   120: 		ld 		BC,$1FF0				; 
                        	   121: 
02:002C EDB0            	   122: 		ldir
                        	   123: 
                        	   124: 		; jp		MONITOR_Start
                        	   125: 
                        	   126: 
                        	   127: ;********************************************************************************************
                        	   128: ;********************************************************************************************	
                        	   129: setSRAMBank:
                        	   130: 		; ***	set the SRAM bank ID; Bank ID in A
                        	   131: 
02:002E E5              	   132: 		push 	HL
02:002F C5              	   133: 		push 	BC
02:0030 210000          	   134: 		ld 		HL,memBankID
02:0033 E60F            	   135: 		and 	$0F 				; clear all bits but 0-3 in A
                        	   136: 
02:0035 47              	   137: 		ld 		B,A
02:0036 7E              	   138: 		ld 		A,(HL)				; get the actl. mem Bank ID
02:0037 E6F0            	   139: 		and 	$F0  				; zero bits 0-3
02:0039 180F            	   140: 		jr 		putBank
                        	   141: 
                        	   142: ;********************************************************************************************
                        	   143: ;********************************************************************************************	
                        	   144: 
                        	   145: setFLASHBank:
                        	   146: 		; ***	set the FLASH bank ID; Bank ID in A
                        	   147: 
02:003B E5              	   148: 		push 	HL
02:003C C5              	   149: 		push 	BC
02:003D 210000          	   150: 		ld 		HL,memBankID
02:0040 E607            	   151: 		and 	$07 				; clear all bits but 0-2
02:0042 07              	   152: 		rlca
02:0043 07              	   153: 		rlca
02:0044 07              	   154: 		rlca
02:0045 07              	   155: 		rlca						; bank ID = bits 4-6
                        	   156: 
02:0046 47              	   157: 		ld 		B,A
02:0047 7E              	   158: 		ld 		A,(HL)				; get the actl. mem Bank ID
02:0048 E68F            	   159: 		and 	$8F  				; zero bits 4-6
                        	   160: putBank:
02:004A B0              	   161: 		or 		B					; put new EEP bank ID in A...
02:004B 77              	   162: 		ld 		(HL),A				; store new value
02:004C D300            	   163: 		out 	(_Z80_BankCS),A		; set bank register number 0 and 64K_SRAM=1	
02:004E C1              	   164: 		pop 	BC
02:004F E1              	   165: 		pop 	HL
02:0050 C9              	   166: 		ret 
                        	   167: 
                        	   168: ;********************************************************************************************
                        	   169: ;********************************************************************************************	
                        	   170: enableFLASH:
                        	   171: 		; ***	activate FLASH MEM, leave bank ID unchanged; 
                        	   172: 				; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	   173: 				; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
02:0051 E5              	   174: 		push 	HL
02:0052 C5              	   175: 		push 	BC
02:0053 210000          	   176: 		ld 		HL,rstBankID
02:0056 CB9E            	   177: 		res 	3,(HL)				; clear bit 3 -> enable FLASH
02:0058 CB96            	   178: 		res 	2,(HL)				; temp enable reset of IC622
                        	   179: putBankF:
02:005A 7E              	   180: 		ld 		A,(HL)
02:005B D300            	   181: 		out 	(_CE_RST_BANK),A		; set bank register number 0 and 64K_SRAM=1	
02:005D C1              	   182: 		pop 	BC
02:005E E1              	   183: 		pop 	HL
02:005F C9              	   184: 		ret 
                        	   185: 		
                        	   186: ;********************************************************************************************
                        	   187: ;********************************************************************************************	
                        	   188: disableFLASH:
                        	   189: 		; ***	disconnect FLASH MEM, leave bank ID unchanged; 
                        	   190: 				; if '64K_SRAM' 1  ($08) no FLASH memory is selected
                        	   191: 				; if '64K_SRAM' 0  ($00) FLASH memory is lower 32k and SRAM upper 32k
02:0060 E5              	   192: 		push 	HL
02:0061 C5              	   193: 		push 	BC
02:0062 210000          	   194: 		ld 		HL,rstBankID
02:0065 CBD6            	   195: 		set 	2,(HL) 			; temp disable reset of IC622
02:0067 CBDE            	   196: 		set 	3,(HL)			; set bit 3 -> disable FLASH
02:0069 18EF            	   197: 		jr 		putBankF
                        	   198: 
                        	   199: ;********************************************************************************************
                        	   200: ;********************************************************************************************	
                        	   201: 
                        	   202: 
                        	   203: disableIC620_OE:
                        	   204: 		; ***	Set IC620 pin 1 high
02:006B E5              	   205: 		push 	HL
02:006C C5              	   206: 		push 	BC
02:006D 210000          	   207: 		ld 		HL,rstBankID
02:0070 CB86            	   208: 		res 	0,(HL)
02:0072 18E6            	   209: 		jr 		putBankF
                        	   210: 
                        	   211: 
                        	   212: ;********************************************************************************************
                        	   213: ;********************************************************************************************	
                        	   214: 
                        	   215: enableIC620_OE: 
                        	   216: 		; ***	Set IC620 pin 1 low
02:0074 E5              	   217: 		push 	HL
02:0075 C5              	   218: 		push 	BC
02:0076 210000          	   219: 		ld 		HL,rstBankID
02:0079 CBC6            	   220: 		set 	0,(HL)
02:007B 18DD            	   221: 		jr 		putBankF
                        	   222: 
                        	   223: 
                        	   224: ;********************************************************************************************
                        	   225: ;********************************************************************************************	
                        	   226: 
                        	   227: 		; out (_8Bitsout),A
                        	   228: ; 
                        	   229: EEPIO_Init:
                        	   230: ; ;----------******************* PIO PORT A
02:007D 3E0F            	   231: 		ld A, $0F                 ;mode 1 out
02:007F D301            	   232: 		out (portA_Contr), A         ; set port A as output
                        	   233: ; 		ld A, Interupt_vector&0xFF                   ; low byte of INT table
                        	   234: ; 		out (portA_Contr), A         ; PIO A interrupt vector
02:0081 3E03            	   235: 		ld A, $03
02:0083 D301            	   236: 		out (portA_Contr), A         ; PIO A interrupt disable
                        	   237: ; 		ld a,Interupt_vector>>8                   ; high byte of INT table
                        	   238: ; 		ld I,A
                        	   239: ; 		ei
                        	   240: ; ;----------******************* PIO PORT B
02:0085 3E0F            	   241:  		ld A, $0F                    ;mode 0 output 
02:0087 D303            	   242:  		out (portB_Contr), A         ; set port B as output
02:0089 3E03            	   243:  		ld A, $03
02:008B D303            	   244:  		out (portB_Contr), A         ; PIO B interrupt disable
02:008D 3E00            	   245:  		ld a,0
02:008F 32D0F1          	   246:  		ld (PIO_B_value),a
02:0092 D302            	   247:  		out (portB_Data), a
02:0094 C9              	   248: 	ret
                        	   249:  
                        	   250: 
                        	   251: 		
                        	   252: ;********************************************************		
                        	   253: 		section EEtestprog			; main program in sram
                        	   254: ;********************************************************	
                        	   255: 
                        	   256: 		; xdef	RDATA_END,RDATA,TB_length
                        	   257: hit:
                        	   258: 
03:0000 CD7D00          	   259: 		call	EEPIO_Init
03:0003 F3              	   260: 		di
                        	   261: hit3:
03:0004 3E81            	   262: 		LD 		A,$81
                        	   263: 		; out 	(_CE_RST_BANK),A
03:0006 D302            	   264: 		out 	(gpio_out),A
                        	   265: 
                        	   266: 
03:0008 3E7E            	   267: 		LD 		A,$7E
                        	   268: 		; out 	(_Z80_BankCS),A
03:000A D302            	   269: 		out 	(gpio_out),A
                        	   270: 
03:000C DD210080        	   271: 		ld 		ix,$8000
                        	   272: 
03:0010 01000F          	   273: 		ld 		bc,$0F00
03:0013 3E3F            	   274: 		ld 		A,$3F
03:0015 DD7700          	   275: 		ld 		(IX+0),A
03:0018 DD23            	   276: 		inc 	IX
                        	   277: .nxt1:
03:001A DD7700          	   278: 		ld 		(IX+0),A
03:001D D302            	   279: 		out 	(gpio_out),A
03:001F DD23            	   280: 		inc 	IX
03:0021 3C              	   281: 		inc 	A
03:0022 10F6            	   282: 		djnz 	.nxt1			
                        	   283: 
                        	   284: ;***********************************
03:0024 3E1B            	   285: 	 	ld 		A,$1B
03:0026 D302            	   286: 		out 	(gpio_out),A
03:0028 D302            	   287: 		out 	(gpio_out),A
03:002A 3EE3            	   288: 	 	ld 		A,$E3
03:002C D302            	   289: 		out 	(gpio_out),A
03:002E 3E0C            	   290: 		ld 		A,$0C
03:0030 D302            	   291: 		out 	(gpio_out),A
                        	   292: 		
03:0032 3E0F            	   293: 		ld 		A,$0F
03:0034 D302            	   294: 		out 	(gpio_out),A
                        	   295: 
03:0036 CD0000          	   296: 		CALL 	InitBuffers			;INITIALIZE in/Out buffers,	;INITIALIZE SIO_0. INTERRUPT SYSTEM
                        	   297: 			; initialize buffer counters and pointers.
                        	   298: 
                        	   299: 
03:0039 CD0000          	   300: 		call 	CTC_Init
                        	   301: 
                        	   302: 
03:003C 3E1D            	   303: 		ld 		A,$1D
03:003E D302            	   304: 		out 	(gpio_out),A
03:0040 3E00            	   305: 		ld 		A,$00
03:0042 D302            	   306: 		out 	(gpio_out),A
                        	   307: 
03:0044 CD0000          	   308: 		call 	SIO_Init
                        	   309: 		; ld      HL,SIO_0INT		;BASE ADDRESS OF INITIALIZATION ARRAY
                        	   310: 		; call    InitSIO_0Ports			; INITIALIZE SIO_0
                        	   311: 
                        	   312: 
03:0047 3E1E            	   313: 		ld 		A,$1E
03:0049 D302            	   314: 		out 	(gpio_out),A
                        	   315: 
03:004B 3E23            	   316: 		ld 		A,'#'
03:004D D300            	   317: 		out		(SIO_A_D),A			;output data
03:004F CD8501          	   318: 		call 	TX_EMP
                        	   319: 
03:0052 3E18            	   320: 		ld 		A,$18
03:0054 D302            	   321: 		out 	(gpio_out),A
                        	   322: 
                        	   323: 		; ld 		A,'A'
                        	   324: 		; call  	WriteChar
                        	   325: 
                        	   326: 		; ld 		A,'B'
                        	   327: 		; call  	WriteChar
                        	   328: 
                        	   329: 		; ld 		A,'C'
                        	   330: 		; call  	WriteChar
                        	   331: 		; call 	CRLF
                        	   332: 
03:0056 3E1A            	   333: 		ld 		A,$1A
03:0058 D302            	   334: 		out 	(gpio_out),A
                        	   335: 
03:005A CD0000          	   336: 		call 	writeSTRBelow
03:005D 000D0A          	   337: 		defb   	"\0\r\n"
03:0060 2323232323232323	   338: 		defb	"##########################################################\r\n"
03:0068 2323232323232323
03:0070 2323232323232323
03:0078 2323232323232323
03:0080 2323232323232323
03:0088 2323232323232323
03:0090 2323232323232323
03:0098 23230D0A
03:009C 2D2A2D2A2F2D2A2F	   339: 		defb	"-*-*/-*/-*/-*/-*//-*/-*/-*/-*/-*/-*/**-/-*/-*/-*/-*/-*/-*/\r\n"
03:00A4 2D2A2F2D2A2F2D2A
03:00AC 2F2F2D2A2F2D2A2F
03:00B4 2D2A2F2D2A2F2D2A
03:00BC 2F2D2A2F2A2A2D2F
03:00C4 2D2A2F2D2A2F2D2A
03:00CC 2F2D2A2F2D2A2F2D
03:00D4 2A2F0D0A
03:00D8 2D2B2D2B2D2B2D2B	   340: 		defb	"-+-+-+-+-+-+-+---++--++--++--++--++--+++-+-+-+-+-+-+-+-+-+\r\n"
03:00E0 2D2B2D2B2D2B2D2D
03:00E8 2D2B2B2D2D2B2B2D
03:00F0 2D2B2B2D2D2B2B2D
03:00F8 2D2B2B2D2D2B2B2B
03:0100 2D2B2D2B2D2B2D2B
03:0108 2D2B2D2B2D2B2D2B
03:0110 2D2B0D0A
03:0114 546865205A383020	   341: 		defb	"The Z80 Board Awakened 2025\r\n"
03:011C 426F617264204177
03:0124 616B656E65642032
03:012C 3032350D0A
03:0131 20202020464C4153	   342: 		defb	"    FLASH->SRAM 0xD000.\r\n"
03:0139 482D3E5352414D20
03:0141 3078443030302E0D
03:0149 0A
03:014A 2020202032303236	   343: 		defb	"    2026-02-07 .\r\n"
03:0152 2D30322D3037202E
03:015A 0D0A
03:015C 0000            	   344: 		defb	"\0\0"
                        	   345: 
03:015E 76              	   346: 		halt
                        	   347: 
                        	   348: 
                        	   349: ;***************************
03:015F 76              	   350: 		halt
                        	   351: ;**************************
03:0160 210204          	   352: 		ld  	HL,$0402
                        	   353: 
03:0163 CD7D00          	   354: 		call 	EEPIO_Init
03:0166 3E30            	   355: 		LD 		A,$30
                        	   356: 
03:0168 0640            	   357: 		ld 		B,$40
                        	   358: hit2:		
03:016A 77              	   359: 		ld 		(HL),a
03:016B 3C              	   360: 		inc 	a
03:016C 23              	   361: 		INC 	HL
03:016D D300            	   362: 		out 	(gpio_in),A
                        	   363: 
                        	   364: 	
03:016F 10F9            	   365: 		djnz 	hit2
                        	   366: 	
03:0171 77              	   367: 		LD 		(hl),a
03:0172 3C              	   368: 		inc 	a
03:0173 23              	   369: 		INC 	HL
03:0174 D300            	   370: 		out 	(gpio_in),A
03:0176 77              	   371: 		LD 		(hl),a
03:0177 3C              	   372: 		inc 	a
03:0178 23              	   373: 		INC 	HL
03:0179 D300            	   374: 		out 	(gpio_in),A
03:017B 77              	   375: 		LD 		(hl),a
03:017C 3C              	   376: 		inc 	a
03:017D 23              	   377: 		INC 	HL
03:017E D300            	   378: 		out 	(gpio_in),A
03:0180 77              	   379: 		LD 		(hl),a
                        	   380: 
03:0181 3E0C            	   381: 		LD 		A,$0C
03:0183 D300            	   382: 		out 	(_CE_RST_BANK),A
                        	   383: 
                        	   384: 		
                        	   385: 
03:0185 97              	   386: TX_EMP:	sub a
03:0186 3C              	   387: 		inc a
03:0187 D302            	   388: 		out (SIO_A_C),A
03:0189 DB02            	   389: 		in 	a,(SIO_A_C)
03:018B CB47            	   390: 		bit 0,A
03:018D 28F6            	   391: 		jr  z,TX_EMP
03:018F C9              	   392: 		ret
                        	   393: 
                        	   394: 
                        	   395: 
                        	   396: 
                        	   397: .end
                        	   398: 
                        	   399: 
                        	   400: ;************************************************************************
                        	   401: ; ShowPC_HALT:
                        	   402: ; Dump prog counter prior to HALT instr. value present in stack (pointed by SP).
                        	   403: ; uses  IX (pointer to HEX chars)
                        	   404: ;       IY (pointer at stack)
                        	   405: ;       BC ( count)
                        	   406: ; ;       HL (value for conversion to HEX)
                        	   407: ; ;       DE (positon of display 2004A)
                        	   408: 	if DOALIGN
                        	   409: 		align 8
                        	   410: 	endif
                        	   411:             
                        	   412: ; ShowPC_HALT:
                        	   413: ; 		ld (SP_value), SP	; save contents of SP
                        	   414: ; 		push AF
                        	   415: ; 		push BC
                        	   416: ; 		push DE
                        	   417: ; 		push HL
                        	   418: ; 		ld HL,(SP_value)
                        	   419: ; 		push HL				; push the SP value on the stack...
                        	   420: ; 		push IX
                        	   421: ; 		Push IY
                        	   422: 
                        	   423: 		
                        	   424: ; 		; first print the labels: adr: t_str4 - 7
                        	   425: ; 		;*****************************************
                        	   426: ; 		ld de, $0000		; row 0, col 1
                        	   427: ; 		ld IX, t_str4
                        	   428: ; nxt2:
                        	   429: ; 		call setcursor		; set cur
                        	   430: ; 		ld B, t_str5-t_str4	; all 4 rows has the same length
                        	   431: ; nxt3:
                        	   432: ; 		ld a, (ix+0)
                        	   433: ; 		inc ix
                        	   434: ; 		call writedata
                        	   435: ; 		djnz nxt3
                        	   436: 
                        	   437: ; 		inc D				;Next row
                        	   438: ; 		ld A,D
                        	   439: ; 		cp $04				; all rows printed ?
                        	   440: ; 		jr NZ, nxt2
                        	   441: 
                        	   442: 
                        	   443: ; 		; set all values, first value (SP)
                        	   444: ; 		;***************************************
                        	   445: ; 		ld iy,(SP_value)		; top of stored stack
                        	   446: ; 		ld IX,cur_pos			; table of cursor positions
                        	   447: 		
                        	   448: 		
                        	   449: ; nxt4:	ld L,(iy+0)
                        	   450: ; 		ld H,(iy+1)
                        	   451: ; 		dec IY
                        	   452: ; 		dec IY					; next value in stack
                        	   453: 
                        	   454: ; 		call Num4Hex			; convert value in HL
                        	   455: ; 		;
                        	   456: ; 		ld E,(IX+0)
                        	   457: ; 		ld D,(IX+1)			; DE - cursor pos d-row e-col
                        	   458: ; 		inc IX
                        	   459: ; 		inc IX				; IX - next cursor position adr.
                        	   460: ; 		call setcursor		; runs also 'command'
                        	   461: ; 	;
                        	   462: ; 		ld b, $04
                        	   463: ; 		push IX
                        	   464: ; 		ld IX, Result_NumToHex	; pointer to hex characters
                        	   465: ; nxt5:
                        	   466: ; 		ld a, (IX+0)
                        	   467: ; 		inc IX
                        	   468: ; 		call writedata
                        	   469: ; 		djnz nxt5
                        	   470: ; 		pop IX
                        	   471: ; 		ld a,(IX+0)				
                        	   472: ; 		cp $FF					; check if end of cursor positions
                        	   473: ; 		jr NZ, nxt4
                        	   474: 
                        	   475: ; 		; print flags Z/NZ, C/NC, PO/PE, P/M
                        	   476: ; 		;***************************************
                        	   477: ; 		ld DE, $0011
                        	   478: ; 		call setcursor
                        	   479: ; 		ld IY,(SP_value)		; IY - top of stack
                        	   480: ; 		ld A, (IY-2)
                        	   481: ; 		ld (AF_value), A
                        	   482: ; 		bit 6, (IY-2)					; test for Z flag
                        	   483: ; 		jr NZ, nx_noNZ			
                        	   484: ; 		ld A,'N'
                        	   485: ; 		call writedata
                        	   486: ; nx_noNZ:
                        	   487: ; 		ld A,'Z'
                        	   488: ; 		call writedata
                        	   489: ; 		inc D					; next row (E=$11), next flag (C)
                        	   490: ; 		call setcursor
                        	   491: ; 		;-----------------------------
                        	   492: 		
                        	   493: ; 		bit 0, (IY-2)					; test for C flag
                        	   494: ; 		jr NZ, nx_noNC			
                        	   495: ; 		ld A,'N'
                        	   496: ; 		call writedata
                        	   497: ; nx_noNC:
                        	   498: ; 		ld A,'C'
                        	   499: ; 		call writedata
                        	   500: ; 		inc D					; next row (E=$11), next flag (PE/PO)
                        	   501: ; 		call setcursor
                        	   502: ; 		;-----------------------------
                        	   503: ; 		ld A,'P'
                        	   504: ; 		call writedata
                        	   505: ; 		bit 2,(IY-2)					; test for P/V flag
                        	   506: ; 		jr Z, nx_PO			
                        	   507: ; 		ld A,'E'				;parity even (PE)
                        	   508: ; 		call writedata
                        	   509: ; 		jr nx_sign
                        	   510: ; nx_PO:
                        	   511: ; 		ld A,'O'					;parity even (PE)
                        	   512: ; 		call writedata
                        	   513: ; nx_sign:		
                        	   514: ; 		inc D					; next row (E=$11), next flag (sign)
                        	   515: ; 		call setcursor
                        	   516: ; 		;-----------------------------
                        	   517: ; 		bit 7,(IY-2)					; test for S flag S=0 positive
                        	   518: ; 		jr Z, nx_S			
                        	   519: ; 		ld A,'M'				;sign negative (Minus)
                        	   520: ; 		call writedata
                        	   521: ; 		jr nx_hlt
                        	   522: ; nx_S:
                        	   523: ; 		ld A,'P'					;sign positive (P)
                        	   524: ; 		call writedata
                        	   525: ; nx_hlt:		
                        	   526: ; 		;-----------------------------
                        	   527: 
                        	   528: ; 		halt
                        	   529: 
                        	   530: ; 		pop IY
                        	   531: ; 		pop IX
                        	   532: ; 		pop HL
                        	   533: ; 		pop HL
                        	   534: ; 		pop DE
                        	   535: ; 		pop BC
                        	   536: ; 		pop AF
                        	   537: 
                        	   538: ; 		ret
                        	   539: 
                        	   540: ; 	align 8        
                        	   541: ; */
                        	   542: 
                        	   543: ;
                        	   544: ;t_intAstr:   .ascii "PIO A INT"
                        	   545: ;************************************************************************
                        	   546: ; Hexadecimal conversion operates directly on nibbles and takes advantage of nifty DAA trick.
                        	   547: ;Input: HL = number to convert, IX = location of ASCII string
                        	   548: ;Output: ASCII string at (IX) 
                        	   549: ; Num4Hex:  	; convert 2 bytes in HL
                        	   550: ; 	push IX
                        	   551: ; 	ld ix, Result_NumToHex
                        	   552: ; 	ld	a,h
                        	   553: ; 	call	Num1
                        	   554: ; 	ld	a,h
                        	   555: ; 	call	Num2
                        	   556: ; Num2Hex:	; converts 1 byte in L
                        	   557: ; 	ld	a,l
                        	   558: ; 	call	Num1
                        	   559: ; 	ld	a,l
                        	   560: ; 	call	Num2
                        	   561: ; 	pop IX
                        	   562: ; 	ret
                        	   563: 
                        	   564: ; Num1:
                        	   565: ; 	rra
                        	   566: ; 	rra
                        	   567: ; 	rra
                        	   568: ; 	rra
                        	   569: ; Num2:
                        	   570: ; 	or	$F0
                        	   571: ; 	daa
                        	   572: ; 	add	a,$A0
                        	   573: ; 	adc	a,$40
                        	   574: 
                        	   575: ; 	ld	(ix+0),a
                        	   576: ; 	inc	ix
                        	   577: ; 	ret
                        	   578: 
                        	   579: ; inc_portB_value:
                        	   580: ; 		ld a, (PIO_B_value)
                        	   581: ; 		inc a
                        	   582: ; 		ld (PIO_B_value), a
                        	   583: ; 		out (portB_Data), a
                        	   584: ; 		ret
                        	   585: 
                        	   586: 
                        	   587: ; #code DAT_TABLE, DataTables,  $200
                        	   588: 
                        	   589: 
                        	   590: 	if DOALIGN
                        	   591: 		align 8
                        	   592: 	endif
                        	   593:             
                        	   594: ; initbytes:   .byte $01, $38, $0E, $06, $B0
                        	   595: ; t_str1:		.ascii "Z80 micro and"
                        	   596: ; t_str2:		.ascii "HD44780 display"
                        	   597: ; t_str3:		.ascii "Z8536 assist->"
                        	   598: ; t_str4:		.ascii " PC:____ AF:____    "
                        	   599: ; t_str5:		.ascii " BC:____ DE:____    "
                        	   600: ; t_str6:		.ascii " HL:____ SP:____    "
                        	   601: ; t_str7:		.ascii " IX:____ IY:____    "
                        	   602: ; t_str8:		.ascii " "
                        	   603: ; t_str9:		.ascii " "
                        	   604: ; t_string_E: equ $
                        	   605: 	if DOALIGN
                        	   606: 		align 4
                        	   607: 	endif
                        	   608: 
                        	   609: ; cur_pos: equ $
                        	   610: ; 		defw	$0004, $000C, $0104, $010C,$0204, $020C,$0304, $030C, $FFFF
                        	   611: 	if DOALIGN
                        	   612: 		align 4
                        	   613: 	endif
                        	   614: 
                        	   615: ; t_str_table: equ $
                        	   616: ; 		defw	t_str1, t_str2, t_str3, t_str4, t_str5, t_str6, t_str7, t_str8
                        	   617: 
                        	   618: 
                        	   619: ; #code INT_TABLE, Interupt_vector, $10
                        	   620: ; 		;.byte $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04
                        	   621: ; 		;.byte $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04, $00, $04
                        	   622: ; 		.word PIO_A_INT,PIO_A_INT,PIO_A_INT,PIO_A_INT
                        	   623: 		
                        	   624: ; 		;defw $0400          ; NMI adress table    
                        	   625: 
                        	   626: 
                        	   627: ; RTestprog:
                        	   628: ; 		;--------------------------------------------------
                        	   629: ; 		; ld A,5
                        	   630: ; 		; out (_CE_RST_BANK),A
                        	   631: ; 		; ld 	A,$00	
                        	   632: ; 		; out (_Z80_BankCS),A		// set bank register number 	
                        	   633: ; 		; ld 	A,$01
                        	   634: ; 		; out (_CE_RST_BANK),A 		// set bank register (HC374) #0 | Bit 7 set 0 -> 32kSRAM/32kFLASH
                        	   635: 
                        	   636: ; 		out (_8Bitsout),A
                        	   637: 
                        	   638: ; 		ld A, $0F                 ;mode 1 out
                        	   639: ; 		out (portA_Contr), A         ; set port A as output
                        	   640: ; 		ld A,$81
                        	   641: 
                        	   642: ; tll:	
                        	   643: ; 		ld (40000),A
                        	   644: ; 		ld A,0
                        	   645: ; 		ld A,(40000)
                        	   646: 
                        	   647: ; 		out (portA_Data),A		; Data to PIO port A
                        	   648: ; 		out (_8Bitsout),A
                        	   649: ; 		;--------------------------------------------------
                        	   650: ; 		ld	DE,$8100
                        	   651: ; 		ld	HL,RDATA
                        	   652: ; 		ld 	BC,RDATA_END-RDATA
                        	   653: ; 		ldir
                        	   654: ; 	if DOALIGN
                        	   655: ; 		align 4
                        	   656: ; 	endif
                        	   657: 
                        	   658: ; RDATA:
                        	   659: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   660: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   661: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   662: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   663: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   664: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   665: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   666: ; 		defw	$1122, $2233, $3344, $5566, $ABCD, $FEDC, $DCBA, $AEAE
                        	   667: ; RDATA_END:
                        	   668: ; TB_length	equ 	RDATA_END-RDATA
                        	   669: 
                        	   670: 
                        	   671: 


Symbols by name:
CH0                             external
CH1                             external
CH2                             external
CH3                             external
CRLF                            external EXP
CTC_Init                        external
DOALIGN                          E:0000
DumpRegisters                   external EXP
EEPIO_Init                      02:007D
EPS1                            00:0000
InitBuffers                     external
PIO_B_value                      E:F1D0
RAM_Start                       external EXP
ReadLine                        external EXP
SC4C                            external EXP
SC5B                            external EXP
SC8B                            external EXP
SD_USB_startup                  external
SIO_A_C                         external
SIO_A_D                         external
SIO_B_C                         external
SIO_B_D                         external
SIO_Init                        external
SIO_Int_Vec                      E:F400
TX_EMP                          03:0185
WriteLine                       external EXP
WriteLineCRNL                   external EXP
_CE_RST_BANK                    external
_RAMSTART                       external
_Z80CTC_Base                    external
_Z80PIO_Base                    external
_Z80SIO_Base                    external
_Z80_BankCS                     external
disableFLASH                    02:0060 EXP
disableIC620_OE                 02:006B
doCopy                          02:0023
enableFLASH                     02:0051 EXP
enableIC620_OE                  02:0074
gpioB                           external
gpio_in                         external
gpio_out                        external
hit                             03:0000
hit2                            03:016A
hit3                            03:0004
memBankID                       external
portA_Contr                     external
portA_Data                      external
portB_Contr                     external
portB_Data                      external
putBank                         02:004A
putBankF                        02:005A
rstBankID                       external
setBanks                        02:0000
setFLASHBank                    02:003B EXP
setSRAMBank                     02:002E EXP
sio_ac                          external
sio_ad                          external
sio_bc                          external
sio_bd                          external
stacktop                         E:FFF0 EXP
writeSTRBelow                   external

Symbols by value:
0000 DOALIGN
0000 EPS1
0000 hit
0000 setBanks
0004 hit3
0023 doCopy
002E setSRAMBank
003B setFLASHBank
004A putBank
0051 enableFLASH
005A putBankF
0060 disableFLASH
006B disableIC620_OE
0074 enableIC620_OE
007D EEPIO_Init
016A hit2
0185 TX_EMP
F1D0 PIO_B_value
F400 SIO_Int_Vec
FFF0 stacktop
