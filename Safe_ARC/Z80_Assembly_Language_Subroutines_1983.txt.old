Z80®
Assembly Language
Subroutines
Z80®
Assembly Language
Subroutines
Lance A. Leventhal
Winthrop Saville




OsbornejMcGraw- Hill
Berkeley, California
Disclaimer of Warranties and Limitation of Liabilities

The authors have taken due care in preparing this book and the programs in it,
including research, development, and testing to ascertain their effectiveness. The
authors and the publisher make no expressed or implied warranty of any kind with
regard to these programs or the supplementary documentation in this book. In no
event shall the authors or the publisher be liable for incidental or consequential
damages in connection with or arising out of the furnishing, performance, or use of
any of these programs.
Z80 is a registered trademark of Zilog, Inc.
ZID and ZSID are trademarks of Digital Research Corp.
ED is a product of Digital Research Corp.
IBM is a registered trademark of IBM.
Teletype is a registered trademark of Teletype Corp.




Published by
Osborne/McGraw-Hill
2600 Tenth Street
Berkeley, California 94710
U.S.A.
For information on translations and book distributors outside of the U.S.A., please write to Osborne/
McGraw-Hill at the above address.

                       Z80® ASSEMBLY LANGUAGE SUBROUTINES
Copyright ©1983 by McGraw-Hill, Inc. All rights reserved. Printed in the United States of America.
Except as permitted under the Copyright Act of 1976, no part of this publication may be reproduced or
distributed in any form or by any means, or stored in a data base or retrieval system, without the prior
written permission of the publisher, with the exception that the program listings may be entered, stored,
and executed in a computer system, but they may not be reproduced for publication.
1234567890 DODO 89876543
ISBN 0-931988-91-8
Cover by Jean Lake
Text design by Paul Butzler
Contents

     Preface   Vll

1    General Programming Methods                   1
2    Implementing Additional Instructions and Addressing Modes   71
3    Common Programming Errors                 139
     Introduction to the Program Section                 161
4    Code Conversion             167
5    Array Manipulation and Indexing                   195
6    Arithmetic 217
7    Bit Manipulation and Shifts             267
8    String Manipulation           288
9    Array Operations            319
10   Input/Output          356
11   Interrupts      394
A    Z80 Instruction Set Summary 433
 B   Programming Reference for the Z80 PIO Device 457
C    ASCII Character Set               463
     Glossary 465
     Index 489




                                                                      v
Preface


   This book is intended to serve as a source and a reference for the assembly language
programmer. It contains an overview of assembly language programming for a partic-
ular microprocessor and a collection of useful subroutines. In the subroutines, a
standard format, documentation package, and parameter passing techniques were
used. The rules of the most popular assemblers have been followed, and the purpose,
procedure, parameters, results, execution time, and memory usage of each routine
have been described.
   The overview sections summarize assembly language programming for those who
do not have the time or need for a complete textbook; the Assembly Language
Programming series provides more extensive discussions. Chapter 1 introduces
assembly language programming for the particular processor and summarizes the
major features that make this processor different from other microprocessors and
minicomputers. Chapter 2 shows how to implement instructions and addressing
modes that are not explicitly available. Chapter 3 describes common programming
errors.
   The collection of subroutines emphasizes common tasks that occur in many applica-
tions. These tasks include code conversion, array manipulation, arithmetic, bit
manipulation, shifting functions, string manipulation, sorting, and searching. We
have also provided examples ofIl 0 routines, interrupt service routines, and initializa-
tion routines for common family chips such as parallel interfaces, serial interfaces, and
timers. You should be able to use these programs as subroutines in actual applications
and as starting points for more complex programs.
   This book is intended for the person who wants to use assembly language imme-
diately, rather than just learn about it. The reader could be
    An engineer, technician, or programmer who must write assembly language
    programs for a design project.
    A microcomputer user who wants to write an 110 driver, a diagnostic program, a
    utility, or a systems program in assembly language.

                                                                                     vii
viii   ZSO ASSEMBLY LANGUAGE SUBROUTINES


    An experienced assembly language programmer who needs a quick review of
    techniques for a particular microprocessor.
    A systems designer who needs a specific routine or technique for immediate use.
    A high-level language programmer who must debug or optimize programs at the
    assembly level or must link a program written in a high-level language to one
    written in assembly language.
    A maintenance programmer who must understand quickly how specific assembly
    language programs work.
    A microcomputer owner who wants to understand the operating system for a
    particular computer or who wants to modify standard 110 routines or systems
    programs.
    A student, hobbyist, or teacher who wants to see examples of working assembly
    language programs.
This book can also serve as a supplement for students of the Assembly Language
Programming series.
   This book should save the reader time and effort. The reader should not have to
write, debug, test, or optimize standard routines or search through a textbook for
particular examples. The reader should instead be able to obtain easily the specific
information, technique, or routine that he or she needs. This book has been organized
and indexed for rapid use and reference.
   Obviously, a book with such an aim demands feedback from its readers. Although
all the programs have been thoroughly tested and carefully documented, please inform
the publisher if you find any errors. If you have suggestions for better methods or for
additional topics, routines, programming hints, or index entries, please tell us about
them. We have used our programming experience to develop this book, but your help
is needed to improve it. We would greatly appreciate your comments, criticisms, and
suggestions.




NOMENCLATURE
  We have used the following nomenclature in this book to describe the architecture of
the Z80 processor, to specify operands, and to represent general values of numbers and
addresses.
                                                                                          PREFACE   ix

zao Architecture
Byte-length registers include
   A (accumulator)                    R (refresh)
   B                                  A'
   C                                  S'
   D                                  e
   E                                  D'
   H                                  E'
   L                                  H'
   F (flags)                          L'
   I (interrupt vector)               F
Of these, the primary user registers are the first seven: A, B, C, D, E, H, and L. The I
(interrupt vector) register contains the more significant byte (page number) of inter-
rupt service addresses in Interrupt Mode 2. The R (refresh) register contains a memory
refresh counter. The F (flag) register consists of a set of bits with independent functions
and meanings, organized as shown in the following diagram:

                   7      6   5   4   3    2        o - B i t Number
                I S I Z I X lAc! X !P/OI N !C               Processor Status Register F


                                                    f       Carry
                                                            Addl Subtract
                                                            Parity I Overflow
                                                            Not Used (Logic I)
                                                            Auxiliary Carry
                                                            Not Used (Logic I)
                                                            Zero
                                                            Sign


Register pairs and word-length registers include
  AF      (Accumulator and flags, accumulator most significant)
  AF      (Registers Nand F, N most significant)
  BC      (Registers Band C, B most significant)
  Be      (Registers B' and e, B' most significant)
  DE      (Registers D and E, D most significant)
  DE'     (Registers D' and E', D' most significant)
  HL      (Registers Hand L, H most significant)
  HL'     (Registers H' and L', H' most significant)
  IX      (Index register X or IX)
  IY      (Index register Y or IY)
  PC      (Program counter)
  SP      (Stack pointer)

Flags include
  Addl Subtract (N)
  Carry (C)
  Auxiliary Carry (Ad
X Z80 ASSEMBLY LANGUAGE SUBROUTINES

      Parity / Overflow (P /0 or P / V)
      Sign (S)
      Zero (Z)
These flags are arranged in the F register as shown previously.
Miscellaneous facilities include
      Interrupt Flip-flop I (lFFI)
      Interrupt Flip-flop 2 (lFF2)



Z80 Assembler
Delimiters include
                                 After a label, except for EQU, DEFL, and MACRO, which require a space
space                            After an operation code
                                 Between operands in the operand (address) field
                                 Before a comment
(,)                              Around memory references
All operands are treated as data unless they are enclosed in parentheses.
Pseudo-Operations include
DB orDEFB                        Define byte; place byte-length data in
                                   memory.
DEFL                             Define label (may be redefined later).
DEFM                             Define string; place ASCII data in memory.
DS orDEFS                        Define storage; allocate bytes of memory.
DWorDEFW                         Define word; place word-length data in
                                   memory.
END                              End of program.
EQU                              Equate; define the attached label.
ORG                              Set origin; place subsequent object code
                                   starting at the specified address.
Designations include
Number systems:
B (suffix)      Binary
D (suffix)      Decimal
H (suffix)      Hexadecimal
Q (suffix)      Octal
The default mode is decimal; hexadecimal numbers must start with a digit (you must
add a leading zero if the number starts with a letter).
Others:
• 'or" "ASCII (characters surrounded by single or double quotation marks)
$       Current value of location (program) counter
                                                                  PREFACE   xi
General Nomenclature
ADDR        A l6-bit address in data memory
ADDRI       A l6-bit address in data memory
ADDR2       A l6-bit address in data memory
BASE        A constant l6-bit address in data memory
BICON       An 8-bit data item in binary format
CONST       A constant 8-bit data item
DEST        A l6-bit address in program memory, the
              destination for a jump instruction
HIGH        A l6-bit data item
INDIR       A l6.-bit address in data memory, the start-
              ing address for an indirect address. The
              indirect address is stored in memory
              locations INDIR and INDIR+ I.
LOW         A 16-bit data item
MASK        An 8-bit number used for masking
n           A bit position in a byte; possible values are
              o through 7
NPARAM      A 16-bit data item
NEXT        A l6-bit address in program memory
NRESLT      A l6-bit data item
NTIMES      An 8-bit data item
NTIML       An 8-bit data item
NTIMM       An 8-bit data item
NUM         A 16-bit data item
NUMI        A 16-bit address in data memory
NUM2        A 16-bit address in data memory
OFF         An 8-bit fixed offset
OFFSET      An 8-bit fixed offset
oper        An 8-bit data item, a register, (HL), or an
              indexed address
OPER        A l6-bit address in data memory
OPERI       A 16-bit address in data memory
OPER2       A 16-bit address in data memory
reg         A primary user register (A, B, C, D, E, H, or L)
regl        A primary user register
RETPT       A 16-bit address in program memory
rp          A primary register pair (BC, DE, or HL)
rph         The more significant byte of rp
rpl         The less significant byte of rp
rpl         A primary register pair
rplh        The more significant byte of rp I
rpll        The less significant byte of rp I
rp2         Another primary register pair, not the same as rp I
rp2h        The more significant byte of rp2
rp21        The less significant byte of rp2
SPTR        A 16-bit address in data memory
STRNG       A 16-bit address in data memory
SUM         A 16-bit address in data memory
TEMP        A 16-bit address in data memory
VAL16       A 16-bit data item
VAL16H      The more significant byte of VAL16
VAL16L      The less significant byte of VAL16
VALUE       An 8-bit data item
xy          An index register, either IX or IY
Chapter 1 General
       Programming Methods


   Some general methods for writing assembly language programs for the Z80 micro-
processor are presented in this chapter. In addition, techniques for performing the
following operations are explained:
     Loading and saving registers
     Storing data in memory
     Arithmetic and logical functions
     Bit manipulation and testing
     Testing for specific values
     Numerical comparisons
     Looping (repeating sequences of operations)
     Array processing and manipulation
     Table lookup
     Character code manipulation
     Code conversion
     Multiple-precision arithmetic
     Multiplication and division
     List processing
     Processing of data structures.
   Also included in this chapter are special sections that describe passing parameters to
subroutines, general methods for writing 110 drivers and interrupt service routines,
and ways of making programs run faster or use less memory.
   The operations described are required in such applications as instrumentation, test
equipment, computer peripherals, communications equipment, industrial control,
process control, business equipment, aerospace and military systems, and consumer
products. Microcomputer users will employ these operations in writing 110 drivers,
utility programs, diagnostics, and systems software, and in understanding, debugging,
and improving programs written in high-level languages. This chapter provides a brief

                                                                                       1
2    Z80 ASSEMBLY LANGUAGE SUBROUTINES


guide to Z80 assembly language programming for those who have an immediate
application in mind.


SUMMARY FOR EXPERIENCED PROGRAMMERS
   For those who are familiar with assembly language programming on other comput-
ers, we provide here a brief review of the peculiarities of the Z80. Being aware of these
unusual features can save a lot of time and trouble.
   1. Arithmetic and logical operations are allowed only between the accumulator and
a byte of immediate data, the contents of a general-purpose register, the contents of the
address in register pair HL, or the contents of an indexed address. Arithmetic and
logical instructions do not allow direct addressing.
   For example, the alternatives for the OR instruction are OR CONST, where CONST
is a fixed data byte; OR reg, where reg is an 8-bit general-purpose register; OR (HL);
and OR (xy+OFF). The third alternative logically ORs the accumulator with the data
byte located at the address in HL. The fourth alternative logically ORs the accumula-
tor with the data byte located at an indexed address; the processor determines the
address by adding the 8-bit offset OFF to a 16-bit index register.
   2. The accumulator and register pair HL are special. The accumulator is the only
byte-length register that can be loaded or stored directly. The accumulator is also the
only register that can be complemented, negated, shifted with a single-byte instruction,
loaded indirectly from the addresses in register pairs BC or DE, stored indirectly at the
addresses in register pairs BC or DE, or used in IN and OUT instructions with direct
addressing.
   HL is the only register pair that can serve as an indirect address in arithmetic or logi-
cal instructions or in loading or storing registers other than the accumulator. HL is also
the only register pair that can be transferred to the program counter or stack pointer.
Furthermore, HL serves as a double-length accumulator in 16-bit addition and sub-
traction. Register pair DE is also special because the instruction EX DE,HL can
exchange it with HL. Thus, the Z80's registers are highly asymmetric, and the pro-
grammer must carefully choose which data and addresses go in which registers.
   3. There are often several names for the same physical register. The registers A, B,
C, D, E, H, and L are all available as 8-bit registers. The register pairs BC (B more
significant), DE (D more significant), and HL (H more significant) are also available
as 16-bit register pairs in many instructions. The terms "register pair B," "registers B
and C," and "register pair BC" all have the same meaning, and there are similar
variations for registers D and E and Hand L. Note that the register pair and the two
single registers are physically identical and cannot be used for different purposes at the
same time.
                                   CHAPTER 1 GENERAL PROGRAMMING METHODS                 3

   In fact, Hand L are almost always used to hold an indirect address because ofthe
availability of instructions that access the data at that address as well as special
instructions like LD SP,HL; lP (HL); EX (SP),HL; and EX DE,HL. Register pair DE
is used for a second address when one is needed because of the EX DE,HL instruction.
Registers Band C are generally used as separate 8-bit registers for temporary data
storage and counters.
  4. The effects of instructions on flags are extremely inconsistent. Some particularly
unusual effects are (a) logical instructions clear the Carry, (b) one-byte accumulator
rotate instructions affect no flags other than the Carry, (c) load, store, transfer,
increment register pair or index register, and decrement register pair or index register
instructions affect no flags at all, and (d) 16-bit addition (ADD HL or ADD xy) affects
only the Carry flag. Table A-I in Appendix A can be used as an aid in determining how
an instruction affects the flags.
  5. There is no indirect addressing through memory locations. The lack of indirect
addressing is overcome by loading the indirect address into register pair HL. Thus,
indirect addressing is a two-step process. The indirect address can also be loaded into
registers pair BC or DE, but it can then only be used to load or store the accumulator.
  6. The Z80's indexing allows only an 8-bit fixed offset in the instruction. Its main
purpose is to implement postindexing and to allow offsets in data structures. A more
general form of indexed addressing requires an explicit 16-bit addition of register pairs
using HL as a 16-bit accumulator. Thus, indexing usually requires several steps: The
index must be loaded into one register pair, the base address must be .loaded into
another register pair (one pair must be HL), the two must be added explicitly (using
AD D HL,rp), and the sum must be used as an indirect address (by referring to (HL».
Generalized indexing on the Z80 is a long, awkward process.
   7. There is a combined Parity/Overflow indicator. This flag indicates even parity
after all instructions that affect it except addition and subtraction. Then it indicates the
occurrence of two's complement overflow.
   8. Many common instructions are missing but can easily be simulated with register
operations. Some examples are clearing the accumulator (use SUB A or XOR A),
clearing the Carry flag (use AND A or OR A), and logically shifting the accumulator
left (use ADD A,A). Either AND A or OR A clears the Carry flag and sets the other
flags according to the contents of the accumulator. But remember, loading a register
does not affect any flags.
  9. There are both relative and absolute branches (using the operation codes lR and
lP, respectively). Both addressing methods are allowed for unconditional branches.
The sets of conditional branches differ; relative branches exist only for the Carry and
Zero flags, whereas absolute branches exist for the Carry, Sign, Parity/Overflow, and
Zero flags. What is interesting here is that the relative branches occupy less memory
4   ZSO ASSEMBLY LANGUAGE SUBROUTINES


than the corresponding absolute branches (2 bytes rather than 3) but execute more
slowly if the branch is taken (12 cycles rather than 10).
   10. Increment and decrement instructions behave differently, depending on whether
they are applied to 8-bit or 16-bit operands. Decrementing or incrementing an 8-bit
register affects all flags except the Carry. Decrementing or incrementing a 16-bit
register pair or index register does not affect any flags at all. A 16-bit register pair can
be used as a counter, but the only way to test the pair for zero is to logically OR the two
bytes together in the accumulator. The 16-bit instructions are intended primarily for
address calculations, not for data manipulation.
   11. Instructions that are additions to the original 8080 instruction set occupy more
memory and execute more slowly than other instructions with similar functions and
addressing modes. Among them are bit manipulation, arithmetic shift, logical shift,
shifts of registers other than the accumulator, and some loads. These instructions
execute more slowly because they require a prefix byte that tells the processor the
instruction is not an original 8080 instruction and the next byte is the real operation
code. Weller makes it easier to recognize the secondary instructions by using mnemon-
ics derived from the 8080 instruction set.l
   12. Certain registers and facilities are clearly secondary in importance. The pro-
grammer should employ them only when the primary registers and facilities are
already in use or too inconvenient to use. The secondary facilities, like the secondary
instructions, represent additions to the underlying 8080 microprocessor. The most
important additions are index registers IX and IY; many instructions use these
registers, but they take more memory and much more time than instructions that use
the other register pairs. Another addition is the primed register set. Only two instruc-
tions (EX ' AF,AF' and EXX) allow access to the primed set, and for this reason
programmers generally reserve it for functions such as fast interrupt response.
   13. Operations that can be done directly to a general-purpose register are shift it,
transfer it to or from another register, load it with a constant, increment it by 1, or
decrement it by 1. These operations can also be performed indirectly on the memory
address in HL or on a memory location addressed via indexing.
   14. Only register pairs or index registers can be moved to or from the stack. One
pair is AF, which consists of the accumulator (more significant byte) and the flags (less
significant byte). The CALL and RET instructions transfer addresses to or from the
stack; there are conditional calls and returns but they are seldom used.
  15. The Z80 has a readable interrupt enable flag. One can determine its value by
executing LD A,I or LD A,R. Either instruction moves the Interrupt flip-flop to the
Parity / Overflow flag. That flag then reflects the state of the interrupt system at a
particular time, and thus can be used to restore the state after the processor executes
code that must run with interrupts disabled.
                                   CHAPTER 1. GENERAL PROGRAMMING METHODS               5

  16. The Z80 uses the following common conventions:
  · The 16-bit addresses are stored with the less significant byte first (that is, at the
lower address). The order of the bytes in an address is the same as in the 8080, 8085, and
6502 microprocessors, but the opposite of that used in the 6800 and 6809.
   · The stack pointer contains the lowest address actually occupied by the stack. This
convention is also used in the 8080, 8085, and 6809 microprocessors, but the obvious
alternative (next available address) is used in the 6502 and 6800. Z80 instructions store
data in the stack using predecrementing (they subtract 1 from the stack pointer before
storing a byte) and load data from the stack using postincrementing (they add 1 to the
stack pointer after loading a byte).
  · The interrupt (enable) flag is 1 to allow interrupts and 0 to disallow them. This
convention is the same as in the 8080 and 8085, but the opposite of that used in the
6502,6800, and 6809.

REGISTER SET
   Z80 assembly language programming is complicated by the asymmetry of the
processor's instruction set. Many instructions apply only to particular registers,
register pairs, or sets of registers. Almost every register has its own unique features,
and almost every instruction has its own peculiarities. Table 1-1 lists the 8-bit registers
and the instructions that use them. Table 1-2 lists the 16-bit registers and the instruc-
tions that use them (of course, all instructions change the program counter implicitly).
Table 1-3 lists the indirect addresses contained in on-board register pairs and the
instructions that use them. Table 1-4 lists the instructions that apply only to the
accumulator, and Table 1-5 lists the instructions that apply only to particular 16-bit
registers. Table 1-6 lists the instructions that apply to the stack.
   The general uses of the registers are as follows:
  · The accumulator, the center of data processing, is the source of one operand and
destination of the result for most arithmetic, logical, and other processing operations.
  · Register pair HL is the primary memory address register. Instructions can often
refer to the data at the address in HL, that is, (HL).
  · Register pair DE is the secondary memory address register because the pro-
grammer can exchange its contents with HL using EX DE,HL.
  · Registers Band C (register pair BC) are general-purpose registers used mainly for
counters and temporary data storage. Register B is often used as a loop counter
because of its special usage in the DJNZ instruction.
  · Index registers IX and IY are used when the programmer is referring to memory
addresses by means of fixed offsets from a variable base. These registers also serve as
backups to HL when that register pair is occupied.
6   Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table 1·1. Eight-Bit Registers and Applicable Instructions

       8-Bit Register                                Instructions

     A only                   CPL, DAA; IN A,(port); LD (ADDR),LD (BC or DE), NEG;
                                 OUT (port),A; RLA, RLCA, RLD, RRA, RRCA, RRD.
     A,B,C,D,E,H,L            ADC A; ADD A; AND, CP, DEC; IN reg,(C); INC, LD, OR;
                                 OUT (C),reg; RL, RLC, RR, RRC, SBC A; SLA, SRA,
                                 SRL, SUB, XOR
     B only                   DJNZ, IND, INDR, INI, INIR, OTDR, OTIR, OUTD, OUTI
     Conly                    IN reg,(C); OUT (C),reg; IND, INDR, INI, INIR, OTDR,
                                 OTIR, OUTD, OUTI
     F (flags)                CCF, SCF (see also AF register pair)
     I (interrupt vector)     LD I,A; LD A,I
     R (refresh)              LD R,A; LD A,R




Table 1·2. Sixteen-Bit Registers and Applicable Instructions

      16-Bit Register                               Instructions

     AF                       POP; PUSH; EX AF,AF'
     AF'                      EX AF,AF'
     BC                       ADC HL, ADD xy, ADD HL, CPD, CPDR, CPI, CPIR,
                                DEC, EXX, INC, LD, LDD, LDDR, LDI, LDIR, POP,
                                PUSH, SBC HL
     Be'                      EXX
     DE                       ADC HL, ADD xy, ADD HL, DEC; EX DE,HL; EXX, INC,
                                LD, LDD, LDDR, LDI, LDIR, POP, PUSH, SBC HL
     DE'                      EXX
     HL                       ADC HL, ADD HL, CPD, CPDR, CPI, CPIR, DEC; EX
                                 DE,HL; EX (SP),HL; EXX, INC, IND, INDR, IN!, INIR,
                                 LD, LDD, LDDR, LDI, LDIR, OTDR, OTIR, OUTD,
                                OUTI, POP, PUSH, SBC HL
     HL'                      EXX
     IX                       ADD IX, LD, POP, PUSH; EX (SP),IX
     IY                       ADD IY, LD, POP, PUSH; EX (SP),IY
     Program Counter          CALL instructions, Jp, JR, RETURN instructions, RETI,
                                    RETN,RST
     Stack Pointer            CALL instructions, ADD HL, DEC, INC, LD, POP, PUSH,
                                 RETURN instructions, RST
                                           CHAPTER 1. GENERAL PROGRAMMING METHODS                          7
Table 1·3. Indirect Addresses and Applicable Instructions

    Location of Address                                         Instructions

     Register pair BC                LD A,(BC); LD (BC),A
     Register pair DE                LD A,(DE); LD (DE),A
     Register pair HL*               ADC A; ADD A; AND, CP, DEC, INC, JP, LD, OR, SBC
                                       A; SUB, XOR
    Stack Pointer                    CALL instructions, POP, PUSH, RETURN instructions,
                                       RST
    Index register
      XorY                          JP

    *   Index register X or Y can also be used as an indirect address for the same instructions as HL by
        specifying indexed addressing with a fixed offset of zero.




Table 1.... Instructions That Apply Only to the Accumulator

          Instruction                                            Function

    ADCA                            Add with carry
    ADDA                            Add
    AND                             Logical AND immediate
    CPL                             One's complement
    CP                              Compare
    DAA                             Decimal adjust (decimal correction)
    IN A,(port)                     Input direct
    LDA,(ADDR)                      Load direct
    LD A,(rp)                       Load indirect
    NEG                             Two's complement (negate)
    OR                              Logical OR
    OUT (port),A                    Output direct
    RLA                             Rotate accumulator left through carry
    RLCA                            Rotate accumulator left
    RRA                             Rotate accumulator right through carry
    RRCA                            Rotate accumulator right
    SBCA                            Subtract with borrow
    SUB                             Subtract
    XOR                             Logical EXCLUSIVE OR
8     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table 1·5. Instructions That Apply Only to One or Two 16-Bit Registers

          Instruction         16· Bit Registers                          Function

          EXAF,AF'                AF,AF'               Exchange program status with alternate
                                                          program status
          EX DE,HL                DE,HL                Exchange HL with DE
          EX (SP),HL              HL                   Exchange HL with top of stack
          EX (SP),xy              IX or IY             Exchange index register with top of stack
          LD SP,HL                HL,SP                Load stack pointer from HL
          LD Sp,xy                IX or IY,SP          Load stack pointer from index register




Table 1·6. Instructions That Use the Stack

          Instruction                                   Function

    Call instructions        Jump and save program counter in stack (including
                                conditionals)
    EX (SP),HL               Exchange HL with top of stack
    EX (SP),xy               Exchange index register with top of stack
    POP                      Load register pair from stack
    PUSH                     Store register pair in stack
    RETURN instructions      Load program counter from stack (including
                                conditionals)
    RST                      Jump to vector address and save program
                                counter in stack




    We may describe the special features of particular registers as follows:
  . Accumulator. Only single register that can be loaded or stored directly. Only 8-bit
register that can be shifted with a one-byte instruction. Only register that can be
complemented, decimal adjusted, or negated with a single instruction. Only register
that can be loaded or stored using the addresses in register pairs BC or DE. Only
register that can be stored in an output port or loaded from an input port using direct
addressing. Source and destination for all 8-bit arithmetic and logical instructions
except DEC and INC. Only registerthat can be transferred to or from the interrupt
vector (I) or refresh (R) register.
  . Register pair HL. Only register pair that can be used indirectly in the instructions
ADC, ADD, AND, CMP, DEC, INC, OR, SBC, SUB, and XOR. Source and
destination for the instructions ADC HL, ADD HL, and SBC HL. Only register pair
                                  CHAPTER 1. GENERAL PROGRAMMING METHODS              9
that can be exchanged with register pair DE or with the top of the stack. Only register
pair that can have its contents moved to the stack pointer (LD SP,HL) or the program
counter (lP (HL». Only register pair that can be shifted with a single instruction
(ADD HL,HL). Automatically used as a source address register in block move, block
compare, and block output instructions. Automatically used as a destination address
register in block input instructions.
 · Register pair DE. Only register pair that can exchanged with HL (EX DE,HL).
Automatically used as a destination address register in block move instructions.
  · Register pair Be. Automatically used as a counter in block move and block
compare instructions.
  · Register B. Automatically used as a counter in the D1NZ instruction and in block
input and output instructions.
  · Register C. Only register that can be used as an indirect port address for input and
output. Automatically used as a port address in block input and output instructions.
  · Index registers IX and IY. Only address registers that allow an indexed offset.
Used as source and destination in ADD xy instruction. Can be exchanged with the top
of the stack, moved to the stack pointer or program counter, or shifted with ADD
xy,xy.
  · Stack pointer. Automatically postincremented by instructions that load data from
the stack and predecremented by instructions that store data in the stack. Only address
register that can be used to transfer other register pairs to or from memory (PUSH and
POP) or to transfer the program counter to or from memory (CALL instructions and
RETURN instructions).
  Note the following:
   · The A register is the only 8-bit register that can be loaded from memory or stored
in memory using direct addressing.
  • Only the address in register pair HL or an address obtained via indexing can be
used in operations other than loading and storing the accumulator. That is, only the
data at the address in HL or at an indexed address can be moved to or from a user
register, decremented, incremented, or used in arithmetic and logical operations.
  · Only DEC reg and INC reg perform 8-bit arithmetic operations without involving
the accumulator (of course, DEC and INC may be applied to the accumulator).
  · Only index registers IX and IY allow an offset from a base address. The data at the
indexed address can be. used like the data at the address in HL.
  · The index registers IX and IY make useful backups to HL because of the
availability of the 16-bit instructions ADD xy; EX (SP),xy; lP (xy); and LD SP,xy.
10    Z80 ASSEMBLY LANGUAGE SUBROUTINES


Register Transfers
   The LD instruction can transfer any 8-bit general-purpose register (A, B, C, D, E, H,
or L) to any other 8-bit general-purpose register. The flag (F) register can only be
transferred to or from the stack along with the accumulator (PUSH AF and POP AF).
Register pairs DE and HL can be exchanged using EX DE,HL.
   The common transfer instructions are
     LD A,reg transfers the contents of reg to the accumulator
     LD reg,A transfers the contents of the accumulator to reg
     LD reg,(HL) loads reg with the contents of the memory address in register pair HL
     LD (HL),reg stores reg at the memory address in register pair HL
     EX DE,HL exchanges register pair DE with HL.
   The destination always comes first in the operand field ofLD. That is, LD regl,reg2
transfers the contents of reg2 to reg I , the opposite of the convention proposed in IEEE
Standard 694 for assembly language instructions. 2 The LD changes the destination,
but leaves the source as it was. Note that EX DE,HL changes all four registers (D, E,
H, and L); it is thus equivalent to four LDs plus some intermediate steps that save one
byte of data while transferring another.



LOADING REGISTERS FROM MEMORY

   The Z80 microprocessor has five addressing modes that can be used to load registers
from memory. These addressing modes are: Direct (from a specific memory address),
Immediate (with a specific value), Indirect (from an address stored in a register pair),
Indexed (from an address obtained by adding a fixed offset to an index register), and
Stack (from the top of the stack).3


Direct Loading of Registers
  The accumulator, a primary register pair (BC, DE, or HL), the stack pointer, or an
index register can be loaded from memory using direct addressing.

Examples
   1. LD A,(2050H)
  This instruction loads the accumulator (register A) from memory location 205016.
                                 CHAPTER 1 GENERAL PROGRAMMING METHODS                 11

  2. LD HL,(OAOOOH)
  This instruction loads register L from memory location AOOO 16 and register H from
memory location. A00116 Note the standard Z80 practice of storing 16-bit numbers
with the less significant byte at the lower address, followed by the more significant byte.

  3. LD SP,(9A12H)
  This instruction loads the stack pointer from memory locations 9 A 12 16 (less signifi-
cant byte) and 9A1316 (more significant byte).


Immediate Loading of Registers
  Immediate addressing can be used to load any register, register pair, or index register
with a specific value. The register pairs include the stack pointer.

Examples
  1. LD C,6
  This instruction loads register C with the number 6. The 6 is an 8-bit data item, not a
16-bit address. Do not confuse the number 6 with the address 000616.

  2. LD DE,15E3H
  This instruction loads register D with 1516 and register E with E316.

  3. LD IY,OB7EEH
  This instruction loads index register IY with B7EEI6.


Indirect Loading of Registers
  The instruction LD reg,(HL) can load any register from the address in register pair
HL. The instruction LD A,( rp) can load the accumulator using the address in a register
pair (BC, DE, or HL). Note that there is no instruction that loads a register pair
indirectly.

Examples
  1. LD D,(HL)
   This instruction loads register D from the memory address in register pair HL. The
assembly language instruction takes the form "LD destination register, source regis-
ter"; the order of the operands is the opposite of that proposed for IEEE Standard
694.4
12    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  2. LD A,(BC)
  This instruction loads the accumulator from the memory address in register pair
BC. Note that you cannot load any register except A using BC or DE indirectly.

Indexed Loading of Registers
  The instruction LD A,(xy+OFFSET) loads the accumulator from the indexed
address obtained by adding the 8-bit number OFFSET to the contents of an index
register. Note that OFFSET is a fixed 8-bit number (its value is part of the program),
while the index register contains a 16-bit address that can be changed. 5 If OFFSET = 0,
indexing is equivalent to indirection, but it is slower since the processor still must
perform the address addition.

Stack loading of Registers
   The instruction POP rp or POP xy loads a register pair or an index register from the
top of the stack and adjusts the stack pointer appropriately. One register pair for POP
rp is AF, which consists of the accumulator (more significant byte) and the flags (less
significant byte). No instructions load 8-bit registers from the stack or use the stack
pointer indirectly without changing it (although EX (SP),HL and EX (SP),xy have no
net effect on the stack pointer since they transfer data both to and from the stack).

Examples
  1. POP DE
   This instruction loads register pair DE from the top of the stack and increments the
stack pointer by 2. Register E is loaded first.

  2. POPIY
   This instruction loads index register IY from the top of the stack and increments the
stack pointer by 2. The less significant byte of IY is loaded first.
   The stack has the following special features:
    · The stack pointer contains the address of the most recently occupied location.
  The stack can be anywhere in memory.
     · Data is stored in the stack using predecrementing-the instructions decrement
   the stack pointer by I before storing each byte. Data is loaded from the stack using
   postincrementing-the instructions increment the stack pointer by I after loading
   each byte.
     · As is typical with microprocessors, there are no overflow or underflow
   indicators.
                                CHAPTER 1 GENERAL PROGRAMMING METHODS             13

STORING REGISTERS IN MEMORY
   The Z80 has four addressing modes that can be used to store registers in memory.
These modes are: Direct (at a specific memory address), Indirect (at an address stored
in a register pair), Indexed (at an address calculated by adding an 8-bit offset to the
contents of an index register), and Stack (at the top of the stack).

Direct Storage of Registers
 Direct addressing can be used to store the accumulator, a register pair (BC, DE, or
HL), the stack pointer, or an index register.

Examples
  1. LD (35C8H),A
  This instruction stores the accumulator in memory location 35C816.

  2. LD (203AH),HL
 This instruction stores register L in memory location 203A16 and register H in
memory location 203B16.

  3. LD (OA57BH),SP
  This instruction stores the stack pointer in memory locations A57B 16 (less signifi-
cant byte) and A57C16 (more significant byte).                         .

Indirect Storage of Registers
  The instruction LD (HL},reg can store any register at the address in register pair
HL. The instruction LD (rp},A can store the accumulator at the address in a register
pair (BC, DE, or HL). Note that there is no instruction that stores a register pair
indirectly.

Examples
  1. LD (HL),C
  This instruction stores register C at the address in register pair HL. The form is
"move to address in HL from C."

  2. LD (DE),A
 This instruction stores the accumulator at the memory address in register pair DE.
Note that you cannot store any register except A using BC or DE indirectly.
14     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Indexed Storage of Registers
  The instruction LD (xy+OFFSET),A stores the accumulator at the indexed address
obtained by adding the 8-bit number OFFSET to the contents of an index register. If
OFFSET = 0, the indexed address is simply the contents of the index register, and
indexing is reduced to a slow version of indirect addressing.


Stack Storage of Registers
  The instruction PUSH rp or PUSH xy stores a register pair or an index register at
the top of the stack and adjusts the stack pointer appropriately. One register pair is AF,
consisting of the accumulator (more significant byte) and the flags (less significant
byte). There is no instruction that stores an 8-bit register in the stack.

Examples
  1. PUSHBC
   This instruction stores register pair BC at the top of the stack and decrements the
                               a
stack pointer by 2. Note that is stored first, so C ends up at the top of the stack.

  2. PUSH IX
  This instruction stores index register IX at the top of the stack and decrements the
stack pointer by 2. Note that the less significant byte of IX is stored last, and thus it
ends up at the top of the stack.


OTHER LOADING AND STORING OPERATIONS
  Other loading and storing operations require more than one instruction. Some
typical examples are

  1.   Direct loading of a register other than A.
           LD       A.(ADDR)
           LD       reg. A
An alternative is
           LD       HL.ADDR
           LD       reg. (HU
The second approach leaves A unchanged, but makes HL an indirect addressing pair.
Of course, the address in HL would then be available for later use.
                                  CHAPTER 1. GENERAL PROGRAMMING METHODS              15

  2. Indirect loading of a register (from the address in memory locations INDIR and
INDIR+I).
            LD     HL, (INDIR)         ;GET INDIRECT ADDRESS
            LD     reg,(HU             ;LOAD DATA INDIRECTLY

     3. Direct storage of a register other than A.
            LD     A,reg
            LD     (ADDR),A
An alternative is
            LD    HL.ADDR
            LD    (HU • reg

  4. Indirect storage of a register (at the address in memory locations INDIR and
INDIR+I).
            LD     HL. (INDIR)         ;GET THE INDIRECT ADDRESS
            LD     (HU • reg           ;STORE DATA THERE




STORING VALUES IN RAM
  The usual ways to initialize RAM locations are (1) through the accumulator, (2)
using register pair HL directly or indirectly, and (3) using an index register with a fixed
offset.

Examples
     I. Store an 8-bit item (VALUE) in address ADDR.
           LD     A.VALUE
           LD     (ADDR),A

or
           LD     HL.ADDR
           LD     (HU , VALUE

  If VALUE = 0, we could use SUB A or XOR A instead ofLD A, 0. Note, however,
that SUB A or XOR A affects the flags, whereas LD A,O does not.

 2. Store a 16-bit item (VALl6) in addresses ADDR and ADDR+ I (MSB in
ADDR+I).
            LD    HL,VAL16
            LD    (ADDR). HL
16     ZSO ASSEMBLY LANGUAGE SUBROUTINES


  3. Store an 8-bit item (VALUE) at the address in memory locations INDIR and
INDIR+I.
          LD     HL, (INDIR)         ;GET INDIRECT ADDRESS
          LD     (HU ,VALUE          ;STORE DATA INDIRECTLY

  4. Store an 8-bit item (VALUE) nine bytes beyond the address in memory locations
INDIR and INDIR+ 1.
          LD     A,VALUE
          LD     xy, (INDIR)          ;GET BASE ADDRESS
          LD     (xy+9),A             ;STORE DATA 9 BYTES BEYOND BASE
Here the indirect address is the base address of an array or other data structure.


ARITHMETIC AND LOGICAl OPERATIONS
   Most arithmetic and logical operations (addition, subtraction, AND, OR, EXCLU-
SIVE OR, and comparison) can be performed only between the accumulator and an
8-bit register, a byte of immediate data, or a byte of data in memory addressed through
register pair HL or via indexing. Note that arithmetic and logical instructions do not
allow direct addressing. If a result is produced (comparison does not produce any), it
replaces the operand in the accumulator.

Examples
   1. Logically OR the accumulator with register C.
          OR     C
  OR C logically ORs register C with the accumulator and places the result in the
accumulator. The programmer only has to specify one operand; the other operand and
the destination of the result are always the accumulator.

  2. Add register B to the accumulator.
          ADD    A,B
ADD A,B adds register B to the accumulator (register A) and places the result in the
accumulator. In the instructions ADC, ADD, and SBC, the programmer must specify
both operands. The reason is that the Z80 also has the instructions ADC HL (add
register pair to HL with carry), ADD HL (add register pair to HL), ADD xy (add
register pair or index register to index register), and SBC HL (subtract register pair
from HL with borrow). Note the inconsistency here: Both operands must be specified
in ADC, ADD, and SBC, but only one operand in SUB; furthermore, the Z80 has an
ADD xy instruction, but no ADC xy or SBC xy instruction. Since the 16-bit arithmetic
instructions are mainly intended for addressing, we will discuss them later.
                                 CHAPTER 1. GENERAL PROGRAMMING METHODS           17
     3. Logicallv AND the accumulator with the binary constant BICON.
            AND    BICON
Immediate addressing is the default mode; no special operation code or designation is
necessary.

     4. Logically OR the accumulator with the data at the address in register pair HL.
            OR     (HU
Parentheses indicate a reference to the contents of a memory address.
  Other operations require more than one instruction. Some typical examples are:
    Add memory locations OPER I and OPER2, place sum in memory location SUM.
            LD     A, (OPER1.l        ;OET FIRST OPERAND
            LD     B,A
            LD     A, (OPER2)         ;OET SECOND OPERAND
            ADD    A,B
            LD     (SlIM),A           ;SAVE SUM
or
            LD     HL,OPERl
            LD     A, (HU             ;OET FIRST OPERAND
            LD     HL,OPER2
            ADD    A, (HU             ;ADD SECOND OPERAND
            LD     HL,SlIM
            LD     (HU,A              ;SAVE SLIM
  We can shorten the second alternative considerably if the operands and the sum
occupy consecutive memory addresses. For example, if OPER2 = OPERI + 1 and
SUM = OPER2 + I, we have
            LD     HL,OPERl
            LD     A, (HU             ;OET FIRST OPERAND
            INC    HL
            ADD    A, (HU             ;ADD SECOND OPERAND
            INC    HL
            LD     (HU,A              ;SAVE SUM

       Add a constant (VALUE) to memory location OPER.

            LD     A, (OPER)
            ADD    A,VALUE
            LD     (OPER),A

or
            LD     HL,OPER
            LD     A, (HU
            ADD    A,VALUE
            LD     (HU,A
18    Z80 ASSEMBLY LANGU/"IGE SUBROUTINES


  If VALUE = I, we can shorten the second alternative to
           LD     HL,OPER
           INC    (HU

  You can use DEC (HL) similarly without changing the accumulator, but both DEC
(HL) and INC (HL) affect all the flags except Carry.

BIT MANIPUlATION
   The Z80 has specific instructions for setting, clearing, or testing a single bit in a
register or memory location. Other bit operations require a series of single-bit instruc-
tions or logical instructions with appropriate masks. Complementing (CPL) applies
only to the accumulator. Chapter 7 contains additional examples of bit manipulation.
   The specific bit manipulation instructions are
           SET n,reg
           RES n,reg
           BIT n,reg
     Sets bit n of register reg
     Clears bit n of register reg
     Tests bit n of register reg, setting the Zero flag if that bit is 0 and clearing the Zero
flag if it is 1.
  All three instructions can also be applied to (HL) or to an indexed address. Note that
the bit position is not a variable; it is part of the instruction."
  Other bit operations can be implemented by applying logical instructions to the
accumulator as follows:
     Set bits to I by logically ORing them with l's in the appropriate positions.
     Clear bits by logically ANDing them with O's in the appropriate positions.
    Invert (complement) bits by logically EXCLUSIVE ORing them with I's in the
appropriate positions .
  . Test bits (for all O's) by logically ANDing them with I's in the appropriate
positions.
  This approach is inconvenient since the logical instructions can only be applied to
the accumulator. It does, however, allow the programmer to invert bits and change
several bits at the same time.

Examples
   I. Set bit 6 of the accumulator.
           SET    6,A
                                   CHAPTER 1 GENERAL PROGRAMMING METHODS               19
or
             OR     01000000B             ;SET BIT 6 BY ORING WITH 1
Logically ORing a bit with 0 leaves it unchanged.

     2. Clear bit 3 of the accumulator.
             RES    3,A
or
             AND    11110111B             ;CLEAR BIT 3 BY ANDING WITH 0
Logically ANDing a bit with I leaves it unchanged.

     3. Invert (complement) bit 2 of the accumulator.
             XOR    00000100B             ; INVERT BIT 2 BY XORING WITH 1
Logically EXCLUSIVE ORing a bit with 0 leaves it unchanged. Here there is no
special bit manipulation instruction. Fortunately, setting and clearing bits are much
more common operations than complementing bits.

  4. Test bit 5 of the accumulator. In other words, clear the Zero flag if bit 5 is I, and
set it if bit 5 is O.
             BIT    5, A
or
             AND    00100000B             ;TEST BIT 5 BY ANDING WITH 1
Note the inversion here in either alternative: The Zero flag is set to I if the bit is 0, and
to 0 if the bit is 1.

     5. Set bit 4 of register D.
             SET 4,0
To use a logical function, we would have to load the data into the accumulator and
load the result back into register D.

     6. Invert (complement) bit 7 of memory location ADDR.
             LD     A, (ADDR)             ;GET DATA
             XOR    10000000B             ;COMPLEMENT BIT 7
             LD     (ADDR), A             ;RETURN RESULT TO MEMORY

  7. Set bit 0 of the memory location five bytes beyond the address in INDIR and
INDlR+I.
          LD      xy,(ADDR)        :GET INDIRECT ADDRESS
          SET 0, (xy+5)            ;SET BIT 0 OF BYTE 5
20       Z80 ASSEMBLY LANGUAGE SUBROUTINES


You can change more than one bit at a time by using a series of bit manipUlation
instructions or by using the logical functions with appropriate masks.

     8. Set bits 4 and 5 of the accumulator.
            OR     00110000B            : SET BITS 4 AND 5 BY ORING WITH 1
or
            SET    4,A                  : SET BIT 4 FIRST
            SET    5,A                  : AND THEN SET BIT 5

     9. Invert (complement) bits 0 and 7 of the accumulator.
            XOR    10000001B            :INVERT BITS 0 AND 7 BY XORING WITH 1
    A handy shortcut to change bit 0 of a register or memory location is to use INC to set
it (if you know that it is 0) and DEC to clear it (if you know that it is 1). You can also use
either INC or DEC to complement bit 0 if you are not using the other bits of a register
or memory location. These shortcuts are useful when you are storing a single I-bit flag
in a register or memory location.


SHIFT OPERATIONS
   The Z80 has shift instructions that operate on any register or memory location.
Special instructions apply only to the accumulator, register pair HL, or an index
register. Chapter 7 contains further examples of shift operations.
   The instructions RL and RR rotate a register or memory location and the Carry flag
as if they formed a 9-bit register. Figures 1-1 and 1-2 show the effects of RL and RR.
The instructions RLC and RRC rotate the register or memory location alone as shown
in Figures 1-3 and 1-4. The bit shifted off the end still appears in the Carry flag as well
as in the bit position at the other end. The instructions SLA and SRL perform logical
shifts (as shown in Figures 1-5 and 1-6) which fill the bit at the far right or left with a O.
SRA performs an arithmetic shift (see Figure 1-7) which preserves the sign bit by
extending (copying) it to the right. Note that RL and RR preserve the old Carry flag (in
either bit 0 or bit 7), whereas the other shift instructions destroy it.
   Certain special instructions are shorter and faster than the regular shifts in specific
situations. One-byte circular shifts (RLA, RLCA, RRA, RRCA) apply only to the
accumulator. Adding a register to itself (ADD A,A; ADD HL,HL; ADD xy,xy) is
equivalent to a logical left shift, while adding a register to itself with Carry (ADC A,A
or ADC HL,HL) is equivalent to a left rotate through Carry.
Examples
     1. Rotate accumulator right two positions without the Carry.
            RRCA
            RRCA
                                    CHAPTER 1. GENERAL PROGRAMMING METHODS              21

                      Original contents of Carry flag and register or memory location
                         Carry                  Data
                          o        IB71BdB51B41B31B2IBdBoi
                      After RL (rotate left through Carry)
                         Carry                    Data
                          ~        IB61 B51 B41 B31 B21 B) 1Bo 1C 1

Figure 1·1. The RL (rotate left through Carry) instruction




                      Original contents of Carry flag and register or memory location
                         Carry                   Data
                          @]       IB71B61B51B41B31B2IBdBoi
                      After RR (rotate right through Carry)
                         Carry                   Data
                          ~       1C 1B71 B61 B51 B41 B31 B21 B) 1


Figure 1·2. The RR (rotate right through Carry) instruction




                    Original contents of Carry flag and register or memory location


                          o
                          Carry                   Data
                                  IB71B61B51B41B31B2IBdBoi
                      After RLC (rotate left)
                         Carry                   Data
                          ~       1B61 Bs! B41 B31 B21 B) 1Bo 1B71

Figure 1·3. The RLC (rotate left) instruction
22    Z80 ASSEMBLY LANGUAGE SUBROUTINES




                      Original contents of Carry flag and register or memory location
                         Carry                    Data
                          @] IB71 B6 IB51 B41 B31 B21 Bd Bo I
                     After RRC (rotate right)
                         Carry                    Data
                          ru       IBoIB71B61BslB41B31B21Bd

Rgure 1-4. The RRC (rotate right) instruction




                      Original contents of Carry flag and register or memory location




                      After SLA (shift left arithmetic)




Rgure 1·5. The SLA (shift left arithmetic) instruction




                      Original contents of Carry flag and register or memory location




                      After SRL (shift right logical)




Rgure 1·6. The SRL (shift right logical) instruction
                                      CHAPTER 1. GENERAL PROGRAMMING METHODS              23


                        Original contents of Carry flag and register or memory location




                        After SRA (shift right arithmetic)




Rgure1·7. The SRA (shift right arithmetic) instruction




Note the special form for the accumulator.

  2. Shift accumulator left logically two positions.
           SLA    A
           SLA    A
A shorter, faster alternative is
           ADD    A,A
           ADD    A,A
The instruction ADD A,A is equivalent to a logical left shift of A. Note that ADD A,A
is a one-byte instruction, whereas SLA is always at least a two-byte instruction since it
is an addition to the 8080 instruction set.

  3. Shift register C right logically one position.
           SRL    C

  4. Shift register pair HL left logically two positions.
           ADD    HL,HL
           ADD    HL,HL
ADD HL, HL is a one-byte logical left shift of HL.
  Shift instructions can also be applied to memory locations addressed either through
register pair HL or through indexing from IX or IY.

   5. Shift memory location ADDR right one position, preserving the sign bit (bit 7).
           LD     HL,ADDR
           SRA    (HU
Shifting while preserving the sign bit is called sign extension. A shift that operates in
24    Z80 ASSEMBLY LANGUAGE SUBROUTINES


this manner is called an arithmetic shift, since it preserves the sign of a two's comple-
ment number. It can therefore be used to divide or normalize signed numbers.

  6. Rotate right the memory location eight bytes beyond the address in INDIR and
INDIR+l.
           LD     xy, (INDIR)         ;GET INDIRECT ADDRESS
           RR     (xy+8)              ~ROTATE BYTE 8 RIGHT



MAKING DECISIONS
  In this section procedures are presented for making the following three types of
decisions:
     Branching if a bit is set or cleared
     Branching if two values are equal or not equal
     Branching if one value is greater or less than another.
   The first type of decision allows the processor to sense the value of a flag, switch,
status line, or other binary (ON/OFF) input. The second type of decision allows the
processor to determine whether an input or a result has a specific value (an input is a
specific command character or terminator, or a result is 0). The third type of decision
allows the processor to determine whether a value is above or below a numerical
threshold (a value is valid or invalid, or is above or below a warning level or setpoint).
Assuming that the primary value is in the accumulator and the secondary value (if
needed) is at address ADDR, the procedures are as follows.
                                 CHAPTER 1. GENERAL PROGRAMMING METHODS              25

Branching Set or Cleared Bit
  Determine if a bit is set or cleared with the BIT instruction. The operands are the bit
position and the register or memory address (either the one in HL or one accessed via
indexing). The Zero flag reflects the bit value and can be used for branching.

Examples
  1. Branch to DEST if bit 5 of the accumulator is 1.
           BIT    5, A
           JR     NZ,DEST
   JP (absolute addressing) can be used instead of JR (relative addressing). The Zero
flag is set to 1 if and only if bit 5 of A is o.

  2. Branch to DEST if bit 2 of register C is O.
           BIT    2, C
           JR     Z, DEST

  3. Branch to DEST if bit 6 of memory location ADDR is 1.
           LD     HL,ADDR
           BIT    6, (HU
           JR     NZ,DEST

   4. Branch to DEST if bit 3 of the memory location seven bytes beyond the address
in INDIR and INDIR+1 is O.
            LD    xy, (INDIR.l
            BIT   3, (xy+7.l
           ..JR   Z, DEST
There are shortcuts for bits 0, 6, and 7 of the accumulator.

  5. Branch to DEST if bit 7 of the accumulator is 1.
           AND    A                   ;ESTABLISH SIGN FLAG
           JP     M,DEST
There is no relative jump based on the Sign flag.

  6. Branch to DEST if bit 6 of the accumulator is o.
           ADD    A,A                 ;ESTABLISH SIGN FLAG FROM BIT 6
           JP     P,DEST

  7. Branch to DEST if bit 0 of the accumulator is 1.
26    Z80 ASSEMBLY LANGUAGE SUBROUTINES


           RRA                       ;MOVE BIT 0 TO CARRY
           JR    C,DEST

Here we have the choice of either a relative or an absolute jump.



Branching Based on Equality

  Determine if the value in the accumulator is equal to another value by subtraction.
The Zero flag is set to I if the values are equal. Compare instructions (CP) are more
useful than subtract instructions (SBC or SUB) because compares preserve the value in
the accumulator for later operations. Note, however, that the Z80 has a 16-bit subtract
with borrow instruction (SBC HL), but no 16-bit compare or subtract instruction.

Examples
  1. Branch to DEST if the accumulator contains the number VALUE.
           CP    VALUE                ;DOES A CONTAIN VALUE?
           JR    Z,DEST               ;YES, BRANCH

  2. Branch to DEST if the contents of the accumulator are not equal to the contents
of memory location ADDR.
           LD    HL,ADDR
           CP    (HU                 ;IS A THE SAME AS DATA IN MEMORY?
           JR    NZ,DEST             ;NO, BRANCH
There are shortcuts if VALUE is 0, 1, or FF 16.

  3. Branch to DEST if the accumulator contains 0.
           AND   A                   ;ESTABLISH ZERO FLAG
           JR    Z,DEST              ,BRANCH IF A CONTAINS ZERO

  4. Branch to DEST if the accumulator does not contain FF 16.
           INC   A                    ;ESTABLISH ZERO FLAG
           JR    NZ,DEST              ;BRANCH IF A WAS NOT FF
This procedure can be applied to any 8-bit register or to a memory location addressed
through HL or via indexing.

  5. Branch to DEST if the accumulator contains 1.
           DEC   A                    ,ESTABLISH ZERO FLAG
           JR    Z,DEST               ,BRANCH IF A WAS 1
                                CHAPTER 1. GENERAL PROGRAMMING METHODS               27
  6. Branch to   DEST if memory location ADDR contains O.
         LD      HL,ADDR
         INC      (HU              ;ESTABLISH ZERO FLAG IN TWO STEPS
         DEC      (HU
         JR      Z,DEST            ;BRANCH IF ADDR CONTAINS ZERO
This procedure will also work on data at an indexed address or in registers B, C, D, E,
H, or L.

  7. Branch to DEST if register pair HL contains VAL16.
           AND   A                    ; CLEAR CARRY, DON"T CHANGE A
           LD    rp,VAL16
           sec   HL,rp                ;DOES HL CONTAIN VAL16?
           JR    Z,DEST               ;YES, BRANCH
The 16-bit subtraction instruction always includes the Carry and is available only for
HL and another register pair (BC, DE, or SP).


Branching Based on Magnitude Comparisons
  Determine if the value in the accumulator is greater than or less than some other
value by subtraction. If, as is typical, the values are unsigned, the Carry flag indicates
which is larger. In general,
   . Carry = I if the value subtracted is larger than the value in the accumulator (that
is, if a borrow is required).
  . Carry = 0 if the value in the accumulator is larger or if the two values are equal.
  Since subtracting equal values makes the Carry 0, the alternatives (considering the
accumulator as the primary operand) are
     Primary operand less than secondary operand (Carry set)
    Primary operand greater than or equal to secondary operand (Carry cleared).
  If the alternatives you need are "less than or equal to" and "greater than," you can
simply exchange the primary and secondary operands (that is, from Y - X instead of
X-Y)o

Examples
   1. Branch to DEST if the contents of the accumulator are greater than or equal to
the number VALUE.
           CP     VALUE               ;IS A ABOVE VALUE?
           JR     NC,DEST             ;YES. BRANCH
28    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  2. Branch to DEST if the contents of memory address OPERI are less than the
contents of memory address OPER2.
          LD     A,(OPER1)            ;GET FIRST OPERAND
          LD     HL,OPER2
          CP      (HU                 ; IS IT LESS THAN SECOND OPERAND?
          ,JR    C,DEST               ;YES, BRANCH

   3. Branch to DEST if the contents of memory address OPERI are less than or equal
to the contents of memory address OPER2.
        LD      A,<OPER2)             ;GET SECOND OPERAND
        LD      HL,OPERl
        CP      (HU                   ;IS IT GREATER THAN OR EQUAL TO FIRST?
        ,JR     NC,DEST               ;YES, BRANCH
  If we loaded the accumulator with OPERI and compared to OPER2, we could
branch only on the conditions
     OPERI greater than or equal to OPER2 (Carry cleared)
     OPERI less than OPER2 (Carry set).
  Since neither is what we want, we must reverse the order in which the operands are
handled.

 4. Branch to DEST if the contents of register pair HL are greater than or equal to
VALl6.
       AND A                     ;CLEAR CARRY
       LD     rp,VAL16           ;IS HL ABOVE VAL16?
       SBC HL,r'p
       .... R NC,DEST            ;YES, BRANCH
   If the values are signed, we must allow for the possible occurrence of two's comple-
ment overflow. 7 This is the situation in which the difference between the numbers
cannot be contained in seven bits and, therefore, the sign bit is changed. For example,
if one number is +7 and the other is -125, the difference is -132, which is beyond the
capacity of eight bits (it is less than -128, the most negative number that eight bits can
hold).
   If overflow is a possibility, we can determine if it occurred by examining the
Parity / Overflow flag after the addition or subtraction instruction. If that flag is I,
overflow did occur. The mnemonics here are confusing, since the Parity/Overflow flag
normally indicates whether the result has even parity; the branches are therefore PE
(Parity Even or Overflow Set) and PO (Parity Odd or Overflow Clear). Weller clarifies
the situation by defining additional mnemonics JV and JNy'8
   Thus, in the case of signed numbers, we must allow for the following possibilities:
  , The result has the sign (positive or negative, as shown by the Sign flag) that we
want, and the Parity/Overflow flag indicates that the sign is valid.
                                 CHAPTER 1. GENERAL PROGRAMMING METHODS            29
    The result does not have the sign that we want, but the Parity/Overflow flag
indicates that two's complement overflow has changed the real sign.
  We have to look for both a true positive (the sign we want, unaffected by overflow)
or a false negative (the opposite of the sign we want, but inverted by two's complement
overflow).

Examples
  1. Branch to DEST if the accumulator contains a signed number greater than or
equal to the number VALUE.
                CP     VALUE        ;PERFORM THE COMPARISON
                JP     PE.FNEG      ;DID OVERFLOW OCCUR?
                JP     P.DEST       ;NO. BRANCH IF RESULT POSITIVE
                JR     DONE
   FNEG;        JP     M.DEST       ;YES. BRANCH IF RESULT NEGATIVE
   DONE:        NOP

There are no relative jumps based on the Parity/Overflow flag.

  2. Branch to DEST if the accumulator contains a signed number less than the
contents of memory address ADDR.
                LD    HL.ADDR
                CP     (HU          ;PERFORM THE COMPARISON
                JP    PE.FPOS       ;DID OVERFLOW OCCUR?
                JP    M.DEST        ;NO. BRANCH IF RESULT NEGATIVE
                JR    DONE
  FPOS:         JP    P.DEST        ;YES. BRANCH IF RESULT POSITIVE
  DONE:         NOP

Remember, lP PE means "jump on overflow," while lP PO means "jump on no
overflow."
  The programmer should also note that this is one of the few cases in which the Z80 is
not fully upward-compatible with the 8080 microprocessor. 9 The 8080 has no overflow
indicator and the P flag always indicates even parity.
  There are some cases in which overflow cannot occur and all we must do is use the
Sign flag instead of the Carry flag for branching. These cases are the following:
  . The two numbers have the same sign. When this occurs, the difference is smaller in
magnitude than the larger of the two numbers and overflow cannot occur. You can
easily determine if two numbers have the same sign by EXCLUSIVE ORing them
together and checking the Sign flag. Remember, the EXCLUSIVE OR of two bits is 1 if
and only if the two bits have different values.

                XOR   VALUE         ;COULD OVERFLOW OCCUR?
                JP    P.NOOVF       ;NOT IF SIGNS ARE THE SAME
30    Z80 ASSEMBLV LANGUAGE SUBROUTINES


  . A value is being compared with zero. In this case, the Sign flag must be set and
examined.

Examples
  1. Jump to DEST if the accumulator contains a signed positive number.
           AND     A          ;SET FLAGS FROM VALUE IN A
           ..JP    P, DEST

  2. Jump to DEST if an 8-bit register contains a signed negative number.
            INC    reg        ;SET FLAGS FROM VALUE IN REGISTER
           DEC     reg
           .JP     M, DEST
This sequence does not affect the accumulator or the register.

  3. Jump to DEST if memory location ADDR contains a signed positive number.
           LD      HL,ADDR    ;POINT TO DATA IN MEMORY
            INC    (HU
           DEC     (HU
           ...IP   P, DEST     ;BRANCH IF DATA IS POSITIVE
This sequence does not affect the accumulator or the memory location.
  Tables 1-7 and 1-8 summarize the common instruction sequences for making
decisions with the Z80 microprocessor. Table 1-7 lists the sequences that depend only
on the value in the accumulator; Table 1-8 lists the sequences that depend on numerical
comparisons between the value in the accumulator and a specific number, the contents
of a register, or the contents of a memory location (addressed through HL or an index
register). Table 1-9 contains the sequences that depend only on the contents of a
memory location.


LOOPING
  The simplest way to implement a loop (that is, to repeat a sequence of instructions)
with the Z80 microprocessor is to perform the following steps:
  I. Load register B with the number of times the sequence is to be repeated.
  2. Execute the sequence.
   3. Use the DJNZ instruction to decrement register B and return to Step 2 if the
result is not O.
  The DJNZ instruction is useful for loop control since it combines a decrement and a
conditional relative branch. Note that DJNZ always operates on register Band
                                         CHAPTER 1· GENERAL PROGRAMMING METHODS                  31
Table 1·7. Decision Sequences Depending on the Accumulator Alone

          Condition                      Flag Setting Instruction             Conditional Jump

      Any bit = 0                   BIT n,A                                   JR Z orJP Z
      Any bit = I                   BIT n,A                                   JR NZ orJP NZ
     Bit 7 = 0                      RLA, RLCA, or ADD A,A                     JR NC orJP NC
     Bit 7= I                       RLA, RLCA, or ADD A,A                     JR C orJP C
     Bit 6= 0                       ADDA,A                                    JP P
     Bit 6= I                       ADDA,A                                    JPM
     Bit 0= 0                       RRA or RRCA                               JR NC orJP NC
     BitO= I                        RRA orRRCA                                JR CorJPC
     Equals zero                    AND A orORA                               JR Z orJP Z
     Not equal to zero              ANDAorORA                                 JR NZ orJP NZ
     Positive (MSB = 0)             ANDAorORA                                 JP P
     Negative (MSB = I)             AND A or OR A                             JPM




Table 1·8. Decision Sequences Depending on Numerical Comparisons
           with the Accumulator (Using CP)

                    Condition                                         Conditional Jump

       Equal                                                     JR Z orJP Z
       Not equal                                                 JR NZ orJP NZ
       Greater than or equal (unsigned)                          JR NC orJP NC
       Less than (unsigned)                                      JR C or JP C
       Greater than or equal (signed)                            JP P (assuming no overflow)
       Less than (signed)                                        JP M (assuming no overflow)

   Note: All conditions assume that the accumulator contains the primary operand; for example,
   less than means "accumulator less than other operand."




Table 1·9. Decision Sequences Depending on a
           Memory Location Alone

          Condition                     Flag Setting Instruction(s)           Conditional Jump

        Any bit = 0                BIT n, (HL) or (xy+OFFSET)                 JR Z orJP Z
        Any bit = I                BIT n,(HL) or (xy+OFFSET)                  JR NZ orJP NZ
        =0                         INC,DEC                                    JR Z orJP Z
        =1'0                       INC, DEC                                   JR NZ orJP NZ
32    Z80 ASSEMBLY LANGUAGE SUBROUTINES


branches if B is not decremented to 0 - the instruction set does not provide any other
combinations. However, DJNZ has limitations: It allows only an 8-bit counter and an
8-bit offset for the relative branch (the branch is thus limited to 129 bytes forward or
126 backward from the first byte of the instruction).
  Typical programs look like the following:
                LD     B.NTIMES             JNTIMES   = NUMBER    OF REPETITIONS
   LOOP:
                      Instructions to be        rep~ated



                DJNZ LOOP
We could, of course, use other 8-bit registers or count up rather than counting down.
These alternative approaches would require a slightly different initialization, an
explicit DEC or INC instruction, and a conditional JR or JP instruction. In any case,
the instructions to be repeated must not interfere with the counting of the repetitions.
Note that register B is special, and most programmers reserve it as a loop counter.
  The 8-bit length of register B limits this simple loop to 256 repetitions. The
programmer can provide larger numbers of repetitions by nesting single-register loops
or by using a register pair as illustrated in the following examples:
  . Nested loops
                LD    C. NTIMM             JSTART OUTER COUNTER
  LOOPO:        LD    B. NTIML             ;START INNER COUNTER
  LOOPI:
                        Instructions to be repeated
                DJNZ LOOPI                 JDECREMENT INNER COUNTER
                DEC C                      JDECREMENT OUTER COUNTER
                JR   NZ,LOOPO
  The outer loop restores the inner counter (register B) to its starting value (NTIML)
after each decrement of the outer counter (register C). The nesting produces a
mUltiplicative factor-the instructions starting at LOOPI are repeated NTIMM X
NTIML times. We use register B as the inner counter to take maximum advantage of
DJNZ. (Clearly, the inner loop is executed many more times than the outer loop.)
   . A register pair as 16-bit counter
                 LD     BC, NTIMES          ;INITIALIZE 16-BIT COUNTER
   LOOP:
                       Instructions to be repeated
                DEC    BC
                LD     A,B                  JTEST 16-BIT COUNTER FOR ZERO
                OR     C
                JR     NZ,LOOP
                                  CHAPTER 1 GENERAL PROGRAMMING METHODS                33

   The extra steps are necessary because DEC rp (or DEC xy) does not affect the Zero
flag (so there is no way of telling if the count has reached 0). The simplest way to
determine if a 16-bit register pair contains 0 is to logically OR the two registers. The
result of the logical OR is 0 if and only if all bits in both registers are O's. Check this
procedure by hand if you are not sure why it works. A major drawback to this
approach is its use of the accumulator, which requires saving the previous contents if
they are needed in the next iteration.


ARRAY MANIPUlATION
  The simplest way to access a particular element of an array is to place the element's
address in register pair HL. In this way, it is possible to
  · Manipulate the element by referring to it indirectly, that is, as (HL).
  · Access the succeeding element (at the next higher address) by using INC to incre-
ment register pair HL or access the preceding element (at the next lower address) by
using DEC to decrement HL.
  · Access an arbitrary element by loading another register pair with the element's
offset from the address in HL and using the ADD HL instruction. If the offset is fixed,
we can also use indexing from a base address in either index register.
  Typical array manipulation procedures are easy to program if the array is one-
dimensional and the elements each occupy one byte. Some examples are
  · Add an element of an array to the accumulator. Assume that the address of the
element is in register pair HL. Update HL so that it contains the address of the
succeeding 8-bit element.
               ADD (HL)             ;ADD CURRENT ELEMENT
               INC HL               ;ADDRESS NEXT EL.EMENT
    Check to see if an element of an array is 0 and add 1 to register C if it is. Assume
that the element's address is in register pair HL. Update HL so that it contains the
address of the preceding 8-bit element.
                LD     A, (HU           ;GET CURRENT ELEMENT
                AND    A                ; IS IT ZERO?
                ,JR    NZ, UPDDT
                INC    C                ;YES, ADD 1 TO COUNT OF ZEROS
  UPDDT:        DEC    HL               ;ADDRESS PRECEDING ELEMENT
  · Load the accumulator with the 35th element of an array. Assume that the base
address of the array is in register pair HL.
                LD     DE,35             GET OFFSET FOR REQUIRED ELEMENT
                ADD    HL,DE             CALCULATE ADDRESS OF ELEMENT
                LD     A,(HL)            OBTAIN THE ELEMENT
34    Z80 ASSEMBLY LANGUAGE SUBROUTINES


   ADD HL,DE performs a 16-bit addition, using register pair HL as a 16-bit accumu-
lator. Note that the 16-bit offset in register pair DE can be either positive or negative.
   The following single instruction performs the same task if the offset is an 8-bit
unsigned number and the base address is in an index register:
                 LD     A,(xy+35) ;OBTAIN THE ELEMENT IN ONE STEP

   Manipulating array elements becomes more difficult if more than one element is
needed during each iteration (as in a sort that requires interchanging of elements), if
the elements are more than one byte long, or if the elements are themselves addresses
(as ina table of starting addresses). The basic problems are the lack of indexing with a
variable offset and the lack of instructions that access 16-bit items indirectly. Some
examples of more general array manipulation are
  . Load register pair DE with a 16-bit element of an array (stored LSB first). The
starting address ofthe element is in register pair HL. Update HL so that it points to the
next 16-bit element.
                LD     E, (HU         ;GET LSB OF ELEMENT
                INC    HL
                LD     D, (HU        ;GET MSB OF ELEMENT
                INC    HL            ;ADDRESS NEXT ELEMENT
    Exchange an element of an array with its successor if the two are not already in
descending order. Assume that the elements are 8-bit unsigned numbers and that the
address of the current element is in register pair HL. Update HL so that it contains the
address of the successor element.
                 LD     A, (HU        ;GET CURRENT ELEMENT
                 INC    (HU
                 CP     (HU           ; I S IT LESS THAN SUCCESSOR?
                 JR     NC,DONE       ;NO, NO INTERCHANGE NECESSARY
                 LD     B, (HU        ;YES, START THE INTERCHANGE
                 LD     (HU,A         ;CURRENT ELEMENT TO NEW POSITION
                 DEC    HL
                 LD     (HU,B         ;SUCCESSOR ELEMENT TO NEW POSITION
                 INC    HL
   DONE:         NOP
  This procedure is awkward because the processor can address only one element at a
time using HL. Clearly, the problem would be even more serious if the two elements
were more than one position apart.
   An alternative approach is to use an index register; that is,
                 LD     A,(xy+O)      ;GET CURRENT ELEMENT
                 CP     (Xy+1)        ; IS IT LESS THAN SUCCESSOR?
                 JR     NC,DONE       ;NO, NO INTERCHANGE NECESSARY
                 LD     B, (Xy+O)     ;YES, START THE INTERCHANGE
                 LD     (xy+1),A      ;CURRENT ELEMENT TO NEW POSITION
                 LD     (xy+O),B      ;SUCCESSOR ELEMENT TO NEW POSITION
   DONE:         INC    xy            ;MOVE ON TO NEXT PAIR
                                CHAPTER 1 GENERAL PROGRAMMING METHODS                35
    Load the accumulator from the 12th indirect address in a table. Assume that the
base address of the table is in register pair HL.
          LD     DE,24         ;GET DOUBLED OFFSET FOR ELEMENT
          ADD    HL,DE         ;CALCULATE STARTING ADDRESS OF ELEMENT
          LD     E, (HU        ;GET LSB OF INDIRECT ADDRESS
          INC    HL
          LD     D, (HU        ;GET MSB OF INDIRECT ADDRESS
          LD     A, <DE)       ; OBTAIN DATA FROM INDIRECT ADDRE::;S
An alternative approach using an index register is
          LD     A,(xy+24) ;GET LSB OF INDIRECT ADDRESS
          LD     E,A
          LD     A,(xy+25) ;GET MSB OF INDIRECT ADDRESS
          LD     D,A
          LD     A, <DE)   ;OBTAIN DATA FROM INDIRECT ADDRESS
  Note that in either approach you must double the index to handle tables containing
addresses, since each 16-bit address occupies two bytes of memory.
  Some ways to simplify array processing are
  · Keep the base address of the table or array in register pair DE (or BC), so ADD HL
or ADD xy does not destroy it.
  · Use ADD A,A to double an index in the accumulator. The doubled index can then
be used to handle arrays or tables consisting of 16-bit elements. ADD HL,HL or ADD
xy,xy may be used to double 16-bit indexes.
  · Use EX DE,HL to move addresses to and from register pair HL.
  Chapters 5 and 9 contain further examples of array manipulation.


Block Move and Block Compare Instructions
   Another way to simplify array processing is to use the Z80's block move and block
compare instructions. The block move instructions not only transfer data from one
memory location to another without using the accumulator, but they also update the
array pointers and decrement a 16-bit loop counter. Thus, a block move instruction
can replace a sequence of load, increment, and decrement instructions. Repeated
block move instructions continue transferring data, updating the pointers, and decre-
menting the counter until the counter is decremented to zero. Block compare instruc-
tions are similar to block moves, except that only a single pointer is involved (the other
operand is in the accumulator), and the repeated versions also terminate if the
operands being compared are equal (this is referred to as a true comparison).
   A further convenience of block moves and block compares is that they solve the
problem of testing a 16-bit counter for O. Both block moves and block compares clear
36      Z80 ASSEMBLY LANGUAGE SUBROUTINES


the Parity/Overflow flag if the 16-bit counter (always in register pair BC) is decre-
mented to zero, and set the Parity/Overflow flag otherwise. Note that the indicator is
the Parity/Overflow flag, not the Zero flag.
  The block move and compare instructions are the following:
  · LDI (LDD) moves a byte of data from the address in HL to the address in DE,
decrements BC, and increments (decrements) DE and HL.
     · LDIR (LDDR) repeats LDI (LDD) until BC is decremented to      o.
  · CPI (CPD) compares the accumulator to the data at the address in HL, decre-
ments BC, and increments (decrements) HL. Both CPI and CPD set the Zero flag if
the operands being compared are equal, and clear the Zero flag otherwise.
     · CPIR (CPDR) repeats CPI (CPD) until BC is decremented to O.
  Note that block moves reserve BC, DE, and HL for special purposes, while block
compares reserve only BC and HL.

Examples
 1. Move a byte of data from memory location ADDRI to memory location
ADDR2.
            LD   BC.l         ~NUMBER OF BYTES TO MOVE   1     =
            LD   DE.ADDRl     ~INITIALIZE SOURCE POINTER
            LD   HL.ADDR2     ~INITIALIZE DESTINATION POINTER
            LDI or LDD        ~MOVE A BYTE OF DATA


Obviously, the overhead of loading all the register pairs makes it uneconomical to use
LDI or LDD to move a single byte of data.

 2. Move two bytes of data from memory locations ADDRI and ADDRI+ I to
memory locations ADDR2 and ADDR2+ 1.

            LD   BC.2         ;NUMBER OF BYTES TO MOVE = 2
            LD   DE.ADDRl     ; INITIALIZE SOURCE POINTER
            LD   HL.ADDR2     ;INITIALIZE DESTINATION POINTER
            LDIR              ;MOVE TWO BYTES OF DATA

or

            LD   BC.2          ;NUMBER OF BYTES TO MOVE = 2
            LD   DE.ADDR1+l    ; INITIALIZE SOURCE POINTER
            LD   HL.ADDR2+1    ; INITIALIZE DESTINATION POINTER
            LDDR               ;MOVE TWO BYTES OF DATA

The block move instructions become more useful as the number of bytes to be moved
increases.
                                CHAPTER 1. GENERAL PROGRAMMING METHODS             37
  3. Move ten bytes of data from memory locations starting at ADDRI to memory
locations starting at ADDR2.
            LD   BC,10         ;NUMBER OF BYTES TO MOVE = 10
            LD   DE,ADDRl      ;INITIALIZE SOURCE POINTER
            LD   HL,ADDR2      ; INITIALIZE DESTINATION POINTER
            LDIR               ;MOVE TEN BYTES OF DATA

or

            LD   BC,10          ;NUMBER OF BYTES TO MOVE = 10
            LD   DE,ADDR1+9     ;INITIALIZE SOURCE POINTER
            LD   HL,ADDR2+9     ,INITIALIZE DESTINATION POINTER
            LDDR                ;MOVE TEN BYTES OF DATA

  4. Examine memory locations starting at ADDR until one is encountered that
contains 0 or until 256 bytes have been examined.
            LD   BC,100H      ;MAXIMUM LENGTH = 100 HEX = 256
            LD   HL,ADDR      ;POINT TO START OF SEARCH AREA
            SUB A             ;GET ZERO FOR COMPARISON
            CPIR
The final value of the Zero flag indicates why the program exited.
     Zero flag = 1 if the program found a 0 in memory.
     Zero flag = 0 if the program decremented BC to O.
   The block move and block compare instructions are convenient, but their forms are
restricted and their applications are limited. The programmer must remember the
following:
   . BC always serves as the counter; it is decremented after each iteration. The
Parity / Overflow flag (not the Zero flag) indicates whether BC has been decremented
to O. Be careful-the P / V flag is set to 0 ifBC has been decremented toO; the polarity
is opposite of that used with the Zero flag. Thus, after a block move or block compare,
the relevant conditional branches have the following meanings:
         lP PE means "branch if BC has not been decremented to 0."
         lP PO means "branch if BC has been decremented to 0."
     HL always serves as the source pointer in block moves and as the memory pointer
in block compares. HL is incremented or decremented after the data is transferred or a
comparison is performed.
  . DE always serves as the destination pointer in block moves; it is not used in block
compares. Like HL, DE is incremented or decremented after the data is transferred.
Note also that LDI and LDIR increment both HL and DE, while LDD and LDDR
decrement both pairs.
38    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  • Repeated block comparisons exit if either a true comparison occurs or Be is
decremented to O. Testing the Zero flag will determine which condition caused the exit.



TABLE LOOKUP
   Although the Z80 processor has indexing, the calculations required for table lookup
must be performed explicitly using the ADD HL or ADD xy instruction. This is
because the Z80's indexing assumes a variable 16-bit address in an index register and a
fixed 8-bit offset. As with array manipulation, table lookup is simple if the table
consists of 8-bit data items; it is more complicated if the table contains longer items or
addresses. The instructions EX DE,HL and lP (HL) or lP (xy) can be useful, but
require the programmer to place the results in specific 16-bit registers.

Examples
  1. Load the accumuiator with an element from a table. Assume that the base
address of the table is BASE (a constant) and the 16-bit index is in memory locations
INDEX and INDEX+I (MSB in INDEX+1).
           LD     DE. BASE            ;OET BASE ADDRESS
           LD     HL. (INDEX)         ;OET INDEX
           ADD    HL.DE               ;CALCULATE ADDRESS OF ELEMENT
           LD     A. (HU              ;OBTAIN THE ELEMENT
  Reversing the roles of DE and HL would slow down the program since LD
DE,(ADDR) executes more slowly and occupies more memory than does LD
HL,(ADDR). This asymmetry is caused by the fact that only LD HL,(ADDR) is an
original 8080 instruction; the direct loads of other register pairs (including the stack
pointer) are additions to the underlying 8080 instruction set.

  2. Load the accumulator with an element from a table. Assume that the base
address of the table is BASE (a constant) and the index is in the accumulator.
           LD     L.A                  ;EXTEND INDEX TO 16 BITS IN HL
           LD     H.O
           LD     DE. BASE            ;OET BASE ADDRESS
           ADD    HL.DE               ;CALCULATE ADDRESS OF ELEMENT
           LD     A. (HU              ;OBTAIN THE ELEMENT

  3. Load register pair DE with a 16-bit element from a table. Assume that the base
address of the table is BASE (a constant) and the index is in the accumulator.
           ADD    A.A                 ;DOUBLE INDEX FOR 16-BIT ELEMENTS
           LD     L,A                 ;EXTEND INDEX TO 16 BITS
           LD     H,O
                                  CHAPTER 1 GENERAL PROGRAMMING METHODS             39
                LD      BC,BASE            ;GET BASE ADDRESS
                ADD     HL,BC              ;CALCULATE STARTING ADDRESS
                LD      E, (HU             ;GET LSB OF ELEMENT
                INC     HL
                LD      D, (HU             ;GET MSB OF ELEMENT
  You can also use the instruction ADD HL,HL to double the index; it is slower than
ADD A,A but it automatically handles cases in which the doubled index is too large
for 8 bits.

  4. Transfer control Uump) to a 16-bit address obtained from a table. Assume that
the base address ofthe table is BASE (a constant) and the index is in the accumulator.
                ADD     A, A               ; DOUBLE INDEX FOR 16-BIT ELEMENTS
                LD      L,A                ;EXTEND INDEX TO 16 BITS
                LD      H,O
                LD      BC,BASE            ;GET BASE ADDRESS
                ADD     HL,BC              ;CALCULATE STARTING ADDRESS
                LD      E, (HU             ;GET LSB OF DESTINATION
                INC     HL
                LD      D, (HU             ;GET MSB OF DESTINATION
                EX      DE,HL
                .JP     (HU                ; ,JUMP TO DESTI NAT I ON
  The common uses of jump tables are to implement CASE statements (multi-way
branches used in languages such as FORTRAN, Pascal, and PLjI), to decode com-
mands from a keyboard, and to respond to function keys on a terminal.



CHARACTER MANIPUlATION
  The easiest way to manipulate characters on the Z80 processor is to treat them as
unsigned 8-bit numbers. The letters and digits form ordered subsequences of the
ASCII character set (for example, the ASCII version of the letter A is one less than the
ASCII version of B). Appendix C contains a complete ASCII character set.

Examples
  1. Branch to address DEST if the accumulator contains ASCII E.
                CP      "E"         ;IS DATA ASCII E?
                ...IR    Z,DEST     ;YES, BRANCH

  2. Search a string starting at address STRNG until a non-blank character is found.
                LD      HL,STRNG     ;POINT TO START OF STRING
   EXAMC:       LD      A,(HL)       ;GET NEXT CHARACTER
                CP                   ; IS IT A BLANK?
                JR      NZ,DONE      ;NO, DONE
40      Z80 ASSEMBLY LANGUAGE SUBROUTINES

                 INC    HL            ~YES.   PROCEED TO NEXT CHARACTER
                 JP     EXAMC
     DONE:       NOP
or
                 LD    HL.STRNG-l ~POINT TO BYTE BEFORE STRING
     EXAMC:       INC HL
                 LD    A. (HU        ,GET NEXT CHARACTER
                 CP                  ~ IS IT A BLANK?
                 JR    Z.EXAMC       ,YES. KEEP LOOKING
  We could make either version execute faster by placing the blank character in a
general-purpose register (for example, register C) and comparing each character with
that register (using CP C) rather than with an immediate data value.
  We could also use the block compare instructions which combine the comparison
and the incrementing ofthe pointer in HL. The CPI instruction, for example, not only
compares the accumulator with the data at the address in HL, but also increments HL
and decrements Be. Thus, the program using CPI is
                 LD   HL.STRNG ,POINT TO START OF STRING
                 LD   A."           ~OET A BLANK FOR COMPARISON
  EXAMC:         CPI                ,IS NEXT CHARACTER A BLANK?
                 JR   Z.EXAMC       ,YES. KEEP LOOKINO
   The CPI instruction sets the Zero flag to I if the operands being compared are equal
and to 0 ifthey are not equal. It also sets the Parity / Overflow flag to 0 if it decrements
BC to 0 and to I if it does not, thus allowing the programmer to check easily for the
termination of the string as well as for a true comparison. We cannot use CPIR here,
since it would terminate as soon as a blank character (rather than a non-blank
character) was found.

   3. Branch to address DEST if the accumulator contains a letter between C and F,
inclusive.
                CP     "C'"          ~IS DATA BELOW C?
                JR     C.DONE        ,YES. DONE
                CP     "0"           ,IS DATA BELOW G?
                JR     C.DEST        ,YES. MUST BE BETWEEN C AND F
     DONE:      NOP
   We have taken advantage of the fact that G follows F numerically in ASCII, just
as it does in the alphabet. Chapter 8 contains further examples of string manipulation.




CODE CONVERSION
   You can convert data from one code to another using arithmetic or logical opera-
tions (if the relationship is simple) or lookup tables (if the relationship is complex).
                                  CHAPTER 1. GENERAL PROGRAMMING METHODS              41
Examples
  1. Convert an ASCII digit to its binary-coded decimal (BCD) equivalent.
            SUB    ~O~           ;CONVERT ASCII TO BCD
Since the ASCII digits form an ordered subsequence of the code, all that must be done
is subtract the offset (ASCII 0).
   You can also clear bits 4 and 5 with the instruction
            AND    11001111B ;CONVERT ASCII TO BCD

Either the arithmetic instruction or the logical instruction will convert ASCII 0 (3016)
to decimal 0 (0016).

  2. Convert a binary-coded-decimal (BCD) digit to its ASCII equivalent.
            ADD    A,~O~         ;CONVERT BCD TO ASCII
The inverse conversion is equally simple. Bits 4 and 5 can be set with the instruction
            OR     00110000B ;CONVERT BCD TO ASCII
Either the arithmetic instruction or the logical instruction will convert decimal 6 (0616)
to ASCII 6 (3616).

  3. Convert one 8-bit code to another using a lookup table. Assume that the lookup
table starts at address NEWCD and is indexed by the value in the original code (for
example, the 27th entry is the value in the new code corresponding to 27 in the original
code). Assume that the data is in memory location CODE.
            LD     A, (CODE)     ;GET THE OLD CODE
            LD     L,A           ;EXTEND INDEX TO 16 BITS
            LD     H,O
            LD     DE,NEWCD      ;GET BASE ADDRESS
            ADD    HL,DE         ;CALCULATE ADDRESS OF ELEMENT
            LD     A, (HU        ;GET THE ELEMENT
Indexed addressing cannot be used here, since memory location CODE contains a
variable value.
   Chapter 4 contains further examples of code conversion.


MULTIPLE·PRECISION ARITHMETIC
  Multiple-precision arithmetic requires a series of 8-bit operations. They are
  . Clear the Carry flag initially, since there is never a carry into or borrow from the
least significant byte.
42    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  . Use the Add with Carry (ADC) or Subtract with Carry (SBC) instruction to
perform an 8-bit operation and include the carry or borrow from the previous
operation.
  A typical 64-bit addition program is
               LD     B,S         ,NUMBER OF BYTES = 8
               SUB A              ;CLEAR CARRY INITIALLY
               LD     HL,NUMI     ,POINT TO START OF NUMBERS
               LD     DE,NUM2
  ADDS:        LD     A, (DE)     ,OET A BYTE OF ONE OPERAND
               ADC A, (HU         ,ADD A BYTE OF THE OTHER OPERAND
               LD     (HU,A       ,STORE THE S-BIT SUM
               INC DE             ;UPDATE POINTERS
               INC HL
               DJNZ ADDS          ,COUNT BYTE OPERATIONS
  Chapter 6 contains further examples.


MULTIPLICATION AND DIVISION
  There are many ways to implement multiplication. One approach is to convert
multiplication by a small integer into a specific short sequence of additions and left
shifts.

Examples
  1. Multiply the contents of the accumulator by 2.
                ADD. A, A             , DOUBLE A

  2. Multiply the contents of the accumulator by 5.
                LD      B,A
                ADD     A,A           ,A TIMES 2
                ADD     A,A           ,A TIMES 4
                ADD     A,B           ;A TIMES :5
   Both examples assume that no carries ever occur. ADD HL could be similarly used
to produce a 16-bit result.
   This approach is often handy in accessing elements of two-dimensional arrays. For
example, assume a set oftemperature readings taken at four different positions in each
of three different storage tanks. Organize the readings as a two-dimensional array
T(I,l), where I is the tank number (I, 2, or 3) and 1 identifies the position in the tank (I,
2, 3, or 4). Store the reading in the computer's memory one after another as follows,
starting with the reading at position I of tank I:
           BASE                 T<1,1>        Reading at tank 1, position 1
           BASE+l               1< 1,2)       Reading at tank 1, position 2
           BASE+2               T(1,3)        Reading at tank 1, position 3
                                 CHAPTER 1 GENERAL PROGRAMMING METHODS                        43
             BASE+3             T< 1. 4)      Reading    at   tank       1. pl::.si t ion 4
             BASE+4             T<2,1)        Reading    at   tank       '" PCIS i t ion 1
                                                                         "-,
             BASE+5             T(2,2)        Reading    at   tank       2,   position    2
             BASE+6             T<2,3)        Reading    at   tank       2,   position    3
             BASE+7             T<2,4)        Reading    at   tank       2,   pc,sition   4
             BASE+8             T<3,1)        Reading    at   tank       3,   position    1
             BASE+9             T<3,2)        Reading    at   tank       3,   position    2
             BASE+I0            T(3,3)        Reading    at   tank       3,   posit ion   3
             BASE+ll            T<3,4)        Reading    at   tank       3,   pc'sition   4
   Generally, the reading T(I,J) is located at address BASE + 4 * (1-1) + (1-1). IfI is in
the accumulator and J is in register B, the accumulator can be loaded with T(I,J) as
follows:
             DEC   A            ;OFFSET FOR TANK I
             ADD   A,A          ;2 * (1-1)
             ADD   A,A          ;4 * (1-1)
             ADD   A,B          ;ADD OFFSET FOR POSITION             J
             DEC   A            ;4   *   (1-1) + (J-l)
             LD    L,A          ;EXTEND INDEX TO 16 BITS
             LD    H,O
             LD    DE, BASE     ;GET BASE ADDRESS OF READINGS
             ADD   HL,DE        ;ACCESS DESIRED READING
             LD    A, (HU       ; FETCH T ( I , •..1)
  Extending this approach to handle arrays with more dimensions is shown in
Chapter 5.
  Division by a power of 2 can be implemented as a series of right logical shifts.

Example
     Divide the contents of the accumulator by 4.
             SRL   A            ;DIVIDE A BY 2
             SRL   A            ;AND THEN BY 2 AGAIN

01

            RRA                ;DIVIDE A BY 4 BY ROTATING IT TWICE
            RRA
            AND    00111111 B ; MAKE SH I FTS LOG I CAL BY CLEAR I NG MSB'- S

  The second alternative uses the one-byte instruction RRA, rather than the two-byte
instruction SRL A. When mUltiplying or dividing signed numbers, be careful to
separate the signs from the magnitudes. Replace logical shifts with arithmetic shifts
that preserve the value of the sign bit.
  Other approaches to multiplication and division include algorithms involving shifts
and additions (multiplication) or shifts and subtractions (division) as described in
Chapter 6, and lookup tables as discussed previously in this chapter.
44     Z80 ASSEMBLY LANGUAGE SUBROUTINES


LIST PROCESSING
   Additional information on the following material can be found in an article by K.S.
Shankar published in IEEE Computer. 10
   Lists can be processed like arrays if the elements are stored in consecutive addresses.
If the elements are queued or chained, however, the limitations of the instruction set
are evident because
    Indexed addressing allows only an 8-bit fixed offset.
    No indirect addressing is available, except through register pairs or index registers.
    Addresses in register pairs or index registers can be used only to retrieve or store
8-bit data.
Examples
   1. Retrieve an address stored starting at the address in register pair HL. Place the
retrieved address in HL.
         LD      E, (HU       ;OET LSB OF LINK
         INC     HL
         LD      D, (HU       ;OET MSB OF LINK
         EX      DE,HL        ;REPLACE CURRENT POINTER WITH LINK
  This procedure allows you to move from one element to another in a linked list.

  2. Retrieve data from the address currently in memory locations INDIR and
INDIR+ 1 and increase that address by 1.
           LD     HL,(INDIR);GET POINTER FROM MEMORY
           LD     A, (HL)     ;GET DATA USING POINTER
           INC    HL          ;UPDATE POINTER BY 1
           LD     <INDIR), HL
  This procedure allows the use of the address in memory as a pointer to the next
available location in a buffer.

  3. Store an address from DE starting at the address currently in register pair HL.
Increment HL by 2.
           LD     (HL),E       ;STORE LSB OF POINTER
           INC    HL
           LD     (HL),D       ;STORE MSB OF POINTER
           INC    HL           ;COMPLETE UPDATING OF HL
   This procedure allows building a list of addresses. Such a list could be used, for
example, to write threaded code in which each routine concludes by transferring
control to its successor. The list could also contain the starting addresses of a series of
test procedures or tasks or the addresses of memory locations or II 0 devices assigned
by the operator to particular functions.
                                 CHAPTER 1 GENERAL PROGRAMMING METHODS              45

GENERAL DATA STRUCTURES
   Additional information on the following material can be found in the book Data
Structures Using Pascal by A. Tenenbaum and M. Augenstein. I I There are several
versions of this book by the same authors for different languages and computers.
   More general data structures can be handled using the procedures for array manipu-
lation, table lookup, and list processing that have been described earlier. The key
limitations in the instruction set are the same ones mentioned in the discussion of list
processing.

Examples
   1. Queues or linked lists. Assume there is a queue header consisting of the base
address of the first element in memory locations HEAD and HEAD+ 1. If there are no
elements in the queue, HEAD and HEAD+ 1 both contain O. The first two locations in
each element contain the base address of the next element or 0 if there is no next
element.
   . Add an element to the head of the queue. Assume that the element's base address is
in DE.
                 LD     HL,HEAD             ;REPLACE HEAD, SAVING OLD VALUE
                 LD     A, (HU              ;MOVE LESS SIGNIFICANT BYTES
                 LD     (HU,E
                 INC    HL
                 LD     B, (HU              ;MOVE MORE SIGNIFICANT BYTES
                 LD     (HU,D
                 LD     <DE),A              ;NEW HEAD POINTS TO OLD HEAD
                 LD     A,B                 ; INCLUDING MORE SIGNIFICANT BYTES
                 INC    DE
                 LD     (DE), A
     Remove an element from the head of the queue and set the Zero flag if no element
is available. Place the base address of the element (or 0 if there is no element) in DE.
                LD     HL,HEAD              ;OBTAIN HEAD OF QUEUE
                LD     E, (HU               ;LESS SIGNIFICANT BYTE
                INC    HL
                LD     D, (HU               ;MORE SIGNIFICANT BYTE
                LD     A,D
                OR     E                    ;ANY ELEMENTS IN QUEUE?
                .JR    Z,DONE               ; NO, DONE
                INC    DE                   ; YES, MAKE NEXT ELEMENT NEW HEAD
                LD     A,(DE)
                LD     (HU ,A               ; MORE SIGNIFICANT BYTE
                DEC    DE
                DEC    HL
                LD     (DE),A               ; LESS SIGNIFICANT BYTE
                LD     (HU,A
   DONE:        NOP
46    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  Since no instruction after OR E affects any flags, the final value of the Zero flag
indicates whether the queue was empty.

   2. Stacks. Assume there is a stack structure consisting of 8-bit elements. The
address of the next empty location is in addresses SPTR and SPTR+ 1. The lowest
address that the stack can occupy is LOW and the highest address is HIGH. Note that
this software stack grows up in memory (toward higher addresses), whereas the Z80's
hardware stack grows down (toward lower addresses).
  . If the stack overflows, set the Carry flag and exit. Otherwise, store the accumula-
tor in the stack and increase the stack pointer by 1. Overflow means that the stack has
expanded beyond its assigned area.
                 LD    HL. (SPTR)           ,GET THE STACK POINTER
                 EX    DE.HL
                 LD    HL.-(HIGH+l)         ,CHECK FOR STACK OVERFLOW
                 ADD HL.DE                  ,SET CARRY IF STACK OVERFLOWS
                 JR    C.DONE               ,AND EXIT ON OVERFLOW
                 EX    DE.HL                ,GET STACK POINTER BACK
                 LD     (HU.A               ,STORE ACCUMULATOR IN STACK
                 INC HL                     ,UPDATE STACK POINTER
                 LD     (SPTR). HL
  DONE:          NOP
  . If the stack underflows, set the Carry flag and exit. Otherwise, decrease the stack
pointer by 1 and load the accumulator from the stack. Underflow means that an
attempt has been made to remove data from an empty stack.
               LD     HL.(SPTR)           ,GET THE STACK POINTER
               EX     DE.HL
               LD     HL.-(LOW+l)         ,CHECK FOR STACK UNDERFLOW
               ADD    HL.DE               ,CLEAR CARRY IF STACK UNDERFLOWS
               JR     NC.DONE             ,AND EXIT ON UNDERFLOW
               EX     DE.HL               ;GET STACK POINTER BACK
               DEC    HL                  ,UPDATE STACK POINTER
               LD     A, (HU              ;LOAD ACCUMULATOR FROM STACK
               LD     (SPTR). HL          ,RESTORE STACK POINTER
  DONE:        CCF                        ,SET CARRY ON UNDERFLOW

  Both example programs utilize the fact that ADD HL affects only the Carry flag.
Remember, AD D HL does not affect the Zero flag. Note also that DEC rp and INC rp
do not affect any flags.


PARAMETER PASSING TECHNIQUES
  The most common ways to pass parameters on the Z80 microprocessor are
  1. In registers. Seven 8-bit primary user registers (A, B, C, D, E, H, and L) are
available, and the three register pairs (BC, DE, and HL) and two index registers (IX
                                CHAPTER 1 GENERAL PROGRAMMING METHODS               47
and IY) may be used readily to pass addresses. This approach is adequate in simple
cases, but it lacks generality and can handle only a limited number of parameters. The
programmer must remember the normal uses of the registers in assigning parameters.
In other words,
  · The accumulator is the obvious place to put a single 8-bit parameter.
  · Register pair HL is the obvious place to put a single address-length (16-bit)
parameter.
  · Register pair DE is a better place to put a second address-length parameter than
register pair Be, because of the EX DE,HL instruction.
   · An index register (IX or IY) is the obvious place to put the base address of a data
structure when elements are available at fixed offsets.
   This approach is reentrant as long as the interrupt service routines save and restore
all the registers.

   2. In an assigned area of memory. There are two ways to implement this approach.
One is to place the base address of the assigned area in an index register. Then
particular parameters may be accessed with fixed offsets. The problem here is that the
Z80's indexing is extremely time-consuming. An alternative is to place the base
address in HL. Then parameters must be retrieved in consecutive order, one byte at a
time.
   In either alternative, the calling routine must store the parameters in memory and
load the starting address into the index register or HL before transferring control to
the subroutine. This approach is general and can handle any number of parameters,
but it requires a lot of management. If different areas of memory are assigned for each
call or each routine, a unique stack is essentially created. If a common area of memory
is used, reentrancy is lost. In this method, the programmer is responsible for assigning
areas of memory, avoiding interference between routines, and saving and restoring the
pointers required to resume routines after subroutine calls or interrupts.

   3. In program memory immediately following the subroutine call. If this approach
is used, remember the following:
  . The base address of the memory area is at the top of the stack; that is, the base
address is the normal return address, the location of the instruction immediately
following the call. The base address can be moved to an index register by popping the
stack with
           POP Xy              :RETRIEVE BASE ADDRESS OF PARAMETERS
  N ow access the parameters with fixed offsets from the index register. For example,
the accumulator can be loaded with the first parameter by using the instruction
          LD     A,   (Xy+O)   :MOVE FIRST PARAMETER TO A
48    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  . All parameters must be fixed for a given call, since the program memory is
typically read-only.
  . The subroutine must calculate the actual return address (the address immediately
following the parameter area) and place it on top of the stack before executing a RET
instruction.

Example
   Assume that subroutine SUBR requires an 8-bit parameter and a 16-bit parameter.
Show a main program that calls SUBR and contains the required parameters. Also
show the initial part of the subroutine that retrieves the parameters, storing the 8-bit
item in the accumulator and the 16-bit item in register pair HL, and places the correct
return address at the top of the stack.

Subroutine call
                  CALL SUBR          ;EXECUTE SUBROUTINE
                  DEFB PAR8          ;8-BIT PARAMETER
                  DEFW PAR16         ; 16-BIT PARAMETER
                         next instruction


Subroutine
  SUBR:           POP    xy          ;POINT TO START OF PARAMETER AREA
                  LD     A, (Xy+1)   ;GET LSB OF 16-BIT PARAMETER
                  LD     E,A
                  LD     A,(xy+2)    ;GET MSB OF 16-BIT PARAMETER
                  LD     D,A
                  LD     A,(xy+O)    ;GET 8-BIT PARAMETER
                  LD     BC,3        ;UPDATE RETURN ADDRESS
                  ADD    xy,BC
                  PUSH   xy


                          remainder of subroutine • • •


                  RET                ;RETURN TO NEXT INSTRUCTION
   The initial POP xy instruction loads the index register with the return address that
CALL SUBR saved at the top of the stack. In fact, the return address does not contain
an instruction; instead, it contains the first parameter (PAR8). The next instructions
move the parameters to their respective registers. Finally, adding 3 to the return
address and saving the sum in the stack makes the final RET instruction transfer
control back to the instruction following the parameters.
   This approach allows parameter lists of any length. However, obtaining the parame-
ters from memory and adjusting the return address is awkward at best; it becomes a
longer and slower process as the number of parameters increases.
                                  CHAPTER 1 GENERAL PROGRAMMING METHODS                 49
   4. In the stack. When using this approach, remember the following:
  · CALL stores the return address at the top of the stack. The parameters that the
calling routine placed in the stack begin at address ssss + 2, where ssss is the contents of
the stack pointer. The l6-bit return address occupies the top two locations of the stack,
and the stack pointer itself always refers to the lowest occupied address, not the highest
empty one.
  · The subroutine can determine the value of the stack pointer (the location of the
parameters) by (a) storing it in memory with LD (ADDR),SP or (b) using the sequence
           LD     HL,O           ~MOVE    STACK POINTER TO HL
           ADD    HL,SP

This sequence places the stack pointer in register pair HL (the opposite of LD SP,HL).
We can use an index register instead of HL if HL is reserved for other purposes.
  · The calling program must place the parameters in the stack and assign space for
the results before calling the subroutine. It must also remove the parameters from the
stack (often referred to as cleaning the stack) afterward. Cleaning the stack is simple if
the programmer always places the parameters above the empty area assigned to the
results. Then the parameters can be removed, leaving the results at the top. The next
example illustrates how this is done. An obvious alternative is for the results to replace
some or all of the parameters.
     Stack locations can be allocated dynamically for results with the sequence

           LD     HL,-NRESLT             ~LEAVE   ROOM FOR RESLILTS
           ADD    HL,SP
           LD     SP,HL

  This sequence leaves NRESLT empty locations at the top of the stack as shown in
Figure 1-8. Of course, if NRESLT is small, simply executing DEC SP NRESLT times
will be faster and shorter. The same approaches can be used to provide stack locations
for temporary storage.

Example
   Assume that subroutine SUBR requires an 8-bit parameter and a l6-bit parameter,
and that it produces two 8-bit results. Show a call of SUBR, the placing of the
parameters in the accumulator and register pair HL, and the cleaning of the stack after
the return. Figure 1-9 shows the appearance of the stack initially, after the subroutine
call, and at the end. Using the stack for parameters and results will generally keep the
parameters at the top of the stack in the proper order. In this case, there is no need to
save the parameters or assign space in the stack for the results (they will replace some
or all of the original parameters). However, space must be assigned on the stack for
temporary storage to maintain generality and reentrancy.
50    Z80 ASSEMBLY LANGUAGE SUBROUTINES


Calling program
                    LD       HL,-2      ;LEAVE ROOM ON STACK FOR RESULT
                    ADD      HL,SP      ;A GENERAL WAY TO ADJUST SP
                    LD       SP,HL
                    LD       HL,(PAR16);OBTAIN 16-BIT PARAMETER
                    PUSH     HL         ;MOVE 16-BIT PARAMETER TO STACK
                    LD       A, (PAR8) ;OBTAIN 8-BIT PARAMETER
                    PUSH     AF         ; MOVE 8-BIT PARAMETER TO STACK
                    INC      SP         ; REMOVE EXTRANEOUS BYTE
                    CALL     SUBR       ;EXECUTE SUBROUTINE
                    LD       HL,3       ;CLEAN PARAMETERS FROM STACK
                    ADD      HL,SP
                    LD       SP,HL      ;RESULT IS NOW AT TOP OF STACK

Subroutine
     SUBR:          LD       HL,2             ;POINT TO START OF PARAMETER AREA
                    ADD      HL,SP
                    LD       A, (HU           ;GET 8-BIT PARAMETER
                    INC      HL
                    LD       E, (HU           ;GET 16-BIT PARAMETER
                    INC      HL
                    LD       D, (HU
                    INC      HL
                    EX       DE,HL
                            • remainder of subroutine
                  RET
  The first three instructions of the calling program could be replaced with two DEC
SP instructions, and the last three instructions with three INC SP instructions. Note
that only 16-bit register pairs can be moved to or from the stack. Remember, AF
consists of the accumulator (MSB) and the flags (LSB).




                                                                                          ssss - NRESLT



                                                        E7:rt;t~~~;
                                                        results in the
                                                                         {
                                                                             1-----1
                                                                 stack       1-----1
                                       ssss
                        1------1          •                                  1--------"
                                       Stack                                               Stack
                                      Pointer                                             Pointer
  No values are placed in the locations.
  The initial contents of the stack pointer are ssss.

 Figure 1·8. The stack before and after assigning NRESL T empty locations for results
                                          CHAPTER 1. GENERAL PROGRAMMING METHODS                    51

             Initial State of             Stack After Execution         Final State of
                the Stack                    0 fCALL SUBR                 t h e S tac k
                                                              ssss-7
                                             LSB of return
                                                address
                                             MSB of return
                                                 address
                                                  8-bit
                                               parameter
                                             LSB of l6-bit
                                               parameter
                                             MSB of 16-bit                                ssss-2
                                               parameter



                                  ,
                                              Empty byte                  Result #1
                                             for result #1
                                ssss          Empty byte                  Result #2

                                 Stack
                                              for result #2
                                                               Stack
                                                                                            1
                                                                                           Stack
                                Pointer                       Pointer                     Pointer
 The initial contents of the stack pointer are ssss.

 Figure 1·9. The effect of a subroutine on the stack



SIMPLE INPUT/OUTPUT
   Simple inputl output can be performed using either 8-bit device (port) addresses or
full 16-bit memory addresses. The advantages of device addresses are that they are
short and provide a separate address space for 110 ports. The disadvantages are that
only a few instructions (IN, OUT, and block 110 instructions) use device addresses. If,
on the other hand, 110 devices occupy memory addresses, any instruction that
references memory can also perform II O. The problems with this approach are that it
is non-standard, it makes it difficult for a reader to differentiate 110 transfers from
memory transfers, and it requires that some memory address space be reserved for II 0
devices.

Examples
     I. Load the accumulator from input port 2.
            IN      A,(2)              ;READ FROM PORT 2
or
            LD      C,2                ;PLlT PORT ADDRESS IN C
            IN      A, (C)             ;READ FROM PORT 2
52      Z80 ASSEMBLY LANGUAGE SUBROUTINES


   The second alternative is longer but more flexible. The IN reg,(C) instruction allows
the data to be obtained from any port and loaded into any register. On the other hand,
IN A,(port) is limited to loading the accumulator from a fixed port address. The Sign
and Zero flags can be set by IN reg,(C) for later testing, whereas IN A,(port) does not
affect the flags.

  2. Load the accumulator from the input port addressed by the contents of memory
location IPORT.
            LD     A,(IPORT) ;GET DEVICE (PORT) ADDRESS
            LD     C,A
            IN     A,(C)     ;READ DATA FROM INPUT PORT
  The port address can be readily changed (by changing RAM location IPORT) to
accommodate multiple input devices attached to a single CPU or to handle different
device addresses used in different models, configurations, or computers.

 3. Load the accumulator from the input port assigned to the memory address in
HL.
            LD     A, (HU       ;READ DATA FROM INPUT PORT

  Here the same input routine can obtain data from any memory address. Of course,
that memory address is no longer available for normal use, thus reducing the actual
memory capacity of the computer.

 4. Store the accumulator in output port 6.
            OUT    (6) ,A       ; WRITE ,DATA TO PORT 6
or
            LD     C,6          ;ACCESS PORT 6
            OUT    (C) ,A       ;WRITE DATA TO PORT 6

 In the second alternative, the indirect port address can be changed easily to accom-
modate a different set of I/O ports or variable I/O devices.

  5. Store the accumulator in the output port addressed by the contents of memory
location OPORT.
            LD     HL,OPORT     ;OBTAIN PORT ADDRESS
            LD     C, (HU
            OUT    (C),A        ;SEND DATA TO OUTPUT PORT
Here the port address is a variable.

     6. Store the accumulator in the output port assigned to the memory address in HL.
            LD     (HU,A        ;SEND DATA TO OUTPUT PORT
                                    CHAPTER 1. GENERAL PROGRAMMING METHODS             53
Here the same output routine can send data to any memory address.

     7. Set the Zero flag if bit 5 of port D416 is   o.
             IN     A, (OD4H)              ;READ DATA FROM PORT D4
             BIT    S,A                    ; TEST BIT S

If the bit position to be tested is 0, 6, or 7, a shift or AND A instruction can be used to
test it.

  8. Load the Carry flag from bit 7 of the input port assigned to memory address
33A516·
             LD     A, (33ASH)             ;OBTAIN DATA
             RLA                           ;MOVE SIGN BIT TO CARRY

or
             LD     HL,(33A5H)
             RL     (HU                    ;MOVE SIGN BIT OF INPUT DATA TO CARRY
   RL (HL) could have unpredictable side effects, since it will attempt to store its result
back in the input port. Although the port is addressed as a memory location, it may not
be writable (that is, it might act like a ROM location). For example, it could be
attached to a set of switches that the microprocessor obviously cannot change.

     9. Set bit 5 of output port A516.
             LD     A, 00 1OOOOOB            ;SET BIT S TO 1
             OUT    <OASH) , A               ;MOVE THE BIT TO PORT AS
To leave the other bits of port A516 unchanged, a copy of the data in RAM is needed.
Then the following sequence will set bit 5 to 1.
             LD     A, (COPY)              ;GET COPY OF DATA
             SET    S,A                    ;SET BIT S
             OUT    (OASH),A               ;UPDATE OUTPUT DATA
             LD     (COPY),A               ;UPDATE COPY OF DATA
  Note that the CPU cannot generally read an output port, and the input port with the
same device address is not necessarily the same physical location.

  10. Clear bit 3 of the output port assigned to memory address B07016.
             LD     HL, OB070H
             RES    3, (HU                 ; CLEAR BIT 3

  Even though the output port is addressed as a memory location, it may not be
readable. If it is not, the overall effect of RES 3,(HL) will be uncertain; the instruction
will surely clear bit 3, but it will assign the other bits of the port the values supposedly
obtained by reading from them. These values are generally arbitrary unless the port is
54    Z80 ASSEMBLY LANGUAGE SUBROUTINES


latched and buffered. Saving a copy of the data in RAM location TEMP removes the
uncertainty. Now bit 3 can be cleared with the sequence
          LD     HL,TEMP
          RES    3, (HL)              ;SET BIT 3 OF COpy
          LD     DE, B070H
          LDI                         ;SET BIT 3 OF OUTPUT DATA ALSO



Block Input and Output Instructions
   The Z80 has special instructions that combine input or output with counting and
updating of a memory pointer. These so-called block 1/ 0 instructions work much like
the block move and block compare instructions discussed earlier. All block I/O
instructions move data either from memory to an output port or from an input port to
memory (without involving the accumulator), update (either increment or decrement)
the memory pointer in register pair HL, and decrement the counter in register B. Note
that block I/O instructions use an 8-bit byte counter in register B, whereas block move
and block compare instructions use a 16-bit counter in Be. In block I/O instructions,
register C always contains the device address. The only meaningful flag is the Zero
flag; it is set to I if the instruction decrements B to 0, and to 0 otherwise.
   Repeated block I/O instructions continue transferring data, updating HL, and
decrementing B until B is decremented to O. The drawback here is that continuous data
transfers make sense only if the I/O device operates at the same speed as the processor.
Obviously, most I/O devices operate much more slowly than the processor, and the
programmer must introduce a delay between transfers. For example, the processor
cannot transfer a block of data to or from a keyboard, printer, video display, or
magnetic tape unit without waiting between characters. Thus, repeated block I/O
instructions are useful only to transfer data to devices that operate at processor speed,
such as a buffer memory or a peripheral chip.
   The Z80's block I/O instructions are the following:

  · INI (IN D) moves a byte of data from the port address in C to the memory address
in HL, increments (decrements) HL, and decrements B.
  · INIR (INOR) repeats INI (INO) until B is decremented to O.
  · OUTI (OUTO) moves a byte of data from the memory address in HL to the port
address in C, increments (decrements) HL, and decrements B.
  • OTIR (OTOR) repeats OUTI (OUTO) until B is decremented to O.

   Note that block I/O instructions reserve B, C, and HL, but not DE. These instruc-
tions also change all the flags except Carry, although only the Zero flag is meaningful.
                                CHAPTER 1. GENERAL PROGRAMMING METHODS           55
Examples
  1. Move a byte of data from memory address ADDR to output port OPORT.
              LD     B,1              ;NUMBER OF BYTES = 1
              LD     C,OPORT          ;PORT ADDRESS = OPORT
              LD     HL,ADDR          ;INITIALIZE MEMORY POINTER
              OUTI                    ;MOVE A BYTE OF DATA
Obviously, the overhead of loading the registers makes it uneconomical to use OUTI to
send a single byte of data.

  2. Move two bytes of data from input port IPORT to memory addresses ADDR
and ADDR+ 1. Use subroutine DELAY to wait before each transfer; assume that
DELAY provides the proper time interval without affecting any registers.
               LD     B,.2                ;NUMBER OF BYTES = 2
               LD     C,IPORT             ;PORT ADDRESS = IPORT
               LD     HL,ADDR             ; INITIALIZE MEMORY POINTER
   INBYT:      CALL   DELAY               ;WAIT BEFORE EACH INPUT BYTE
               INI                        ;READ A BYTE AND UPDATE
               JR     NZ,INBYT

The Zero flag indicates whether the counter in B has been decremented to O. Not only
does INI transfer the data directly into memory, but it also increments HL and
decrements B.

  3. Move ten bytes of data from memory addresses starting with ADDR to output
port OPORT. Use subroutine DELAY to wait between bytes.
              LD     B,10             ;NUMBER OF BYTES = 10
              LD     C,OPORT          ;PORT ADDRESS = OPORT
              LD     HL,ADDR          ;INITIALIZE MEMORY POINTER
   OUTBYT:    OUTI                    ; WRITE A BYTE AND UPDATE
              CALL DELAY              ;WAIT BETWEEN BYTES
              JR     NZ,OUTBYT
We cannot use the repeated block output instruction OTIR, since it does not allow a
delay between bytes.

  4. Move 30 bytes of data from an input buffer addressed through input port IPORT
to memory addresses starting with ADDR. Assume that the processor can read
successive bytes of data from the buffer without waiting.
               LD   B,30                 ;NUMBER OF BYTES = 30
               LD   C,IPORT              ;PORT ADDRESS = IPORT
               LD   HL,ADDR              ;INITIALIZE MEMORY POINTER
               INIR                      ;READ A BLOCK OF DATA
This sequence does not allow any programmed delay between input operations, so it
makes sense only if the input device operates at the same speed as the processor.
 56     Z80 ASSEMBLY LANGUAGE SUBROUTINES


 LOGICAL AND PHYSICAL DMCES
     One way to allow references to I/O devices by number is to use an 1/ 0 device table.
  An I/O device table assigns the actual I/O addresses (physical devices) to the device
  numbers (logical devices) to which a program refers. A systems program then uses the
  table to convert the device numbers into actual I/O addresses.
     The same applications program can be made to utilize different I/O devices by
  making the appropriate changes in the I/O device table. A program written in a
  high-level language may, for example, refer to input device #2 and output device #5.
  For testing purposes, an operator may assign devices #2 and #5 to be the input and
  output ports, respectively, of his or her console. For normal stand-alone operation, the
  operator may assign device #2 to be an analog input unit and device #5 the system
. printer. For operation by remote control, the operator may assign devices #2 and #5 to
  be communications units used for input and output.
     This distinction between logical and physical devices can be implemented by using
  the instructions IN reg,(C) and OUT (C),reg. If a device table starting in address
  IOTBL and consisting of 8-bit device addresses is used, input and output are general-
  ized as follows:
     Load the accumulator from a fixed device number DNUM.
           LD    A.(IOTBL+DNUM) ;GET DEVICE ADDRESS
           LD    C.A       .
           IN    A.(C)              ,OBTAIN DATA FROM DEVICE
      Load the accumulator from the device number in memory location DEVNO.
            LD    A.(DEVNO)         ;GET DEVICE NUMBER
            LD    L.A               ;MAKE DEVICE NUMBER INTO INDEX
           LD     H.O
           LD     DE. IOTBL         ,GET BASE ADDRESS OF DEVICE TABLE
            ADD HL.DE               ,ACCESS ACTUAL DEVICE ADDRESS
           LD     C. (HL>           ,OBTAIN DEVICE ADDRESS
            IN    A. (C)            ,'OBTAIN DATA FROM DEVICE
     Store the accumulator in a fixed device number DNUM.
           LD     HL,IOTBL+DNUM ,GET DEVICE ADDRESS
           LD     C, (HL>
            OUT (C),A                ;SEND DATA TO DEVICE
      Store the accumulator in the device number in memory location DEVNO.
            LD     B,A                 ,SAVE OUTPUT DATA
            LD     A, <DEVNO)          ,GET DEVICE NUMBER
            LD     L,A                 ,MAKE DEVICE NUMBER INTO INDEX
            LD     H.O
            LD     DE, IOTBL           ,GET BASE ADDRESS OF DEVICE TABLE
            ADD    HL,DE               ,ACCESS ACTUAL DEVICE ADDRESS
            LD     C, (HL>             ;OBTAIN DEVICE ADDRESS
            OUT    (C), B              ,SEND DATA TO DEVICE
                                CHAPTER 1. GENERAL PROGRAMMING METHODS             57

In real applications (see Chapter 10), the device table generally contains the starting
addresses of 110 subroutines (drivers) rather than actual device addresses.



STATUS AND CONTROL
  Status and control signals can be handled like any other data. The only special
problem is that the processor cannot ordinarily read output ports. To know the current
contents of an output port, retain a copy in RAM of the data stored there.

Examples
  1. Branch to address DEST if bit 3 of input port 6 is 1.
           IN     A.(6)              ;READ STATUS FROM PORT 6
           BIT    3.A                ; TEST BIT 3
           ,JR    NZ. DEST           ;BRANCH IF BIT 3 IS 1

  2. Branch to address DEST if bits 4,5, and 6 of input port STAT are 5 (101 binary).
           IN     A.(STAT)           ;READ STATUS
           AND    01110000B          ;MASK OFF BITS 4.5,AND 6
           CP     01010000B          ;IS STATUS FIELD = 5?
           JR     Z.DEST             ;YES, BRANCH TO DEST

   3. Set bit 5 of output port CNTL to 1. Assume that a copy of the data is in a table
starting at address OUTP.
           LD     HL.OUTP+CNTL       ;GET COPY OF DATA
           LD     A. (HU
           OR     00100000B          ;SET BIT 5 OF PORT
           OUT    (CNTU.A            ;SEND DATA TO OUTPUT PORT
           LD     (HU .A-            ;UPDATE COpy OF DATA
Update the copy every time the data is changed.

  4. Set bits 2, 3, and 4 of output port CNTL to 6 (110 binary). Assume that a copy of
the data is in a table starting at address OUTP.
         LD      HL.OUTP+CNTL       ; GET COPY OF DATA
         LD      A. (HU
         AND     11100011B          ;CLEAR BITS 2.3. AND 4
         OR      00011000B          ;SET CONTROL FIELD TO 6
         OUT     (CNTU.A            ;SEND DATA TO OUTPUT PORT
         LD      (HU.A              ;UPDATE COpy OF DATA
  Retaining copies of the data in memory (or using the values stored in a latched,
buffered output port) allows changing part of the data without affecting other parts
that may have unrelated meanings. For example, changing the state of one indicator
58     Z80 ASSEMBLY LANGUAGE SUBROUTINES


light (such as a light that indicated remote operation) will not affect other indicator
lights attached to the same port. Similarly, changing one control line (for example, a
line that determined whether an object was moving in the positive or negative
X-direction) would not affect other control lines attached to the same port.

  5. Branch to address DEST if bit 7 of input port IPORT is O.
           LD       C,IPORT           ;ESTABLISH PORT ADDRESS
            IN      A, (C)            ;READ DATA FROM PORT
           .... P   Z,DEST            ;BRANCH IF INPUT BIT 7 IS 0

The instruction IN reg,(C) affects the Sign and Zero flags, whereas IN A,(port) does
not.


PERIPHERAL CHIPS
   The most common peripheral chips in Z80-based computers are the PIO (Parallel
Input/Output device), SIO (Serial Input/Output device), and CTC (Clock/Timer
Circuit). All these devices can perform many functions, much as the microprocessor
itself can. Of course, peripheral chips perform fewer different functions than proces-
sors, and the range offunctions is much more limited. The idea behind programmable
peripheral chips is that each chip contains many useful circuits; the designer selects the
one he or she wants to use by storing arbitrary codes in control registers, much like
selecting circuits from a designer's casebook by specifying arbitrary page numbers or
other designations. The advantages of programmable chips are that a single board
containing such devices can handle many applications, and changes or corrections can
be made by changing selection codes rather than by redesigning circuit boards. The
disadvantages of programmable chips are the lack of standards and the difficulty of
learning and explaining how specific chips operate.
   Chapter 10 contains typical initialization routines for the PIO, SIO, and CTC
devices. (The PIO and CTC are discussed in detail in the Osborne 4 & 8-Bit Micro-
processor Handbook. 12) We will provide only a brief overview of the PIO device here,
since it is the most widely used. Bas and Kaynak describe a typical industrial applica-
tion using a PIO.I3


PIO (Parallel Input/Output Device)
General Description
  The PIO contains two 8-bit ports, A and B. Each port contains
     An 8-bit output register.
     An 8-bit input register.
                                    CHAPTER 1· GENERAL PROGRAMMING METHODS                     59
    A 2-bit mode control register, which indicates whether the port is in an output,
input, bidirectional, or control mode.
  · An 8-bit input/ output control register, which determines whether the correspond-
ing data pins are inputs (1) or outputs (0) in the control mode.
  · Two control lines (STB and RDY) that can be used for handshaking signals (the
contents of the mode control register determine how these lines operate).
  · An interrupt enable bit.
  · A 2-bit mask control register (used only in the control mode) that determines the
active polarity of the inputs and whether they will be logically ANDed or ORed to
form an interrupt signal.
   · An 8-bit mask register (used only in the control mode) that determines which port
lines will be monitored to form the interrupt signal.
  · An 8-bit vector address register used with the interrupt system.
   Here, the important points are the input and output registers, the mode control
register, the input/ output control register, and the control lines. The interrupt-related
features of the PIO are discussed in Z80 Assembly Language Programming. 14
  The meanings of the bits in the various control and mask registers are related to the
underlying hardware and are entirely arbitrary as far as the programmer is concerned.
Tables are provided here and in Appendix B for looking them up.
   Each PIO occupies four input port addresses and four output port addresses. The
B/ A SEL (Port B or A select) and Cj D SEL (Control or Data select) lines choose one
of the four ports as described in Table 1-10. Most often, designers attach address line
Ao to B/ A SEL and Al to Cj D SEL. The PIO then occupies the four consecutive port
addresses given in the last column of Table 1-10.
  Clearly, there are far more internal control registers than there are port addresses
available. In fact, all the control registers for each port occupy one address determined



Table 1·10. PIO Addresses

     Control or                Port B or A               Register            Port Address (Starting
     Data select                 Select                 Addressed               with PIOADD)

          0                         0                 Data Register A            PIOADD
          0                         I                 Data Register B            PIOADD+I
           I                        0                 Control A                  PIOADD+2
           I                        I                 Control B                  PIOADD+3

   The port addresses assume that C; D SEL is tied to Al and Bj A SEL to   Ao.
60     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table 1·11. Addressing of PIO Control Registers

           Register                                      Addressing

    Mode Control                   D3 = D2 = D j = Do = I
    Input/ Output Control          Next byte after port placed in mode 3
    Mask Control Register          D3 = 0, D2 = D j = Do = I
    Interrupt Mask Register        N ext byte after mask control register accessed with D4= I
    Interrupt Enable               D3 = D2 = 0, D j = Do = I
    Interrupt Vector               Do= I




by the C/O SEL connection. Thus, some of the data bits sent to a control register are
actually used for addressing. Note the following situations (see Table 1-11):

  · If Do = 0, the remaining data bits are loaded into the interrupt vector register.
  · If 03= Oand 02= 01 = 00= I, the remaining data bits are loaded into the mask
control register. If 04 = I, the next control byte is loaded into the interrupt mask
register. Interrupts can be enabled (07 = I) or disabled (07 = 0) with 03 = 02 = 0,
0 1 = 00= 1.

  · If 03,02,01, and Do are alII's, the remaining data bits are loaded into the mode
control register. If 07 = 06 = 1 (that is, the port has been placed in the control mode),
the next control byte is loaded into the input/ output control register.

  This sharing of an external address means

   · The programmer must be careful to specify the proper addresses, data values, ancl
order of operations. The actual destination of an OUT instruction directed to a PIO
control address depends on the data value and may also depend on the OUT instruc-
tion that preceded it.
  · The programmer should document the PIO initialization in detail. The device is
complex, and a reader cannot be expected to understand the initializing sequence.

   The control registers of the PIO are usually initialized only in an overall startup
routine. Other routines typically refer only to the PIO input and output registers. Since
all of its control registers share a port address, a repeated block output instruction
(OTIR or OTOR) can be used to initialize a PI~. No timing problem occurs, since the
PIO operates at the same speed as the CPU. Chapter 10 contains an example showing
the use of repeated block output instructions to initialize PIOs and other peripheral
chips.
                                      CHAPTER 1 GENERAL PROGRAMMING METHODS                     61

PIO Operating Modes
   A startup program selects the operating mode of a PIO port by writing a control
byte to the PIO in the form shown in Figure 1-10. The lower table in Figure 1-10
describes the operating modes and their associated control bytes. Note that only bits 6
(Mo) and 7 (MI) affect the operating mode; bits 4 and 5 are not used and bits 0 through
3 are used for addressing. When power is turned on, the PIO comes up in mode I
(input). The modes may be summarized as follows:
  . Mode 0 - Output (bit 7 = bit 6 = 0)
  Writing data into the port's output register latches the data and causes it to appear
on the port's data bus. The Ready (ROY) line goes high to indicate Data Ready; it
remains high until the peripheral sends a rising edge (a O-to-l or low-to-high transition)
on the Strobe (STB) line to indicate Data Accepted or Device Ready. The rising edge
of STB causes an interrupt if the interrupt is enabled .
   . Mode 1- Input (bit 7 = 0, bit 6 = I)
   The peripheral latches data into the port's input register using the Strobe signal. The
rising edge of STB causes an interrupt (if enabled) and deactivates ROY (makes it 0).
When the CPU reads the data, ROY goes high to indicate Data Accepted or Input
Register Empty. Note that the peripheral can strobe data into the register regardless of
the state of ROY. The programmer is therefore responsible for guarding against
overrun (new data being placed in the register before the CPU has read the old data).



    Set Mode
       Ml         MO                   Mode
        0          0         Output
        0          I         Input
        I          0         Bidirectional
        I          I         Bit Control                   If a port is placed in mode 3. the
                                                           next byte sets the I/O control
                                                           register:
      PIO                                Control Byte
      Mode             Meaning
                                       (Binary)   (Hex)
        0         Output               00001111    OF
        I         Input                01001ll1    4F      1/0= I Sets bit to Input
        2         Bidirectional        10001ll1    8F      1/0= 0 Sets bit to Output
        3         Control              1I001111    CF

      Note that bits 4 and 5 are not used and could have
      any values.



Figure 1·10. Mode control for the Z80 PIO
62    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  · Mode 2 - Bidirectional (bit 7 = 1, bit 6 = 0)
   Since this mode uses all four handshake lines, it is allowed only on port A. The port
A RDY and STB signals are used for output control and the port B RDY and STB
signals are used for input control. The only difference between this mode and a
combination of modes 0 and 1 is that data from the port A Output register is enabled
onto the port's data bus only when A STB is active. This allows the port A bus to be
used bidirectionally under the control of A STB (Output Data Request) and B STB
(Input Data Available). Note that operations on input register A govern port B's
control signals in this mode.
   · Mode 3-Control (bit 7 = 1, bit 6 = 1)
   This mode does not use the RDY and STB signals. It is intended for status and
control applications in which each bit has an individual meaning. When mode 3 is
selected, the next control byte sent to the PIO defines the directions of the port's bus
lines. A 1 in a bit position makes the corresponding bus line an input, whereas a 0
makes it an output.
   Note the following features of the PIO's operating modes:
  · In modes 0, 1, and 2, the peripheral indicates Data Ready, Device Ready, or Data
Accepted with a rising edge on the STB line. This edge also causes an interrupt if the
interrupt is enabled.
  · In modes 0, 1, and 2, the PIO indicates Data Ready, Input Buffer Empty, or Data
Accepted by sending RDY high. This signal remains high until the next rising edge on
STB.
  • The bidirectional mode (mode 2) applies only to port A, and port B must be placed
in mode 3 (control) since all the handshaking lines are already committed.
  · The input/ output control register is used only in the control mode (mode 3).
Otherwise, the entire 8-bit port is used for either input or output.
  · There is no way for the processor to determine if a pulse has occurred on STB if
interrupts are not being used. The PIO is designed for use in interrupt-driven systems
rather than in programmed I/O systems. STB should be tied low if it is not being used.
   · The processor cannot control the RDY lines directly. The RDY line on a port goes
high when data is transferred to or from the port and goes low on the rising edge of
STB.
   · The contents of the output register can be read if the port is in the output or
bidirectional mode. If the port is in the control mode, the output register data from the
lines assigned as outputs can be read. The contents of control registers cannot be read.
If a program needs to know their contents, it must save copies in RAM of the values
stored there.
   · If the RDY output is tied to the STB input on a port in the output mode, RDY will
go high for one clock period after each output operation. This brief pulse can be used
to multiplex displays.
                                   CHAPTER 1: GENERAL PROGRAMMING METHODS               63

PIO Initialization
   When power is turned on, the PIa comes up in the input mode with all interrupts
disabled and inhibited and control signals deactivated (low). The steps in initializing a
PIa port are
  . Select the operating mode by writing the appropriate control byte into the mode
control register. Interrupt control as well as I/O mode information may have to be
sent.
  . If in mode 3, establish the directions of the 1/ a pins by writing a control byte into
the input/ output control register. This byte must follow the control byte that selected
mode 3.

Examples
   1. Make port B output.
           LD     A,OOOOll11B           ;MAKE PORT B OUTPUT
           OUT    (PIOCRB),A
Bits 0 through 3 of the control byte are all I 's to address the mode control register. Bits
6 and 7 are both O's to put the port in the output mode. Bits 4 and 5 are not used.

  2. Make port A input.
           LD     A,01001111B           ;MAKE PORT A INPUT
           OUT    (PIOCRA>, A

Bit 7 = 0 and bit 6 = I to put the port in the input mode.

  3. Make port A bidirectional.
           LD     A,10001111B           ;MAKE PORT A BIDIRECTIONAL
           OUT    (PIOCRA),A

Bit 7 = I and bit 6 = 0 to put the port in the bidirectional mode. Remember that only
port A can be operated in the bidirectional mode, and that port B must then be
operated in the control mode.

  4. Make port A control with all lines inputs.
           LD     A,l1001111B           ;MAKE PORT A CONTROL
           OUT    (PIOCRA},A
           LD     A,l1111111B           ;ALL BITS INPUTS
           OUT    (PIOCRA),A

   The first OUT instruction puts port A in the control mode, since bits 6 and 7 are both
1. The second OUT operation to the same address loads a different register (the
64     Z80 ASSEMBLY LANGUAGE SUBROUTINES


inputj output control register). A 0 in a bit position of that register makes the
corresponding pin an output, while a 1 makes it an input. The polarity here is arbitrary,
and many bidirectional devices use the opposite convention.

  5. Make port B control with all lines outputs.
           LD     A,11001111B         ;MAKE PORT B CONTROL
           OUT    (PIOCRB),A
           SUB    A                   ; ALL BITS OUTPUTS
           OUT    (PIOCRB),A
The second byte is directed automatically to the inputj output control register if the
first byte puts the port in the control mode.

  6. Make port A control with lines 1, 5, and 6 inputs and lines 0, 2, 3,4, and 7
outputs.
           LD     A,11001111B         ;MAKE PORT A CONTROL
           OUT    (PIOCRA),A
           LD     A,01100010B         ;1,5,6 IN--O,2,3,4,7 OUT


INTERRUPT SERVICE ROUTINES
   More information on material in this section can be found in the book Practical
Microcomputer Programming: The Z80 by w.J. Weller, Chapter 16.
   Z80 interrupt systems may operate in any of three modes. ls In all three modes, the
processor responds to an interrupt by executing a CALL or RST instruction which
transfers control to a specific memory address and saves the current program counter
at the top of the stack. Table 1-12 lists the destination addresses for the RST instruc-
tions and the non-maskable interrupt. No other registers (besides the program coun-
ter) are saved automatically.
   There are two common approaches to saving registers:
  . If there is only a single level of interrupts, primary registers may be saved in the
alternate set. The service routine begins with
           EX     AF, AF'"            ; SAVE PRIMARY REGISTERS IN ALTERNATES
           EXX
The EXX instruction exchanges registers B, C, D, E, H, and L with their primed
equivalents. The service routine must end by restoring the original primary registers
with
         EXX                          ;RESTORE ORIGINAL PRIMARY REGISTERS
         EX      AF ,AF"
This approach assumes that the alternate (primed) registers are reserved for use in
interrupt service routines.
                                   CHAPTER 1. GENERAL PROGRAMMING METHODS                  65
Table 1·12. Destination Addresses for RST (Restart) Instructions and
            the Non-Maskable Interrupt

                                                               Destination Address
    RST Instruction         Operation Code
     (Mnemonic)                 (Hex)
                                                       (Hex)                   (Decimal)

   RSTO                          C7                    0000                            0
   RST8                          CF                    0008                           08
   RSTIOH                        D7                    0010                           16
   RST 18H                       DF                    0018                           24
   RST 20H                       E7                    0020                           32
   RST 28H                       EF                    0028                           40
   RST 30H                       F7                    0030                           48
   RST 38H                       FF                    0038                           56
   Non-maskable                                        0066                          102
     interrupt




  . If there are several levels of interrupts, each service routine must save all registers
that it uses in the stack. Since the Z80 has so many registers, most programmers keep
their service routines simple so that they must save only a few registers. Otherwise, the
overhead involved in servicing interrupts (sometimes called the interrupt latency)
becomes excessive. A typical sequence for saving the primary registers in the stack is

           PUSH       AF        ;SAVE REGISTERS
           PUSH       BC
           PUSH       DE
           PUSH       HL

The opposite sequence restores the primary registers.

           POP    HL            ;RESTORE REGISTERS
           POP    DE
           POP    BC
           POP    AF

   Interrupts must be reenabled explicitly with EI immediately before the RET instruc-
tion that terminates the service routine. The EI instruction delays the actual enabling
of interrupts for one instruction cycle to avoid unnecessary stacking of return ad-
dresses (that is, an RET instruction can remove the return address from the stack
before a pending interrupt is recognized).
   You must be careful to save any write-only registers that may have to be restored at
the end of the routine. For example, the PIa's control registers are all write-only, and
66    Z80 ASSEMBLY LANGUAGE SUBROUTINES


many external priority registers are also write-only. Copies of such registers must be
saved in RAM and restored from the stack. A typical example is
          PUSH   AF           ;SAVE REGISTERS
          PUSH   BC
          PUSH   DE
          PUSH   HL
          LD     A, (PRTY)    ;SAVE OLD PRIORITY
          PUSH   AF
          LD     A, NPRTY     ;GET NEW PRIORITY
          OUT    PPORT        ;PLACE IT IN EXTERNAL PRIORITY REGISTER
          LD     (PRTY),A     ;SAVE COPY OF NEW PRIORITY IN RAM

  The restoration procedure must recover the previous priority as well as the original
contents ofthe registers.
          POP    AF           ;RESTORE OLD PRIORITY
          OUT    PPORT        ;PLACE IT IN EXTERNAL PRIORITY REGISTER
          LD     (PRTY),A     ;SAVE COPY OF PRIORITY IN RAM
          POP    HL           ;RESTORE REGISTERS
          POP    DE
          POP    BC
          POP    AF
  To achieve general reentrancy, the stack must be used for all temporary storage
beyond that provided by the registers. As noted in the discussion of parameter passing,
space is assigned on the stack (NPARAM bytes) with the sequence
          LD     HL,-NPARAM          ;ASSIGN NPARAM EMPTY BYTES
          ADD    HL,SP
          LD     SP,HL

Later, of course, the temporary storage area is discarded with the sequence

          LD     HL,NPARAM           ;REMOVE NPARAM BYTES FROM STACK
          ADD    HL,SP
          LD     SP,HL

If NPARAM is small, save execution time and memory by replacing these sequences
with NPARAM DEC SP or INC SP instructions. Chapter 11 contains examples of
simple interrupt service routines.
   Interrupt service routines that are based on signals from Z80 peripheral chips (PIOs,
SIOs, or CTCs) or that utilize the non-maskable input require special terminating
instructions. These special instructions restore the program counter from the top of
the stack just like the normal RET. The RETI (return from interrupt) instruction also
signals the peripheral chips that the service routine has been completed, thus unblock-
ing lower priority interrupts. The RETN (return from non-maskable interrupt)
instruction also restores the interrupt enable logic, thus reenabling interrupts if (and
only if) they were enabled when the non-maskable interrupt occurred.
                                 CHAPTER 1· GENERAL PROGRAMMING METHODS               67

MAKING PROGRAMS RUN FASTER
   More information on material in this section can be found in an article by T. Doll-
hoff, "Microprocessor Software: How to Optimize Timing and Memory Usage. Part
Four: Techniques for the Zilog Z80," Digital Design, February 1977, pp. 44-45.
   In general, programs can be made to run substantially faster only by first determin-
ing where they spend their time. This requires determining which loops (other than
delay routines) the processor is executing most often. Reducing the execution time of a
frequently executed loop will have a major effect because of the mUltiplying factor. It is
thus critical to determine how often instructions are being executed and to work on
loops in the order of their frequency of execution.
   Once it is determined which loops the processor executes most frequently, reduce
their execution time with the following techniques:
   · Eliminate redundant operations. These may include a constant that is being added
during each iteration or a special case that is being tested repeatedly. Another example
is a constant value or a memory address that is being fetched from memory each time
rather than being stored in a register or register pair.
   · Reorganize the loop to reduce the number of jump instructions. You can often
eliminate branches by changing the initial conditions, inverting the order of opera-
tions, or combining operations. In particular, you may find it helpful to initialize
everything one step back, thus making the first iteration the same as all the others.
Inverting the order of operations can be helpful if numerical comparisons are involved,
since the equality case may not have to be handled separately. Reorganization may
also combine condition checking inside the loop with the overall loop control.
  o   Use in-line code rather than subroutines. This will save at least a CALL and RET.
  · Use the stack rather than specific memory addresses for temporary storage.
Remember that EX HL,(SP) exchanges the top of the stack with register pair HL and
thus can serve to both restore an old value and save the current one.
  o Assign registers to take maximum advantage of such specialized instructions as
LD HL,(ADDR); LD (ADDR),HL; EX DE, HL; EX HL,(SP); DJNZ; and the block
move, compare, and 110 instructions. Thus it is preferable to always use B or BC for a
counter, HL for an indirect address, and DE for another indirect address if needed.
  o  Use the block move, block compare, and block 110 instructions to handle blocks
of data. These instructions can replace an entire program sequence, since they combine
counting and updating of pointers with the actual data manipulation or transfer
operations. Note, in particular, that the block move and block I 10 instructions
transfer data to or from memory without using the accumulator.
  o  Use the 16-bit instructions whenever possible to manipulate 16-bit data. These
instructions are ADC, ADD, DEC, EX, INC, LD, POP, PUSH, and SBC.
68    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  · Use instructions that operate directly on data in user registers or in memory to
avoid having to save and restore the accumulator, HL, or an index register. These
instructions include DEC, EX, INC, LD, POP, PUSH, and the bit manipulation and
shift instructions.
  · Minimize the use of the index registers, since they always require extra execution
time and memory. The index registers are generally used only as backups to HL and in
handling data structures that involve many fixed offsets.
  · Minimize the use of special Z80 instructions that require a 2-byte operation code.
These always require extra execution time and memory. Examples are BIT, RES, SET,
SLA, SRA, and SRL, as well as some load instructions such as LD DE,(ADDR), LD
(ADDR),BC, and LD SP,(ADDR).
  · Take advantage of specialized short instructions such as the accumulator shifts
(RLA, RLCA, RRA, and RRCA) and DJNZ.
   · Use absolute jumps (JP) rather than relative jumps (JR). The absolute jumps take
less time if a branch actually occurs.
  · Organize sequences of conditional jumps to minimize average execution time.
Branches that are often taken should come before ones that are seldom taken, for
example, checking for a result being negative (true 50% of the time if the value is
random) before checking for it to be zero (true less than 1% of the time if the value is
random).
  · Test for conditions under which a sequence has no effect and branch around it if
the conditions hold. This will be profitable if the sequence is long, and it frequently
does not change the result. A typical example is the propagation of carries through
higher order bytes. If a carry seldom occurs, it will be faster on the average to test for it
rather than simply propagate a O.
  A general way to reduce execution time is to replace long sequences of instructions
with tables. A single table lookup can perform the same operation as a sequence of
instructions if there are no special exits or program logic involved. The cost is extra
memory, but that may be justified if the memory is available. If enough memory is
available, a lookup table may be a reasonable approach even if many of its entries are
repetitive-that is, even if many inputs produce the same output. In addition to its
speed, table lookup is also general, easy to program, and easy to change.



MAKING PROGRAMS USE LESS MEMORY
  Only by identifying common instruction sequences and replacing those sequences
with subroutine calls can a program be made to use significantly less memory. The
result is a single copy of each sequence; the cost is the extra execution time of the
                                   CHAPTER 1 GENERAL PROGRAMMING METHODS                   69

CALL and RET instructions. The more instructions placed in subroutines, the more
memory is saved. Of course, such subroutines are typically not general and may be
difficult to understand or use. Some sequences may even be available in a monitor or
other systems program. Then those sequences can be replaced with calls to the systems
program as long as the return is handled properly.
   Some methods that reduce execution time also reduce memory usage. In particular,
eliminating redundant operations, reorganizing loops, using the stack, organizing the
use of registers, using the l6-bit registers, using block instructions and short forms,
operating directly on memory or registers, and minimizing the use of the index
registers and special Z80 instructions reduce both memory usage and execution time.
Of course, using in-line code rather than loops and subroutines reduces execution time
but increases memory usage. Absolute and relative jumps represent a minor tradeoff
between memory and execution time; absolute jumps are faster (if a branch occurs) but
use more memory.
   Lookup tables generally use extra memory but save execution time. Some ways to
reduce their memory requirements are to eliminate intermediate values and interpo-
late the results, eliminate redundant values with special tests, and reduce the range of
input values. 16 ,17 Often a few prior tests or restrictions will greatly reduce the size of the
required table.


REFERENCES
   1. Weller, WJ., Practical Microcomputer Programming: The Z80, Evanston, Ill.:
Northern Technology Books, 1979.
   2. Fisher, W.P., "Microprocessor Assembly Language Draft Standard," IEEE
Computer, December 1979, pp. 96-109. Further discussions of the draft standard
appear on pp. 79-80 of IEEE Computer, April 1980 and on pp. 8-9 of IEEE Computer,
May 1981. See also Duncan, F.G., "Level-Independent Notation for Microcomputer
Programs," IEEE Micro, May 1981, pp. 47-56.
   3. Osborne, A. An Introduction to Microcomputers: Volume 1- Basic Concepts,
2nd ed., Berkeley, Calif.: Osborne/ McGraw-Hill, 1980.
   4. Fisher, op.cit.
   5. Osborne, op. cit.
   6. Weller, op.cit., p. 224.
   7. Ibid., pp. 19-26.
   8. Ibid.
   9. Ibid., p. 69.
70    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  10. Shankar, K.S., "Data Structures and Abstractions," IEEE Computer, April,
1980, pp. 67-77.
  11. Tenenbaum, A. and M. Augenstein, Data Structures Using Pascal, Englewood
Cliffs, N.J.: Prentice-Hall, 1981.
  12. Osborne, A. and G. Kane, 4 & 8-Bit Microprocessor Handbook, Berkeley,
Calif.: Osborne/ McGraw-Hill, 1981, pp. 7-45 to 7-54 (PIa), pp. 7-54 to 7-62 (CTC).
   13. Bas, S. and O. Kaynak, "Microprocessor Controlled Single Phase Cycloconver-
ter," 1981 IECI Proceedings on Industrial Applications of Mini and Microcomputers,
pp. 39-44. Available from IEEE, 445 Hoes Lane, Piscataway, N.J. 08854 (catalog no.
81CHI714-5).
  14. Leventhal, L., Z80 Assembly Language Programming, Berkeley, Calif.:
Osborne/ McGraw-Hill, 1979, Chapter 12.
  15. Ibid.
  16. Seim, T.A., "Numerical Interpolation for Microprocessor-Based Systems,"
Computer Design, February 1978, pp. 111-1l6.
   17. Abramovich, A. and T.R. Crawford, "An Interpolating Algorithm for Control
Applications on Microprocessors," 1978 IECI Proceedings on Industrial Applications
of Microprocessors, pp. 195-201. This Proceedings is available from IEEE, 445 Hoes
Lane, Piscataway, N.J. 08854.
Chapter 2 Implementing
  Additional Instructions and
  Addressing Modes



  This chapter shows how to implement instructions and addressing modes that are
not included in the Z80 instruction set. Of course, no instruction set can ever include all
possible combinations. Designers must choose a set based on how many operation
codes are available, how easily an additional combination could be implemented, and
how often it would be used. A description of additional instructions and addressing
modes does not imply that the basic instruction set is incomplete or poorly designed.
  The chapter will concentrate on additional instructions and addressing modes that
are
    Obvious parallels to those included in the instruction set.
     Described in Fischer's "Microprocessor Assembly Language Standard".!
     Discussed in Volume I of An Introduction to Microcomputers. 2
    Implemented on other microprocessors, especially ones that are closely related or
partly compatible. 3
  This chapter should be of particular interest to those who are familiar with the
assembly languages of other computers.



INSTRUCTION SET EXTENSIONS
   In describing extensions to the instruction set, we follow the organization sug-
gested in the draft standard for IEEE Task P694.4 Instructions are divided into the
following groups (listed in the order in which they are discussed): arithmetic, logical,
data transfer, branch, skip, subroutine call, subroutine return, and miscellaneous.
For each type of instruction, types of operands are discussed in the following order:
byte (8-bit), word (l6-bit), decimal, bit, nibble or digit, and multiple. In describing
addressing modes, we use the following order: direct, indirect, immediate, indexed,
                                                                                       71
72    Z80 ASSEMBLY LANGUAGE SUBROUTINES


register, autopreincrement, autopostincrement, autopredecrement, autopostdecre-
ment, indirect preindexed (also called preindexed or indexed indirect), and indirect
postindexed (also called postindexed or indirect indexed).


ARITHMETIC INSTRUCTIONS
   This group includes addition, addition with Carry, subtraction, subtraction in
reverse, subtraction with Carry (borrow), increment, decrement, multiplication, divi-
sion, comparison, two's complement (negate), and extension. Instructions that do not
clearly fall into a particular category are repeated for convenience.


Addition Instructions (Without Carry)
   1. Add memory location ADDR to accumulator.
          LD     HL,ADDR      ;POINT TO DATA
          ADD    A, (HL)      :THEN ADD IT
   2. Add Carry to accumulator.
         ADC A,O            ;ACC     = ACC   +   CARRY + 0
   3. Decimal add Carry to accumulator.
          ADC A,O           :ACC = ACC + CARRY + 0
          DAA                  IN DECIMAL
   4. Decimal add VALUE to accumulator.
          ADD    A,VALUE      ;ACC = ACC + VALUE
          DAA                    IN DECIMAL
   5. Decimal add register to accumulator.
          ADD    A,rE/9       ;ACC = ACC + REG
          DAA                    IN DECIMAL
   6. Add 16-bit number VALl6 to HL.
           LD    rp, VAL16
           ADD   HL,rp         ;HL = HL + VAL16
 rp can be either BC or DE.

   7. Add 16-bit number VALl6 to an index register.
          LD     rp,VAL16
          ADD xY,rp        ;XY = XY + VAL16
 rp can be either BC or DE.
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                  73

  8.   Add memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) to HL.
           LD     rp,<ADDR)
           ADD    HL,rp

The 16-bit data is stored in the usual Z80 format with the less significant byte first (at
the lower address).

  9. Add memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) to an index
register.
           LD     rp,<ADDR)
           ADD    KY,rp

   10. Add memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) to memory
locations SUM and SUM+l (MSB in SUM+I).
           LD     HL, (SUM)            ~GET    CURRENT SUM
           LD     DE, <ADDR)           ~ADD    ELEMENT
           ADD    HL,DE
           LD     <SUM),HL             ~SAVE   UPDATED SUM

  11. Add the 16-bit number VALl6 to memory locations ADDR and ADDR+ 1
(MSB in ADDR+I).
           LD     HL,(SUM)             ~GET    CURRENT SUM
           LD     DE,VAL16             ~ADD    ELEMENT
           ADD    HL,DE
           LD     (SUM),HL             ~SAVE    UPDATED SUM




Addition Instructions (with Carry)
  1. Add memory location ADDR to accumulator with Carry.
           LD     HL,ADDR              ~POINT    TO DATA
           ADC    A, (HU               ~THEN    ADD IN DATA

  2. Add Carry to accumulator.
           ADC    A,O                  ~ACC    = ACC   + CARRY + 0

  3. Decimal add VALUE to accumulator with Carry.
           ADC    A,VALUE              ~ACC  = ACC + VALUE + CARRY
           DAA                             IN DECIMAL

  4. Decimal add register to accumulator with Carry.
           ADC    A,reg                ~ACC  = ACC + REG + CARRY
           DAA                             IN DECIMAL
74      Z80 ASSEMBLY LANGUAGE SUBROUTINES


     5. Add 16-bit number VAL16 to HL with Carry.
           LD      rp,VAL16
           ADC     HL,rp             ;HL = HL + VAL16 + CARRY
  6. Add memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) to HL with
Carry.
            LD     rp,(ADDR)
            ADC    HL,rp             ; HL   = HL   + ,(ADDR) + CARRY


Subtraction Instructions (Without Borrow)
     1. Subtract memory location ADDR from accumulator.
            LD     HL,ADDR           ;POINT TO DATA
            SUB    (HU               ;THEN SUBTRACT IT
     2. Subtract borrow (Carry) from accumulator.
           sec A,O                  ;ACC = ACC - CARRY
     3. Decimal subtract VALUE from accumulator.
           SUB     VALUE             ;ACC = ACC - VALUE
           DAA                          IN DECIMAL
     4. Decimal subtract register from accumulator.
            SUB    reg               ;ACC = ACC - REG
            DAA                         IN DECIMAL
Since the Z80 has an Add/ Subtract flag, it can perform decimal subtraction directly.
On the 8080 and 8085 processors, the programmer must implement decimal subtrac-
tion as the addition of a negative number.
     5. Subtract register pair from HL.
          AND     A                  ;CLEAR CARRY
          SBC     HL,rp              ;SUBTRACT REGISTER PAIR WITH CARRY
The Z80 has a subtract register pair with Carry instruction, but no plain subtract
register pair (without Carry).
     6. Subtract 16-bit number VAL16 from HL.
          LD    rp,-VAL16
          ADD HL,rp
or
          AND     A                  ;CLEAR CARRY
          LD      rp, VAL16
          sec     HL,rp              ;SUBTRACT 16-BIT NUMBER FROM HL
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIOf\JS AND ADDRESSING MODES                75

rp can be either BC or DE. Carry is an inverted borrow in the first alternative and a true
borrow in the second. The first alternative is 0 bviously much shorter, particularly since
SBC HL requires a 2-byte operation code.

 7. Subtract memory locations ADDR and ADDR+I (MSB in ADDR+I) from
HL.
             AND   A                     ;CLEAR CARRY
             LD    rp, (ADDR)            ;THEN SUBTRACT WITH CARRY
             SBC   HL,r-p
There is no subtract register pair (without Carry) instruction.


Subtraction in Reverse Instructions
     1. Subtract accumulator from VALUE and place difference in accumulator.
             NEG                         ; NEGATE A
             ADD   A,VALUE               ;FORM - A    +   VALUE
or
             LD    reg, A               ;CALCULATE VALUE - ACC
             LD    A,VALUE
             SUB   reg
The Carry is an inverted borrow in the first method and a true borrow in the second.

     2. Subtract accumulator from register and place difference in accumulator.
             NEG                       ;NEGATE A
             ADD A,reg                 ;FORM - A + REG
The Carry is an inverted borrow; that is, it is I if the subtraction does not require a
borrow.

   3. Decimal subtract accumulator from VALUE and place difference in accumu-
lator.
             LD    reg,A                ; CALCULATE VALUE - ACC
             LD    A,VALUE
             SUB   reg
             DAA

     4. Decimal subtract accumulator from register and place difference in accumulator.
             LD    regl,A               ;CALCULATE REG - ACC
             LD    A,reg
             SUB   regl
             DAA                        ;IN DECIMAL
76    Z80 ASSEMBLY LANGUAGE SUBROUTINES


Subtraction with Borrow (Carry) Instructions
  1. Subtract memory location ADDR from accumulator with borrow.
          LD    HL.ADDR              ;POINT TO DATA
          SBC   A, (HU               ; THEN SUBTRACT WITH BORROW

  2. Subtract borrow (Carry) from accumulator.
          SBC    A.O                 ;FORM A - BORROW

  3. Decimal subtract inverted borrow from accumulator (Carry = 1 if no borrow
was generated, 0 if a borrow was generated).
          ADC   A,99H                ;ADD 99 PLUS CARRY
          DAA
The final Carry is 1 if the subtraction generates a borrow and 0 if it does not.

  4. Decimal subtract VALUE from accumulator with borrow.
          SBC   A,VALUE              ;A   =A-   VALUE - BORROW
          DAA                             IN DECIMAL

  5. Decimal subtract register from accumulator with borrow.
          SBC   A, t-eg              ;A   =A -  REG - BORROW
          DAA                             IN DECIMAL

  6. Subtract l6-bit number VAL16 from HL with borrow.
          LD    l'"P,VAL16
          SBC   HL.l'"P              ;HL   = HL   - VAL16 - BORROW




Increment Instructions
  1. Increment memory location ADDR.
          LD    HL.ADDR
          INC   (HU


  2. Increment accumulator, setting the Carry flag if the result is O.
          ADD   A,l
Remember that INC does not affect Carry, but it does affect the Zero flag.
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES            77

     3. Decimal increment accumulator (add 1 to A in decimal).
                   ADD    A,1
                   DAA
You cannot use INC, since it does not affect Carry.

     4. Decimal increment register (add 1 to reg in decimal).
                   LD     A,reg
                   ADD    A,1
                   DAA
                   LD     reg, A
DAA applies only to the accumulator.

     5. Increment memory locations ADDR and ADDR+l (MSB in ADDR + 1).
                   LD     HL,(ADDR)
                   INC    HL        ;16-BIT INCREMENT
                   LD     (ADDR),HL
or
                   LD     HL,ADDR
                   INC    (HU           ; INCREMENT LSB
                   JR     NZ,DONE
                   INC    HL            ;ADD CARRY TO MSB
                   INC    (HU
                   DEC    HL
     DONE:         NOP
The second alternative leaves ADDR in HL for later use.

     6. Increment register pair, setting the Zero flag if the result is O.
                   INC    rp            ;16-BIT INCREMENT
                   LD     A, tOpl       ;TEST RESULT FOR ZERO
                   OR     rph
This sequence destroys the old contents of the accumulator and the flags. OR clears
Carry.




Decrement Instructions
     1. Decrement memory location ADDR.
                   LD     HL,ADDR
                   DEC    (HU
78   Z80 ASSEMBLY LANGUAGE SUBROUTINES


  2. Decrement accumulator, setting Carry flag if a borrow is generated.
         SUB    1

  3. Decrement accumulator, setting Carry flag if no borrow is generated.
         ADD    A,OFFH

  4. Decimal decrement accumulator (subtract I from A in decimal).
         SUB    1
         DAA
DEC cannot be used here, since it does not affect Carry.

  5. Decimal decrement register (subtract I from reg in decimal).
         LD     A,reg
         SUB    1
         DAA
         LD     reg, A
DAA applies only to the accumulator.

  6. Decrement memory locations ADDR and ADDR+I (MSB in ADDR+I).
         LD     HL,(ADDR)
         DEC    HL                   ; 16-BIT DECREMENT
         LD     (ADDR),HL

  7. Decrement register pair, setting the Zero flag if the result is O.
         DEC    rp                   ; 16-BIT DECREMENT
         LD     A,rpl                ;TEST 16-BIT RESULT FOR ZERO
         OR     rph
This sequence destroys the old contents of the accumulator and changes the other
flags. OR clears the Carry flag.


Multiplication Instructions
  1. Multiply accumulator by 2.
         ADD    A,A

  2. Multiply accumulator by 3 (using reg for temporary storage).
         LD     reg, A                SAVE A
         ADD    A,A                   2 XA
         ADD    A,reg                 3 XA
CHAPTER 2. IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                79

     3. Multiply accumulator by 4.
             ADD    A.A                   ;2 X A
             ADD    A,A                   ;4 X A
We can easily extend cases 1, 2, and 3 to multiplication by other small integers.

     4. Multiply register by 2.
             SLA    reg

     5. Multiply register by 4.
             SLA    reg                   ; MUL TI PL Y BY 2
             SLA    reg                   ;AND THEN BY 2 AGAIN
Since SLA is a 2-byte instruction, it eventually becomes faster to move the data to the
accumulator and use the I-byte instruction ADD A, A.

     6. MUltiply register pair HL by 2.
             ADD    HL,HL

     7. Multiply register pair HL by 3 (using rp for temporary storage).
             LD     rph,H
             LD     rpl,L
             ADD    HL.HL                 ;2 X HL
             ADD    HL,rp                 ;3 X HL
Note that you cannot use EX DE,HL here, since it changes HL.

     8. Multiply an index register by 2.
             ADD    xy,Xy

     9. Multiply memory locations ADDR and ADDR+ I (MSB in ADDR+ 1) by 2.
             LD     HL,ADDR
             SLA    (HU                   ;SHIFT LSB LEFT LOGICALLY
             INC    HL
             RL     (HU                   ;THEN ROTATE MSB TO PICK UP CARRY

or
             LD     xy,ADDR
             SLA    (Xy+O)                ;SHIFT LSB LEFT LOGICALLY
             RL     (xy+l)                ;THEN ROTATE MSB TO PICK UP CARRY

Note that you must rotate the more significant byte to pick up the Carry produced by
shifting the less significant byte.
80       Z80 ASSEMBLY LANGUAGE SUBROUTINES


Division Instructions
     1. Divide accumulator by 2 unsigned.
            SRL    A                   ;DIVIDE BY 2, CLEARING SIGN

     2. Divide accumulator by 4 unsigned.
             SRL   A                    ;DIVIDE BY 2, CLEARING SIGN
             SRL   A                    ; THEN BY 2 AGAIN
or
            RRA                        ;ROTATE A RIGHT TWICE
            RRA
            AND    00111111B           ; THEN CLEAR   2   MSB" S
Since SRL is a 2-byte instruction, it eventually becomes faster to use the I-byte
instruction RRA and clear the more significant bits explicitly at the end.

     3. Divide accumulator by 2 signed.
            SRA    A                   ;DIVIDE BY 2, EXTENDING SIGN

  4. Divide memory locations ADDR and ADDR+l (MSB in ADDR+l) by 2
unsigned.
            LD      XY,ADR
            SRL     (XY+l)             ;SHIFT MSB RIGHT LOGICALLY
            RR      (XY+(I)            ;THEN ROTATE LSB RIGHT
Rotating the less significant byte picks up the Carry from the more significant byte.

   5. Divide memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) by 2
signed.
            LD      XY,ADR
            SRA     (XY+1)             ;SHIFT MSB RIGHT ARITHMETICALLY
            RR      (XY+(I)            ;THEN ROTATE LSB RIGHT

     6. Divide register pair by 2 unsigned.
             SRL   r-ph                 ;SHIFT MSB RIGHT LOGICALLY
             RR    rpl                  ;THEN ROTATE LSB RIGHT

     7. Divide register pair by 2 signed.
            SRA    rph                 ;SHIFT MSB RIGHT ARITHMETICALLY
            RR     rpl                 ;THEN ROTATE LSB RIGHT
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES              81

Comparison Instructions
   1. Compare VALUE with accumulator bit by bit, setting each bit position that is
different.
            XOR   VALUE
Remember, the EXCLUSIVE OR of two bits is I if and only if the two bits are different.

   2. Compare register with accumulator bit by bit, setting each bit position that is
different.
            XOR   reg

  3. Compare register pairs (rp and HL). Set Carry if rp is larger (unsigned) than HL
and clear Carry otherwise.
            AND   A                    ; CLEAR CARRY
            SBC   HL,rp

This sequence changes HL.

     4. Compare register pair HL with 16-bit number VALl6.
            LD    rp,-VAL16            ;FORM HL - VAL16 BY ADDING
            ADD   HL,rp
or
            AND   A                    ;CLEAR CARRY
            LD    rp,VAL16
            SBC   HL,rp

Carry is an inverted borrow after the first alternative and a true borrow after the
second. Both sequences change HL and rp.

  5. Compare index register with 16-bit number VALl6. Clear Carry if VALl6 is
greater than index register and set Carry otherwise.
            LD    rp, -VAL16           ;FORM INDEX REGISTER - VAL16
            ADD   xY,rp
Carry is an inverted borrow here, since we are subtracting by adding the two's
complement.

 6. Compare register pair with memory locations ADDR and ADDR+ I (MSB in
ADDR+I).
            AND   A                   ;CLEAR CARRY
            LD    rp,(ADDR)           ;SUBTRACT REGISTER PAIR
            SBC   HL,rp
Carry is a true borrow.
82    Z80 ASSEMBLY LANGUAGE SUBROUTINES


 7. Compare index register with memory locations ADDR and ADDR+ 1 (MSB in
ADDR+l).
       PUSH xy                   ;MOVE INDEX REGISTER TO HL
       POP HL
       AND A                     ;CLEAR CARRY
       LD    rp,(ADDR)           ;FORM INDEX REGISTER - OTHER OPERAND
       sec HL,rp
The Z80 has no SBC xy instruction.

  8. Compare stack pointer with the 16-bit number VAL16.
          LD    HL,O             ;MOVE STACK POINTER TO HL
          ADD   HL,SP
          LD    rp,-VAL16
          ADD   HL,rp
Carry is an inverted borrow.

 9. Compare stack pointer with memory locations ADDR and ADDR+ 1 (MSB in
ADDR+l).
          LD    HL,O             ;MOVE STACK POINTER TO HL
          ADD   HL,SP
          LD    rp, (ADDR)
          AND   A                ;CLEAR CARRY
          sec   HL,rp            ;FORM SP - MEMORY
Carry is a true borrow.



Two's Complement (Negate) Instructions
  1. Negate register.
          SUB   A                ;FORM 0 - REG
          SUB   reg
          LD    reg, A
or
          LD    A,reg
          NEG
          LD    reg, A

  2. Negate memory location ADDR.
          SUB   A
          LD    HL,ADDR
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES              83
             SUB    (HU               ,FORM 0 - (MEMORY)
             LD     (HU.A
or
             LD     HL.ADDR
             LD     A. (HU             ,FORM -    (ADDR)
             NEG
             LD     (HU.A

     3. Negate register pair.
             LD     A.rph             ,16-BIT    ONE~S   COMPLEMENT
             CPL
             LD     rph.A
             LD     A.rpl
             CPL
             LD     rpl.A
             INC    rp                ,ADD 1 FOR     TWO~S   COMPLEMENT
or
             LD     HL.O              ,FORM 0 - (RP)
             AND    A                 ;CLEAR CARRY
             SBC    HL.rp
The second sequence leaves the negative in HL; it can then be moved easily to another
register pair.

  4. Negate memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1).
             LD     HL.O              ,FORM 0 - (MEMORY)
             LD     rp.(ADDR)
             AND    A
             SBC    HL.rp
             LD     (ADDR). HL

  5. Nine's complement accumulator (that is, replace (A) with 99-(A».
             LD     reg. A
             LD     A.99H
             SUB    reg
No DAA is necessary, since 99 - (A) is always a valid BCD number if the accumulator
originally contained a valid BCD number.

  6. Ten's complement accumulator (that is, replace (A) with lOQ-(A».
             NEG                      ,FORM 0 - ACCUMULATOR
             DAA                      ,THEN DECIMAL ADJUST
84    Z80 ASSEMBLY LANGUAGE SUBROUTINES


Extend Instructions
  l. Extend accumulator to a 16-bit unsigned number in a register pair.
         LD     rpl,A               ;S-BIT MOVE
         LD     rph,O               ;EXTEND S BITS TO 16 BITS

This procedure allows you to use the value in the accumulator as an index. ADD HL
or ADD xy will then add the index to the base.


  2. Extend accumulator to a 16-bit signed number in a register pair.

         LD     rpl,A               ;S-BIT MOVE
         ADD    A,A                 ;MOVE SION BIT TO CARRY
         SBC    A.A                 ;SUBTRACT SION BIT FROM ZERO
         LD     rph,A               ;EXTEND 8 BITS TO 16 BITS SIONED


SBC A,A produces 00 if Carry is 0 and FF'6 if Carry is 1. It thus extends Carry
across the entire accumulator.


 3. Extend memory location ADDR to a 16-bit signed number in memory locations
ADDR (LSB) and ADDR+ 1 (MSB).
         LD     HL,ADDR             ;FETCH NUMBER
         LD     A, (HU
         ADD    A,A                 ;MOVE SION TO CARRY
         SBC    A.A                 ;FORM SION BYTE (00 OR FF)
         INC    HL                  ;STORE SION BYTE
         LD     (HL>,A


  4. Extend bit 0 of accumulator across entire accumulator; that is, (A)= 00 ifbitO=
o and FF16 if bit 0 = l.

         RRA                        ;MOVE BIT 0 TO CARRY
         SBC    A.A                 ;FORM 0 - BIT 0


  5. Sign function. Replace the value in the accumulator by 00 if it is positive and by
FF 16 if it is negative.

         ADD    A,A                 ;MOVE SION BIT TO CARRY
         SBC    A.A                 ;FORM 0 - SION BIT
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                     85

LOGICAL INSTRUCTIONS
  This group includes logical AND, logical OR, logical EXCLUSIVE OR, logical
NOT (complement), shift, rotate, and test instructions. Also included are arithmetic
instructions (such as adding the accumulator to itself) that perform logical functions.



Logical AND Instructions
   1. Clear bits of accumulator.
            AND    MASK                   ;CLEAR BITS BY MASKING

MASK has O's in the bit positions to be cleared and I's in the positions to be left
unchanged. For example:
           AND     11011011B              ;CLEAR BITS 2 AND 5

Remember, logically ANDing a bit with I does not affect its value. Since RES can clear
only one bit at a time, the following sequence would be needed to produce an
equivalent result:
            RES    2,A                    ;CLEAR BIT 2
            RES    5,A                    ;AND THEN CLEAR BIT 5

  2. Bit test-set the flags as if accumulator had been logically ANDed with a register
or memory location, but do not change the accumulator.
            LD     reg, A                 ;SAVE ACCUMULATOR
            LD     HL,ADDR
            AND    (HU                    ;PERFORM LOGICAL AND
            LD     A,reg                  ;RESTORE ACCUMULATOR

LD does not affect any flags.

  3. Test bits of accumulator. Set the Zero flag to I if all the tested bits are 0 and to 0
otherwise.
            AND    MASK                   ;TEST BITS BY MASKING

MASK has I's in the positions to be tested and O's elsewhere. The Zero flag is set to I
if all the tested bit positions are 0, and to 0 otherwise. Since the BIT instruction can test
only one bit position at a time, AND MASK is equivalent to a sequence of BIT
instructions and conditional jumps. For example:
           AND     010000010B             ;TEST BITS 1 AND 6 FOR ZERO
86    Z80 ASSEMBLY LANGUAGE SUBROUTINES


is equivalent to the sequence
                BIT     6. A                ;TEST BIT 6 FOR ZERO
                ...IR   NZ. DONE            ;BRANCH IF IT IS NOT ZERO
                BIT     1. A                ;THEN TEST BIT 1 FOR ZERO
  DONE:         NOP
  4. Logical AND immediate with flags (condition codes). Logically AND a byte of
immediate data with the Flag register, clearing those flags that are logically ANDed
with O's.
                PUSH    AF                  ;MOVE AF TO A REGISTER PAIR
                POP     rp
                LD      A.MASK              ;CLEAR FLAGS
                AND     rpl
                LD      rpl.A
                PUSH    rp                  ;RESTORE AF WITH FLAGS CLEARED
                POP     AF
This sequence changes a register pair (Be, DE, or HL).


Logical OR Instructions
  1. Set bits of accumulator.
                OR      MASK                ;SET BITS BY MASKING
MASK has 1's in the bit positions to be set and O's elsewhere. For example:
                OR      00010010B           ;SET BITS 1 AND 4
Remember, logically ORing a bit with 0 does not affect its value. Since SET can set
only one bit at a time, we would need the following sequence to produce the same
result:
                SET     I.A                 ;SET BIT 1
                SET     4.A                 ;AND THEN SET BIT 4

  2. Test a register pair for O. Set the Zero flag if both halves of a register pair are O.
                LD      A.rph               ;TEST REGISTER PAIR FOR ZERO
                OR      rpl
The Zero flag is set if and only ifboth halves of register pair rp are O. The accumulator
and the other flags are also changed.

   3. Logical OR immediate with flags (condition codes). Logically OR a byte of
immediate data with the flag register, setting those flags that are logically ORed with
1'so
               PUSH AF                     ;MOVE AF TO A REGISTER PAIR
               POP rp
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                87

          LD      A,MASK             ;SET FLAGS
          OR      rpl
          LD      rpl, A
          PlISH   rp                 ;RESTORE AF WITH FLAGS SET
          POP     AF
This sequence changes a register pair (BC, DE, or HL).


Logical EXCLUSIVE OR Instructions
  I. Complement bits of accumulator.
           XOR    MASK               ;COMPLEMENT BITS BY MASKING
MASK has I 's in the bit positions to be complemented and O's in the positions that are
to be left unchanged. For example:
           XOR    11000000B          ;COMPLEMENT BITS 6 AND 7

Remember, logically EXCLUSIVE ORing a bit with 0 leaves it unchanged.

  2. Complement accumulator, setting flags.
           XOR    11111111B          ;INVERT AND SET FLAGS
Logically EXCLUSIVE ORing with all I's inverts all the bits. This instruction differs
from CPL only in that it affects the flags, whereas CPL does not.

   3. Compare register with accumulator bit by bit, setting each bit position that is
different.
           XOR    reg                ;BIT BY BIT COMPARISON
The EXCLUSIVE OR function is the same as a "not equal" function. Note that the
Sign flag is I if the two operands have different values in bit 7.

  4. Add register to accumulator logically (that is, without any carries between bit
positions).
           XOR    reg                 ;LOGICAL ADDITION
  The EXCLUSIVE OR function is also the same as a bit-by-bit sum with no carries.
Logical sums are often used to form checksums and error-detecting or error-correcting
codes.


Logical NOT Instructions
  1. Complement accumulator, setting flags.
88      Z80 ASSEMBLY LANGUAGE SUBROUTINES

            XOR    11111111B          ; INVERT AND SET FLAGS
Logically EXCLUSIVE ORing with all l's inverts all the bits. This instruction differs
from CPL only in that it affects the flags, whereas CPL does not.

     2. Complement bits of accumulator.
            XOR   MASK                ;COMPLEMENT BIT BY MASKING
MASK has l's in the bit positions to be complemented and O's in the positions that are
to be left unchanged. For example:
           XOR    01010001B           ;COMPLEMENT BITS 0, 4, AND 6
Remember, logically EXCLUSIVE ORing a bit with 0 leaves it unchanged.

 3. Complement memory location ADDR.
            LD    HL,ADDR
            LD    A, (HU              ;OBTAIN DATA
            CPL                       ; COMPLEMENT
            LD     (HU,A              ;RESTORE RESULT
CPL applies only to the accumulator.

 4. Complement bit 0 of a register.
           INC    reg
or
            DEC    reg

Either instruction may, of course, affect the other bits in the register. The final value of
bit 0 will surely be 0 if it was originally I and if it was originally O.

     5. Complement bit 0 of a memory location.
            LD     HL,ADDR
            INC    (HU

or
            LD    HL,ADDR
            DEC   (HU

 6. Complement digit of accumulator.
        Less significant digit
            XOR   00001111 B          ;COMPLEMENT LESS SIGNIFICANT DIGIT
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                 89

      More significant digit
            XOR    11110000B              ~COMPLEMENT   MORE SIGNIFICANT DIGIT
These procedures are useful if the accumulator contains a decimal digit in negative
logic, such as the input from a typical ten-position rotary or thumbwheel switch.

   7. Complement a register pair.
            LD     HL,OFFFFH              ~SET HL TO ALL ONES
            AND    A                      ~CLEAR CARRY
            sac    HL,rp                  ~SUBTRACT REGISTER PAIR FROM ALL ONES
The result ends up in HL.


Shift Instructions
   I. Shift accumulator left logically.
            ADD    A.A                    ~SHIFT   A LEFT LOGICALLY
Adding the accumulator to itself is equivalent to a logical left shift.

   2. Shift register pair HL left logically.
            ADD    HL,HL                  ~SHIFT   HL LEFT LOGICALLY

   3. Shift index register left logically.
            ADD    XY,XY                  ~SHIFT   IX OR IY LEFT LOGICALLY

  4. Shift register pair right logically.
            SRL    rph                    ~SHIFT MSB RIGHT LOGICALLY
            RR     rpl                    ~AND THEN ROTATE Lsa RIGHT
The key point here is that the less significant byte must be rotated to pick up the Carry
from the logical shifting of the more significant byte.

  5. Shift register pair right arithmetically.
           SRA rph                     ~SHIFT MSB RIGHT ARITHMETICALLY
           RR     rpl                  ~AND THEN ROTATE LSB RIGHT

The rotation of the less significant byte is the same as in the logical shift.

   6. Shift memory locations ADDR and ADDR+l (MSB in ADDR+l) left
logically.
90     Z80 ASSEMBLY LANGUAGE SUBROUTINES


                LD      HL,ADDR
                SLA     (HU                ~SHIFT    LSB LEFT LOGICALLY
                INC     HL
                RL      (Hl-)              ~AND    THEN ROTATE MSB LEFT
or
                LD      xy,ADDR
                SLA     (Xy+O)             ~SHIFT    LSB LEFT LOGICALLY
                RL      (xy+l)             ~AND    THEN ROTATE MSB LEFT
To produce a 16-bit left shift, you must shift the less significant byte first and then
rotate the more significant byte.

  7. Shift memory locations ADDR and ADDR+ 1 (MSB m ADDR+ 1) right
logically.
                LD      HL,ADDR+l
                SRL     (HU                ~SHIFT    MSB RIGHT LOGICALLY
                DEC     HL
                RR      (HU                ~AND    THEN ROTATE LSB RIGHT
or
                LD      xy,ADDR
                SRL     (Xy+1)             ~SHIFT    MSB RIGHT LOGICALLY
                RR      (Xy+O)             ~AND    THEN ROTATE LSB RIGHT

  8. Digit swap accumulator. That is, exchange the four least significant bits with the
four most significant bits.
                RLCA                       ~DIGIT   SHIFT    =4   LEFT ROTATES
                RLCA
                RLCA
                RLCA
or
                RRCA                       ~   DIGIT SHIFT     4 RIGHT ROTATES
                RRCA
                RRCA
                RRCA

  9. Normalize accumulator. That is, shift the accumulator left until its most signif-
icant bit is 1. Do not shift at all if the accumulator contains O.
                AND     A                  ;TEST ACCUMULATOR
                ..JP    M, DONE            ;EXIT IF ALREADY NORMALIZED
                ..JR    Z,DONE             ; EX IT IF ZERO
     SHIFT:     ADD     A,A                ; OTHERWISE, SHIFT A LEFT 1 BIT
                ,..IP   p, SHIFT           ; KEEP SHIFTING UNTIL NORMALIZED
     DONE:      NOP
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                        91

   10. Normalize register pair HL. That is, shift the l6-bit number left until its most
significant bit is 1. Do not shift the number at all if it is o.
                  LD     A.H                   ,IS ENTIRE NUMBER O?
                  OR     L
                  .JR    Z.DONE                ,YES. DONE
   SHIFT:         ADD    HL.HL                 ,SHIFT NUMBER LEFT 1 BIT
                  .JR    NC.SHIFT              ,KEEP SHIFTING UNTIL CARRY IS 1
                  RR     H                     ,THEN SHIFT BACK ONCE
                  RR     L
   DONE:          NOP
ADD HL affects the Carry but not the Sign or Zero flag.


Rotate Instructions
  1. Rotate register pair right.
                  RRC    rpl                   ,COPY BIT 0 FOR ROTATION
                  RL     rpl                   ,CARRY = BIT 0
                  RR     rph                   ,ROTATE MSB WITH BIT 0
                  RR     rpl                   ,THEN ROTATE LSB RIGHT
                                                                                                   •
The RRC rpl instruction places bit 0 both in bit 7 and in the Carry flag; RL rpl then
restores the register but leaves the original bit 0 in the Carry.

  2. Rotate register pair left.
                 RLC     rph                   ,COPY BIT 15 FOR ROTATION
                 RR      rph                   ,CARRY = BIT 15
                 RL      rpl                   ,ROTATE LSB WITH BIT 15
                 RL      rph                   ,THEN ROTATE MSB LEFT
RLC rph places bit 7 of the more significant byte both in bit 0 and in the Carry. RR rph
then restores the register but leaves the original bit 7 (bit 15 of the l6-bit register pair) in
the Carry.

  3. Rotate accumulator left through Carry, setting flags.
                 ADC     A.A                   ,ROTATE LEFT AND SET FLAGS
This instruction is the same as RLA, except that it affects all the flags whereas RLA
affects only the Carry.

  4. Rotate register pair right through Carry.
                 RR      rph                   ,ROTATE MSB RIGHT WITH CARRY
                 RR      rpl                   ,THEN ROTATE LSB RIGHT WITH CARRY
     92      Z80 ASSEMBLY LANGUAGE SUBROUTINES


          5. Rotate register pair left through Carry.
                 RL     rpl                 ;ROTATE LSB LEFT WITH CARRY
                 RL     rph                 ;ROTATE MSB LEFT WITH CARRY

       6. Rotate memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) right 1 bit
     position through Carry.
                 LD     HL.ADDR+l
                 RR     (HU                 ;ROTATE MSB RIGHT WITH CARRY
                 DEC    HL
                 RR     (HU                 ;THEN ROTATE LSB RIGHT WITH CARRY
     or
                 LD     xy.ADDR
                 RR     (Xy+1)              ;ROTATE MSB RIGHT WITH CARRY
                 RR     (Xy+O)              ;THEN ROTATE LSB RIGHT WITH CARRY

       7. Rotate memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) left one bit
     position through Carry.
                 LD     HL.ADDR
                 RL     (HU
..               INC    HL
                                            ;ROTATE LSB LEFT WITH CARRY
                 RL     (HU                 ;THEN ROTATE MSB LEFT WITH CARRY
     or
                 LD     xy.ADDR
                 RL     (Xy+O)              ;ROTATE LSB LEFT WITH CARRY
                 RL     (xy+1)              ;THEN ROTATE MSB LEFT WITH CARRY


     Test Instructions
       1. Test accumulator. Set flags according to the value in the accumulator without
     changing that value.
                 AND    A                   ;TEST ACCUMULATOR
     or
                 OR     A                   ;TEST ACCUMULATOR
     Both alternatives clear the Carry.

       2. Test register. Set flags according to the value in a register without changing that
     value.
               INC reg                     ;TEST REGISTER
               DEC reg
     This sequence does not affect the Carry or the accumulator.
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                     93
 3. Test memory location. Set flags according to the value in memory location
ADDR without changing that value.
           LD     HL,ADDR               ;TEST MEMORY LOCATION ADDR
           INC    (HU
           DEC    (HU
This sequence does not affect the Carry or the accumulator.

  4. Test register pair. Set the Zero flag according to the value in a register pair
without changing that value.
           LD     A,rph                 ;TEST REGISTER PAIR
           OR     rpl
This sequence changes the accumulator and the other flags.

  5. Test index register. Set the Zero flag according to the value in an index register
without changing that value.
           PUSH   Xy                    ;MOVE INDEX REG TO REGISTER PAIR
           POP    rp
           LD     A,rph                 ;TEST REGISTER PAIR
           OR     rpl

This sequence changes a register pair, the accumulator, and the other flags.

 6. Test a pair of memory locations. Set the Zero flag according to the contents of
memory locations ADDR and ADDR+ 1.
           LD     HL,(ADDR)             ;TEST A MEMORY WORD
           LD     A,H
           OR     L

This sequence changes HL, the accumulator, and the other flags.

  7. Test bits of accumulator. Set the Zero flag if all the tested bits are O's and clear the
Zero flag otherwise.
           AND    MASK                  ;TEST BITS BY MASKING

   MASK has l's in the bit positions to be tested and O's elsewhere. The Zero flag is set
to I if all the tested bits are O's and to 0 otherwise. For example:
           AND    10000001B             ;TEST BITS 0 AND 7

  The Zero flag is set to I if bits 0 and 7 of the accumulator are both zero, and to 0
otherwise. The BIT instruction, on the other hand, can only handle one bit at a time;
for example:
           BIT    7, A                  ; TEST BIT 7
94      Z80 ASSEMBLY LANGUAGE SUBROUTINES


To duplicate the AND instruction, we would need the sequence
                  BIT    7,A               ; TEST BIT 7
                  JR     NZ,DONE           ;EXIT IF IT IS 1
                  BIT    O,A               ;TEST BIT 0
     DONE:        NOP

  8. Compare register with accumulator bit by bit. Set each bit position that is
different to 1.
                  XOR    reg               ;BIT-BY-BIT COMPARISON
The EXCLUSIVE OR function is the same as a "not equal" function.

  9. Bit test. Set flags as ifthe accumulator had been logically ANDed with a memory
location, but do not change the accumulator.
                  LD     l-eg, A           ;SAVE ACCUMULATOR
                  LD     HL,ADDR
                  AND    (HU               ;PERFORM LOGICAL AND
                  LD     A,reg             ;RESTORE ACCUMULATOR


DATA TRANSFER INSTRUCTIONS
   In this group, we consider load, store, move, exchange, input, output, clear, and set
instructions. We also include arithmetic instructions (such as subtracting the accumu-
lator from itself) that move a specific value or the contents of another register to the
accumulator or other destination without changing any data.


Load Instructions
     1. Load register direct.
                  LD     A, (ADDR)
                  LD     reg, A
or
                  LD     HL,ADDR
                  LD     reg, (HU
The first alternative uses the accumulator, while the second alternative uses register
pair HL.

     2. Load register indirect.
       . From address in HL
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES             95
          LD     reg, (HL)
      From address in BC or DE
         LD    A,(rp)
         LD    reg, A
Note that only the accumulator can be loaded indirectly via BC or DE.
      From address in an index register
          LD     reg, (Xy+O)

  3. Load flag register with the 8-bit number VALUE.
          LD   rpl,VALUE             ;PUT VALUE IN LSB OF REGISTER PAIR
          PUSH rp                    ;MOVE TO FLAGS THROUGH STACK
          POP AF

The limitation of pushing and popping register pairs causes some unnecessary
operations.

  4. Load interrupt vector register with the 8-bit number VALUE.
          LD     A, VALUE
          LD     I,A

  5. Load refresh register with the 8-bit number VALUE.
          LD     A, VALUE
          LD     R,A

  6. Load flag register direct from memory location ADDR.
          LD   HL,(ADDR)            ;LOAD L FROM AD DR
          PUSH HL                   ;HL TO STACK, L ON TOP
          POP AF                    ;HL TO AF WITH L TO FLAGS

This procedure allows a user to initialize the flag register for debugging or testing
purposes. Note that it changes the accumulator and the less significant byte of a
register pair.

  7. Load interrupt vector register direct from memory location ADDR.
          LD     A, (ADDR)
          LD     I,A

  8. Load refresh register direct from memory location ADDR.
          LD     A, (ADDR)
          LD     R,A
96       Z80 ASSEMBLY LANGUAGE SUBROUTINES


     9. Load register pair HL indirect from address in HL.
             LD     A, (HU             ,LOAD LSB
             INC    HL
             LD     H, (HU             ,LOAD MSB
             LD     L,A

     10. Load register pair (BC or DE) indirect from address in HL.
             LD     rpl, (HU           ,LOAD LSB
             INC    HL
             LD     rph, (HU           ,LOAD MSB
             DEC    HL                 ,RESTORE HL TO ORIGINAL VALUE

     11. Load alternate processor status (AF') from stack.
             POP    AF
             EX     AF,AF'"

     12. Load memory locations PTR and PTR+ I (MSB in PTR+ I) with ADDR.
             LD  HL,ADDR            ,GET INDIRECT ADDRESS
             LD   (PTR),HL          ,STORE INDIRECT ADDRESS IN MEMORY




Store Instructions
     1. Store register direct.
             LD     A,reg
             LD     (ADDR),A
or
             LD     HL,ADDR
             LD     (HU ,reg

The first alternative uses the accumulator, whereas the second uses register pair HL.

     2. Store register indirect.
         At address in HL
             LD    (HU ,reg

         At address in DE or Be
             LD    A,reg
             LD    (rp),A

Only the accumulator can be stored at the address in BC or DE.
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                    97

         At address in an index register
              LD     (xy+O),reg

     3. Store flag register direct.
              PUSH AF                    ;F TO TOP OF STACK
              POP HL                     ;F TO L
              LD   (ADDR),HL             ;F TO ADDR, DESTROY ADDR+l
or
             PUSH   AF                   ;F   TO   TOP OF STACK
             POP    HL                   ;F   TO   L
             LD     A,L                  ;F   TO   A
             STA    ADDR                 ;F   TO   AD DR

     4. Store interrupt vector register direct.
              LD     A,I
              LD     (ADDR),A

     5. Store refresh register direct.
              LD     A,R
              LD     (ADDR),A

     6. Store register pair (BC or DE) indirect at address in HL.
              LD     (HL),rpl            ;STORE LSB
              INC    HL
              LD     (HL),rph            ;STORE MSB
              DEC    HL                  ;RETURN HL TO ORIGINAL VALUE
The register pair is stored in memory in the usual upside-down fashion.

     7. Store alternate processor status (AF') in stack.
             EX     AF,AF'"
              PUSH AF


Move Instructions
     1. Transfer accumulator to flag register.
              LD   rpl,A
              PUSH rp
              POP AF
The flag register is the less significant byte of register pair AF. This sequence also
changes the accumulator and the less significant byte of a register pair (i.e., C, E, or L).
98    Z80 ASSEMBLY LANGUAGE SUBROUTINES


  2. Transfer flag register to accumulator.
          PUSH AF
          POP rp
          MOV A.rpl

This sequence changes register pair rp.

  3. Move register pair I to register pair 2.
        LD     rp21, rp 11
        LD     rp2h.rplh

This sequence transfers the contents of register pair rp I to rp2 without changing rp 1.
Remember, EX DE,HL exchanges register pairs DE and HL specifically.

  4. Move stack pointer to HL.
          LD     HL,O
          ADD    HL,SP

  5. Move stack pointer to an index register.
        LD     xy,O
        ADD Xy,SP


  6. Move index register to register pair.
          PUSH xy
          POP rp

  7. Move register pair to index register.
        PUSH rp
        POP xy

  8. Move index register IX to index register IY.
          PUSH IX
          POP IV

  9. Move index register IY to index register IX.
          PUSH IV
          POP IX

 10. Move HL to program counter.
          JP     (HU
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                  99
  11. Move index register to program counter.
                 JP     (Xy)


  12. Move memory locations ADDR and ADDR+ 1 (MSB in ADDR+ 1) to the
program counter (an indirect jump).
                LD     HL,(ADDR)
                JP     (HL>

   13. Move multiple (fill). Place the accumulator in successive memory locations
starting at the address in register pair HL. The number of bytes to be filled (one or
more) is in register B.
   FILBYT:       LD   (HL>,A                ;FILL A MEMORY LOCATION
                 INC HL                     ;POINT TO NEXT LOCATION
                 DJNZ FILBYT                ;COUNT BYTES
  This routine can initialize an array or buffer. If more than 256 bytes are to be filled,
the repeated block move instructions become handy. The approach is to fill the first
byte from the accumulator and then use a repeated block move to fill the succeeding
bytes. The destination pointer is always one byte ahead of the source pointer, so the
data being moved is always the same.
                LD     (HL> ,A              ;FILL THE FIRST BYTE MANUALLY
                LD     D,H                  ; DESTINATION POINTER IS 1 BYTE UP
                LD     E,L
                INC    DE
                DEC    BC                   ;COUNT DOWN 1 BYTE
                LDIR                        ;FILL THE REST AUTOMATICALLY


Exchange Instructions
  1. Exchange registers using the accumulator.
                LD     A,l"egl
                LD     regl,l"eg2
                LD     reg2,A

  2. Exchange register pairs.
       DE with HL
                 EX    DE,HL
       Be with HL
                PUSH BC                      BC TO TOP OF STACK
                EX   HL,(SP)                 BC TO HL, HL TO TOP OF STACK
                POP BC                       HL TO BC
100       Z80 ASSEMBLY LANGUAGE SUBROUTINES


EX HL,(SP) exchanges HL with the top of the stack.
        general, rp 1 with rp2
            PUSH   rpl                 ;PUT RP1, RP2 IN STACK
            PUSH   rp2
            POP    rpl                 ;EXCHANGE BY POPPING IN WRONG ORDER
            POP    rp2

     3. Exchange stack pointer with HL.
            EX     DE,HL               ;HL TO DE
            LD     HL,O                ;SP TO HL
            ADD    HL,SP
            EX     DE,HL               ;SP TO DE, RESTORE HL
            LD     SP,HL               ; HL TO SP
            EX     DE,HL               ;SP TO HL
This procedure can be used to differentiate between the user stack and the operating
system or monitor stack.

     4. Exchange index register with register pair.
            PUSH   xy                  ;SAVE INDEX REG, REG PAIR IN STACK
            PUSH   rp
            POP    xy                  ;EXCHANGE BY POPPING IN WRONG ORDER
            POP    rp

     5. Exchange index registers.
            PUSH   IX                 ;SAVE BOTH INDEX REGISTERS IN STACK
            PUSH   IY
            POP    IX                 ;EXCHANGE BY POPPING IN WRONG ORDER
            POP    IV


Clear Instructions
     1. Clear the accumulator.
            SUB    A
or
            XOR    A
or
            LD     A,O

  The third alternative executes more slowly and occupies more memory than the
other two, but does not affect the flags.
CHAPTER 2 IMPLEMENTI NG ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES               101

     2. Clear a register.
              LD     reg,O

     3. Clear memory location ADDR.
              SlIB   A
              LD     (ADDR),A
or
              LD     HL,ADDR
              LD     (HU,O
  The second alternative executes more slowly than the first, but does not affect the
accumulator or the flags. Of course, it does use register pair HL.

     4. Clear a register pair.
              LD     rp,O

     5. Clear memory locations ADDR and ADDR+ 1.
              LD     HL,O
              LD     (ADDR),HL
HL is faster to use here than DE or Be.

     6. Clear Carry flag.
              AND    A
or
              OR     A

   Any other logical instruction (except CPL) will also clear the Carry, but these two
are particularly useful because they do not change the accumulator. Remember,
ANDing or ORing a bit with itself does not affect its value. To clear Carry without
affecting any other flags, use the sequence
              SCF                        ;FIRST SET CARRY FLAG
              CCF                        ;THEN CLEAR CARRY BY COMPLEMENTING

     7. Clear bits of accumulator.
              AND    MASK                ;CLEAR BITS BY MASKING
   MASK has O's in the bit positions to be cleared and l's in the positions that are to be
left unchanged. For example:
              AND    10111110B           ;CLEAR BITS 0 AND 6
RES can clear only one bit at a time.
102       Z80 ASSEMBLY LANGUAGE SUBROUTINES


Set Instructions
     1. Set the accumulator to FF 16 (all l's in binary).
             LD     A.OFFH
or
             SlIB   A
             DEC    A

     2. Set register to FF 16.
             LD     reg.OFFH

     3. Set memory location ADDR to FF 16.
             LD     A.OFFH
             LD     (ADDR).A
or
             LD     HL.ADDR
             LD     (HU ,OFFH

     4. Set bits of accumulator.
             OR     MASK                ;SET BITS BY MASKING
MASK has l's in the bit positions to be set and D's elsewhere. For example:
       OR      10110000B            ;SET BITS 4, 5. AND 7
The SET instruction can set only one bit at a time.



BRANCH (JUMP) INSTRUCTIONS

Unconditional Branch Instructions
     1. Jump indirect.
         To address in HL
            JP     (HU
         To address at the top of the stack
             RET
     Note that RET isjust an ordinary indirect jump that obtains its destination from the
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES            103

top of the stack. RET can be used for purposes other than returning from a subroutine.
       To address in DE
                EX       DE,HL
                ...IP    (HU
       To address in    Be
                LD       H,B
                LD       L,C
                ,jp      (HU
or
                PUSH BC
                RET
  The second alternative is much slower than the first (21 cycles as compared to 12
cycles), but does not change HL.
       To address in an index register
                JP       (xy)

       To address in memory locations ADDR and ADDR+ 1
                LD       HL,ADDR           ;FETCH INDIRECT ADDRESS
                JP       (HU               ;AND BRANCH TO IT

  2. Jump indexed, assuming that the base of the address table is in register pair HL
and the index is in the accumulator.
                ADD      A,A               ;DOUBLE INDEX FOR 2-BYTE ENTRIES
                LD       E,A               ;EXTEND INDEX TO 16 BITS
                LD       D,O
                ADD      HL,DE             ;CALCULATE ADDRESS OF ELEMENT
                LD       E, (HU            ; FETCH ELEMENT FROM ADDRESS TABLE
                INC      HL
                LD       D, (HU
                EX       DE,HL             ;AND JUMP TO IT
                JP       (HU
We have assumed that the address table (jump table) consists of as many as 128 2-byte
entries, stored in the usual Z80 format with the less significant byte at the lowel
address. A typical table would be
     JTAB:      DW       ROUTO             ;ADDRESS ENTRY (,I
                DW       ROUTt             ;ADDRESS ENTRY 1
                DW       ROUT2             ;ADDRESS ENTRY 2


  3. Jump and link; that is, transfer control to address DEST, saving the current
program counter in register pair HL.
104          Z80 ASSEMBLV LANGUAGE SUBROUTINES


                  LD     HL,HERE           ;LOAD HAND L WITH LINK
     HERE:        JP     DEST              ;TRANSFER CONTROL

  This procedure can provide a subroutine capability that does not use the stack. The
subroutine can return control by adjusting the link and executing lP (HL). For
example, to return control to the instruction immediately following lP DEST, the
subroutine would have to add 3 to HL (since lP DEST occupies 3 bytes). Of course,
the link could also be changed to HERE+3.


Conditional Branch Instructions
     1. Branch if O.
         Branch if accumulator contains 0
                  AND    A                 ;TEST ACCUMULATOR
                  JR     Z,DEST
         Branch if a register contains 0
                  INC    reg               ;TEST REGISTER
                  DEC    reg
                  JR     Z,DEST
         Branch if memory location ADDR contains 0
                  LD     HL,ADDR           ;TEST MEMORY LOCATION
                  INC    (HU
                  DEC    (HL-)
                  JR     Z,DEST
or
                  LD     A,(ADDR)          ;TEST MEMORY LOCATION
                  AND    A
                  JR     Z,DEST
         Branch if a register pair contains 0
                  LD     A,rph             ;TEST REGISTER PAIR
                  OR     rpl
                  JR     Z,DEST
         Branch if an index register contains 0
                  PUSH   Xy                ;MOVE INDEX REGISTER TO REGISTER PAIR
                  POP    rp
                  LD     A,rph             ;TEST REGISTER PAIR
                  OR     rpl
                  JR     Z,DEST
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                  105
         Branch if memory locations ADDR and ADDR+ 1 both contain 0
             LD      HL, (ADDR)               ;TEBT A 16-BIT NUMBER IN MEMORY
             LD      A,H
             OR      L
             JR      Z, DEBT
         Branch if a bit of a register is 0
             BIT     N, reg                   ;TEST BIT N OF REGISTER
             .JR     Z, DEST
Special cases are
         Branch if bit 7 of the accumulator is 0
             AND     A                        ;TEST BIT 7 OF ACCUMULATOR
             JP      P,DEST
or
             RLA                              ;MOVE BIT 7 TO CARRY
             .JR     NC,DEST
The second alternative allows relative jumps, but it also changes the accumulator.
         Branch if bit 6 of the accumulator is 0
            ADD A,A                     ;SET SIGN FROM BIT 6
            ...IP  P, DEST              ; THEN TEST SIGN FLAG
         Branch if bit 0 of the accumulator is 0
            RRA                         ;MOVE BIT 0 TO CARRY
            JR     NC,DEST              ;AND TEST CARRY
         Branch if a bit of a memory location is 0
             LD      HL,ADDR
             BIT     N, (HU                   ;TEST BIT N OF MEMORY LOCATION AD DR
             JR      Z,DEST
         Branch if interrupts are disabled (that is, if interrupt flip-flop IFF2 is 0)
              LD     A,I                      ;MOVE IFF2 TO P/V FLAG
             ...IP   PO, DEST
   The instruction LD A,I and LD A,R both move interrupt enable flip-flop IFF2 to
the Parity/Overflow flag. This sequence can be used to save the current interrupt
status before executing a routine that must run with interrupts disabled. That status
can then be restored afterward.

     2. Branch if not O.
         Branch if accumulator does not contain 0
             AND     A                        ;TEST ACCUMULATOR
             ,JR     NZ, DEST
106       Z80 ASSEMBLY LANGUAGE SUBROUTINES


         Branch if a register does not contain 0
            INC      reg                 ;TEST REGISTER
            DEC      reg
            JR       NZ,DEST
         Branch if memory location ADDR does not contain 0
             LD      HL,ADDR             ;TEST MEMORY LOCATION
              INC    (HU
             DEC     (HU
             ,..IR   NZ,DEST
or
             LD      A, (ADDR)           ;TEST MEMORY LOCATION
             AND     A
             JR      NZ,DEST
     .. ' Branch if register pair does not contain 0
             LD      A,rph               ;TEST REGISTER PAIR
             OR      rpl
             JR      NZ,DEST
         Branch if index register does not contain 0
             PUSH    Xl'                 ;TRANSFER INDEX REGISTER TO REG PAIR
             POP     rp
             LD      A,rph               ;TEST REGISTER PAIR
             OR      rpl
             JR      NZ,DEST
         Branch if memory locations ADDR and ADDR+ 1 do not both contain 0
             LD      HL.(ADDR)           ;TEST 16-BIT NUMBER IN MEMORY
             LD      A,H
             OR      L
             JR      NZ,DEST
         Branch if a bit of a register is 1
             BIT     N,reg               ;TEST BIT N OF REGISTER
             JR      NZ,DEST
Special cases are
      Branch if bit 7 of the accumulator is 1
           AND A                   ;TEST BIT 7 OF ACCUMULATOR
          JP      M,DEST
or
             RLA                         ;MOVE BIT 7 TO CARRY
             JR      C,DEST
     The second alternative allows relative jumps, but it also changes the accumulator.
CHAPTER 2: IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                 107

      Branch if bit 6 of the accumulator is I
         ADD A,A                     ;SET SIGN FROM BIT 6
         JP     M,DEST               ;THEN TEST SIGN FLAG
      Branch if bit 0 of the accumulator is I
         RRA                         ;MOVE BIT 0 TO CARRY
         JR     C,DEST               ;THEN TEST CARRY
      Branch if a bit of a memory location is 1
          LD    HL,ADDR
          BIT   N, (HU                 ;TEST BIT N OF MEMORY LOCATION ADDR
          JR    NZ,DEST
      Branch if interrupts are enabled (that is, if interrupt flip-flop IFF2 is 1)
          LD    A,I                    ;MOVE IFF2 TO P/V FLAG
          JP    PE,DEST
   The instructions LD A,I and LD A,R both move interrupt enable flip-flop IFF2 to
the Parity/Overflow flag. This sequence can be used to save the current interrupt
status before executing a routine that must run with interrupts disabled. That status
can be restored afterward.
  3. Branch if Equal.
      Branch if (A) = VALUE
          CP    VALUE                  ;COMPARE BY SUBTRACTING
          JR    Z,DEST
The following special cases apply to any register or to a memory location addressed
using HL or through indexing.
      Branch if (reg) = I
          DEC   reg                    ;CHECK BY DECREMENTING
          JR     Z,DEST                ;AND TESTING RESULT FOR ZERO
This procedure can be applied to any primary register, to the memory location
addressed through HL, or to memory locations addressed via indexing.
      Branch if (reg) = FF 16
          INC   reg                    ;CHECK BY INCREMENTING
          JR    Z,DEST                 ;AND TESTING RESULT FOR ZERO
This procedure can be applied to any primary register, to the memory location
addressed through HL, or to memory locations addressed via indexing.
      Branch if (A) = (reg)
          CP     reg                   ;COMPARE BY SUBTRACTING
          JR     Z,DEST
108     Z80 ASSEMBLY LANGUAGE SUBROUTINES


      Branch if (A) = (ADDR)
         LD     HL.ADDR             ;COMPARE 8Y SU8TRACTING
         CP     (HU
         JR     I. DEST
      Branch if (rp) = VAL16
         LD     HL.VAL16
         AND    A                   ;CLEAR CARRY
         S8C    HL.rp
         JR     I.DEST
Carry must be cleared, since the Z80 lacks a 16-bit subtract instruction without Carry.
Note that the two's complement of VAL16 cannot be added using AD D HL, since that
instruction does not affect the Zero flag.
      Branch if (HL) = (rp)
         AND    A                   ;CLEAR CARRY
         S8C    HL.rp
         JR     I. DEST

Note: Do not use either of the next two sequences to test for stack overflow or under-
flow, since intervening operations could change the stack pointer by more than 1.
      Branch if (SP) = VAL16
         LD     HL.VAL16
         AND    A                   ;CLEAR CARRY
         S8C    HL,SP
         JR     I, DEST
      Branch if (SP) = (HL)
         AND    A                   ;CLEAR CARRY
         S8C    HL,SP
         JR     I,DEST
      Branch if (xy) = VAL16
         PUSH   xy                  ;MOVE INDEX REGISTER TO REGISTER PAIR
         POP    rp
         LD     HL,VAL16            ;THEN COMPARE REGISTER PAIR, VAL16
         AND    A                   ;CLEAR CARRY
         SBC    HL,SP
         JR     I,DEST
ADD xy cannot be used to add the two's complement of VAL16, since ADD xy does
not affect the Zero flag.

  4. Branch if Not Equal.
      Branch if (A)"# VALUE
         CP     VALUE               ;COMPARE BY SUBTRACTING
         JR     NI,DEST
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES            109
  The following special cases apply to any register or to a memory location addressed
using HL or through indexing.
      Branch if (reg) #- I
          DEC      reg                :CHECK BY DECREMENTING
          JR       NZ,DEST            :AND TESTING RESULT FOR ZERO
       Branch if (reg) #- FF16
           INC reg                    :CHECK BY INCREMENTING
          ..JR   NZ,DEST              :AND TESTING RESULT FOR ZERO
       Branch if (A) #- (reg)
          CP       reg                ;COMPARE BY SUBTRACTING
          JR       NZ,DEST
       Branch if (A) #- (AD DR)
          LD       HL,ADDR            ;COMPARE BY SUBTRACTING
          CP       (HU
          ...JR    NZ, DEST
       Branch if (rp) #- VALl6
          LD       HL, VAL16
          AND      A                 ;CLEAR CARRY
          SBC      HL,rp
          ..JR     NZ, DEST
       Branch if (HL) #- (rp)
          AND      A                  ;CLEAR CARRY
          SBC      HL,rp
          ,JR      NZ, DEST
  Note: You should not use either of the next two sequences to test for stack overflow
or underflow, since intervening operations could change the stack pointer by more
than 1.
       Branch if (SP) #- VALl6
        LD        HL, VAL16
        AND       A                    ;CLEAR CARRY
        SSC       HL,SP
        ,JR       NZ,DEST
       Branch if (SP) #- (HL)
         AND      A                   ;CLEAR CARRY
         SBC      HL,SP
         JR       NZ,DEST
      Branch if (xy) #- VALl6
          PUSH Xy                     ;MOVE INDEX REGISTER TO REGISTER PAIR
          POP rp
110     Z80 ASSEMBLY LANGUAGE SUBROUTINES


         LD       HL.VAL16           ;THEN COMPARE REGISTER PAIR AND VAL16
         AND      A                  ;CLEAR CARRY
         SBC      HL.rp
         •...IR   NZ. DEST
ADD xy cannot be used to add the two's complement of VALl6, since ADD xy does
not affect the Zero flag.


 5. Branch if Positive.
      Branch if contents of accumulator are positive
         AND      A                  ;TEST ACCUMULATOR
         JP       P.DEST
      Branch if contents of a register are positive
         INC      reg                ;TEST REGISTER
         DEC      reg
         JP       P.DEST
      Branch if contents of memory location ADDR are positive
         LD       HL.ADDR            ;TEST MEMORY LOCATION
         INC      (HU
         DEC      (HU
         JP       P.DEST

or
          LD      A. (ADDR)          ;TEST MEMORY LOCATION
          AND     A
          JP      P.DEST
      Branch if contents of a register pair are positive
         INC      rph                ;TEST MORE SIGNIFICANT BYTE ONLY
         DEC      rph
         ",IP     P.DEST

      Branch if contents of index register are positive
         PUSH     xy                 ;TRANSFER INDEX REGISTER TO AF
         POP      AF
         AND      A                  ;TEST MORE SIGNIFICANT BYTE ONLY
         ..JP     P.DEST
    Branch if 16-bit number in memory locations ADDR and ADDR + I (MSB in
ADDR+ 1) is positive
         LD       A. (ADDR+l)        ;TEST MORE SIGNIFICANT BYTE ONLY
         AND      A
         JP       P.DEST
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES     111

or
             LD     HL,ADDR+l            ,TEST SIGN BIT OF MSB
             BIT    7, (HU
             JR     Z,DEST

     6. Branch if Negative.
         Branch if contents of accumulator are negative
             AND    A                    ,TEST ACCUMULATOR
             JP     M,DEST
         Branch if contents of a register are negative
             INC    reg                  ,TEST PRIMARY REGISTER
             DEC    reg
             JP     M,DEST
         Branch if contents of memory location ADDR are negative
             LD     HL,ADDR              ,TEST MEMORY LOCATION
             INC    (HU
             DEC    (HU
             JP     M,DEST
or
             LD     A, (ADDR)            ,TEST MEMORY LOCATION
             AND    A
             JP     M,DEST
         Branch if contents of a register pair are negative
             INC    rph                  ,TEST MORE SIGNIFICANT BYTE ONLY
             DEC    rph
             JP     M,DEST
        Branch if contents of an index register are negative
             PUSH xy                     ,MOVE INDEX REGISTER TO AF
             POP AF
             AND A                       ,TEST MORE SIGNIFICANT BYTE ONLY
             JP   M,DEST
        Branch if 16-bit number in memory locations ADDR and ADDR + 1 (MSB in
        ADDR+ 1) is negative
           LD      A, (ADOR+l)        ,TEST MORE SIGNIFICANT BYTE ONLY
           AND A
           JP      M,DEST

or
             LD    HL,ADDR+l             ,TEST SIGN BIT OF MSB
             BIT   7, (HU
             JR    NZ,DEST
112     Z80 ASSEMBLY LANGUAGE SUBROUTINES


  7. Signed Branches.
  These sequences must allow for two's complement overflow. After a comparison, the
setting of the Parity / Overflow flag indicates that overflow occurred. The branches are
lP PE (Branch on Overflow) and lP PO (Branch on No Overflow). The idea then is to
force a branch if the specified condition holds and overflow did not occur (a true
positive), or if the condition does not hold but overflow did occur (a false negative).
The operand in the initial comparison (indicated as oper) could be a data byte, a
register, (HL), or an indexed address.
      Branch if accumulator is greater than other operand (signed)
                CP      oper        ;PERFORM COMPARISON
                ,JP     PE,CHRVS    ;BRANCH IF OVERFLOW OCCURRED
                ,JP     M,DONE      ;NO OVERFLOW - NO BRANCH ON NEGATIVE
                ,JR     NZ,DEST         BRANCH IF RESULT NON-ZERO POSITIVE
                ..JR    DONE
  CHRVS:        ,JP     M,DONE      ; BRANCH IF NEGATIVE BUT OVERFLOW
  DONE:         NOP
  This sequence forces a branch if the result is greater than 0 and overflow did not
occur, or if the result is less than 0 but overflow did occur.
       Branch if accumulator is greater than or equal to other operand (signed)
               CP       oper        ;PERFORM COMPARISON
               .JP      PE, CHRVS   ; BRANCH I F OVERFLOW OCCURRED
               ,JP      P,DEST      ;BRANCH IF NO OVERFLOW, POSITIVE
               ,JR      DONE
  CHRVS:       ,JP      M,DEST      ;BRANCH IF OVERFLOW, NEGATIVE
  DONE:        NOP
  This sequence forces a branch if the result is greater than or equal to 0 and overflow
did not occur, or if the result is less than 0 but overflow did occur.
      Branch if accumulator is less than other operand (signed)
               CP       oper        ;PERFORM COMPARISON
               ,JP      PE, CHRVS   ;BRANCH IF OVERFLOW OCCURRED
               ,JP      M,DEST      ;BRANCH IF NO OVERFLOW, NEGATIVE
               ,JR      DONE
  CHRVS:       ,JP      P,DEST      ;BRANCH IF OVERFLOW, POSITIVE
  DONE:        NOP
  This sequence forces a branch if the result is less than 0 and overflow did not occur,
or if the result is greater than or equal to 0 and overflow did occur.
        Branch if accumulator is less than or equal to other operand (signed)
                CP      oper        ;PERFORM COMPARISON
                ,-,p    PE,CHRVS    ;BRANCH IF OVERFLOW OCCURRED
                ...IP   M,DEST      ;BRANCH IF NO OVERFLOW, NEGATIVE
                ,JR     Z,DEST      ;BRANCH IF NO OVERFLOW, ZERO
                ...IR   DONE
  CHRVS:        ,JP     M,DONE
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES               113
                 ,JR    NZ. DEST       ;BRANCH IF OVERFLOW, POSITIVE
     DONE:       NOP
  This sequence forces a branch if the result is less than or equal to 0 and overflow did
not occur, or if the result is greater than 0 and overflow did occur.

     8. Branch if Higher (Unsigned).
  Branch if the operands being compared are not equal and the comparison does not
require a borrow. The special problem here is avoiding a branch when the operands are
equal.
         Branch if (A) > VALUE (unsigned)
                 CP     VALUE          ;COMPARE BY SUBTRACTING
                 JR     C,DONE         ;NO BRANCH IF BORROW NEEDED
                 JR     NZ,DEST        ;BRANCH IF NO BORROW, NOT EQUAL
     DONE:       NOP
     Comparing equal numbers clears Carry. An alternative approach is
                 CP     VALUE+l        ;COMPARE BY SUBTRACTING VALUE+l
                 JR     NC.DEST        ;BRANCH IF NO BORROW NEEDED
        Branch if (A) > (reg) (unsigned)
                 CP     reg            ;COMPARE BY SUBTRACTING
                 JR     G,DONE         ;NO BRANCH IF BORROW NEEDED
                 ,JR    NZ,DEST        ;BRANCH IF NO BORROW, NOT EQUAL
     DONE:       NOP
or
                 LD     regl,A         ;FORM REG - A
                 LD     A,reg
                 CP     regl
                 \.IR   NC,DEST        ;BRANCH IF BORROW NEEDED
or
                 INC    reg         ;FORM A - REG - 1
                 CP     reg
                 \.IR   NC.DEST        ; BRANCH IF NO BORROW NEEDED
In the third alternative, we could replace INC reg with DEC A, thus changing the
accumulator instead of the register.
         Branch if (A) > (ADDR) (unsigned)
                 LD     HL,ADDR
                 CP     (HU            ;COMPARE BY SUBTRACTING
                 \.IR   C, DONE        ;NO BRANCH IF BORROW NEEDED
                 \.IR   NZ. DEST       ;BRANCH IF NO BORROW, NOT EQUAL
 DONE:           NOP
or
114       Z80 ASSEMBLV LANGUAGE SUBROUTI NES


           LD     reg, A             ;FORM (ADDR) - A
           LD     A, (ADDR)
           CP     reg
           JR     C,DEST             ;BRANCH IF BORROW NEEDED
        Branch if (HL) > (rp) (unsigned)
           SCF                       ;SET CARRY FLAG
           SBC    HL,rp
           JR     NC,DEST            ;BRANCH IF NO BORROW NEEDED
         Branch if (HL) > VALl6 (unsigned)
           LD     rp.-VAL16-1        ;FORM HL - VAL16 - 1
           ADD    HL.rp
           JR     C.DEST             ;BRANCH IF NO BORROW NEEDED
Carry is an inverted borrow here, since we are subtracting by adding the two's
complement.
      Branch if (SP) > (HL) (unsigned)
            AND   A                  ;CLEAR CARRY FLAG
            SBC   HL.SP
          . JR    C.DEST
         Branch if (SP) > VALl6 (unsigned)
           LD     HL.-VAL16-1        ;FORM SP - VAL16 - 1
           ADD    HL.SP
           JR     C.DEST             ;BRANCH IF NO BORROW GENERATED
         Branch if (xy) > VALl6 (unsigned)
           LD     rp.-VAL16-1        ;FORM XY - VAL16 - 1
           ADD    xy.rp
           JR     C.DEST             ;BRANCH IF NO BORROW GENERATED
         Branch if (xy) > (HL) (unsigned)
           PUSH   Xy                 ;MOVE INDEX REGISTER TO REGISTER PAIR
           POP    rp
           AND    A                  ;CLEAR CARRY FLAG
           SBC    HL.rp
           JR     C.DEST
     9. Branch if Not Higher (Unsigned).
  Branch if the operands being compared are equal or the comparison requires a
borrow. The special problem here is forcing a branch if the operands are equal.
         Branch if (A) :::; VALUE (unsigned)
           CP     VALUE              ;COMPARE BY SUBTRACTING
           JR     C.DEST             ;BRANCH IF BORROW NEEDED
           JR     Z.DEST                OR IF EQUAL
or
CHAPTER 2. IMPLEMENTI NG ADDITIONAL INSTRUCTI ONS AND ADDRESS ING MODES    115

          CP      VALlIE+1             ;COMPARE BY SlIBTRACTING VALlIE+1
          ...IR   C.DEST               ;BRANCH IF BORROW NEEDED

      Branch if (A) ::; (reg) (unsigned)
          CP      reg                  ; COMPARE BY SlIBTRACT! NG
          ...IR   C. DEST              ;BRANCH IF BORROW NEEDED
          ...IR   Z. DEST                  OR IF EQUAL
or
          LD      reg1.A               ;FORM REG - A
          LD      A.reg
          CP      reg1
          ...IR   NC.DEST              ;BRANCH IF NO BORROW NEEDED
or
           INC    reg                  ;FORM A - REG - 1
          CP      reg
          ...IR   C. DEST              ;BRANCH IF BORROW NEEDED
In the third alternative, we could replace INC reg with DEC A, thus changing the
accumulator instead of the register.
      Branch if (A)::; (ADDR) (unsigned)
         LD      HL.ADDR
         CP      (HU                ;COMPARE BY SlIBTRACTING
         ...IR   C. DEST            ;BRANCH IF BORROW NEEDED
         ...IR   Z.DEST                OR IF EQUAL
or
          LD      reg. A               ;FORM (ADDR.l - A
          LD      (ADDR).A
          CP      reg
          ...IR   N(:.DEST             ;BRANCH IF NO BORROW NEEDED
     Branch if (HL)::; (rp) (unsigned)
          SCF                          ;SET CARRY FLAG
          SBC     HL.rp                ;FORM HL - RP - 1
          ...IR   C.DEST               ;BRANCH IF BORROW NEEDED
     Branch if (HL) ::; VALl6 (unsigned)
          LD      rp.-VAL16-1
          ADD     HL.rp                ;FORM HL - VAL16 - 1
          ...IR   NC.DEST              ;BRANCH IF BORROW NEEDED
     Branch if (SP)::; (HL) (unsigned)
          AND     A                    ;CLEAR CARRY
          SBC     HL.SP                ;FORM HL - SP
          ...IR   NC.DEST              ;BRANCH IF NO BORROW NEEDED
116    Z80 ASSEMBLY LANGUAGE SUBROUTINES


      Branch if (SP):::; VAL16 (unsigned)
        LD     HL,-VAL16-1          ;FORM SP - VAL16 - 1
        ADD    HL,SP
        .JR    NC,DEST              ;BRANCH IF BORROW NEEDED
      Branch if (xy) :::; VAL16 (unsigned)
         LD    rp,-VAL16-1         ;FORM XY - VAL16 - 1
         ADD   xY,rp
         ,JR   NC,DEST             ;BRANCH IF BORROW NEEDED
      Branch if (xy):::; (HL) (unsigned)
        PUSH   }(y                  ;MOVE INDEX REGISTER TO REGISTER PAIR
        POP    rp
        AND    A                    ;CLEAR CARRY
        SBC    HL,rp                ;FORM HL - XY
        ,JR    NC,DEST              ;BRANCH IF NO BORROW NEEDED

  10. Branch if Lower (Unsigned). Branch if the unsigned comparison requires a
borrow.
      Branch if (A) < VALUE (unsigned)
         CP    VALUE               ;COMPARE BY SUBTRACTING
         .JR   C, DEST             ;BRANCH IF BORROW NEEDED
      Branch if (A) < (reg) (unsigned)
        CP     reg                 ;COMPARE BY SUBTRACTING
        ,JR    C,DEST              ;BRANCH IF BORROW NEEDED

      Branch if (A) < (ADDR) (unsigned)
        LD     HL,ADDR
        CP      (HU                 ;COMPARE BY SUBTRACTING
        .JR    C,DEST
      Branch if (HL) < (rp) (unsigned)
        AND    A                   ;FORM HL - RP
        SBC    HL,rp
        .JR    C,DEST              ;BRANCH IF BORROW NEEDED
      Branch if (HL) < VAL16 (unsigned)
         LD    t-p, -VAL16         ;FORM HL - VAL16
         ADD   HL,rp
         ,JR   NC,DEST             ;BRANCH IF BORROW NEEDED
      Branch if (SP) < (HL) (unsigned)
        SCF                       ;FORM HL - SP-l
        SBC HL,SP
        ...IR  NC, DEST           ;BRANCH IF NO BORROW NEEDED
CHAPTER 2. IMPLEMENTING ADDITIONAL INSmUCTIONSAND ADDRESSING MODES          117
      Branch if (SP) < VAL16 (unsigned)
          LD     HL, -VAL16                ;FORM SP - VAL16
          ADD    HL,SP
          JR     NC,DEST                   ;BRANCH IF NO BORROW NEEDED
      Branch if (xy) < VAL16 (unsigned)
          LD     rp,-VAL16                 ;FORM XY - VAL16
          ADD    >:Y,rp
          JR     NC,DEST               ;BRANCH IF NO BORROW NEEDED
      Branch if (xy) < (HL) (unsigned)
          PUSH Xy                      ; MOVE INDEX REGISTER TO REGISTER PAIR
          POP rp
          SCF                              ; FORM HL   -   XY-l
          SBC HL,t-p
          ,-IR NC,DEST                     ; BRANCH IF NO BORROW NEEDED

  I I. Branch if Not Lower (U nsigned). Branch if the unsigned comparison does not
require a borrow.
      Branch if (A) 2': VALUE (unsigned)
          CP     VALUE                     ;COMPARE BY SUBTRACTING
          JR     NC,DEST                   ;BRANCH IF NO BORROW NEEDED
      Branch if (A) 2': (reg) (unsigned)
          CP     reg                   ;COMPARE BY SUBTRACTING
          JR     NC,DEST               ;BRANCH IF NO BORROW NEEDED
      Branch if (A) 2': (ADDR) (unsigned)
          LD     HL,ADDR
          CP     (HU                   ;COMPARE BY SUBTRACTING
          ,-IR   NC,DEST               ;BRANCH IF NO BORROW NEEDED
      Branch if (HL) 2': (rp) (unsigned)
          AND    A                     ;FORM HL - RP
          SBC    HL, tOP
          ,-IR   NC, DEST              ;BRANCH IF NO BORROW NEEDED
      Branch if (HL) 2': VAL16 (unsigned)
          LD     rp, -VAL16            ; FORM HL -         VAL16
          ADD    HL, tOP
          ,-IR   C,DEST                ;BRANCH IF NO BORROW NEEDED

      Branch if (SP) 2': (HL) (unsigned)
          SCF                              ; FORM HL -     SP-l
          SBC    HL,SP
          ,-IR   C,DEST                    ;BRANCH IF BORROW NEEDED
118     ZSO ASSEMBLY LANGUAGE SUBROUTINES


      Branch if (SP) 2: VALl6 (unsigned)
               LD      HL, -VAL16 ; FORM SP - VAL16
               ADD     HL,rp
               ,JR     C:, DEST   : BRANCH I F NO BORROW NEEDED
      Branch if (xy) 2: VALl6 (unsigned)
               LD      rp,-VAL16 :FORM XY - VAL16
               ADD     Xy,SP
               JR      C,DEST    :BRANCH IF NO BORROW NEEDED
      Branch if (xy) 2: (HL) (unsigned)
               PUSH xy             :TRANSFER INDEX REG TO REGISTER PAIR
               POP tOP
               SCF                 :FORM HL - XY - 1
               SBC HL.rp
               ,JR  C,DEST         :BRANCH IF BORROW NEEDED



SKIP INSTRUCTIONS
  Skip instructions can be implemented on the Z80 microprocessor by using jump
instructions with the proper destination. That destination should be one instruction
beyond the one that follows the jump sequentially. The actual number of bytes skipped
will vary, since Z80 instructions vary from one to four bytes in length.



SUBROUTINE CALL INSTRUCTIONS

Unconditional Call Instructions
  An indirect call on the Z80 microprocessor can be implemented by calling a routine
that performs an indirect jump. An RET instruction at the end of the subroutine will
then transfer control back to the original calling point. The main program performs
  CALL TRANS
where subroutine TRANS transfers control to the ultimate destination. Note that
TRANS ends with a jump, not with a return. Typical TRANS routines are
     . To address in HL
  TRANS:       ...IP   (HU         :ENTRY POINT IN HL
     . To address in an index register
  TRANS:       JP      (Xy)        :ENTRY POINT IN AN INDEX REGISTER
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES              119
       · To address in DE
     TRANS:           EX       DE,HL       ;ENTRY POINT IN DE
                      ...IP    (HU
       · To address in BC
     TRANS:           LD       H,B         ;ENTRY POINT IN Be
                      LD       L,e
                      ,..IP    (HU
or
     TRANS:           PUSH Be              ;ENTRY POINT IN Be
                      RET
The second alternative is longer, but leaves HL unchanged.
       · To address in memory locations ADDR and ADDR+ 1
     TRANS:            LD      HL,(ADDR) ;ENTRY POINT AT ADDR
                       ...IP   (HU
    · To address at the top of the stack. Here we must exchange the return address
with the top of the stack. This can be done in the main program as follows:
                       LD      HL,RETPT    ;GET RETURN POINT ADDRESS
                       EX      HL,(SP)     ;PUT RETURN ADDRESS ON STACK
                       ...IP   (HL.l       ;AND JUMP TO OLD TOP OF STACK
   The exchange can allow later resumption of a suspended program or provide a
special exit to an error-handling routine.
   You can implement indexed calls in the same way as indirect calls. The CALL
instruction transfers control to a routine that performs an indexed jump as shown
earlier. That routine ends with an ordinary jump instruction (typically lP (HL)) that
does not affect the stack. An RET instruction at the end of the actual subroutine will
the!efore_ transfer control back to the original calling point.
   If the main program executes CALL lMPIND with the index in the accumulator
and the starting address of the jump table in register pair HL, the indexed jump routine
IS

     ,-IMPIND:         ADD     A,A         ;DOUBLE INDEX FOR 2-BYTE ENTRIES
                       LD      E,A         ;EXTEND INDEX TO 16 BITS
                       LD      D,O
                        ADD    HL,DE       ;CALCULATE ADDRESS OF ELEMENT
                       LD      E, (HU      ;FETCH ELEMENT FROM ADDRESS TABLE
                        INC    HL
                       LD      D, (HU
                       EX      DE,HL       ; AND JUMP TO IT
                       ...IP   (HL)
   One problem with indexed and indirect calls is that the transfer routines may
interfere with the subroutines. For example, the indexed jump routine lMPIND
changes the accumulator, register pair DE, register pair HL, and the flags. Thus, none
120    Z80 ASSEMBLY LANGUAGE SUBROUTINES


of these registers can be used to pass parameters to the subroutine. The programmer
must always remember that the intermediate transfer routines are interposed between
the main program and the actual subroutine. A similar interposition occurs when
operating system routines transfer control from one task to another or from a main
program to an 110 driver or an interrupt service routine.


Conditional Call Instructions
  Conditional calls can be implemented on the Z80 by using the sequences shown for
conditional branches. The only change is that jumps to the actual destination must be
replaced with calls (for example, replace lR NZ,DEST with CALL NZ,DEST or lP
P,DEST with CALL P,DEST).



SUBROUTINE RETURN INSTRUCTIONS

Unconditional Return Instructions
  The RET instruction returns control automatically to the address saved at the top of
the stack. If the return address is saved elsewhere (for example, in a register pair or in
two fixed memory locations) you can transfer control to it by performing an indirect
jump.


Conditional Return Instructions
  Conditional returns can be implemented on the Z80 microprocessor by using the
sequences shown earlier for conditional branches. The only change is that you must
replace jumps to the actual destination with RETs (for example, replace lR NC, DEST
with RET NC or lP M,DEST with RET M).


Return with Skip Instructions
     . Return control to the address at the top of the stack after it has been
incremented by an offset NEXT. This sequence lets you transfer control past
parameters, data, and other non-executable items.
          POP    DE                  ;OET RETURN ADDRESS
          LD     HL,NEXT             ;OFFSET TO NEXT EXECUTABLE INSTRUCTION
          ADD    HL,DE
          ",IP   (HU                 ;AND RETURN
CHAPTER 2. IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                121

     . Change the return address to RETPT. Assume that the return address is
currently stored at the top of the stack.
           LD     HL,RETPT               ;CHANGE RETURN ADDRESS TO RETPT
           EX     HL, (SP)
   EX HL,(SP) exchanges HL with the top of the stack. This procedure allows you to
force a special exit to an error routine or other exception-handling program without
changing the logic of the subroutine or losing track of the original return address.


Return from Interrupt Instructions
  If the initial portion of the interrupt service routine saves all the primary registers
and the index registers with the sequence
           PUSH   AF                     ;SAVE PRIMARY REGISTERS
           PUSH   BC
           PUSH   DE
           PUSH   HL
           PUSH   IX                     ;SAVE INDEX REGISTERS
           PUSH   IY
a standard return sequence is
           POP    IY                     ;RESTORE INDEX REGISTERS
           POP    IX
           POP    HL                     ;RESTORE PRIMARY REGISTERS
           POP    DE
           POP    BC
           POP    AF
           EI                            ;REENABLE INTERRUPTS
           RETI
   The order of restoration is the opposite of the order in which the registers were
saved. The instruction EI must come immediately before RETI to avoid unnecessary
stacking of return addresses.



MISCELlANEOUS INSTRUCTIONS
   In this category, we include no operations, push, pop, halt, wait, trap (break or
software interrupt), decimal adjust, enabling and disabling of interrupts, translation
(table lookup), and other instructions that do not fall into any of the earlier categories.

  1. No Operation Instructions.
  Like NOP itself, any LD instruction with the same source and destination register
does nothing except advance the program counter. These additional no-ops are
122     Z80 ASSEMBLY LANGUAGE SUBROUTINES


          LD     A,A
          LD     B,B
          LD     C,C
          LD     D,D
          LD     E,E
          LD     H,H
          LD     L,L

  2. Push Instructions.
       Push a single register (A, B, D, or H)
          PUSH tOP                    ;PUSH THE REGISTER PAIR
          INC SP                      ;EUT DROP THE LESS SIGNIFICANT HALF
  The register pair could be AF. Programmers generally prefer to combine byte-length
operands or simply waste a byte of the stack rather than attempt to push a single byte.
      Push memory location ADDR
          LD   A, (ADDR)              ;OBTAIN.DATA FROM MEMORY
          PUSH AF                     ;PUSH DATA, FLAGS
          INC SP                      ;THEN DROP THE FLAGS
ADDR could be an external priority or control register (or a copy of an external
register).
       Push memory locations ADDR and ADDR+ I
           LD   HL,(ADDR)       ;PUSH A PAIR OF MEMORY LOCATIONS
           PUSH HL
      Push the interrupt flip-flop IFF2
          LD   A,I                    ;MOVE IFF2 TO PARITY/OVERFLOW FLAG
          PUSH AF
  This sequence allows you to save the interrupt status in the Parity / Overflow flag (bit
2 of register F) for later restoration.

  3. Pop (Pull) Instructions .
    . Pop a single register (A, B, D, or H), assuming that it has been saved as shown
previously
          DEC    SP                   ;BACK UP THE STACK POINTER
          POP    tOP                  ;POP THE REGISTER PAIR
This sequence changes the less significant half of the register pair unpredictably.
    . Pop memory location ADDR, assuming that it has been saved at the top of the
stack
          DEC    SP                   ;BACK UP THE STACK POINTER
          POP    AF                   ;POP ACCUMULATOR AND FLAGS
          LD     (ADDR),A             ;RESTORE DATA TO MEMORY
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                 123
  This sequence changes the flags unpredictably. ADDR could be an external priority
or control register (or a copy of an external register).
     . Pop memory locations ADDR and ADDR+ 1, assuming that they were saved as
shown previously
                POP     HL         ;RESTORE A PAIR OF MEMORY LOCATIONS
                LD      (ADDR) ,HL
Sometimes you must push and pop key memory locations and other values beside the
registers.
       Restore interrupt status, assuming that it has been saved at the top of the stack.
                POP     AF        ;OBTAIN PREVIOUS INTERRUPT STATUS
                JP      PE,ENABLE
                DI                ;DISABLE INTERRUPTS IF PREVIOUSLY SO
                ,..IR   DONE
  ENABLE:       EI                ;ENABLE INTERRUPTS IF PREVIOUSLY SO
  DONE:         NOP
The interrupt flip-flop IFF2 is saved in the Parity/Overflow flag; interrupts were
previously enabled if that flag is 1 and disabled if it is O.



Wait Instructions
  The simplest way to implement a wait on the Z80 microprocessor is to use an endless
loop such as
  HERE:         JP      HERE
The processor will execute JP until it is interrupted and will resume executing it after
the interrupt service routine returns control. Of course, regular interrupts must have
been enabled (with EI) or the processor will execute the endless loop indefinitely. The
non-maskable interrupt can interrupt at any time without being enabled.



Trap Instructions
   The common Z80 traps (also called breaks or software interrupts) are the RST
instructions (see the list in Table 1-9). RST n calls the subroutine starting at address n.
Thus, for example, RST 0 transfers control to memory address 0000 after saving the
current program counter in the stack. Similarly, RST 30H transfers control to memory
address 003016 after saving the current program counter in the stack. The interrupt
system generally uses the RST instructions, but the programmer can dedicate unused
ones to common subroutines, error traps, or supervisor entry points. RST then serves
as a I-byte call.
124       ZSO ASSEMBLY LANGUAGE SUBROUTINES


Adjust Instructions
     1. Branch if accumulator does not contain a valid decimal (BCD) number.
           LD      reg,A             ;SAVE COPY OF ACCUMULATOR
           ADD     A,O               ;THEN DECIMAL ADJUST ACCUMULATOR
           DAA
           CMP     reg               ;DID DECIMAL ADJUST CHANGE A?
           JR      NZ,DEST           ;YES, A WAS NOT DECIMAL

     2. Decimal increment accumulator (add I to A in decimal).
           ADD     A,l              ;ADD 1 IN DECIMAL
           DAA

     3. Decimal decrement accumulator (subtract 1 from A in decimal).
           SUB     1                 ;SUBTRACT 1 IN DECIMAL
           DAA
or
           ADD     A,99H             ;SUBTRACT 1 BY ADDING 99
           DAA
  The second alternative is compatible with the 8080 and 8085 processors, where DAA
works properly only after addition instructions.


Enable and Disable Interrupt Instructions
   1. Enable interrupts but save previous value of interrupt flip-flop 2 (the interrupt
status).
            LD   A, I               ;MOVE INTERRUPT FLIP-FLOP TO P/V FLAG
            PUSH AF                 ;SAVE OLD IFF2 IN STACK
            EI                      ;THEN ENABLE INTERRUPTS

   2. Disable interrupts but save previous value of interrupt flip-flop 2 (the interrupt
status).
            LD   A, I               ;MOVE INTERRUPT FLIP-FLOP TO P/V FLAG
            PUSH AF                 ;SAVE OLD IFF2 IN STACK
            DI                      ;THEN DISABLE INTERRUPTS

  3. Restore interrupt status, assuming that it is currently saved in the Parity I
Overflow flag at the top of the stack.
            POP.   AF                ;OBTAIN PREVIOUS INTERRUPT STATUS
            JP     PE,ENABLE         ;WERE INTERRUPTS ENABLED ORIGINALLY?
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES             125
                DI                  ;NO, THEN DISABLE THEM NOW
                JR     DONE
  ENABLE:       EI                  ;YES, THEN ENABLE THEM NOW
  DONE:         NOP
  After LD A,I or LD A,R, jp PE means "branch if interrupts are enabled,"while jp
PO means "branch if interrupts are disabled."


Translate Instructions
  1. Translate the accumulator into the corresponding entry in a table starting at the
address in register pair HL.
                LD     E,A          ;EXTEND OPERAND TO 16-BIT INDEX
                LD     D,O
                ADD    HL,DE        ;USE OPERAND TO ACCESS TABLE
                LD     A, (HU       ;REPLACE OPERAND WITH TABLE ENTRY
This procedure can be used to convert data from one code to another.

   2. Translate the accumulator into the corresponding 16-bit entry in a table starting
at the address in register pair HL. Place the entry in HL.
                EX    DE,HL         ;MOVE STARTING ADDRESS TO DE
                LD    L,A           ;EXTEND OPERAND TO 16-BIT INDEX
                LD    H,O
                ADD   HL,HL         ;DOUBLE INDEX FOR 2-BYTE ENTRIES
                ADD   HL,DE         ;CALCULATE INDEXED ADDRESS
                LD    E, (HU        ;OBTAIN ENTRY
                INC   HL
                LD    D, (HU
                EX    DE,HL         ;MOVE ENTRY TO HL
 Using ADD HL,HL to double the operand allows it to take on any 8-bit value (using
ADD A,A would limit us to values below 128).


Miscellaneous Instructions
   1. Allocate space on the stack; decrease the stack pointer to provide NUM empty
locations at the top.
                LD    HL,-NUM       ;ADD NUM EMPTY BYTES TO TOP OF STACK
                ADD   HL,SP
                LD    SP,HL         ;SP = SP - NUM
An alternative is a series of DEC SP instructions.

  2. Deallocate space from the stack; increase the stack pointer to remove NUM
temporary locations from the top.
126     Z80 ASSEMBLY LANGUAGE SUBROUTINES


           LD    HL,NUM              ;DELETE NUM BYTES FROM STACK
           ADD   HL.SP
           LD    SP,HL              ;SP = SP + NUM
An alternative is a series of INC SP instructions.



ADDITIONAL ADDRESSING MODES
   . Indirect Addressing. Indirect addressing can be provided on the Z80 processor by
loading the indirect address into register pair HL. Then addressing through HL
provides the equivalent of true indirect addressing. This is a two-step process that
generally requires HL, although BC or DE can be employed to load and store the
accumulator. The index registers may also be used, although at the cost of extra
execution time and memory. Note that indexed addressing with a 0 offset is simply a
slow version of indirect addressing.

Examples
  1. Load the accumulator indirectly from the address in memory locations ADDR
and ADDR+l.
         LD    HL,(ADDR)          ;FETCH INDIRECT ADDRESS
        LD     A. (HU             ;FETCH DATA INDIRECTLY
or
           LD    xy.(ADDR)          ;FETCH INDIRECT ADDRESS
           LD    A, (Xy+O)          ;FETCH DATA INDIRECTLY

 2. Store the accumulator indirectly at the address in memory locations ADDR and
ADDR+l.
        LD     HL,(ADDR)           ;FETCH INDIRECT ADDRESS
        LD      (HU,A              ;STORE DATA INDIRECTLY
or
           LD    xy,(ADDR)          ;FETCH INDIRECT ADDRESS
           LD    (xy+O),A           ;STORE DATA INDIRECTLY

   3. Load the accumulator indirectly from the address in register pair HL (that is,
from the address stored starting at the address in HL).
           LD    E,(HL)             ;FETCH INDIRECT ADDRESS
           INC   HL
           LD    D, (HU
           LD    A, (DE)            ;FETCH DATA INDIRECTLY
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES                127

  4. Load the accumulator indirectly from the address in an index register (that is,
from the address stored starting at the address in an index register).
          LD     L,(xy+O)           ;FETCH INDIRECT ADDRESS
          LD     H,(xy+l)
          LD     A, (HU             ;FETCH DATA INDIRECTLY

  5. Store the accumulator indirectly at the address in register pair HL (that is, at the
address stored starting at the address in HL).
           LD     E, (HU              ;FETCH INDIRECT ADDRESS
           INC    HL
           LD     D, (HU
           LD     (DE), A             ;STORE DATA INDIRECTLY

  6. Store the accumulator indirectly at the address in an index register (that is, at the
address stored starting at the address in an index register).
           LD     L,(xy+O)            ;FETCH INDIRECT ADDRESS
           LD     H,(xy+l)
           LD     (HU,A               ;STORE DATA INDIRECTLY

     7. Jump indirectly to the address in memory locations ADDR and ADDR+ 1.
           LD     HL,(ADDR)           ;FETCH INDIRECT ADDRESS
           JP     (HL)                ;AND TRANSFER CONTROL TO IT
or
           LD     Xy, (ADDR)          ;FETCH INDIRECT ADDRESS
           JP     (Xy)                ;AND TRANSFER CONTROL TO IT
Indirection can be repeated indefinitely to provide multi-level indirect addressing. For
example, the following routine uses the indirect address indirectly to load the
accumulator:
           LD     E, (HU              ;FETCH FIRST INDIRECT ADDRESS
           INC    HL
           LD     D, (HU
           EX     DE,HL
           LD     E, (HU              ;USE INDIRECT ADDRESS INDIRECTLY
           INC    HL
           LD     D, <HU
           LD     A, (DE)             ;FETCH DATA INDIRECTLY
Indirect addresses should be stored in memory in the usual Z80 format~that is, with
the less significant byte first (at the lower address).
  . Indexed Addressing. Indexed addressing can be provided by using ADD HL to
add the base and the index. Obviously, the explicit addition requires extra execution
time. The index registers are useful when the index is fixed (as in a data structure) or
when HL is already occupied.
128     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Examples
   1. Load the accumulator from an indexed address obtained by adding the accumu-
lator to a fixed base address.
                 LD     DE, BASE               ;GET BASE ADDRESS
                 LD     L,A                    ;EXTEND INDEX TO 16 BITS
                 LD     H,O
                 ADD    HL,DE                  ;CALCULATE INDEXED ADDRESS
                 LD     A, (HL>                ;FETCH DATA FROM INDEXED ADDRESS

   2. Load the accumulator from an indexed address obtained by adding the accumu-
lator to memory locations BASE and BASE+ 1.
                 LD     HL,(BASE)              ;GET BASE ADDRESS
                 LD     E,A                    ;EXTEND INDEX TO 16 BITS
                 LD     D,O
                 ADD    HL,DE                  ;CALCULATE INDEXED ADDRESS
                 LD     A, (HL>                ;FETCH DATA FROM INDEXED ADDRESS

  3. Load the accumulator from an indexed address obtained by adding memory
locations INDEX and INDEX+ I to register pair HL.
                 LD     DE, <INDEX)            ;GET INDEX FROM MEMORY
                 ADD    HL,DE                  ;CALCULATE INDEXED ADDRESS
                 LD     A, (HL>                ;FETCH DATA FROM INDEXED ADDRESS

  4. Jump indexed to a jump instruction in a list. The index is in the accumulator and
the base address of the list is in register pair HL.
                LD     B,A                     ;MULTIPLY INDEX TIMES 3
                ADD A,A
                ADD B,A
                LD     C,A                     ;EXTEND INDEX TO 16 BITS
                LD     B,O
                ADD HL,BC                      ;CALCULATE INDEXED ADDRESS
                JP     (HL>                    ;AND TRANSFER CONTROL THERE
The following is a typical list starting at   address BASE:
  BASE:         JP     SUBO                   ;JUMP TO SUBROUTINE 0
                JP     SUB1                   ;JUMP TO SUBROUTINE 1
                JP     SUB2                   ;JUMP TO SUBROUTINE 2

Since each JP instruction occupies three bytes, we must multiply the index by 3 before
adding it to the base address. If the list is more than 256 bytes long, we can use the
following procedure to multiply the index by 3:
                EX     DE,HL                   ;SAVE BASE ADDRESS IN DE
                LD     L,A                     ;EXTEND INDEX TO 16 BITS
                LD     H,O
                LD     B,L                     ;COPY INDEX INTO BC
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES             129
           LD    C,H
           ADD   HL,HL               ;DOUBLE INDEX
           ADD   HL,BC               ;TRIPLE INDEX
           ADD   HL,DE               ;CALCULATE INDEXED ADDRESS
           ,JP   (HU                 ;AND TRANSFER CONTROL THERE

   Autopreincrementing. In autopreincrementing, the address register is incre-
mented automatically before it is used. Autopreincrementing can be provided on the
Z80 by incrementing a register pair before using it as an address.

Examples
     Load the accumulator using autopreincrementing on register pair HL.
           INC   HL                  ;AUTOPREINCREMENT HL
           LD    A, (HU              ;FETCH DATA

     Store the accumulator using autopreincrementing on register pair DE.
           INC   DE                  ;AUTOPREINCREMENT DE
           LD    (DE), A             ;STORE DATA

     Load register pair DE starting at the address two larger than the contents of HL.
           INC   HL                  ;AUTOPREINCREMENT HL BY 2
           INC   HL
           LD    E, (HU              ;FETCH LSB
           INC   HL
           LD    D, (HU              ;FETCH MSB
   Autoincrementing by 2 is essential in handling arrays of addresses or 16-bit data
items .
  . Store the accumulator using autopreincrementing on memory locations ADDR
and ADDR+1.
           LD    HL, (ADDR)          ;AUTOPREINCREMENT INDIRECT ADDRESS
           INC   HL
           LD    (HU,A               ;STORE DATA
           LD    (ADDR),HL           ;UPDATE INDIRECT ADDRESS
 Autopreincrementing can be combined with indirection. Here memory locations
ADDR and ADDR + I could point to the last occupied location in a buffer.
   . Transfer control to the address stored starting at an address two larger than the
contents of memory locations NXTPGM and NXTPGM+ 1.
           LD    HL,(NXTPGM)         ;GET POINTER
           INC   HL                  ;AUTOPREINCREMENT POINTER
           INC   HL
           LD    (NXTPGM),HL         ;UPDATE POINTER
           LD    E, (HU              ;FETCH STARTING ADDRESS
           INC   HL
130     Z80 ASSEMBLY LANGUAGE SUBROUTINES


                LD       D, (HU
                EX       DE,HL          ;AND TRANSFER CONTROL TO IT
                ....IP   (HU

  Here NXTPGM and NXTPGM + I point to the starting address of the routine that
the processor has just executed. Initially, NXTPGM and NXTPGM + I would contain
BASE-2, where BASE is the starting address of a table of routines. A typical table
would be
   BASE:        DW       ROUTO          ;STARTING     ADDRESS   FOR   ROUTINE    0
                DW       ROUT 1         ;STARTING     ADDRESS   FOR   ROUTINE    1
                DW       ROUT2          ;STARTING     ADDRESS   FOR   ROUTINE    2
                DW       ROUT3          ;STARTING     ADDRESS   FOR   ROUTINE    3

    Autopostincrementing. In autopostfncrementing, the address register is incre-
mented after it is used. Autopostincrementing can be provided on the Z80 by
incrementing a register pair after using it as an address. Note that the Z80 autopostin-
crements the stack pointer when it executes POP and RET.


 Examples
    Load the accumulator using autopostincrementing on register pair HL.
                LD       A, (HU         ;FETCH DATA
                INC      HL             ;AUTOPOSTINCREMENT HL
    Store the accumulator using autopostincrementing on register pair DE.
               LD        <DE),A         ;STORE DATA
               INC       DE             ;AUTOPOSTINCREMENT DE
    Load register pair DE starting at the address in HL. Then increment HL by 2.
                LD       E,(HL)         ;FETCH LSB
                INC      HL
                LD       D,(HL)         ;FETCH MSB
                INC      HL
   Autoincrementing by 2 is essential in handling arrays of addresses or 16-bit data
items. Note that postincrementing is generally simpler and more natural than
preincrementing .
  . Store the accumulator using autopostincrementing on memory locations ADDR
and ADDR+l.
                LD       HL, (ADDR)     ;FETCH INDIRECT ADDRESS
                LD       (HL.l, A       ;STORE DATA
                INC      HL             ;AUTOPOSTINCREMENT INDIRECT ADDRESS
                LD       (ADDR), HL
   Autopostincrementing can be combined with indirection. Here memory locations
ADDR and ADDR+ 1 could point to the next empty location in a buffer.
CHAPTER 2 IMPLEMENTING ADDITIONAL INSTRUCTIONSANDADDRESSING MODES                131
  • Transfer control to the address stored at the address in memory locations
NXTPGM and NXTPGM+l. Then increment those locations by 2.
                LD    HL, (NXTPGM)
                LD    E, (HU             ,FETCH STARTING ADDRESS
                INC   HL
                LD    D, (HU
                INC   HL                 ,COMPLETE AUTOPOSTINCREMENT
                LD    (NXTPGM),HL
                EX    DE,HL              ,TRANSFER CONTROL TO START ADDRESS
                JP    (HU
  Here NXTPGM and NXTPGM+ 1 point to the starting address ofthe next routine
the processor is to execute. Initially, NXTPGM and NXTPGM+ 1 would contain
BASE, the starting address of a table of routines. A typical table would be
   BASE:        DW    ROUTO              ,STARTING    ADDRESS    FOR   ROUTINE   0
                DW    ROUTt              ,STARTING    ADDRESS    FOR   ROUTINE   1
                DW    ROUT2              ,STARTING    ADDRESS    FOR   ROUTINE   2
                DW    ROUT3              ,STARTING    ADDRESS    FOR   ROUTINE   3

    Autopredecrementing. In autopredecrementing, the address register is decre-
mented automatically before it is used. Autopredecrementing can be provided on the
Z80 processor by decrementing a register pair before using it as an address. Note that
the processor autopredecrements the stack pointer when it executes PUSH and
CALL.

Examples
    Load the accumulator using autopredecrementing on register pair HL.
              DEC HL                 ;AUTOPREDECREMENT HL
              LD   A, (HL)           ;FETCH DATA

    Store the accumulator using autopredecrementing on register pair DE.
               DEC    DE                 ;AUTOPREDECREMENT DE
               LD     (DE),A             ,STORE DATA
    Load register pair DE starting at the address two smaller than the contents of HL.
               DEC    HL                 ;FETCH MSB
               LD     D, (HU
               DEC    HL                 ,FETCH LSB
               LD     E, (HU
Autodecrementing by 2 is essential in handling arrays of addresses or 16-bit data
items. Note that predecrementing is generally simpler and more natural than
postdecrementing.
   . Store the accumulator using autopredecrementing on memory locations ADDR
and ADDR+l.
132     Z80 ASSEMBLY LANGUAGE SUBROUTINES


               LD    HL. (ADDR)          ,AUTOPREINCREMENT INDIRECT ADDRESS
               DEC   HL
               LD    (HU,A           ;STORE DATA
               LD    (ADDR),HL       ;UPDATE INDIRECT ADDRESS
Autodecrementing can be combined with indirection. Here memory locations ADDR
and ADDR+ I could point to the last occupied location in a stack.
   . Transfer control to the address stored at an address two smaller than the contents
of memory locations NXTPGM and NXTPGM+ 1.
               LD    HL.(NXTPGM)         ;FETCH STARTING ADDRESS
               DEC   HL
               LD    0, (HU
               DEC   HL
               LD    E. (HU
               LD    (NXTPGM),HL         ;STORE AUTOPREDECREMENTED POINTER
               EX    DE,HL               ;TRANSFER CONTROL TO START ADDRESS
               JP       (HU
Here NXTPGM and NXTPGM+ 1 point to the starting address of the most recently
executed routine in a list. Initially, NXTPGM and NXTPGM+ 1 would contain
FINAL+2, where FINAL is the address of the last entry in a table of routines. A
typical table would be
               OW       ROUTO            ;STARTINO ADDRESS FOR ROUTINE 0
               OW       ROUT!            ;STARTINO ADDRESS FOR ROUTINE 1


  FINAL:       OW       ROUTL            ;STARTINO ADDRESS FOR LAST ROUTINE
Here we work through the table backward. This approach is useful in evaluating
mathematical formulas entered from a keyboard. If, for example, the computer must
evaluate the expression
  Z   = LN   (A x SIN (B x EXP(C x      V»~)

it must work backward. That is, the order of operations is
      Calculate C x Y
      Calculate EXP (C x Y)
      Calculate B x EXP(C x Y)
      Calculate SIN (B x EXP(C x Y))
      Calculate A x SIN (B x EXP(C x Y))
      Calculate LN(A x SIN(B x EXP(C x Y))) .
Working backward is convenient when the computer cannot start a task until it has
received an entire line or command. It must then work back to the beginning.
CHAPTER 2. IMPLEMENTING ADDITIONAL INSTI<UCTIONSAND ADDRESSING MODES              133
  · Autopostdecrementing. In autopostdecrementing, the address register is decre-
mented automatically after it is used. Autopostdecrementing can be implemented on
the Z80 by decrementing a register pair after using it as an address.

Examples

    Load the accumulator using autopostdecrementing on register pair HL.
           LD    A, (HU               ;FETCH DATA
           DEC   HL                   ; AUTOF'OSTDECREMENT HL
    Store the accumulator using autopostdecrementing on register pair DE.
           LD     (DE), A             ;STORE DATA
           DEC    DE                  ;AUTOPOSTDECREMENT DE

    Load register pair DE starting at the address in HL. Afterward, decrement HL
by 2.
           INC   HL                   ; FETCH MSB
           LD    D, (HU
           DEC   HL                   ; FETCH LSB
           LD    E, (HU
           DEC   HL                   ; AUTOPOSTDECREMENT HL BY 2
           DEC   HL
Autodecrementing by 2 is essential in handling arrays of addresses or 16-bit data items.
  · Store the accumulator using autopostdecrementing on memory locations ADDR
and ADDR+1.
           LD     HL,(ADDR)           ;FETCH INDIRECT ADDRESS
           LD     (HU,A               ;STORE DATA
           DEC    HL                  ;AUTOPOSTDECREMENT INDIRECT ADDRESS
           LD     (ADDR.l,HL
 Autopostdecrementing can be combined with indirection. Here memory locations
ADDR and ADDR+ I could point to the next empty location in a buffer.
 · Transfer control to the address stored at the address in memory locations
NXTPGM and NXTPGM + 1. Then decrement those locations by 2.
           LD    HL,(NXTPGM)          ;FETCH POINTER
           INC   HL                   ;FETCH STARTING ADDRESS
           LD    D, (HU
           DEC   HL
           LD    E, (HU
           DEC   HL                   ;AUTOPOSTDECREMENT POINTER
           DEC   HL
           LD    (NXTPGM),HL
           EX    DE, HL               ; ,JUMP TO START! NG ADDRESS
           ,JP   (HU
  Here NXTPGM and NXTPGM+ I point to the starting address of the next routine
134     Z80 ASSEMBLY LANGUAGE SUBROUTINES


the processor is to execute. Initially, NXTPGM and NXTPGM+ 1 contain FINAL,
the address of the last entry in a table of routines. A typical table would be
                DW     ROUTO               ;STARTING ADDRESS OF ROUTINE 0
                DW     ROUT!               ;STARTING ADDRESS OF ROUTINE!


   FINAL:       DW     ROUTL               ;STARTING ADDRESS OF LAST ROUTINE
Here the computer works through the table backward. This approach is useful in
interpreting commands entered in the normalleft-to-right manner from a keyboard.
For example, assume that the operator of a process controller enters the command
SETTEMP(POSITION 2)= MEAN(TEMP(POSITION 1), TEMP(POSITION 3)).
The controller program must execute the command working right-to-Ieft and starting
from inside the inner parentheses as follows:
  1. Determine the index corresponding to POSITION 1.
  2. Obtain TEMP(POSITION 1) from a table of temperature readings.
  3. Determine the index corresponding to POSITION 3.
  4. Obtain TEMP(POSITION 3) from a table of temperature readings.
  5. Evaluate MEAN(TEMP(POSITION 1), TEMP(POSITION 3)) by executing
the MEAN program with the two entries as data.
  6. Determine the index corresponding to POSITION 2.
  7. Execute the SET function, which presumably involves setting controls and
parameters to achieve the desired value of TEMP (POSITION 2).
   The operator enters the command working left to right and from outer parentheses
to inner parentheses. The computer, on the other hand, must execute it inside out
(starting from the inner parentheses) and right to left. Autodecrementing is obviously
a handy way to implement this reversal.
  . Indirect preindexed addressing (preindexing). In preindexing, the processor
must first calculate an indexed address and then use that address indirectly. Since the
indexed table must consist of 2-byte indirect addresses, the indexing must involve a
multiplication by 2.

Examples
  . Load the accumulator using preindexing. The base address is in an index register
and the index is a constant INDEX.
                LD     L, (xy+2lonNDEX)            OBTAIN LSB OF ADDRESS
                LD     H,(xy+2*INDEX+!)            OBTAIN MSB OF ADDRESS
                LD     A, (HU                      OBTAIN DATA INDIRECTLY
CHAPTER 2: IMPLEMENTING ADDITIONAL INSTRUCTIONS AND ADDRESSING MODES           135
Because of the limitations of Z80 indexing, this approach works only when INDEX is a
constant.

  . Load the accumulator using preindexing. The base address is in register pair HL
and the index is in the accumulator.
          ADD    ArA                    ,DOUBLE INDEX FOR 2-BYTE ENTRIES
          LD     ErA                    ,EXTEND INDEX TO 16 BITS
          LD     DrO
          ADD    HLrDE                  ,CALCULATE INDEXED ADDRESS
          LD     Er (HU                 ,OBTAIN INDIRECT ADDRESS
          INC    HL
          LD     Dr (HU
          LD     Ar (DE)                ,OBTAIN DATA INDIRECTLY
  Store the accumulator using pre indexing. The base address is in memory locations
ADDR and ADDR+ I and the index is a constant INDEX.
          LD     XYr (ADDR)             ,OBTAIN BASE ADDRESS
          LD     Lr (xy+2*INDEX)        ,OBTAIN INDIRECT ADDRESS
          LD     Hr (xy+2*INDEX+l)
          LD     (HL)rA                 ,STORE DATA INDIRECTLY

  Store the accumulator using preindexing. The base address is in memory locations
ADDR and ADDR+l and the index is in memory location INDEX.
           LD    HLr(ADDR)              ,FETCH BASE ADDRESS
           LD    BrA                    ,SAVE DATA
           LD    Ar <INDEX)             ,FETCH INDEX
           ADD   ArA                    ;DOUBLE INDEX FOR 2-BYTE ENTRIES
           LD    ErA                    ,EXTEND INDEX TO 16 BITS
           LD    DrO
           ADD   HLrDE                  ,CALCULATE INDEXED ADDRESS
           LD    Er (HU                 ;OBTAIN INDIRECT ADDRESS
           INC   HL
           LD    Dr (HU
           EX    DErHL                  ,STORE DATA INDIRECTLY
           LD    (HUrB

    Transfer control (jump) to the address obtained indirectly from the table starting
at address JTAB. The index is in the accumulator.
          ADD    ArA                    ,DOUBLE INDEX FOR 2-BYTE ENTRIES
          LD     ErA                    ,EXTEND INDEX TO 16 BITS
          LD     DrO
          LD     HLrJTAB                ,OET BASE ADDRESS
          ADD    HLrDE                  ,CALCULATE INDEXED ADDRESS
          LD     Er (HU                 ,OBTAIN INDIRECT ADDRESS
          INC    HL
          LD     Dr (HU
          EX     DErHL                  ,JUMP TO INDIRECT ADDRESS
          JP     (HU
136     Z80 ASSEMBLY LANGUAGE SUBROUTINES


  The table starting at address JTAB would appear as follows:
  JTAB:         DW    ROUTO               ;STARTING ADDRESS OF ROUTINE 0
                DW    ROUT 1              ;STARTING ADDRESS OF ROUTINE 1
                DW    ROUT2               ;STARTING ADDRESS OF ROUTINE 2


    Indirect postindexed addressing (postindexing). In postindexing, the processor
must first obtain an indirect address and then apply indexing with that address as the
base. Thus the indirect address tells the processor where the table or array starts.


Examples
 . Load a register using postindexing. The base address is in memory locations
ADDR and ADDR+ I and the index is a constant OFFSET.
             LD     xy,(ADDR)          ;OBTAIN BASE ADDRESS INDIRECTLY
             LD     reg, (xy+OFFSET);OBTAIN DATA
  This approach is useful when AD DR and ADDR+ I contain the base address of a
data structure and OFFSET is the fixed distance from the base address to a particular
data item.
   . Load the accumulator using postindexing. The base address is in memory loca-
tions ADDR and ADDR+I and the index is in the accumulator.
                LD    HL,(ADDR)           ;OBTAIN BASE ADDRESS INDIRECTLY
                LD    E,A                 ;EXTEND INDEX TO 16 BITS
                LD    D,O
                ADD   HL,DE               ;CALCULATE INDEXED ADDRESS
                LD    A, (HU              ;OBTAIN DATA
  Store a register using postindexing. The base address is in memory locations
ADDR and ADDR+I and the index is a constant OFFSET.
                LD    xy,(ADDR)       ;OBTAIN BASE ADDRESS INDIRECTLY
                LD    (xy+OFFSET),reg;STORE DATA POSTINDEXED
     Store the accumulator using postindexing. The base address is in memory loca-
tions ADDR and ADDR+ I and the index is in memory location INDEX.
                LD    HL,(ADDR)           ;OBTAIN BASE ADDRESS INDIRECTLY
                LD    B,A                 ;SAVE DATA
                LD    A, (INDEX)          ;OBTAIN INDEX
                LD    E,A                 ;EXTEND INDEX TO 16 BITS
                LD    D,O
                ADD   HL,DE               ;CALCULATE INDEXED ADDRESS
                LD     (HU,B              ;STORE DATA
   By changing the contents of memory locations AD DR and ADDR+ I, we can make
this routine operate on many different arrays.
CHAPTER 2. IMPLEMENTING ADDITIONAL INSTRUCTIONSANDADDRESSING MODES                137

   . Transfer control Uump) to the address 0 btained by indexing from the base address
in memory locations ADDR and ADDR+ 1. The index is a constant OFFSET
                LD       x y. (ADDR)     ; OBTA I N BASE ADDRESS I ND I RECTL Y
                LD       L.(xy+OFFSET) ;OBTAIN LSB OF DESTINATION
                LD       H.(xy+OFFSET+l);OBTAIN MSB OF DESTINATION
                ....IP   (HU             ;JUMP TO DESTINATION
  This procedure is useful when a data structure contains the starting address of a
routine at a fixed offset. The routine could, for example, be a driver for an I/O control
block, an error routine for a mathematical function, or a control equation for a process
loop .
   . Transfer control Uump) to the address obtained by indexing from the base address
in memory locations ADDR and ADDR+ 1. The index is in the accumulator.
                LD       B.A               ;TRIPLE INDEX FOR 3-BYTE ENTRIES
                ADD      A.A
                ADD      A.B
                LD       E.A               ;EXTEND INDEX TO 16 BITS
                LD       D.O
                LD       HL.(ADDR)         ;OBTAIN BASE ADDRESS INDIRECTLY
                ADD      HL.DE             ; CALCULATE INDEXED ADDRESS
                ",IP     (HU               ;AND TRANSFER CONTROL TO IT
The table contains 3-byte JP instructions; a typical example is
  BASE:         JP       ROUTO             ; ",lUMP TO ROUTINE 0
                ",IP     ROUT1             ;JUMP TO ROUTINE 1
                ",IP     ROUT2             ; '-'LIMP TO ROUT I NE 2

The address BASE must be placed in memory locations ADDR and ADDR+ 1.

REFERENCES
  1. Fisher, W.P., "Microprocessor Assembly Language Draft Standard," IEEE
Computer, December 1979, pp. 96-lO9. (See also Distler, R.J. and M.A. Shaver, "Trial
Implementation Reveals Errors in IEEE Standard," IEEE Computer, July 1982,
pp.76-77.)
  2. Osborne, A., An Introduction to Microcomputers. Volume 1: Basic Concepts.
2nd ed. Berkeley, Calif.: Osborne/McGraw-Hill, 1980.
  3. Leventhal, L.A., 8080A/8085 Assembly Language Programming. Berkeley,
Calif.: Osborne/McGraw-Hill, 1978.
  4. Fischer, op. cit.
Chopter3 Common Programming
                         Errors




   This chapter describes common errors in Z80 assembly language programs. The
final section describes common errors in input/ output drivers and interrupt service
routines. Our aims here are the following:
    To warn programmers of potential trouble spots and sources of confusion.
    To describe likely causes of programming errors.
    To emphasize the techniques and warnings presented in Chapters I and 2.
    To inform maintenance programmers of likely places to look for errors and
    misinterpretations.
    To provide the beginner with a starting point in the difficult process of locating
    and correcting errors.
   Of course, no list of errors can be complete. Only the most common errors are
emphasized - not the infrequent or subtle errors that frustrate even the experienced
programmer. However, most errors are remarkably obvious once uncovered, and this
discussion should help in debugging most programs.




CATEGORIZATION OF PROGRAMMING ERRORS
  Common Z80 programming errors can be divided into the following categories:
  . Reversing the order of operands or parts of operands. Typical errors include
reversing source and destination in load instructions, inverting the format in which
16-bit quantities are stored, and inverting the direction of subtractions or comparisons.

                                                                                  139
140     Z80 ASSEMBLY LANGUAGE SUBROUTINES


  · Using the flags improperly. Typical errors include using the wrong flag (such as
Sign instead of Carry), branching after instructions that do not affect a particular flag,
inverting branch conditions (particularly those involving the Zero flag), branching
incorrectly in equality cases, and changing a flag accidentally before branching.
  · Confusing registers and register pairs. A typical error is operating on a register
instead of on a register pair.
  • Confusing addresses and data. The most common error is omitting the paren-
theses around an address and hence accidentally using immediate addressing instead
of direct addressing. Another error is confusing registers or register pairs with the
memory locations addressed via register pairs.
  • Using the wrong formats. Typical errors include using BCD (decimal) instead of
binary, or vice versa, and using binary or hexadecimal instead of ASCII.
  · Handling arrays incorrectly. The usual problem is going outside the array's
boundaries.
   · Ignoring implicit effects. Typical errors include using the accumulator, a register
pair, the stack pointer, flags, or memory locations without considering the effects of
intervening instructions. Most errors arise from instructions that have unexpected,
implicit, or indirect effects.
   · Failing to provide proper initial conditions for routines or for the microcomputer
as a whole. Most routines require the initialization of counters, indirect addresses, base
addresses, registers, flags, and temporary storage locations. The microcomputer as a
whole requires the initialization ofthe interrupt system and all global RAM addresses.
(Note particularly indirect addresses and counters.)
  · Organizing the program incorrectly. Typical errors include skipping or repeating
initialization routines, failing to update counters or address registers, and forgetting to
save intermediate or final results.

  A common source of errors that is beyond the scope of this discussion is conflict
between user programs and systems programs. A simple example of conflict is for a
user program to save data in memory locations that a systems program also uses. The
user program's data thus changes mysteriously whenever the systems program is
executed.
  More complex sources of conflict include the interrupt system, input/ output ports,
the stack, and the flags. After all, systems programs must employ the same resources as
user programs. Systems programs generally attempt to save and restore the user's
environment, but they often have subtle or unexpected effects. Making an operating
system transparent to the user is a pro blem comparable to devising a set of regulations,
laws, or tax codes that have no loopholes or side effects.
                                CHAPTER 3 COMMON PROGRAMMING ERRORS                    141

REVERSING THE ORDER OF OPERANDS

  The following instructions and conventions are the most common sources of errors:
  · The LD D,S instruction moves the contents of S to D. Reversing the source and
the destination in LD instructions is probably the single most common error in Z80
assembly language programs. The best way to avoid this problem is to use the operator
notation described by Duncan. l
  · 16-bit addresses and data items are assumed to be stored with their less significant
bytes first (that is, at the lower address). This convention becomes particularly confus-
ing in instructions that load or store register pairs or use the stack.
  · The CP instruction subtracts its operand from the accumulator, not the other way
around. Thus, CP sets the flags as if the processor had calculated (A) - OPER, where
OPER is the operand specified in the instruction.

Examples
  1. LD A,B
  This instruction loads the accumulator from register B. Since it does not change B,
the instruction acts like "copy B into A."

  2. LD (HL),A
  This instruction stores the accumulator at the memory address in register pair HL.
Since it does not change the accumulator, the instruction acts like "copy A into
memory addressed by HL."

  3. LD (2040H),A
  The address 204016 occupies the two bytes of program memory immediately follow-
ing the operation code; 4016 comes first and 2016 last. This order is particularly
important to remember when entering or changing an address at the object code level
during debugging.

  4. PUSHHL
   This instruction stores register pair HL in memory at the addresses immediately
below the initial contents of the stack pointer (that is, at addresses S-l and S-2 if S is the
initial contents of the stack pointer). Register H is stored at address S-l and L at S-2 in
the usual upside-down format.

  5. LD HL,(2050H)
  This instruction loads register L from memory address 205016 and H from 205116.
142     Z80 ASSEMBLY LANGUAGE SUBROUTINES


  6. LD (3600H),HL
  This instruction stores register L at memory address 360016 and H at address 360116.

  7. CPB
  This instruction sets the flags as if register B had been subtracted from the
accumulator.

  8. CP25H
  This instruction sets the flags as if the number 2516 had been subtracted from the
accumulator.


USING THE FLAGS INCORRECTLY
  Z80 instructions have widely varying effects on the flags. There are few general rules,
and even instructions with similar meanings may work differently. Cases that require
special' caution are
  · Data transfer instructions such as LD and EX (except EX AF, AF') do not affect
any flags. You may need an otherwise superfluous arithmetic or logical instruction
(such as AND A, DEC, INC, or OR A) to set the flags.
  · The Carry flag acts as a borrow after CP, SBC, or SUB instructions; that is, the
Carry is set if the 8-bit unsigned subtraction requires a borrow. If, however, you
implement subtraction by adding the two's or ten's complement of the subtrahend, the
Carry is an inverted borrow; that is, the Carry is cleared if the 8-bit unsigned
subtraction requires a borrow and set if it does not.
   • After a comparison (CP), the Zero flag indicates whether the operands are equal; it
is set if they are equal and cleared if they are not. There is an obvious source of
confusion here - JZ means "j urn p if the result is 0, " that is, "jump ifthe Zero flag is 1. "
JNZ, of course, has the opposite meaning.
   · When comparing unsigned numbers, the Carry flag indicates which number is
larger. CP sets Carry if the accumulator is less than the other operand and clears it if the
accumulator is greater than or equal to the other operand. Note that the Carry is
cleared if the operands are equal. If this division of cases ("greater than or equal" and
"less than'') is not what you want (that is, you wantthe division to be "greater than" and
"less than or equal''), you can reverse the subtraction, subtract 1 from the accumulator,
or add 1 to the other operand.
  · In comparing signed numbers, the Sign flag indicates which operand is larger
unless two's complement overflow occurs (see Chapter 1). CP sets the Sign flag ifthe
accumulator is less than the other operand and clears it if the accumulator is greater
                                CHAPTER 3 COMMON PROGRAMMING ERRORS                   143
than or equal to the other operand. Note that comparing equal operands clears the
Sign flag. As with the unsigned numbers, you can handle the equality case in the
opposite way by adjusting either operand or by reversing the subtraction. If overflow
occurs (signified by the setting of the Parity / Overflow flag), the sense ofthe Sign flag is
inverted.
   · All logical instructions except CPL clear the Carry flag. AND A or OR A is, in
fact, a quick, simple way to clear Carry without affecting any registers. CPL affects no
flags at all (XOR OFFH is an equivalent instruction that affects the flags).
   · The common way to execute code only if a condition is true is to branch around it
if the condition is false. For example, to increment register B if Carry is I, use the
sequence
                          ,-IR  NC, NEXT
                           INC B
           NEXT:          NOP
The branch occurs if Carry is O.
  · Many 16-bit arithmetic instructions have little effect on the flags. INC and DEC do
not affect any flags when applied to register pairs or index registers; ADD HL and
ADD xy affect only the Carry flag. The limited effects on the flags show that these
instructions are intended for address arithmetic, not for the processing of 16-bit data.
Note, however, that ADC HL and SBC HL affect all the flags and can be used for
ordinary processing of 16-bit data.
   · INC and DEC do not affect the Carry flag. This allows them to be used for
counting in loops that perform multiple byte arithmetic. (The Carry is needed to
transfer carries or borrows between bytes.) The 8-bit versions of INC and DBC do,
however, affect the Zero and Sign flags, and you can use those effects to determine
whether a carry or borrow occurred.
   · The special instructions RLCA, RLA, RRCA, and RRA affect only the Carry
flag.
  · Special-purpose arithmetic and logical instructions such as ADD A,A (logical left
shift accumulator), ADC A,A (rotate left accumulator), SUB A (clear accumulator),
and AND A or OR A (test accumulator) affect all the flags.
  · PUSH and POP instructions do not affect the flags, except for POP AF which
changes all the flags. Remember, AF consists of the accumulator (MSB) and the flags
(LSB).

Examples
  1. The sequence
           LD      A, (2040H)
           JR      Z,DONE
144      Z80 ASSEMBLY LANGUAGE SUBROUTINES


has unpredictable results, since LD does not affect the flags. To produce a jump if
memory location 204016 contains 0, use
            LD    A.(2040H)
            AND   A                   JTEST ACCUMULATOR
            JR    Z.DONE
OR A may be used instead of AND A.
     2. The sequence
            LD    A.E
            .JP   p. DEST
has unpredictable results, since LD does not affect the flags. Either of the following
sequences forces a jump if register E is positive:
           LD     A.E
           AND    A
           .JP    P.DEST
or
            SUB   A
            OR    E
            JP    P.DEST
     3. The instruction CP 25H sets the Carry flag as follows:
       • Carry = I if the contents of A are between 00 and 2416.
       . Carry = 0 if the contents of A are between 2516 and FF 16.
  The Carry flag is set if A contains an unsigned number less than the other operand
and is cleared if A contains an unsigned number greater than or equal to the other
operand.
  If you want to set Carry if the accumulator contains 2516, use CP 26H instead ofCP
25H. That is, we have
          CP    25H
          JR    C.LESS                JBRANCH IF (A) LESS THAN 25
or
            CP    26H
            JR    C.LESSEQ            JBRANCH IF (A) 25 OR LESS
     4. the sequence
         RLA
         JP    P.DONE
has unpredictable results, since RLA does not affect the Sign flag. The correct
sequence (producing a circular shift that affects the flags) is
            ADC   A.A                 ;SHIFT CIRCULAR. SETTING FLAGS
            .JP   P. DONE
                              CHAPTER 3 COMMON PROGRAMMING ERRORS                145
Of course, you can also use the somewhat slower
           RLA
           RLA
           JR     C,DONE
This approach allows a relative branch.
  5. The sequence
           INC   B
           JR    C,OVRFLW
has unpredictable results, since INC does not affect the Carry flag. The correct
sequence is
          INC    B
          JR     Z,OVRFLW
since INC does affect the Zero flag when it is applied to an 8-bit operand.
  6. The sequence
           DEC    B
           JR     C,OVRFLW
has unpredictable results, since DEC does not affect the Carry flag. If B cannot contain
a number larger than 8016 (unsigned), you can use
           DEC   B
           JP    M,OVRFLW
since DEC does affect the Sign flag (when applied to an 8-bit operand). Note, however,
that you will get an erroneous branch if B initially contains 8116.
   A longer but more general sequence is
          INC    B                     ,TEST REGISTER B
          DEC    B
          JR     Z,OVRFLW              ,BRANCH IF B CONTAINS ZERO
          DEC    B
Note that register B will contain 0 (not FF16) if the program branches to address
OVRFLW.
  7. The sequence
          DEC    BC
          JR     NZ,LOOP
has unpredictable results, since DEC does not affect any flags when it is applied to a
16-bit operand. The correct sequence for decrementing and testing a 16-bit counter in
register pair BC is
          DEC    BC
          LD     A,C                   ,CHECK IF BC HAS ANY 1 BITS
          OR     B
          JR     NZ,LOOP               ,BC CANNOT BE ZERO IF ANY BITS ARE 1
146     Z80 ASSEMBLY LANGUAGE SUBROUTINES


This sequence affects the accumulator and all the flags, including Carry (which OR
clears).

  8. AND A or OR A clears Carry without affecting any registers. To clear Carry
without affecting the other flags, use the sequence
         SCF                          :FIRST SET THE CARRY FLAG
         CCF                          :THEN CLEAR IT BY COMPLEMENTING

   9. SUB A or XOR A clears the accumulator, the Carry flag, and the Sign flag (and
sets the Zero flag). To clear the accumulator without affecting the flags, use LD A,O.

  10. The sequence
          ADD    HL,DE
          JR     Z,BNDRY
has unpredictable results, since ADD HL does not affect the Zero flag. To force a
branch if the sum is 0, you must test HL explicitly as follows:
          ADD   HL,DE
          LD    A,H                   :TEST HAND L FOR ZERO
          OR    L
          JR    Z,BNDRY
An alternative is
          AND   A                    :CLEAR CARRY
          ADC   HL,DE
          JR    Z,BNDRY
Unlike ADD HL, ADC HL affects the Zero flag.



CONFUSING REGISTERS AND REGISTER PAIRS
  The rules to remember are
  · ADC, ADD, DEC, INC, LD, and SBC can be applied to either 8-bit operands or
16-bit register pairs. ADD, DEC, INC, and LD can also be applied to index registers.
    AND, OR, SUB, and XOR can only be applied to 8-bit operands.
  · EX, POP, and PUSH can only be applied to register pairs or index registers.
  · (rp) refers to the byte of memory located at the address in the register pair. It does
not refer to either half of the register pair itself.
  One common error is that of referring to H or L instead of (HL). The use of register
pairs to hold addresses means that certain transfers are uncommon. For example, LD
                               CHAPTER 3 COMMON PROGRAMMING ERRORS                  147
L,(HL) would load register L from the address in HL; HL would then contain one byte
of an address (in H) and one byte of data (in L). While this is legal, it is seldom useful.


Examples
  1. LD A,H
  This instruction moves register H to the accumulator. lt does not change register H
or any memory location.

  2. LD A,(BC)
   This instruction loads the accumulator from the memory address in register pair BC.
lt does not affect either register B or register C.

  3. LD H,O
  This instruction places 0 in register H. It does not affect memory.

  4. LD(HL),A
  This instruction stores the accumulator in the memory location addressed by
register pair HL. It does not affect either H or L. A sequence that loads HL with an
address indirectly is

           LD     E. (HU                 ;GET LSB OF INDIRECT ADDRESS
           INC    HL
           LD     D. (HU                 ;GET MSB OF INDIRECT ADDRESS
           EX     DE.HL                  ;PUT INDIRECT ADDRESS IN HL
We may limit ourselves to a single temporary register (the accumulator) by loading the
more significant byte directly into H as follows:
           LD     A. (HU                 ;GET LSB OF INDIRECT ADDRESS
           INC    HL
           LD     H. (HU                 ;GET MSB OF INDIRECT ADDRESS
           LD     L.A                    ;MOVE LSB OF ADDRESS TO L

This takes the same number of clock cycles as the previous sequence, but uses A instead
of DE for temporary storage.
  5. LD HL,2050H
  This instruction loads 205016 into register pair HL (2016 into Hand 5016 into L).

  6. ADD A,(HL)
  This instruction adds the memory byte addressed via register pair HL to the
accumulator. It does not affect either H or L.
148     Z80 ASSEMBLY LANGUAGE SUBROUTINES


  7. ADDHL,HL
  This instruction adds register pair HL to itself, thus shifting HL left 1 bit logically.
This instruction does not affect the accumulator or access data from memory.




CONFUSING ADDRESSES AND DATA
  The rules to remember are
  · LD requires an address when you want to move data to or from memory. That
address must be placed in parentheses.
   · The standard assembler treats all operands as data unless they are enclosed in
parentheses. Thus, if you omit the parentheses around an address, the assembler will
treat it as a data item.
  • DJNZ, JP, JR, and CALL always require addresses.
  There is some confusion with addressing terminology in jump instructions. These
instructions essentially treat their operands as if one level of indirection had been
removed. For example, we say that JP 2040H uses direct addressing, yet we do not
place the address in parentheses. Furthermore, JP 2040H loads 204016 into the
program counter, much as LD HL,2040H loads 204016 into register pair HL. LD
HL,(2040H) loads the contents of memory locations 204016 and 204116 into register
pair HL. Note also that JP (HL) loads HL into the program counter; it does not use
HL indirectly or access the memory at all.

Examples
  1. LD A,40H loads the number 4016 into the accumulator. LD A,(40H) loads the
contents of memory location 004016 into the accumulator.
  2. LD HL,OCOOH loads OC0016 into register pair HL (OCI6 into Hand 0016 into L).
LD HL,(OCOOH) loads the contents of memory locations OC0016 and OCOl16 into
register pair HL (the contents of OCOO16 into L and the contents of OCOl16 into H).
  3. JP (xy) transfers control to the address in an index register. No indexing is
performed, nor is the address used to access memory.
   Confusing addresses and their contents is a common error in handling data struc-
tures. For example, the queue of tasks to be executed by a piece of test equipment
might consist of a block of information for each task. That block might contain
    Starting address of the test routine
    Number of seconds for which the test is to run
                              CHAPTER 3 COMMON PROGRAMMING ERRORS                149
    Address in which the result is to be saved
    Upper and lower thresholds against which the result is to be compared
    Base address of the next block in the queue.
  Thus, the block contains data, direct addresses, and indirect addresses. Typical
errors that a programmer could make are
  · Transferring control to the memory locations containing the starting address of
the test routine, rather than to the actual starting address.
    Storing the result in the block rather than in the address specified in the block.
    Using a threshold as an address rather than as data.
    Assuming that the next block starts in the current block, rather than at the base
address given in the current block.
  Jump tables are another common source of errors. The following are alternative
implementations:
  · Form a table of jump instructions and transfer control to the correct element (for
example, to the third jump instruction).
  · Form a table of destination addresses and transfer control to the contents of the
correct element (for example, to the address in the third element).
   You will surely have problems if the processor uses jump instructions as addresses or
VIce versa.




FORMAT ERRORS
  The rules you should remember for the standard Z80 assembler are
  · An H at the end of a number indicates hexadecimal and a B indicates binary.
  · The default mode for numbers is decimal; that is, the assembler assumes all
numbers to be decimal unless they are specifically marked otherwise.
  · All operands are treated as data unless they are enclosed in parentheses. Operands
enclosed in parentheses are assumed to be memory addresses.
  · A hexadecimal number that starts with a letter digit (A, B, C, D, E, or F) must be
preceded by 0 (for example, OCFH instead of CFH) for the assembler to interpret it
correctly. Of course, the leading 0 does not affect the value of the number.
  · All arithmetic and logical operations are binary, except DAA, which corrects the
result of an 8-bit binary addition or subtraction to the proper BCD value.
150   Z80 ASSEMBLY LANGUAGE SUBROUTINES


  You should beware of the following common errors:
  • Omitting the H from a hexadecimal operand. The assembler will assume it to be
decimal if it contains no letter digits and to be a name if it starts with a letter. The
assembler will indicate an error only if it cannot interpret the operand as either a
decimal number or a name.
  · Omitting the B from a binary operand. The assembler will assume it to be decimal.
  · Confusing decimal (BCD) representations with binary representations. Remem-
ber, ten is not an integral power of two, so the binary and BCD representations are not
the same beyond nine. BCD constants must be designated as hexadecimal numbers,
not as decimal numbers.
  · Confusing binary or decimal representations with ASCII representations. An
ASCII input device produces ASCII characters and an ASCII output device responds
to ASCII characters.



Examples
  1. LD A,(2000)
  This instruction loads the accumulator from memory address 200010 (070016), not
address 200016. The assembler will not produce an error message, since 2000 is a valid
decimal number.

  2. AND 00000011
   This instruction logically ANDs the accumulator with the decimal number 11
(10112), not with the binary number 11 (310). The assembler will not produce an error
message, since 00000011 is a valid decimal number despite its unusual form.

  3. ADD A,40
  This instruction adds the number 4010 to the accumulator. Note that 4010 is not the
same as BCD 40, which is 4016; 4010 = 2816. The assembler will not produce an error
message, since 40 is a valid decimal number.

  4. LD A,3
   This instruction loads the accumulator with the number 3. If this value is now sent to
an ASCII output device, the device will respond as if it had received the character ETX
(0316), not the character 3 (3316). The correct version is
          LD                                 ;OET AN ASCII 3
                                 CHAPTER 3 COMMON PROGRAMMING ERRORS                  151

     If memory location 204016 contains a single digit, the sequence
            LD     A, (2040H)
            OUT c.DEVCE), A
will not print that digit on an ASCII output device. The correct sequence is
           LD     A, (2040H)           ;GET DECIMAL DIGIT
           ADD A, ~O·'                 ; AD,JUST TO ASCI I
           OUT <DEVCE), A
     If input port INDEV contains a single ASCII decimal digit, the sequence
              IN    A, <INDEV)
              LD     (2040H),A
will not store the actual digit in memory location 204016. Instead, it will store the
ASCII version, which is the actual digit plus 3016. The correct sequence is
             IN    A, <INDEV.I            ;GET ASCII DIGIT
             SUB    ·'0'                  ;AD,JUST TO DECIMAL
             LD     (2040H.I, A
  Performing decimal arithmetic on the Z80 is awkward, since a DAA instruction is
required after each 8-bit addition or subtraction. Chapter 6 contains programs for
decimal arithmetic operations. Since DAA does not work properly after DEC or INC,
the following sequences are necessary to perform decimal increment and decrement
by 1:
      Add 1 to the accumulator in decimal.
             ADD   A,1
             DAA
      Subtract 1 from the accumulator in decimal.
             SUB   1
             DAA
or
             ADD   A,99H
             DAA
In the second alternative, Carry is an inverted borrow.



HANDLING ARRAYS INCORRECTLY
   The most common problems here are executing an extra iteration or stopping one
short. Remember, memory locations BASE through BASE+ N contain N+ 1 bytes, not
N bytes. It is easy to forget the last entry or drop the first one. On the other hand, if you
have N entries, they will occupy memory locations BASE through BASE+ N-l; now it
is easy to find yourself working beyond the end of the array.
152    Z80 ASSEMBLY LANGUAGE SUBROUTINES


IMPLICIT EFFECTS
  Some implicit effects you should remember are
  · The clearing of Carry by all logical operations except CPL.
  · The moving of the interrupt flip-flop IFF2 to the Parity / Overflow flag by LD A,I
and LD A,R.
  · The use of the data at the address in HL by the digit rotations RRD and RLD.
  · The use of the memory address one larger than the specified one by LD
rp,(ADDR), LD (ADDR),rp, LD xy,(ADDR), and LD (ADDR),xy.
  · The changing of the stack pointer by POP, PUSH, CALL, RET, RET!, RETN,
and RST.
    The saving of the return address in the stack by CALL and RST.
    The decrementing of register B by DJNZ.
    The implicit effects on BC, DE, and HL of the block compare, input, move, and
output instructions.
   · The use of the Parity / Overflow flag by LDD, LDI, CPD, CPDR, CPI, and CPIR
to indicate whether the counter in BC has been decremented to O.


Examples

  1. AND OOOOllllB
  This instruction clears the Carry, as well as performing a logical operation.


  2. LD A,I
   This instruction not only loads the accumulator, but also moves the interrupt
flip-flop IFF2 to the Parity/Overflow flag. The interrupt status can then be saved
before the computer executes a routine that must run with interrupts disabled.


  3. RRD
  This instruction performs a 4-bit (digit) circular shift right involving the accumula-
tor and the memory location addressed by HL. The results are
  · The 4 least significant bits of A go into the 4 most significant bits of the memory
location.
   · The 4 most significant bits of the memory location go into its 4 least significant
bits.
                              CHAPTER 3 COMMON PROGRAMMING ERRORS                153
     The 4 least significant bits of the memory location go into the 4 least significant
bits of A.
  The result is thus a 4-bit right rotation ofthe 12-bit number made up of the 4 LSBs of
the accumulator and the memory byte.

  4. LD HL,(16EFH)
  This instruction loads register L from memory location 16EF 16 and H from memory
location 16F016. Note the implicit use of address 16F016.

  5. POPHL
  This instruction not only loads register pair HL from memory, but also increments
the stack pointer by 2.

  6. CALLSUBR
  This instruction not only transfers control to address SUBR, but it also saves the
address of the next sequential instruction in the stack. Furthermore, CALL decre-
ments the stack pointer by 2.

  7. DJNZ LOOP
  This instruction decrements register B and branches to address LOOP if the result is
not O. Note that register B is implied as the counter.

  8. LDD
  This instruction moves data from the address in HL to the address in DE. It also
decrements BC, DE, and HL by 1. The Parity/Overflow flag (not the Zero flag) is
cleared (not set) if BC is decremented to 0; the Parity/Overflow flag is set otherwise.

  9. CPIR
  This instruction compares the accumulator with the memory byte at the address in
HL. After the comparison, it increments HL by 1 and decrements BC by 1. It repeats
these operations until it decrements BC to 0 (indicated by the Parity/Overflow flag
being cleared) or until the comparison sets the Zero flag. Note that CPIR updates BC
and HL before it tests for an exit condition.

  10. OUTI
  This instruction transfers data from the memory address in HL to the output port in
C. It then decrements B (not BC) by 1 and increments HL by 1. OUTI sets the Zero flag
to 1 if it decrements BC to 0; it clears the Zero flag otherwise.
154    Z80 ASSEMBLY LANGUAGE SUBROUTINES


INITIALIZATION ERRORS
  Initialization routines must perform the following tasks, either for the microcom-
puter system as a whole or for particular routines:
  · Load all RAM locations with initial values. This includes indirect addresses and
other temporary storage. You cannot assume that a memory location contains 0 just
because you have not used it.
  · Load all registers and flags with initial values. Reset initializes the interrupt system
by disabling regular interrupts and selecting Mode O. The startup program for an
interrupt-driven system must set the interrupt mode (if it is not 0), initialize the stack
pointer, and load the interrupt vector register (in Mode 2).
   · Initialize all counters and indirect addresses. Pay particular attention to register
pairs that are used as address registers; you must initialize them before using instruc-
tions that refer to them indirectly.



ORGANIZING THE PROGRAM
INCORRECTLY
  The following problems are the most common:
   · Accidentally reinitializing a register, register pair, flag, memory location, counter,
or indirect address. Be sure that your branches do not result in the repetition of
initialization instructions.
  · Failing to update a counter, index register, address register, or indirect address. A
problem here may be a path that branches around the updating instructions or changes
values before executing those instructions.
  · Forgetting to save results. It is remarkably easy to calculate a result and then load
something else into the accumulator. Identifying this kind of error is frustrating and
time-consuming, since all the instructions that calculate the result work properly and
yet the result itself is being lost. For example, a branch may transfer control to an
instruction that writes over the result.
   · Forgetting to branch around instructions that should not be executed in a particu-
lar path. Remember, the computer will execute instructions consecutively unless told
to do otherwise. Thus, the computer may fall through to a section ofthe program that
you expect it to reach only via a branch. An unconditional jump instruction will force a
branch around the section that should not be executed.
                               CHAPTER 3 COMMON PROGRAMMING ERRORS                 155

ERROR RECOGNITION BY ASSEMBLERS

  Most assemblers will recognize some common errors immediately, such as
   · Undefined operation code (usually a misspelling or the omission of a colon after a
label).
    Undefined name (often a misspelling or an omitted definition).
    Illegal character (for example, a 2 in a binary number or a B in a decimal number).
    Illegal format (for example, an incorrect delimiter or the wrong operands).
    Illegal value (usually a number too large for 8 or 16 bits).
    Missing operand.
    Double definition (two different values assigned to one name).
    Illegal label (for example, a label attached to a pseUdo-operation that does not
allow a label).
  · Missing label (for example, on an EQU pseudo-operation that requires one).
  These errors are annoying but easy to correct. The only problem comes when an
error (such as omitting the semicolon from a comment line) confuses the assembler
completely and results in a series of meaningless error messages.
  There are, however, many simple errors that assemblers will not recognize. The
programmer should be aware that his or her program may contain such errors even if
the assembler does not report them. Typical examples are
   · Omitted lines. Obviously, the assembler cannot tell that you have omitted a line
completely unless it contains a label or definition that is used elsewhere. The easiest
lines to omit are ones that are repetitious or seem unnecessary. Typical repetitions are
series of shifts, branches, increments, or decrements. Instructions that often appear
unnecessary include AND A, DEC HL, INC HL, OR A, and SUB A.
  · Omitted designations. The assembler cannot tell if you meant an operand to be
hexadecimal or binary unless the omission results in an illegal character (such as C in a
decimal number). Otherwise, the assembler will assume all numbers to be decimal.
Problems occur with hexadecimal numbers that contain no letter digits (such as 44 or
2050) and with binary numbers (such as 00000110).
  · Omitted parentheses. The assembler cannot tell if you meant to refer to a memory
address unless omitting the parentheses results in an error. Many instructions, such as
LD A,(40H), INC (HL), DEC (HL), and LD HL,(2050H), are also valid without
parentheses.
  · Misspellings that are still valid. Typical examples are typing AND or ADC instead
of ADD, DI instead of EI, or D instead of E. Unless the misspelling is invalid, the
156     Z80 ASSEMBLY LANGUAGE SUBROUTINES


assembler has no way of sensing an error. Valid misspellings are often a problem if you
use names that look alike, such as XXX and XXXX, LI21 and LI12, or VARlI and
VARII.
   · Designating instructions as comments. If you place a semicolon at the start of an
instruction line, the assembler will treat the line as a comment. This can be a perplexing
error, since the line appears in the listing but is not assembled into code.
   Sometimes you can confuse an assembler by entering completely invalid instruc-
tions. An assembler may accept them simply because its developer never anticipated
such mistakes. The results can be unpredictable, much like the result of accidentally
entering your weight instead of your age or your telephone number instead of your
credit card number on a form. Some cases in which a Z80 assembler can go wrong are
  · If you specify a single register instead of a register pair. Some assemblers will
accept instructions like LD A,(L), ADD HL,D, or LD E,2040H. They will produce
meaningless object code without any indication of error.
  · If you enter an invalid digit, such as X in a decimal or hexadecimal number or 7 in
a binary number. Some assemblers will assign arbitrary values to such invalid digits.
  · If you enter an invalid operand such as 40H in RST, AF in LD, or SP in PUSH or
POP. Some assemblers will accept these and generate meaningless code.
  The assembler will only recognize errors that its developer anticipated. Pro-
grammers are often able to make mistakes the developer never imagined, much as
automobile drivers are often capable of getting into predicaments that no highway
engineer or traffic policeman ever thought possible. Note that only a line-by-line hand
checking of the program will find errors that the assembler does not recognize.



COMMON ERRORS IN I/O DRIVERS
   Since most errors in 110 drivers involve both hardware and software, they are
difficult to categorize. Some things you should watch for are
  · Confusing input ports and output ports. Input port 2016 and output port 2016 are
different in most systems. Even when the two ports are the same physically, it may still
be impossible to read back output data unless the port is latched and buffered.
  · Attempting to perform operations that are physically impossible. Reading data
from an output device (such as a display) or sending data to an input device (such as a
keyboard) makes no physical sense. However, accidentally using the wrong port
number will cause no assembly errors; the port, after all, exists and the assembler has
no way of knowing that certain operations cannot be performed on it. Similarly, a
program may attempt to save data in an unassigned address or in a ROM.
                              CHAPTER 3 COMMON PROGRAMMING ERRORS                 157
     Forgetting implicit hardware effects. At times, transferring data to or from a port
will change the status lines automatically (as in most PIa modes). Even reading or
writing the port while debugging a program will change status lines. When using
memory-mapped 1/0, be particularly careful of instructions like comparisons and BIT
that read a memory address even though they do not change any registers. Similarly,
instructions like BIT, RES, SET, DEC, INC, and shifts can both read and write a
memory address. Automatic port operations can save parts and simplify programs, but
you must remember how they work and when they occur.
  · Reading or writing without checking status. Many devices can only accept or
provide data when a status line indicates they are ready. Transferring data to or from
them at other times will have unpredictable results.
   · Ignoring the differences between input and output. Remember that an input device
normally starts out not ready - it has no data available although the computer is ready
to accept data. On the other hand, an output device normally starts out ready - that is,
it could accept data but the computer usually has none to send it. In many situations
(particularly when using PIOs), you may have to send a null character (something that
has no effect) to each output port just to change its state from ready to not ready
initially.
  · Failing to keep a copy of output data. Generally, you will not be able to read data
back from an output port. You must save a copy in memory ifit could be needed later to
repeat a transmission, change some bits, or restore interrupt status (the data could, for
example, be the current priority level).
  · Reading data before it is stable or while it is changing. Be sure that you understand
exactly when the data from the input device is guaranteed to be stable. In the case of
switches that may bounce, you may want to sample them twice (more than a debounc-
ingtime apart) before taking any action. In the case of keys that may bounce, you may
want to take action only when they are released rather than when they are pressed.
Acting on release also forces the operator to release the key rather than holding it
down. In the case of persistent data (such as in serial 1/0), you should center the
reception (that is, read the data near the centers of the pulses rather than at the edges
where the values may be changing).
  · Forgetting to reverse the polarity of data being transferred to or from devices that
operate in negative logic. Many simple 110 devices, such as switches and displays, use
negative logic; a logic 0 means that a switch is closed or a display is lit. Common
ten-position switches or dials also often produce data in negative logic, as do many
encoders. The solution is simple -complement the data using CPL after reading it or
before sending it.
  · Confusing actual 110 ports with registers that are inside 110 chips. Programmable
110 devices, such as the CTC, PIa, and SIO, typically have control or command
registers that determine how the device operates and status registers that reflect the
158     Z80 ASSEMBLY LANGUAGE SUBROUTINES


current state of the device or the transfer. These registers are inside the chips; they are
not connected to peripherals. Transferring data to or from these registers is not the
same as transferring data to or from actual 110 ports.
   · Using bidirectional ports improperly. Many devices, such as the PI~, have bidirec-
tional 110 ports that can be used either fot input or output. Normally, resetting the
computer makes these ports inputs in order to avoid initial transients, so the program
must explicitly change them to outputs if necessary. Be particularly careful of instruc-
tions that read bits or ports that are designated as outputs or that write into bits or
ports designated as inputs. The only way to determine what will happen is to read the
documentation for the specific device.
  · Forgetting to clear status after performing an 110 operation. Once the processor
has read data from a port or written data into a port, that port should revert to the not
ready state. Some I 10 devices change the status of their ports automatically after input
or output operations, but others either do not or they change status automatically only
after input. Leaving the status set can result in an endless loop or erratic operation.




COMMON ERRORS IN INTERRUPT
SERVICE ROUTINES
   Many errors that are related to interrupts involve both hardware and software. The
following are some of the more common mistakes:
  · Failing to reenable interrupts. The Z80 disables interrupts automatically after
accepting one, but does not reenable interrupts unless it executes EI.
  · Failing to save registers. The Z80 does not automatically save any registers except
the program counter, so any registers that the service routine uses must be saved
explicitly in the stack.
  · Saving or restoring registers in the wrong order. Registers must be restored in the
opposite order from that in which they were saved.
  · Enabling interrupts before initializing modes, priorities, the interrupt vector
register, or other parameters of the interrupt system.
   · Forgetting that the response to an interrupt includes saving the program counter
at the top of the stack. The return address will thus be on top of whatever else is in the
stack.
  · Not disabling the interrupt during multi-byte transfers or instruction sequences
that cannot be interrupted. In particular, watch for possible partial updating of data
(such as time) that a service routine may use.
                               CHAPTER 3 COMMON PROGRAMMING ERRORS                 159
   · Failing to reenable interrupts after a sequence that must be run with interrupts
disabled. One problem here is that interrupts should not be enabled afterward if they
were not enabled originally. This requirement is difficult to meet on the Z80 since its
interrupt enable is not directly readable. The only way to access the interrupt flip-flop
is by executing LD A,I or LD A,R; either instruction moves the interrupt flip-flop to
the Parity I Overflow flag.
   · Failing to clear the signal that caused the interrupt. The service routine must clear
the interrupt even if no 110 operations are necessary. For example, even when the
processor has no data to send to an interrupting output device, it must nonetheless
either clear or disable the interrupt. Otherwise, the processor will get caught in an
endless loop. Similarly, a real-time clock will typically require no servicing other than
an updating of time, but the service routine still must clear the clock interrupt. This
clearing may involve reading a timer register.
  · Failing to communicate with the main program. The main program will not know
that the interrupt has been serviced unless it is informed explicitly. The usual way to
inform the main program is to have the service routine change a flag. The main
program can tell from the flag's value whether the service routine has been executed.
This procedure works like a postal pairon raising a flag to indicate that there is mail to
be picked up. The letter carrier lowers the flag after picking up the mail. Note that this
simple procedure means that the main program must examine the flag often enough to
avoid missing changes in its value. Of course, the programmer can always provide a
buffer that can hold many data items.
  · Failing to save and restore priority. The priority of an interrupt is often held in a
write-only register or in a memory location. That priority must be saved just like a
CPU register and restored properly at the end of the service routine. If the priority
register is write-only, a copy of its contents must be saved in memory.


REFERENCES
  1. Duncan, F.G., "Level-Independent Notation for Microcomputer Programs,"
IEEE Micro, May 1981, pp. 47-52.
Introduction to the
Program Section



   The program section contains sets of assembly language subroutines for the Z80
microprocessor. Each subroutine is documented with an introductory section and
comments and is followed by at least one example of its use. The introductory material
contains the following information about the purpose of the routine: its procedure and
the registers that are used; the execution time, program size, and data memory
required for the routine; as well as special cases, entry conditions, and exit conditions.
   We have made each routine as general as possible. This is particularly difficult for
the inputl output (II 0) and interrupt service routines described in Chapters 10 and ll,
since these routines are always computer-dependent in practice. In such cases, we have
limited the computer-dependence to generalized input and output handlers and inter-
rupt managers. We have drawn specific examples from computers based on the CP 1M
operating system, but the general principles are applicable to other Z80-based com-
puters as well.
   In all routines, we have used the following parameter passing techniques:
  I. A single 8-bit parameter is passed in the accumulator. A second 8-bit parameter is
passed in register B, and a third in register C.
   2. A single 16-bit parameter is passed in register pair HL with the more significant
byte in H. A second 16-bit parameter is passed in register pair DE with the more
significant byte in D.
  3. Large numbers of parameters are passed in the stack, either directly or indirectly.
We assume that subroutines are entered via a CALL instruction that places the return
address at the top of the stack, and hence on top of the parameters.
  Where there has been a choice between execution time and memory usage, we have
generally chosen to minimize execution time. We have therefore avoided slowly
executing instructions such as stack transfers and instructions that use the index
registers, even when they would make programs shorter. However, we have used


                                                                                    161
162     Z80 ASSEMBLV LANGUAGE SUBROUTINES


relative jumps whenever possible rather than the slightly faster but longer absolute
jumps to make programs easier to relocate.
   We have also chosen the approach that minimizes the number of repetitive calcula-
tions. For example, in the case of array indexing, the number of bytes between the
starting addresses of elements differing only by one in a particular subscript (known as
the size of that subscript) depends only on the number of bytes per element and the
bounds of the array. Thus, the sizes of the various subscripts can be calculated as soon
as the bounds ofthe array are known; the sizes are therefore used as parameters for the
indexing routines, so that they need not be calculated each time a particular array is
indexed.
   As for execution time, we have specified it for most short routines. For longer
routines we have given an approximate execution time. The execution time of pro-
grams involving many branches will obviously depend on which path the computer
follows in a particular case. This is further complicated for the Z80 because condi-
tionaljump instructions themselves require different numbers of clock cycles depend-
ing on whether the branch is taken. Thus, a precise execution time is often impossible
to define. The documentation always contains at least one typical example showing an
approximate or maximum execution time.
   Although we have drawn examples from CP / M-based systems, we have not made
our routines compatible with the 8080 or 8085 processors. Readers who need routines
that can run on any of these processors should refer to the 8080/8085 version of this
book. We have considered the Z80 as an independent processor and have taken
advantage of such features as block moves, block compares, loop control instructions,
and relative jumps.
   Our philosophy on error indicators and special cases has been the following:

  l. Routines should provide an easily tested indicator (such as the Carry flag) of
whether any errors or exceptions have occurred.
   2. Trivial cases, such as no elements in an array or strings of zero length, should
result in immediate exits with minimal effect on the underlying data.
  3. Incorrectly specified data (such as a maximum string length of zero or an index
beyond the end of an array) should result in immediate exits with minimal effect on the
underlying data.
  4. The documentation should include a summary of errors and exceptions (under
the heading of "Special Cases").
  5. Exceptions that may actually be convenient for the user (such as deleting more
characters than could possibly be left in a string rather than counting the precise
number) should be handled in a reasonable way, but should still be indicated as errors.

  Obviously, no method of handling errors or exceptions can ever be completely
consistent or well-suited to all applications. And rather than assume that the user will
                                    INTRODUCTION TO THE PROGRAM SECTION     163
always provide data in the proper form, we believe a reasonable set of subroutines
must deal with this issue.
  The subroutines are listed as follows:
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************

*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************
*********************************************************************************************

Appendix A                               zao Instruction Set
                                         Summary




                                        MAIN REG SET                  ALTERNATE REG SET
                                            1\                                1\
                           /

                               ACCUMULATOR         FLAGS      ACCUMULATOR           FLAGS
                                    A                  F           A'                 F'




                                   H
                                    B


                                    0
                                                       C              B'


                                                                      0'


                                                                      H'
                                                                                     C'


                                                                                     E'


                                                                                     L'
                                                                                               }...,,"
                                                                                                PURPOSE
                                                                                                REGISTERS




                                                 INTERRUPT
                                                 VECTOR
                                                             I      MEMORY
                                                                    REFRESH
                                                 I                  R

                                                 INDEX REGISTER IX
                                                                                   SPECIAL
                                                                                   PURPOSE
                                                 INDEX REGISTER IV                 REGiSTERS

                                                 STACK POINTER SP


                                                 PROGRAM COUNTER PC
                                                                                                                  ":t:f-
                                                                                                                  o
                                                                                                                  02
~   ____________________________________________________________________________                             ~8
                                                                                                                  ~


Figure A-1. Z80 internal register organization

                                                                                                            433
434      Z80 ASSEMBLY LANGUAGE SUBROUTINES




                                  765432                   0




                                iJHERE:
                                                                                 u
                                                                                 ~
                                   C         CARRY FLAG                          r5
                                   N         ADD/SUBTRACT FLAG                   :3
                                 p/v         PARITY/OVERFLO~ FLAG                N
                                    H        HALF-CARRY FLAG                     ~
                                    z        ZERO FLAG                           :::~
                                    S        SIGN FLAG                           @
                                                                                 f-
                                    X        NOT USED                            :I:

                                                                                 ">-
                                                                                 ;:
    ______________________________________________________________________       "-
~
                                                                         ~
                                                                             8
Figure A-2. Organization of the Z80 flag register
                                                               APPENDIX A Z80 INSTRUCTION SET SUMMARY                  435

                  MASKABLE (INTI
                  MODE 0


                      PLACE INSTRUCTION ONTO DATA BUS DURING INTACK =           Mi· lORa LIKE 8080A

                  MODE 1


                      RESTART TO 38101 OR 56 10 ('RST 56')


                  MODE 2


                      USED BY Z80 PERIPHERALS




                  INTERRUPT




                                                      l·
                     SERVICE         LOW ORDER
                    ROUTINE                                               I REGISTER                 8·BIT VECTOR
                   STARTING ~                                             CONTENTS                   FROM PERIPHERAL
                    ADDRESS          HIGH ORDER
                       TABLE




                  NON MASKABLE (NMI)


                      RESTART TO 66 H OR 102 10


                  INTERRUPT ENABLE I DISABLE FLIP·FLOPS


                                               ACTION             IFF,   IFF2


                                               CPU RESET           0     0


                                               01                  0     0


                                               EI                  1     1


                                               LD A. I             ·                    IFF, - PARITY FLAG

                                                                                                                             u
                                               LD A. R
                                                                   · ·                  IFF, - PARITY FLAG
                                                                                                                             ~
                                                                                                                             g
                                               ACCEPT NMI          0
                                                                         ·                                                   ..J
                                                                                                                             N
                                               RETN               IFF2
                                                                         ·              IFf2 -IFF,                           ~
                                                                                                                             '"'~
                                               ACCEPT    iNT       0     0                                                   @
                                                                                                                             I-
                                                                                     :x:
                                               RETI
                                                                   ·                 o
                                                                                     iii
                                         " ••• INDICATES NO CHANGE
~__________________________________________________________________________________
                                                                                     ~
                                                                                    ~U
                                                                                                                             o

Rgure A-3. Z80 interrupt structure
436       Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A-1. Z80 Instructions in Alphabetical Order

  ADC HL, ss      Add with Carry Reg. pair ss to HL     CPL           Complement Acc. (1 's comp)

  ADC A, s        Add with carry operand s to Acc.      DAA           Decimal adjust Acc.

  ADD A, n        Add value n to Acc.                   DECm          Decrement operand m

  ADD A, r        Add Reg. r to Acc.                    DECIX         Decrement I X

  ADD A, (HL)     Add location (HL) to Ace.             DECIY         Decrement IY

  ADD A, /lX+d)   Add location /lX+d) to Acc.           DEC ss        Decrement Reg. pair ss

  ADD A, /lV+d)   Add location (lV+d) to Ace.           01            Disable interrupts

  ADD HL, ss      Add Reg. pair ss to HL                DJNZ e        Decrement B and Jump
                                                                      relative if BjO
  ADD IX, pp      Add Reg. pair pp to IX

  ADD IV. rr      Add Reg. pair rr to IV                EI            Enable interrupts

  AND s           Logical 'AND' of operand s and Ace.   EX (SP), HL   Exchange the location (SP) and H L

                                                        EX (SP), IX   Exchange the location (SP) and IX
  BIT b, (HL)     Test BIT b of location (HL)
                                                        EX (SP), IV   Exchange the location (SP) and IV
  BIT b, /lX+d)   Test BIT b of location /lX+d)
                                                        EX AF, AF'    Exchange the contents of AF
  BIT b, /lY+d)   Test BIT b of location /lV+d)                       and AF'

  BIT b, r        Test BIT b of Reg. r                  EX DE, HL     Exchange the contents of DE
                                                                      and HL

  CALL cc, nn     Call subroutine at location nn if     EXX           Exchange the contents of BC, DE,
                  condition cc if true                                HL with contents of BC', DE', HL'
                                                                      respectively
  CALL nn         Unconditional call subroutine at
                  location nn
                                                        HALT          HALT (wait for interrupt or resed
  CCF             Complement carry flag
                                                        IMO           Set interrupt mode 0
  CP s            Compare operand s with Acc.
                                                        1M 1          Set interrupt mode 1
   CPO            Compare location (HL) and Acc.
                  decrement HL and BC                   1M 2          Set interrupt mode 2

                                                        IN A, (n)     Load the- Acc. with input from       U
   CPDR            Compare location (HL) and Acc.                                                          ~
                   decrement HL and BC, repeat                        device n                             c:i
                                                                                                           0
                   until BC;O                                                                              ..J
                                                        IN r, (C)     Load the Reg. r with input from      N
                   Compare location (HL) and Acc.                     device (C)                           >-
   CPI
                   increment H L and decrement BC                                                          '":::::
                                                        INC (HL)      Increment location (HL)
  CPIR            Compare location (HL) and Acc.
                                                                                                           ..
                                                                                                           ~

                                                                                                           I-
                                                        INC IX        Increment IX                         ::c:
                  increment HL, decrement BC                                                               0
                  repeat until BC;O
                                                                                                           02
                                                        INC /lX+d)    Increment location /lX+d)            >-
                                                                                                           0-
                                                                                                           0
                                                                                                           U
                                                      APPENDIX A Z80 INSTRUCTION SET SUMMARY                 437

Table A·i. (Continued)

  INC IV         Increment IV                              LD A, (nn)      Load Acc. with location nn

                                                           LD A, R         Load Acc. with Reg. R
  INC (lV+d)     I ncrement location (I V+d)
                                                           LD (BC), A      Load location (BC) with Acc.
  INC r          Increment Reg. r
                                                           LD (DE), A      Load location (DE) with Acc.
  INC 55         Increment Reg. pair 55
                                                           LD (HL), n      Load location (H L) with value n
  IND           Load location (H L) with input
                from port (C), decrement HL                LD dd, nn       Load Reg. pair dd with value nn
                and B
                                                           LD HL, (nn)     Load HL with location (nn)
  INDR          Load location (H L) with input
                from port (C), decrement H Land            LD (HL), r      Load location (HL) with Reg. r
                decrement B, repeat until B=O
                                                           LDI,A           Load I with Acc.
  INI           Load location (HL) with input
                from port (C); and increment HL            LF IX, nn       Load IX with value nn
                and decrement B
                                                           LD IX, (nn)     Load IX with location (nn)
  INIR          Load location (HL) with input              LD (lX+d) , n   Load location (lX+d) with value n
                from port (C), increment HL
                and decrement B, repeat until              LD (lX+d) , r   Load location (I X+d) with Reg. r
                B=O
                                                           LD IV, nn       Load IV with value nn
  JP (HL)       Unconditional Jump to (HL)
                                                           LD IV, (nn)     Load IV with location (nn)
  JP (IX)       Unconditional Jump to (IX)
                                                           LD (lV+d), n    Load location (lV+d) with value n
  JP (IV)       Unconditonal Jump to (IV)
                                                           LD (lV+d), r    Load location (lV+d) with Reg. r
  JP cc, nn     Jump to location nn if
                                                           LD (nn), A      Load location (nn) with Acc.
                condition cc i5 true

  JP nn         Unconditional jump to location             LD (nn), dd     Load location (nn) with Reg. pair dd
                nn
                                                           LD (nn), HL     Load location (nn) with HL
  JP C, e       Jump relative to PC+e if carry=l
                                                           LD (nn), IX     Load location (nn) with IX
  JR e          Unconditional Jump relative
                                                           LD (nn),IV      Load location (nn) with IV
                to PC+e
                                                           LD R,A          Load R with Acc,
  JP NC, e      Jump relative to PC+e if carry=O                                                                   rj
                                                           LD r, (HL)      Load Reg, r with location (HL)          1S
  JR NZ, e      Jump relative to PC+e if non                                                                       c:5
                                                                                                                   0
                zero (Z=O)                                 LD r, (lX+d)    Load Reg. r with location (lX+d)        ..J
                                                                                                                   N
  JR Z, e       Jump relative to PC+e if zero (Z=l)                                                                >-
                                                           LD r, (lV+d)    Load Reg. r with location (lV+d)        '"<-<-
  LD A, (BC)    Load Acc. with location (BC)               LD r, n         Load Reg. r with value n                '"
                                                                                                                   @
                                                                                                                   f-
                                                                                                                   ;r.
  LD A, (DE)    Load Ace. with location (DE)               LD r, r'        Load Reg. r with Reg. r'                u
                                                                                                                   02
  LD A, I       Load Acc. with I                           LD SP, HL       Load SP with H L                        >-
                                                                                                                   "-
                                                                                                                   0
                                                                                                                   u
438      Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A·i. (Continued)

  LD SP,IX      Load SP with IX                        RES b, m        Reset Bit b of operand m
  lO SP,IV      Load SP with IV                        RET             Return from subroutine
  LDD           Load location (DE) with location       RET cc          Return from subroutine if condition
                (HL), decrement DE, HL and BC                          cc is true

  LDDR          Load location (DE) with location       RETI            Return from interrupt
                (HL), decrement DE, HL and BC;
                repeat until Be=O                      RETN            Return from non maskable interrupt

                                                       RL m            Rotate left through carry operand m
  lOl           Load location (DE) with location
                (HL), increment DE, HL,                RLA             Rotate left Ace. through carry
                decrement BC
                                                       RLC (HL)        Rotate location (HL) left circular
  LDIR          Load location (DE) with location
                (HL), increment DE, HL,                RLe (lX+d)      Rotate location (lX+d) left circular
                decrement BC and repeat until
                                                       RLe (lV+d)      Rotate location (lV+d) left circular
                Be=o

  NEG           Negate Ace. (2's complement)           RLC r           Rotate Reg. r left circular

  Nap           No operation                           RLCA            Rotate left circular Ace.

                                                       RLD             Rotate digit left and right between
  OR s          Logical 'OR' or operand s and Ace.                     Ace. and location (H L)
  OTDR          Load output port (C) with location
                (HL) decrement HL and B, repeat        RR m            Rotate right through carry operand m
                until B=O
                                                       RRA             Rotate right Ace. through carry
  OTIR          Load output port (C) with location
                (HL), increment HL, decrement B,       RRCm            Rotate operand m right circular
                repeat until B=O                       RRCA            Rotate right circular Ace.
  OUT (e), r     Load output port (e) with Reg. r
                                                       RRD             Rotate digit right and left between
  OUT (n), A     Load output port ( n) with Ace.                       Ace. and location (HL)
  OUTD           Load output port (e) with location    RST p           Restart to location p
                 (HL), decrement HL and B

  OUTI           Load output port (e) with location    SBC A, s        Subtract operand s from Ace. with
                 (HL), increment HL and decrement                      carry
                 B
                                                       SBC HL, ss      Subtract Reg. pair ss from H L with    0
  POP IX         Load IX with top of stack                             carry                                  1:
  POP IV         Load IV with top of stack             SCF             Set carry flag (C=l)                   "
                                                                                                              0
                                                                                                              ..J
                                                                                                              N
  POP qq         Load Reg. pair qq with top of stack   SET b, (HL)     Set Bit b of location (HL)             >-
                                                                                                              '""-"-
  PUSH IX        Load IX onto stack                    SET b, (lX+d)   Set Bit b of location (I X+d)          '"
                                                                                                              @
                                                                                                              f-
                                                                                                              ;I:
  PUSH IV        Load IV onto stack                    SET b, (IV+d)   Set Bit b of location (lV+d)
                                                                                                              '02>-"
  PUSH qq        Load Reg. pair qq onto stack          SET b, r        Set Bit b of Reg. r                    "-
                                                                                                              0
                                                                                                              u
                                                             APPENDIX A Z80 INSTRUCTION SET SUMMARV                439
Table A·i. (Continued)
                                                                                                                         o
r-----------------------------------------------------------------------------------,~
                                                                                                                         <.:i
                                                                                                                         o
                                                                                                                         ..J
                                                                                                                         N
    SLA m         Sh ift operand m left arithmetic               SUB s              Subtract operand s from Ace.         ;..

    SRAm          Shift operand m right arithmetic               XOR s              Exclusive 'OR' operand s and Ace.
                                                                                                                         '"
                                                                                                                         ~
                                                                                                                         ~

                                                                                                                         2:

    SRL m         Shift operand m right logical                                                                          ":t:f--
                                                                                       02
                                                                                       ;..
                                                                                                                         "
~   __________________________________________________________________________________~u
                                                                                       "-
                                                                                       o




Table A·2. Z80 Operation Codes in Numerical Order

    OBJECT CODE          INSTRUCTION              OBJECT CODE            INSTRUCTION

      00            NOP                              19              ADD       HL,DE
      01 VYYY       LD         Bc'data16             IA              LD        A.lDEI
      02            LD         (BCIA                 IB              DEC       DE
      03            INC        BC                    IC              INC       E
      04            INC        B                     ID              DEC       E
      05            DEC        B                     IE yy           LD        E.data
      06 yy         LD         B,data                IF              RRA
      07            RLCA                             20 dlsp-2       JR        NZ,dlsp
      08            EX         AFAF'                 21 yyyy         LD        HL.data 16
      09            ADD        HL,BC                 22 ppqq         LD        laddrl.HL
      OA            LD         A,(BCI                23              INC       HL
      OB            DEC        BC                    24              INC       H
      OC            INC        C                     25              DEC       H
      OD            DEC        C                     26 yy           LD        H,data
      OE yy         LD         C,data                27              DAA
      OF            RRCA                             28 dlsp-2       JR        Z,disp
      10 dlsp-2     DJNZ       dtsp                  29              ADD       HL,HL
      II yyyy       LD         DE,data16             2A ppqq         LD        HL,laddrl
      12            LD         (DEI.A                2B              DEC       HL
      13            INC        DE                    2C              INC       L
      14            INC        D                     2D              DEC       L
      15            DEC        D                     2E              LD        L,data
      16 yy         LD         D.data                2F              CPL
      17            RLA                              30 dlsp-2       JR        NC,dlsp
      18 dtsp-2     JR         dlsp                  31 yyyy         LD        SP,data16
440          Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A·2. (Continued)


 OBJECT CODE          INSTRUCTION        OBJECT CODE               INSTRUCTION

    32 ppqq          LD      laddriA    CB 0 Orn           RLC         reg
    33               INC     SP         CB 06              RLC         IHLI
    34               INC     IHLI       CB 0 1m            RRC         reg
    35               DEC     IHLI       CB OE              RRC         IHLI
    36 yy            LD      IHUdata    CB 1 Orrr          RL          reg
    37               SCF                CB 16              RL          IHLI
    38               JR      C,drsp     CB 1 lrrr          RR          reg
    39               ADD     HLSP       CB IE              RR          IHLI
    3A ppqq          LD      AJaddrl    CB 2 Om            SLA         reg
    3B               DEC     SP         CB 26              SLA         IHLI
    3C               INC     A          CB 2 lrrr          SRA         reg
    3D               DEC     A          CB 2E              SRA         IHLI
    3E yy            LD      Adata      CB 3 lrrr          SRL         reg
    3F               CCF                CB 3E              SRL         IHLI
    40sss            LD      B,reg      CB 01bbbrrr        BIT         b,reg
    46               LD      B,IHLI     CB 01bbbll0        BIT         b,IHLI
    4 lsss           LD      C,reg      CB lObbbrrr        RES         b.reg
    4E               LD      CIHLI      CB 10bbb 110       RES         b,IHLI
    50sss            LD      D,reg      CB l1bbbrrr        SET         b,reg
    56               LD      D,IHLI     CB llbbbllO        SET         b,IHLI
    5 lsss           LD      E,reg      CC ppqq            CALL        Z,addr
    5E               LD      E,IHLI     CD ppqq            CALL        addr
    60sss            LD      H,reg      CE yy              ADC         A,data
    66               LD      H,IHLI     CF                 RST         08H
    6 lsss           LD      L,reg      DO                 RET         NC
    6E               LD      UHLI       01                 POP         DE
    70sss            LD      IHLI,reg   02 ppqq            JP          NC,addr
    76               HALT               03 yy              OUT         IportlA
    7 lsss           LD      A,reg      04 ppqq            CALL        NC,addr
    7E               LD      A,IHLI     05                 PUSH        DE
    80rrr            ADD     Areg       06 yy              SUB         data
    86               ADD     A,IHLI     07                 RST          lOH
    8 lrrr           ADC     A,reg      08                 RET         C
    8E               ADC     A,IHLI     D9                 EXX
    gOm              SUB     reg        DA ppqq            JP          C,addr
    96               SUB     IHLI       DB yy              IN          A,lportl
    9 1m             SBC     A,reg      DC ppqq            CALL        C,addr
    9E               SBC     AIHLI      DO OOxx 9          ADD         IX,pp
    AOrrr            AND     reg        DO 21 yyyy         LD          IX-data 16
    A6               AND     IHLI       DO 22 ppqq         LD          laddrl.tX
    A lrrr           XOR     reg        DO 23              INC         IX
    AE               XOR     IHLI       DO 2A ppqq         LD           IX,laddrl
    BOm              OR      reg        DO 2B              DEC         IX
    B6               OR      IHLI       DO 34 dlsp         INC         OX + dlsp)
    B 1m             CP      reg        DO 35 rjlSP        DEC         IIX + dlspl
    BE               CP      IHLI       DO 31: dlsp YV     LD          OX + dlspl.data
    CO               RET      NZ        DO 01dddllO dlsp   LD           reg,OX + dlsp)
    Cl               POP      BC        DO 7 Osss dlsp     LD          (IX + dlsp).reg
    C2 ppqq          JP       NZ,addr   DO 86 dlsp         ADD          A,IIX + dlspl
    C3 ppqq          JP       addr      DO 8E dlsp         ADC          A,IIX + dlspl
    C4 ppqq          CALL     NZ,addr   DO 96 dlsp         SUB         (IX   + dtsp)
    C5               PUSH     BC        DO 9E dlsp         SBC          AIIX +dlspl
    C6 yy            ADD      A.data    DO A6 dlsp         Ar-lD       IIX + dlspl
    C7               RST      OOH       DO AE dlsp         XOR         IIX + dlspl
    C8               RET      Z         DO B6 dlsp         OR          IIX + dlspl
    C9               RET                DO BE dlsp         CP           (IX + dlSp)
    CA ppqq          JP       Z,addr    DO CB dlsp 06      RLC          IIX + dlspl
                                                                    APPENDIX A Z80 INSTRUCTION SET SUMMARY   441
Table A·2. (Continued)

   OBJECT CODE                 INSTRUCTION                  OBJECT CODE            INSTRUCTION

  DO CB dlsp DE         RRC         IIX    + dlsp)     ED BS                 LDDR
  DO CB dlsp 16         RL          (IX + dlspl        ED B9                 CPDR
  DO CB disP lE         RR          (IX + dlsp)        ED BA                 IN DR
  DO CB dlsp 26         SLA         (IX + dlsp)        ED BB                 OTDR
  DO CB dlsp 2E         SRA         (IX + dlsp)        EE yy                 XOR        data
  DO CB dlsp 3E         SRL         (IX +dlspl         EF                    RST        2SH
  DO CB dlsp 01bbb110   BIT         b.IIX    + dlsp)   FO                    RET        P
  DO CB dlsp lObbb110   RES         b,(1X + dlsp)      F1                    POP        AF
  DO CB dlsp 11bbb110   SET         b.OX + dlsp)       F2 PPQQ               jp         P.addr
  DO E1                 PDP         IX                 F3                    01
  DO E3                 EX          (SP).IX            F4 PPQQ               CALL       P,addr
  DO E5                 PUSH        IX                 F5                    PUSH       AF
  DD E9                 jp          IIX)               F6 YV                 OR         data
  DD F9                 LD          SP.IX              F7                    RST        30H
  DE yy                 SBC         A.data             FS                    RET        M
  DF                    RST         1SH                F9                    LD         SP.HL
  EO                    RET         PO                 FA PPQQ               jp         M.addr
  E1                    POP         HL                 FB                    EI
  E2 PPQQ               jp          PO,addr            FC PPQQ               CALL       M,addr
  E3                    EX          (SP).HL            FD OOxx 9             ADD        IY,n
  E4 PPQQ               CALL        PO.addr            FD 21 yyyy            LD         IY,data16
  E5                    PUSH        HL                 FD 22 PPQQ            LD         (addrl.IY
  E6 yy                 AND         data               FD 23                 INC        IY
  E7                    RST         20H                FD 2A ppqQ            LD         IY.laddri
  ES                    RET         PE                 FD 2B                 DEC        IY
  E9                    jp          (HLI               FO 34 dlsp            INC        (ly + dlsp)
  EA PPQQ               jp          PE,addr            FO 35 dlsp            DEC        (IV + dlsp)
  EB                    EX          DE.HL              FD 36 dlsp YY         LD         (ly + dlsp),data
 EC PPQQ                CALL        PE,addr            FD 01ddd110 dlsp      LD         reg.OY + dlsp)
 ED 01dddOOO            IN          reg.(C)            FD 7 Osss dlsp        LD         (ly + dlsp},reg
 ED 01555001            OUT         (Cl.reg            FO 86 dlsp            ADD        A.OY + dlsp)
 EDOlxx 2               SBC         HL,rp              FD BE dlsp            ADC        A,(lY + dlsp)
 EDOlxx 3 ppqQ          LD          (addrl,rp          FD 96 dlsp            SUB        (IV + dlsp)
 ED 44                  NEG                            FD 9E dlsp            SBC        A.IIY + dlsp)
 ED 45                  RETN                           FD A6 dlsp            AND        (IV   + dlsp)
 ED 01Onn110            1M          m                  FD AE dlsp            XOR        (lY + dlsp)
 ED 47                  LD          I.A                FD B6 dlsp            OR        (lY + dlSp)
 ED 01xx-ll             ADC         HL,rp              Fa BE dlsp            CP        IIY + dlsp)
 ED 01xx B ppqq         LD          rp,(addr)          FD CB dlSP 06         RLC       (IY + dlsp)
 ED 4D                  RETI                           FD CB dlsp OE         RRC       (ly + dlsp)
 ED 4F                  LD          R.A                FD CB dlsp 16         RL        (lY + dlsp)
 ED 57                  LD          A.I                FD CB dlsp 1E         RR        IIY + dlsp)
 ED 5F                  LD          A.R                FD CB dlSP 26         SLA       (lY + dtsp)
 ED 67                  RRD                            FD CB dlsp 2E         SRA       (lY + dtspl
 ED 6F                  RLD                            FD CB dlsp 3E         SRL       (lY + dlsp)
 ED AO                  LDI                            FD CB dtsp 01bbb110   BIT       b,OY + dlsp)
 ED A1                  CPI                            FD CB dlsp lObbb110   RES       b.IIY + dlsp)
 ED A2                  INI                            FD CB dlsp 11bbb11O   SET       b,(lY + dtsp)
 ED A3                  OUTI                           FD E1                 POP       IY
 ED AS                  LDD                            FD E3                 EX        (SP).IY
 ED A9                  CPD                            FD E5                 PUSH      IY
 ED AA                  IND                            FD E9                 jp        (ly)
 ED AB                  OUTD                           FD F9                 LD        SP.IY
 ED 80                  LDIR                           FE vv                 CP        data
 ED 81                  CPIR                           FF                    RST       3SH
 ED B2                  INIR
 ED B3                  OTIR
442     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A-3. Z80 8-Bit Load Instructions

                                                            Flags               OP-Code         No.       No.      No.
                                 Symbolic                                                       of        orM      ofT
            Mnemonic             Operation        C Z P/V      s    N H 76 543 210              Byte,     Cycles   Cycles   Comments
            LD r, r'
            LD   I, n
                                 r+--c'
                                 r~n                ·· ·· ·· ·· ·· ··      01
                                                                           00
                                                                           ~
                                                                               r
                                                                               r
                                                                               n
                                                                                      110
                                                                                          r'

                                                                                          ~
                                                                                                I
                                                                                                2
                                                                                                          I
                                                                                                          2
                                                                                                                   4
                                                                                                                   7
                                                                                                                            r, r'
                                                                                                                            000
                                                                                                                            001
                                                                                                                                    Reg.
                                                                                                                                     B
                                                                                                                                     C
            LDr, (HL)
            LD r, (lX+d)
                                 r~(HL)

                                 r~(IX+d)         ·· ·· ·· ·• · ·•  ~
                                                                           01 r
                                                                           II Oil
                                                                           01 r
                                                                                      110
                                                                                      101
                                                                                      1I0
                                                                                                I
                                                                                                3
                                                                                                          2
                                                                                                          5
                                                                                                                   7
                                                                                                                   19
                                                                                                                            010
                                                                                                                            Oil
                                                                                                                            100
                                                                                                                                     D
                                                                                                                                     E
                                                                                                                                     H
                                                                            ~   d         ~                                 101      L
            LD r, (IY+d)         r~(IY+d)

                                                   ······                  II III 101
                                                                           01 r 110
                                                                                                3         5        19       III      A

                                                                           ~   d          -
            LD(HL),r
            LD (IX+d),r
                                 (HL)~r

                                 (lX+d)      ~r    ·· ·· ·· ·· ·· ··       01 110 r
                                                                           II Oil 101
                                                                           01 110 r
                                                                                                I
                                                                                                3
                                                                                                          2
                                                                                                          5
                                                                                                                   7
                                                                                                                   19

                                                                           ~ d            ~



            LD (IY+d), r         (IY+d)~r
                                                    ···· • •            II III 101
                                                                        01 110 r
                                                                           ~ d            ~
                                                                                                3         5        19



            LD (HL), n           (HL)~n
                                                    ······              00 110 110
                                                                           ~ n            ~
                                                                                                2         3        10

            LD (IX+d), n         (IX+d)~n
                                                    ······              I I 01 I 101
                                                                        00 110 110
                                                                           ~ d            ~
                                                                                                4         5        19



                                                                           ~
                                                                             n            ~



            LD (IY+d), n         (IY+d)~n
                                                    · · ··· ·           11 111 101
                                                                        00 110 110
                                                                           ~ d            ~
                                                                                                4         5        19



                                                                           ~ n            ~




            LD A, (BC)
            LDA, (DE)
                                 A~(BC)

                                 A~(DE)              ·· ·· ·· ·· ·• ··  00 001 010
                                                                        00 Oil CID
                                                                                                1
                                                                                                1
                                                                                                          2
                                                                                                          2
                                                                                                                   7
                                                                                                                   7
            LD A, (nn)           A~(nn)

                                                     ·· ····            00 III 010
                                                                           ~



                                                                           ~
                                                                             n
                                                                             n
                                                                                          ~



                                                                                          ~
                                                                                                3         4        13



            LD (BC), A
            LD (DE), A
                                 (BC)~A

                                 (DE)~-A             ·· ·· ·· ·· ·· ··  00 000 010
                                                                        00 010 010
                                                                                                1
                                                                                                1
                                                                                                          2
                                                                                                          2
                                                                                                                   7
                                                                                                                   7
            LD (nn), A           (nn)   +-   A
                                                      ······            00 110 010
                                                                           ~



                                                                           ~
                                                                             n
                                                                             n
                                                                                          ~




                                                                                          ~
                                                                                                3         4        13



            LDA,I                A~I
                                                      · I
                                                      tIFF t        0 0 11 101 101
                                                                        01 010 111
                                                                                                2         2        9


            LDA, R               A~R
                                                      ·
                                                      t IFF I       0 0 Il 101 101
                                                                        01 Oil III
                                                                                                2         2        9


            LDI,A                I~A

                                                      ······            Il 101 101
                                                                        01 000 111
                                                                                                2         2         9


            LDR,A
                             I
                                 R~A

                                                      ···· ··            II 101 101
                                                                        01 001 111
                                                                                                2         2         9



            Notes:      r, r' means any of the registers A, B, C, D, E, H, L

                        IFF the content of the interrupt enable flip-flop (IFF) is copied into the P/V flag
                                                                                                                                           I-
                                                                                                                                           :I:
            Flag Notation:       • = flag not affected. 0   = flag reset, 1 = flag set,   X = flag is unknown,                             ":>-2
                     t = flag is affected according to the result of the operation.
L-______________________________________________________________________________________ ~u                                                b
                                                                                     APPENDIX A ZSO INSTRUCTION SET SUMMARV                              443
Table A-4. Z80 16-Bit Load Instructions
                                                                             FI.,.                Op-Code       No.        No.      No.
                                          Symbolic                                                              of         ofM      ofT
                        Mnemonic          Operation                   C Z             N H 16 543 110            Bytes      Cycles   States   Comments
                        LO dd, nn         dd _nn
                                                                              ·
                                                                            '" S
                                                                                             00 ddO 001                             10       dd
                                                                                                                                             00
                                                                                                                                             01
                                                                                                                                                  Pair
                                                                                                                                                  BC
                                                                                                                                                  DE
                        lO IX, nn          IX-nn
                                                                      ·· ·· · ·               II 011 101
                                                                                             00 100 001
                                                                                                                                    14       10
                                                                                                                                             11
                                                                                                                                                  HL
                                                                                                                                                  SP



                        lOIY,nn            IV -nn
                                                                      ···· · ·                II III 101
                                                                                             00 100 001
                                                                                                                                    14




                        LO Ht, (nn)        H-(oo+l)
                                           L ..... (nn)               ······                 00 101 010                             16



                        LO dd, (nn)       dd H _(nn+!)
                                          ddL - (nn)                  ······                  11 101 101
                                                                                             01 ddt 011
                                                                                                                                    10




                        LO IX, (nn)        IX H .... (00+\)
                                           (XL      <-   (nn)
                                                                      · ·····                11 011 101
                                                                                             00 101 010
                                                                                                                                    20




                        LD IY, (nn)        IY H <- {nn+l)
                                           (Y L .- (nn)               ······                 II 111 101
                                                                                             00 101 010
                                                                                                                                    10




                        LD (nn), HL        (on+1) .. · H
                                           (nn) ...... L              ···· ··                00 tOO 010                             16



                        LO (nn), dd        (on+1) +-dd H
                                           (nn) +- ddL                ·· · ···                11 101 101
                                                                                             01 ddO 01\
                                                                                                                                    10




                        LO (nn), IX        ~nn+l)        ..... IX H
                                           (nn) ..... tX t            · ·····                11 011 101
                                                                                             00 100 010
                                                                                                                                    20




                        LO (nn), IV       (nn+l) -IY H
                                           (nn)-IY L                  ···· ··                II III 101
                                                                                             00 100 010
                                                                                                                                    20




                        LD SP, HL         SP-HL                                               11 111 001
                        LDSP,IX           SP-IX                                               II 011 101                            10
                                                                                              11 III 001
                        LD SP, IY


                        PUSH qq
                                          SP-IV

                                          (5P-2) ..... qqL
                                                                      ······                  II III 101
                                                                                              II III 001
                                                                                              II qqO 101
                                                                                                                                    10

                                                                                                                                    II
                                                                                                                                             qq
                                                                                                                                             00
                                                                                                                                                  Pair
                                                                                                                                                  BC
                                          (8P-1) +-qqH                                                                                       01   DE
                        PU8H IX


                        PUSH IY
                                          (8P-2) +-IXL
                                          (SP-I) ~IXH
                                          (8P-2) +-IY L
                                                                      · ·· ···               11 011 101
                                                                                             11
                                                                                             11
                                                                                                  100
                                                                                                  111
                                                                                                        101
                                                                                                        iOl
                                                                                                                                    15


                                                                                                                                    15
                                                                                                                                             10
                                                                                                                                             11
                                                                                                                                                  HL
                                                                                                                                                  AF


                                          (SP-I) .·IY H                                      11   100   101                                                    u
                        POPqq             qqH - (SP+l)                                       11   qqO   001                         10                         1':
                                          qqL ~ (SP)                                                                                                           6
                        pop IX            IX H +- (8P+l)
                                                                            ·                 II OIl 101                            14
                                                                                                                                                               3
                        POl'IY



                        Notes:
                                          IX L +- (SP)
                                          IY H +- (8P+l)
                                          IYL      ~     (SP)
                                                                      l
                                                                      ·.
                                    dd IS any of the register pairs BC, DE, HL, SP
                                    qq IS8ny of the register pairs AF, BC, DE, HL
                                                                                              11 100 001
                                                                                              11 111 101
                                                                                             11 100 001
                                                                                                                                    14
                                                                                                                                                               N
                                                                                                                                                               ;..
                                                                                                                                                               co
                                                                                                                                                               ~
                                                                                                                                                               :e:
                                                                                                                                                               @
                                                                                                                                                               f-
                                    (PAIR)H' (PAIR)L refer to high order and low order eight bits of the register pair respectIvely.
                                                          E.g. BC L =: C, AFH = A
                                                                                                                                                               :r:
                        FIa8 Notation:    •   =:   flag not affected, 0     =:   flag reset, 1 = flag set, X = flag is unknown,
                           t flag is affected according to the result of the operation.
                                                                                                                                                               "c:2
                                                                                                                                                               ;..
L-__________________________________________________________________________________                                                                       ~8
                                                                                                                                                               "-
444     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A·5. Z80 Exchange, Block Transfer, and Block Search Instructions
                                                                              Flags                 Op-Code
                                                                                                                  No.       No.      No.
                                  Symbolic                                                                        01        olM      ofT
                Mnemonic          Operation                       C Z V S             N H 76 543 210              Bytes     Cycles   States   Comments
                                                                             "'
                EX DE, HL
                EX AF, AF'
                                  DE··Hl
                                  AF ··AF'                                                 .   11 101 011
                                                                                               00 001 000
                                                                                                                   1        1



                                (~*~)
                EXX                                                                            11 011 001                                     ,Register bank and
                                                                                                                                               auxiliary register
                                  H                    L'                                                                                      bank exchange
                EX (SP), ilL      H-(SP+l)                                                     11 100 011                            19
                                  1 - (SP)
                EX (SP), IX       IXH-(SP+I)                                                   II 011 101                            23


                                                                  · · . ·. .
                                  IX L .... (SPI                                               11 100011
                l:X (SP), IV      IV H"'(SP+ I)                                                11 111 101                            23
                                  IV L .... (SP)                                               11 100 011
                                                                             CD
                WI                (DE) ......
                                  DE -OE+1
                                  ilL            UL+ I
                                                      (HLJ
                                                                  ·· ·        1       0    0   11 101 101
                                                                                               10 100 000
                                                                                                                                     16       Load (HL) mto
                                                                                                                                              (DE), Increment the
                                                                                                                                              pointers and
                                           <-
                                                                                                                                              decrement the byte
                                  Be ... He-I                                                                                                 counter (BC)

                LDiR              (DEI ..... /IIL)
                                  DE
                                  liL
                                           +-

                                           <-
                                                 D[+ I
                                                  HL+I
                                                                  ·· ·       0        0    0   11 101 101
                                                                                               10 110 000
                                                                                                                                     21
                                                                                                                                     16
                                                                                                                                              1fDC¢ 0
                                                                                                                                              1rSC= 0


                                  Be       <-    HC·I
                                  Rl'peat until
                                  lW=O
                                                                             CD
                LOO               (01:.)


                                  HL ..... HL-!
                                                +--

                                  1>1·, .... OF-J
                                                      (Ill)
                                                                  ·· ·        f       U 0      11   WI
                                                                                               10 101 000
                                                                                                         101                         16



                                  IK-- BC-I

                LDOI{             (OL)
                                  DE --- m',-I
                                                +-



                                  III. ...... HL-l
                                                      (!-Ill
                                                                  ·· ·       0        I)   0   11 101 101
                                                                                               10 111 000
                                                                                                                                     21
                                                                                                                                     16
                                                                                                                                              IfBC." 0
                                                                                                                                              IfDe= 0


                                  Be -          8C-1
                                  Repeal until
                                  HC '" 0
                                                                       <%JCD
                ('PI              A - (HL)
                                  HL--HL+!
                                  BC ... 8C-1
                                                                  ·     1 !       I   1 !      11   101 101
                                                                                               10 100 001
                                                                                                                                     16




                                                                       <%JCD
                CPIR              A - (111.)
                                  HL-HL+I
                                  S('      <-   BC-I
                                                                  ·     1     f   1   1    f   11 101 101
                                                                                               10 110 001
                                                                                                                                     21
                                                                                                                                     16
                                                                                                                                              If Be   '* 0 and A
                                                                                                                                              If BC ::: 0 or A
                                                                                                                                                                   ¢

                                                                                                                                                                 =(HL)
                                                                                                                                                                       (HL)



                                  Rep.'at until
                                  A -" (IILI or
                                  HC = 0
                                                                       <%J    1
                CPO               A - {HLJ
                                  HL~-HL-I

                                  Be - BC-I
                                                                  ·     I     !   !   1    !   11 101 101
                                                                                               10 101 001
                                                                                                                                     16



                                                                       \1     1                                                                                               0
                ('PDR             A - (HI.)
                                                                   ·    !     !   I   1 I      11 101 101                            21       If De ¢ 0 and A .. (HL)
                                                                                                                                                                              1:
                                  HL ...... HL-1
                                  BC+--BC-J
                                  Repeal until
                                                                                               10 III 001                            16       !fBC= OorA = (HL)
                                                                                                                                                                              "
                                                                                                                                                                              0
                                                                                                                                                                              .J
                                                                                                                                                                              N
                                  A=IHL)or
                                                                                                                                                                              >-
                                  BC =0                                                                                                                                       '"<--<--
                                                                                                                                                                              ~
                                                                                                                                                                              @
                Notes:    CD   PIV flag i~ 0 if the result of RC-l "" 0, otherwise P/V = I
                                                                                                                                                                              f-
                          (l) Z flag 1\ I             if A = (HU, otherWIse Z:. D.                                                                                            :I:

                Hag Notation:     • = nag not affected, 0 = flag reset. 1 = nag set. X                         =flag IS unknown.                                              "02>-
                                                                                                                                                                              0..
                                  1   =.   nag         I~   affecll!d accordmg to the re'rult of the operatJon.                                                               0
                                                                                                                                                                              U
                                                                               APPENDIX A Z80 INSTRUCTION SET SUMMARY                                445
Table A-6. Z80 8-Bit Arithmetic and Logical Instructions


                                                               Flags               Op-Code
                                                                                                   No.     No.      No.

          Mnemonic
                               Symbolic
                               Operation
                                                               ~                                   of      ofM      ofT
                                                                                                                    States   Comments
                                                      C Z V S          N H 76 543 210              Bytes   Cycles

         ADDA,r                A-A+r                  ;    I   V ;     0   ;   10 IQQQ]      r     I       I        4        r         Reg.
                                                      ;    ;                                                                 000       B
         ADDA,n                A~A+n                           V ;             IIIQQQ] 110         2       2        7
                                                                           !
                                                                                             -
                                                                       0
                                                                                                                             001       C
                                                                               ~      n                                      010        0
         ADDA,(HL)             A   ~    A+(HLJ        ;    I   V ;     0   I   10 IQQQIIIO         I       2        7        011       E
                                                                                                                             100       H
         ADD A, (IX+d)         A~A       + (IX+d)     !    I   V ;     0   !   II 011 101          3       5        19
                                                                                                                             101       L
                                                                               10 [QQQI11O


         ADD A, (IY+d)
                           I   A~A+(IY+dJ             !    I   V ;     0   ;
                                                                               ~
                                                                                      d
                                                                               II 111 101
                                                                                             -     3       5        19
                                                                                                                             III       A



                                                                               10 [QQQIIIO
                                                                               ~
                                                                                      d      -
          ADC A,s              A   ~    A+   S   + CY I    ;   V I     0   I        [@]                                      S IS any of r, n,

          SUB s                A~A-s                  ;    ;   V ;         ;        [QIQ]                                    (HL), (IX+dJ.
                                                                       I
                                                                                                                             (lY +d) as shown for
          SBe A,s              A~       A -s-CY       I    I   V I     I   I        IQI.I]                                   ADD instruction
          ANDs                 A~A          A s       0   l> I 0 1
                                                           I                        [j]QJ
          OR s                 A~A          V s       0 I P ; 0 0                   [Q]]                                     The mdicated bits
                                                                                                                             replace the 000 In
          XORs                 A~A        .. s        0    I   P   !   0   0        Will                                     the ADD set abov e.
          CP s                 A-s                    I    I   V I     I   I        [ill]
          INC r                r .- r + 1             •    I   V ;     0   ;   00  r      illill   I       I        4
          INC (HL)
          INC (IX+d)
                               (BLJ
                               (IX+d)~
                                        ~   (HLJ+ I

                                       (IX+d)+1
                                                      ··   I
                                                           ;
                                                               V I
                                                               V I
                                                                       0
                                                                       0
                                                                           I
                                                                           I
                                                                               00 11 0 IT.:QQ]
                                                                               II 011 101
                                                                               00 1I0[j]Q]
                                                                                                   I
                                                                                                   3
                                                                                                           3
                                                                                                           6
                                                                                                                    II
                                                                                                                    23

                                                                               .      d      .
          INC (IY+dl           (IY+d) -
                                  (lY+d) + I
                                                      •    I   V !     0   I   II III 101          3       6        23
                                                                               00 '110 [J]Q]
                                                                               -      d
          DECm                 m+-m-I                 •    t   V I     I   ;              0Jill                              m is any of r, (H L),
                                                                                                                             (IX+d). (IY+d) as
                                                                                                                             shown for INC
                                                                                                                             Same form.lt ,mu
                                                                                                                             'tates as INC.
                                                                                                                              Replace 100 with
                                                                                                                              10lmOPcode.


          Notes:     The V symbol in till' P/V flag column indicate, that the P!V flag contains the overflow of the Ie,"1t of the
                     operatioc, Similarly the P symbol indicates panty. V;; I mc;,ms overtlow, V = 0 means not ovcrt1ow. p;: I
                     means parity of the result is even, P = 0 mcan~ panty of thl' re'mlt iii odd.

          Flag Notation:       •   = flag not affected, 0 = nag Ie<;ct, I = nag "'1. X = nag IS lInknown.
                               t   =   flag is affected according to the re!'lult of the opt!ratlon.




                                                                                                                                                           @
                                                                                                                                                           I-
                                                                                                                                                           :t:

                                                                                                                                                           "
                                                                                                                                                           ;:
~   ______________________________________________________________________________________                                                             ~8
                                                                                                                                                           ~
446     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Tabl• • 7. Z80 General-Purpose Arithmetic and CPU Control

                                                  Flap                 Op-Code
                                                                                    No.       No.      No.
                         S)'IIIboJic             ~                                  of        arM      ofT
        Mnemonic         Operation         C Z V S N H 76 543 210                   Bytes     Cycles   States   Comments

                                               * *• *
        DAA              Converts acc.     t      P               00 100 111        1         1        4        Decimal adjust
                         content into                                                                           accumulator
                         packed BCD
                         following add
                         or subtract
                         with packed
                         BCD operands
        CPL              A+-A              • • • •        1   1 00 101 111          1         1        4        Complement
                                                                                                                accumulator
                                                                                                                (one's complemen t)
        NEG              A+-O-A            t t    V   t 1 t 11 101 101              2         2        8        Negate acc. (two's
                                                              01 000 100                                        complement)
        CCF              CY +-CY           t   • •    •   0 X 00 111 111            1         1        4        Complement car
                                                                                                                flag
        SCF              CY +-1            1   • •    •   0 0 00 110 111            1         1        4        Set carry flag
        NOP              No operation      •   • •    • • •       00 000 000        1         1        4
        HALT             CPU halted        •   • •    •   •   •   01 110 110        1         1        4
        DI               IFF +- 0          •   • •    •   •   •   11 110011         I         1        4
        EI               IFF +-1           •   • •    •   •   •   11 111 011        1         1        4
        IMO              Set interrupt
                         mode 0
                                           •   • •    •   •   •   11    101   101   2         2        8
                                                                  01    000   110
        1M 1             Set interrupt
                         mode 1
                                           • • • • • •            11    101   101   2         2        8
                                                                  01    010   110
        1M2              Set interrupt
                         mode 2
                                           • • • • • •            11    101   101   2         2        8
                                                                  01    011   110

        Notes:   IFF indicates the interrupt enable flip-flop
                 CY indicates the carry flip· flop.

        Flag Notation:   • = flag not affected, 0 = flag reset, 1 = flag set, X = flag is unknown,
                         t =flag is affected according to the result of the operation.




                                                                                                                                       ..
                                                                                                                                       !i;
                                                                                                                                       \!)
                                                                                                                                       02
L-____________________________________________________________________________                                                         t
                                                                                                                                      ~8
                                                                   APPENDIX A Z80 INSTRUCTION SET SUMMARY                      447

Table A-I. Z80 16-Bit Arithmetic Instructions

                                                     Flags            Op-Code       No.        No.      No.
                          Symbolic                                                  of         ofM      ofT
         Mnemonic         Operation          C Z IP~ S N H 76 543 210               Bytes      Cycles   States   Comments


                                      *• • •
         ADDHL, ss        HL - HL+ss                         0   X 00 ssl 001        I         3        1\       as     Reg.
                                                                                                                 00     DC
                          HL-HL+ss+CY *                                             2                   15       01     DE
         ADCHL, IS                       V                   0   X 11 101 101                  4
                                        * *                        01 ssi 010
                                                                                                                 10
                                                                                                                 11
                                                                                                                        HL
                                                                                                                        SP
         SBC HL,   IS     HL-HL-ss-CY    V                   I   X 1\ 101 101        2         4        15
                                      ** *                         01 ssO 010

                                              *• • •
         ADD IX,pp         IX -IX+pp                         0   X 11 Oil 101        2         4        15       pp     Reg.
                                                                   00 ppl 001                                    00     DC
                                                                                                                 01     DE
                                                                                                                 10     IX
                                                                                                                 11     SP

                                              *• • •
         ADD IY,rr         IY-IY+rr                          0   X 11 III 101        2         4        15       rr     Reg.
                                                                   00 rrl 001                                    00     He
                                                                                                                 01     DE
                                                                                                                 10     IV
                                                                                                                 II     SP


         INC IS            55-ss+1           • • • • • •           00 ssO 011        I         I        6


         INC IX            IX-IX+ I          • • • • • •           11 01\ 101        2         2        10
                                                                   00 100 Oil
         INCIY             IY-IV + I         • • • • • •           II III 101        2         2        10
                                                                   00 100 011
         DEC ss            55-55-1           • • • • • •           00 551 011        I         I        6

         DEC IX            IX-lX-I           • • • • • •           11 011 101        2         2        10
                                                                   00 101 011
         DECIY             IY-IY-I            • • • • • •          11 111 101        2         2        10
                                                                   00 101 Oil


         Notes:     55 is any of Ihe register pairs BC, DE, HI., SP
                    pp is any of the register pairs BC, DE, IX, SP
                    rr is any of the register pain BC, DE, IY. SP.

         Flag Notation:   •   = Ilag not affected, 0 = nag reset, I = Ilag set. X = nag IS unknown.
                          t = flag is affected according to the result of the operdtion.


                                                                                                                                     u
                                                                                                                                     25
                                                                                                                                     c:5
                                                                                                                                     3
                                                                                                                                     N
                                                                                                                                     >-
                                                                                                                                     <Xl
                                                                                                                                     ::::
                                                                                                                                     ..
                                                                                                                                     ~


                                                                                                                                     !i:
                                                                                                                                     ">-
                                                                                                                                     Oii
L-______________________________________________________________________________________                                         ~8
                                                                                                                                     "-
448     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table M. Z80 Rotate and Shift Instructions
                                                               Flags             Op-Code
                                                                                             No.      No.      No.
         Mnemonic
                                   Symbolic
                                   Operation           C
                                                             't
                                                           Z V     S N H 76 543 210
                                                                                             or
                                                                                             Bytes
                                                                                                     'ofM
                                                                                                      Cycles
                                                                                                               ofT
                                                                                                               States    Comments


                                                       *• • •
         RLCA
                           ~7~O~
                                                                       0 0 00 000 111        1       I         4         Rotate left circular
                                                                                                                         accumulator


         RLA              ~               .            *• • •          0 0 00 010 111        I       I         4         Rotate left
                                                                                                                         accumulator


                          Y7~O~
                                                       *• • •
         RRCA                                                          0 0 00 001 III        I       I         4         Rotate right circular
                                                                                                                         accumulator


         RRA
                          ~ *•                                 • •     0 0 00 011 111        1       1         4         Rotate right
                                                                                                                         accumulator


         RLCr                                          t
                                  * t
                                                               P       0 0 11 001 011        2       2         8         Rotate left circular
                                                                           OO[QQQ]r                                      register r
         RLC(HL)                    p  0                                 0 11 001 011        2       4         IS        r            ~.
                                 ** *                                      00(QQQ]1l0                                    000          B
         RLC(IX+d)
                               ~ *t P *0
                                 r,(HL),UX+dI.(IY+dl
                                                                         0 11 011 101        4       6         23        001
                                                                                                                         010
                                                                                                                                      C
                                                                                                                                      0



         RLC (IY+d)                                            p
                                                                             - -
                                                                           II 001 011
                                                                                 d
                                                                           00[QQQ]1J0
                                                                       0 0 11 111 101        4       6         23
                                                                                                                         011
                                                                                                                         100
                                                                                                                         101
                                                                                                                         111
                                                                                                                                      E
                                                                                                                                      H
                                                                                                                                      L
                                                                                                                                      A
                                                       ** *
                                                                               -
                                                                           11 001 011
                                                                             ~
                                                                                 d
                                                                           00 [iiiiQ] 11 0
         RLm
                          ~
                          III "r.(HLUIX+dI.(IYtdj
                                                       t
                                                           * *
                                                               P       0 0       [Q!Q]                                   Instruction format and
                                                                                                                         states are as shown
                                                                                                                         for RLC,rn. To form
                                                                                                                         new OP-code replace
         RRCm             ~
                          m "-r.(HL).(IX+d).(lV+d)     *t
                                                               P
                                                                   *
                                                                       0 0       ~                                      fiiQQJof RLC,m with
                                                                                                                         shown code


         RRm              t::cij:8J                            p       0 0       (]IT]
                          m -'r, (HL),(lX+dl.(IY+d1    ** *
         SLAm              ~o                          t       P       0 0       rnQ]
                          m -,; r.IHLI.nX+dl.ClYtd)        * *
         SRAm
                          ~
                          m Er.IHLI,(lX+dl,(lY+d)
                                                       t
                                                           *
                                                               P ;     0 0       [ill]


         SRLm         ~                                t t     P       0 0       [ill]
                          m~   r (HL),{IX+dl.(IY+d)                *
         RLD          '~tHLo •                             t   P   ; 0 0 II 101 101          2       5         18       Rotate digit left and
                                                                             01 101 111                                 righ t between the
                                                                                                                        accumulator

                      A~tHLo.
                                                                                                                        and location (HL).
         RRD                                               t   p       0 0   11 101 101      2       5         18       The content of the
                                                                   *         01 100 III                                 upper half of the
                                                                                                                        accumulator is
                                                                                                                        unaffected
         Flag'Notation:   • =lIag not affected, 0 =flag reset, I =flag set, X =flag is unknown,
                          t =flag is affected according to the result of the operation.
                                                                            APPENDIX A Z80 INSTRUCTION SET SUMMARY                            449
Table A-10. Z80 Bit Manipulation Instructions

                                                    Flags                 Op-Code
                                                                                           /110.     No.      No.
                         Symbolic                   ~                                      or
                                                                                           Bytes
                                                                                                     ofM
                                                                                                     Cycles
                                                                                                              ofT
                                                                                                              States   Comments
        Mnemonic         Operation          C Z V S N H 76 543 210
        BITb.,           Z +-'b             •       X X 0     1 11 oot 011                 2          2       8        ,         Reg.
                                              *                 01 b                ,                                  000       B
                                                                                                                       001       C
        BIT b, (HL)      z +- '('HIib       • *X        X 0   1 11 001 011                 2          3       12
                                                                                                                       010       D
                                                                01 b 110                                               011       E
        BIT b, (IX+d)    Z +- (lX+d)b       • *X        X 0   1 11 011 101                 4          5       20       100
                                                                                                                       101
                                                                                                                                 H
                                                                                                                                 L
                                                                11 001 011
                                                                                                                       III       A
                                                                +- d    ....
                                                                01 b 110                                               b         Bit Tested
        BIT b. (lY +d)   Z +- (lY+d)b       •       X X 0     1 11 lit 101                 4          5       20       000       0
                                                *               11 001 011
                                                                                                                       001       I
                                                                                                                                 2
                                                                                                                       010
                                                                +- d    ....                                           011       3
                                                                01 b 110                                               100       4
                                                                                                                       101       5
                                                                                                                       110       6
                                                                                                                       111       7
        SETb, ,          'b +-1             • • • • • •            11 001 011              2          2       8
                                                                  ITIlb    r
        SETb, (HL)       (HL)b -I           • • • • • •            11 001 011              2          4       IS
                                                                  [j]b 110
        SET b, (lX+d)    (IX+d)b+- 1        •   ·• • • •           11 011 101              4         6        23


                                                                      -
                                                                   11 001 011
                                                                       d
                                                                  [j]b 1\0
                                                                                    ....
        SET b, (IY+d)    (IY+d)b'" 1        • • • • • •            11 111 101              4         6        23
                                                                   11 001 011
                                                                      ...
                                                                       d   ....
                                                                  OIl  b 110


       RES b, m          ~+-O                                     [iQ]                                                 To form new oP·
                                                                                                                       code replace [TI)
                         m=" (HL),
                                                                                                                        of SET b,m with
                           (IX+d),
                           (lY+d)
                                                                                                                       [Q). Flags and time
                                                                                                                        states for SET
                                                                                                                        instruction




        Notes:    The notation ~ indicates bit b (0 to 7) 0' location s.

        Flag Notstion:   •   =flag not affected, 0 =flag ,eset,   I   ~     flag set. X = flag is unknown,
                         *= flag i. affected according to the result of the operation.
                                                                                                                                                    @
                                                                                                                                                    f-
                                                                                                                                                    :I:
                                                                                                                                                    <.:)
                                                                                                                                                    0::
                                                                                                                                                    >-
                                                                                                                                                    0-
~   __________________________________________________________________________                                                                  ~U
                                                                                                                                                    o
450      Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A·11. Z80 Jump Instructions
                                                  Flags            Op-Code
                                                                                   No.        No.      No.
                         Symbolic                 ~                                of         ofM      ofT
      Mnemonic           Operation         C Z     V S N H 76 543 210              Hytes      Cycles   States   Comments

      IP nn              PC -nn            • • • • • •
                                                       --
                                                                 II 000 011        3          3        10
                                                                     n      .~




                                                                     n      ~                                   cc        Condition
      IP cc, nn          If condition cc
                         is true PC -nn,
                                           • • • • • •           II cc 010         J          3        10       000    NZnon zero
                                                                 +. n       ~                                   001    Z zero
                         otherwise
                         continue                                -    n    ~
                                                                                                                010
                                                                                                                Oil
                                                                                                                100
                                                                                                                       NCnon carry
                                                                                                                       C carry
                                                                                                                       PO pari ty odd
                                                                                                                101    PE pari ty even
                                                                                                                110    P sign positive
      lR e               PC+-PC+e          • • • • • •           00 OIl 000        2          3        12       III    M sign negative

      lR C, e            IfC    =0,        • • • • • •
                                                                 -  e-2     ~




                                                                 -
                                                                 00 III 000        2          2        7        If condition not met
                         continue
                                                                     e-2    ~




                         IfC = I,                                                  2          3        12       If condition is met
                         PC -PC+e
      lR NC, e           IfC = I,
                         continue

                         If C =0,
                                           • •    ·• • • -       00 110 000
                                                                     e-2   ~
                                                                                   2          2        7        If condition not met

                                                                                                                If condition
                                                                                   2          3        12                      IS   met
                         PC-PC+e
      lR Z, e            If Z   =0         • • • • • •           00 101 000        2          2        7        If l.:ondition not met
                         continue
                         IfZ = I,
                                                                 -   e-2    ~




                                                                                   2          3        12       If condition IS met
                         PC-PCte
      lR NZ, e           If Z = I,         • • • • • •           00 100 000        2          2        7        If condition not rnt'
                         continue
                         IfZ =0,
                                                                 -  e-2     ~




                                                                                   2          3        12       If condition met
                         l'C-PC+e
      IP (HL)            PC-HL             • • • • • •           1; 101 001        1          1        4


      IP (IX)            PC-IX             • • • •        ·•     11 011 101
                                                                 II 101 001
                                                                                   2          2        8

      IP (lY)            PC-IV             • • • • • •           II III 101        2          2        8
                                                                 11 101 DOl


      DJNZ,e             B - B-1           • • • • • •           00 010 000        2          2        8        If B =0
                         IfB =0,
                         continue                                -   e-2    ~




                         IfB 0, *                                                  2          3        13       IF B   *0
                         PC-PC+e


      Notes:      e represents the extension in the relative addressing mode.
                  e is a signed two's complement number in the range <-126,129>
                  e-2 in the op-code provides an effective address of pc +e as PC is
                  incremented by 2 prior to the addition of e.

      Flag Notation:     • = flag not affected, 0 = flag reset, I = flag set, X = flag is unknown,
                         t = flag is affected according to the result of the operation.
                                                                         APPENDIX A Z80 INSTRUCTION SET SUMMARY                     451
Table A·12. Z80 Call and Return Instructions

                                              Flags                O!K:ode
                                                                                  No.     No.      No.
                     Symbolic                ~                                    of      ofM      ofT
    Mnemonic         Operation         C Z V S N H 16 543 210                     Bytes   Cycles   States   Comments
    CALL nn          (SP-I) ....PC H   • • • • • •           II 001 101           3       S        11
                     (SP-2) ....PC L                        .... n ....
                     PC-nn                                  .... n   ....
    CALL cc, nn      If condition
                     cc is false
                                       • • • • • •          II cc         100     3       3        10       If cc is false

                     continue,
                                                            ....     n     ....
                     otherwise                              ....     n     ....   3       S        17       If cc is true
                     same as
                     CALLnn
    RET              PC L<-(SP)        • • • • • •          II 001 001            I       3        10
                     PCH<-(SP+ I)


    RETcc            If condition
                     cc is false
                                       • • • • • •          II cc         000     1       I        S        If cc is false

                     continue,
                     otherwise                                                    1       3        II       Ifcc is true
                     same as                                                                                cc     Condition
                     RET                                                                                    000 NZ       non zero
                                                                                                            001     Z    zero
                                                                                                            010 NC       non carry
    RETI             Return from
                     interrupt
                                       • • • • • •          II 101 101            2       4        14       011     C    carry
                                                            01 001 101                                      100 PO       parity odd
                                                                                                            101     PE   parity even
    RETN             Return from
                     non maskable
                                       • • • • • •          11 101 101            2       4        14
                                                                                                            110 P        sign positive
                     interrupt                              01 000 101                                      III     M    sign negative
    RSTp             (SP-I)....PC H    • • • • • •          II t III              1       3        11
                     (SP-2)+-PC L
                     PCH .... O
                     PCL ....P
                                                                                                            t       P
                                                                                                            000     ooH
                                                                                                            001     08H
                                                                                                            010     10H
                                                                                                            011     18H
                                                                                                            100     20H
                                                                                                            101     28H
                                                                                                            110     30H
                                                                                                            III     38H

    Flag Notation:   • = flag not affected, 0 = flag reset, I = flag set, X =flag is unknown                                              o
                     * = flag is affected according to the result of the operation.                                                       ~
                                                                                                                                          g
                                                                                                                                          N
                                                                                                                                          i:;
                                                                                                                                          .....
                                                                                                                                          ~
                                                                                                                                          ":I:f-o
                                                                                                                                          C
                                                                                                                                          02
L-____________________________________________________________________________                                                            t
                                                                                                                                         ~8
452     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A·13. Z80 I/O Instructions

                                                           Flags               Op-Code
                                                                                                 No.       No.         No.
                              Symbolic                     ~                                     of        ofM         ofT
           Mnemonic           Operation         C Z V S N 'H 76 543 210                          8ytes     Cycles      States   Comment.

                                                • • • • • •
                                                                           - -
           IN A, (n)          A-(n)                                        11 011 011            2         3           11       n to AO - A7
                                                                               n                                                Acc to AS - AI5
           IN ,,(C)           ,-(C)
                              if' = 110 only
                              the flags will
                                                ·    t P t         0   I   11 101 101
                                                                            ,
                                                                           01     000
                                                                                                 2         3           12       CtoAO -A7
                                                                                                                                8 to AS - A IS

                              be affected
                                                    I"i'
                                                    I'"
           INI                (HL)-(C)          X    t     X X I       X II 101 101              2         4           16       C to AO - A7
                              8 -8·1                                     10 100010                                              8 to AS - AI5
                              HL -HL+ I
           [NIR               (HL)- (C)         X     I    X X I       X 11 101 101              2         5           21       Cto AO - ~
                              8-8·1                                      10 110 010                      ([f8" 0)               8 to AS - A IS
                              HL-HL+ I                                                           2         4           16
                              Repeat until                                                               (If B = 0)
                              8=0
                                                    :",
           IND                (HL)-(C)          XI~        X X I       X II 101 101              2         4           16       CtoA O -A 7
                              8~8-1                                      10 101 010                                             8 to AS - AI5
                              HL-HL-I
           INDR               (HL)-(C)          X     I    X X I       X 11 101 101              2          5          21       Cto AO - A7
                              B-8-1                                      10 III 010                      (If B .. 0)
                                                                                                                                B to AS - AI5
                              HL~HL-I
                                                                                                 2         4           16
                              Repeat until
                                                                                                         (If B = 0)
                              B=O
           OUT (n), A         (n)-A
                                                ··· • ·•                   II 010 Oil
                                                                           +- n -->
                                                                                                 2         3           II       n to AO - A7
                                                                                                                                Ace to AS - AI5
           OUT (C)"           (C)   ~,

                                                ······
                                                    Q)
                                                                           11 101 101
                                                                           01     ,
                                                                                  001
                                                                                                 2         3           12       C to AO - A7
                                                                                                                                BtoA B -A I5

           OUT!               (C)   ~(HL)       X    t     X X I       X 11 101 101              2         4           16       C to AO - A7
                              B~B-I                                      10 100 OIl                                             B to AS - AI5
                              HL-HL+ I
           OTIR               (C)~(HL)          X     I    X X 1 X 11 101 101                    2          5          21       (' to AU - A7
                              B-B-I                                10 110 OIl                            (If B .. 0)
                                                                                                                                B to Ag - AI5
                              HL-HL+ I
                                                                                                 2         4           16
                              Repeat until                                                               (If B = 0)
                              B=O
                                                    I",
                                                    I""
           OUTD               (C)~(HL)          X     I X X I          X II 101 101              2         4           16       (' to AO - A7
                              B ~B-I                                     10 101 Oil                                             B to AS - AI5
                              HL~HL-I

           OTDR               (C)~(HL)          X     I    X X I       X II 101 101              2         5           21       C to AO - A7
                              B-B-I                                                                      (If B .. 0)            BtoA g -A 15
                                                                         10 III 011
                              HL~HL-I
                                                                                                 2         4           16
                              Repeat until                                                               (lfB = 0)
                              B=O
           Notes:     Q)   If the result of B-1 is zero the Z flag is set, otherwise it is reset·

           Flag Notation:     • = flag not affected, 0     = flag reset, 1 =   flag set, X   = flag is unknown,
                              t = flag is affected according to the result of the operation.
                                                                              APPENDIX A: Z80 INSTRUCTION SET SUMMARY                                 453
Table A·14. Summary of Z80 Flag Operations

            IDstruction                                cz     \s      NH            Comments
           ADD A, .; ADC A,s
                                                         **v *o *                   8·bit add or add with carry
           SUB s; SBC A, s, CP s, NEG
                                                       * *v * I *                   8·bit subtract, subtract with carry, compare and
                                                                                       negate accumulator
           ANOs                                        0 *P *0 I                    Logjcal operations
           ORs;XORs                                    0 *P *0 0                    And set's different flags
           INCs                                        e *V *0 f                    8-bit increment
                                                       e *V * I
           DECm                                                                     8·bit decrement
           ADDDD,ss                                    *e e e 0 x      X*           16·bit add
           ADC HL,ss
                                                                  * 0               16·bit add with carry

                                                       *f* e* ev e* oI 0X
           SBC HL,ss
                                                               v
                                                                                    16·bit subtract with carry
           RLA;RLCA,RRA,RRCA                                                        Rotate accumulator
           RL m; RLC m; RR m; RRC m
             SLA m; SRA m; SRL m                       *f     p       o   0         Rotate and shift location m

           RLO,RRD                                     e f P f 0          0         Rotate digit left and right
           DAA                                         f f P f e          f         Decimal adjust accumulator
           CPL                                         e e e e            I         Complement accumulator
           SCF                                           e e e o          0         Set carry
           CCF                                           e e e 0          X         Complement carry
           IN r, (C)                                   e f P   o          0         Input register indirect
           INI; IND; OUTI; OUTO                        e f XXI            X         Block input and output
           INIR; INDR; OTlR; OTOR                         XXI             X         Z = 0 if B .. 0 otherwise Z = I
                                                       •
           LDI,LOO                                     ·xIt X 0           0         Block transfer instructions
           LDIR,LODR                                   eX o X 0           0         P/V = I if BC .. 0, otherwise P/V = 0
           CPI, CPIR, CPO, CPDR                           ttl             X         Block search instructions
                                                       • f                             Z = I if A =(HL), otherwise Z = 0
                                                                                       P/V = I if BC .. 0, otherwise P/V = 0
           LDA, I;LD A, R                                     FFf 0 0               The content of the interrupt enable f1ip·flop (IFF)
                                                       • f                             is copied into the P/V flag
           BITb,s
            NEG
                                                       • f
                                                      t t
                                                              xixt
                                                              V
                                                                      0 I
                                                                      I t
                                                                                    The state of bit b of location s is copied into the Z flag
                                                                                    N ega te accum ula tor


                  The following notation is used in this table:
            Symbol                                                            Operation
            c             Carry/link flag. C= 1 if the operation produced a carry from the MSB of the operand or result.
            z             Zero flag. Z= 1 if the result of the operation is zero.
            s             Sign flag. S=1 if the MSB of the result is one.
            PfV           Parity or overflow flag. Parity (P) and overflow (V) share the same flag. Logical operations affect this flag
                          with the parity of the result while arithmetic operations affect this flag with the overflow of the result. If P/V
                          holds parity. PN=l if the result of the operation is even, PfV=O if result is odd. If P/V holds overflow, P/V=1
                          if the result of the operation produced an overflow.
            H             Half-carry flag. H=1 if the add or subtract operation produced a carry into or borrow from into bit 4 of the accumulator.
            N             Add/Subtract flag. N=l if the previous operation was a subtract.
                          H and N flags are used in conjunction with the decimal adjust instruction (DAA) to properly correct the re·
                                                                                                                                                            U

           .
                          sult into packed nCD format following addition or subtraction using operands with packed BCD format.

                          ~:    g:: :: ::~~~~,!:dboy~neg~~e~~ti~~~UIt   of the operation.                                                                   ~
            o             The   flag is reset by the operation.                                                                                             6
            I             The   flag is set by the operation.                                                                                               q
            X             The   flag is a "don't care."                                                                                                     -
            V             P/V   flag affected according to the overflow result of the operation.                                                            N
            P             P/V   flag affected according to the parity result of the operation.                                                              ~
            r             Anyone of the CPU registers A, B, C, D, E, H, L.                                                                                  ::::
            S             Any 8-bit location for all the addressing modes allowed for the particular instruction. .                                         ~
            51            Any 16-bit location for all the addressing modes allowed for that instruction.                                                    @
            il            ~e~~e~~~:r.two index registers IX or IY.                                                                                          ~
            R
            n             8-bit value in range <1), 255>                                                                                                    t:>
            nn            H,.bit value in range <D. 65535>                                                                                                  i2
           m      Any 8-bit location for all the addressing modes allowed for the particular instruction.
L-______________________________________________________________________________________                                                                -J8t
454     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Table A-15. Summary of Z80 Restart Instructions


                                                            ,--
                                                            OP
                                                            CODE



                                                   OOOOH        C7   'RST 0'



                                                   OOOSH        CF   'RST S'

                                                  i----- f----
                                          C        OOlOH        07   'RST 16'
                                          A
                                          l       r---
                                          l
                                                   0018 H       OF   'RST 24'
                                          A
                                          0
                                          D
                                          H        0020 H       E7              (j
                                                                     'RST 32'
                                          E
                                          S                                     ~
                                          S                                     <.:i
                                                   002S H       EF   'RST 40'
                                                                                0
                                                                                ...J
                                                                                N
                                                                                >-
                                                                                co
                                                   0030H        F7   'RST 48'
                                                                                '"
                                                                                '"~
                                                                                @

                                                   003S H       FF   'RST 56'   f-

                                         "-"---   -~-
                                                            -                   '0;:"
                                                                                C!l

                                                                                >-
                                                                                "-
                                                                                0
                                                                                u
                                                    APPENDIX A Z80 INSTRUCTION SET SUMMARY          455
Table A-16. Summary of the Z80 Assembler


             ASSEMBLER FIELD STRUCTURE
             The assembly language instructions have the standard field structure (see Table
             2-1). The required delimiters are:
             1)   A colon after a label. except for the pseudo-operations EQU. DEFL. and
                  MACRO. which require a space.
             2)   A space after the operation code.
             3)   A comma between operands in the operand field. (Remember this oneil
             4)   A semicolon before a comment.
             5)   Parentheses around memory references.

             LABELS
             The assembler allows six characters in labels; the first character must be a letter.
             while subsequent characters must be letters. numbers. ? • or the underbar
             character (_). We will use only capital letters or numbers. although some versions
             of the assembler allow lower-case letters and other symbols.
             RESERVED NAMES
             Some names are reserved as keywords and should not be used by the program-
             mer. These are the register names (A. B. C. D. E. H. L. I. R). the double register
             names (IX. IV. SPI. the register names (AF. BC. DE. HL. AF·. BC·. DE'. HL·). and
             the states of the four testable flags IC. NC. Z. NZ. M. P. PE. PO).

             PSEUDO-OPERATIONS
             The assembler has the following basic pseudo-operations:
                                   DEFB or DB           DEFINE BVTE
                                   DEFL                 DEFINE LABEL
                                   DEFM                 DEFINE STRING
                                   DEFS orDS -          DEFINE STORAGE
                                   DEFWorDW -           DEFINE WORD
                                   END                  END
                                   EQU                  EQUATE
                                   ORG                  ORIGIN
             ADDRESSES
             The Zilog zao  assembler allows entries   In   the address field In any
             of the following forms:
             1)   Decimal (the default case)
                  Example: 1247
             2)   Hexadecimal (must start With a digit and end With an H)
                  Examples· 142CH. OE7H
             3)   Octal (must end With 0 or O. but 0 IS far less confUSing)
                  Example: 12470 or 12470
             4)   Binary (must end with B)
                  Example: 1001001000111 B
             5)   ASCII (enclosed in single quotation marks)
                  Example: 'HERE'
             6)   As an offset from the Program Counter ($)
                  Example: $+237H
Appendix B Programming
                                       Reference for the
                                       zao PIO Device

                                 D2               I             40           D3
                                 07               2             39           D4
                                 D6               3             38           D5
                                 CE               4             37           MI
                             C(5SEL               5             36           IORQ
                             B/ASEL               6             35           RD
                                 A7               7             34           B7
                                 A6               8             33           B6
                                 A5               9             ~            85
                                 A4              10    Z80      31           B4
                                GND              II    PIO      30           B3
                                 A3              12             29           B2
                                 A2              13             28           BI
                                 Al              14             27           BO
                                 AO              15             26           +5V
                               ASTB              16             25           ct>
                                  ifS"fB         17             24           lEI
                                  ARDY           18             23             iNf
                                    DO           19             22             lEO
                                    DI           20             21             BRDY


                        Pin Name       Description                      Type
                         DO-07         Data Bus                         Tristate, Bidirectional
                         CE            Device Enable                    Input
                         B/ASEL        Select Port A or Port B          Input
                         C/DSEL        Select Control or Data           Input
                         MI            Instruction fetch machine        Input
                                         cycle signal from CPU
                        IORQ           Input/ Output request from CPU   Input
                        RD             Read cycle status from CPU       Input
                        AO-A7          Port A Bus                       Tristate, Bidirectional
                        ARDY           Register A Ready                 Output
                        ASTB           Port A strobe pulse              Input
                        BO-B7          Port B Bus                       Tristate, Bidirectional
                        BRDY           Register BReady                  Output
                        BSTB           Port B strobe pulse              Input
                        lEI            Interrupt enable in              Input
                        lEO            Interrupt enable out             Output
                        INT         Interrupt request                   Output, Open-drain
                        ct>,+5V,GND Clock, Power, and Ground



Figure B-1. PIO pin assignments

                                                                                                  457
458     Z80 ASSEMBLY LANGUAGE SUBROUTINES



                                           +5VGND<I>


                                                 ttt                           Data or
                                                                               Control


                                                                             } Handshake

               CPU {                                                                         Peripheral
           Interface                                                                         Interface
                                                                               Data or
                                                                               Control


                                                                              } Handshake



                                       Interrupt Control Lines



Figure B-2. Block diagram of the PIO




                                                                    Data
                                                                  Output
                                                                    Reg
                                  Internal Bus                    (8 Bits)

                                                                             8-Bit Peripheral
                                                                             Data or Control Bus

                        Mask                                       Data
                       Control         Mask                        Input
                         Reg            Reg                         Reg
                       (2 Bits)       (8 Bits)                    (8 Bits)
                                                     Input Data


                                                 Interrupt                     Handshake
                                                 Requests                      Lines




Figure B-3. Block diagram of PIO port 1/0
                                                       APPENDIX B PROGRAMMING REFERENCE FOR THE Z80 PIO DEVICE                                                                    459


               Register Selection

        Select Lines
                                Register Selected
     C/D        B/A

                                A Data
                                B Data
                                A Control
                                B Control



   Mode Control Word                                                                          Interrupt Control Word

   ID,ID,ID,ID.I' I' I' 1'1                                                                   ID,IDdD,ID.1 0 I' 1'1'1
        tI t
    -.,-'-.-~                                                                                                ~

                     ~'denllfle, mnde control wmd                                                                      ~Identlfies interrupt
                  - - - - - - - D o o ' t care
                  L.._
                                                                                                                                control word
         ' - - - - - - - - - - M o d e select                                                              '-------D.         ~ 0 No mask word follows
                                                              Mode 0          Output                                      D4 = I Mask word follows
                                                              Mode 1          Input                    L - - - - - - - - D , ~ 0 Active level is low
                                                              Mode 2          Bidirectional                               Ds = I Active level is high
                                                              Mode 3          Bit Control
                                                                                                   '---------g<             6
                                                                                                                                ~ Interrupt on OR function
                                                                                                                                  Interrupt on AN D function
                                                                                                '----------D,                        ~   0 Interrupt disabled
                                                                                                                                D7   =I     Interrupt enabled·
                                                                                                                                *Note: The Port IS not enabled until the interrupt enable
                                                                                                                                is followed by an active M t.
   Interrupt Vector Word                                                                      Mask Control Word

   LDJDoI~I~ID,I~ID11°1                                                                       I~I~I~I~I~I~I~I~I

    ~ ldentifiesinterrUPt                           vector
                                                    User-supplied interrupt
                                                                                                            f' - - - - - - M Bo-M B7 mask bits. A
                                                                                                                            bit is mOnitored for an
                                                    vector                                                                  Interrupt if it is defined
                                                                                                                            as an input and the mask
                                                                                                                            bit is set to O.
   1/0 Register Control Word                                                                  Interrupt Disable Word


   I~I~I~I~I~I~I~I~I                                                                          ID,ID61~1~lolol           'I II
    "
                         +  - - - - - - 0 sets bit to output
                         L.._

                                         I sets bit to mput
                                                                                                  ----I      - - C l d e n t i f i e s interrupt
                                                                                                                                disable word
                                                                                                     ' - - - - - - - - O o n ' 1 care
                                                                                               ' - - - - - - - - - - 0 7 = 0 Interrupt disable
                                                                                                                            07 = I Interrupt enable




Figure 1-4. Programming summary for the PIO
460     Z80 ASSEMBLY LANGUAGE SUBROUTINES




           Ml       MO        Mode

            0        0    Output                                    When selecting Mode 3, the next byte must
            0        I    Input                                     set the I/O Register:
            I        0    Bidirectional
            I        I    Bit Control


                                                                    1/0= I Sets bit to input
                                                                    1/0= 0 Sets bit to output
           PIO Mode          Meaning         Control Word

                                             (Binary) (Hex)
                0        Output              00001111 OF
                I        Input               01001111 4F
                2        Bidirectional       10001111 8F
                3        Control             11001111 CF

           Note that bits -4 and 5 are not used and
           could have any values.



Figure 1-5. Mode control for the PIO




                     7   6     5   4     3     2       o   -4--- Bit no.
                    r-...,......,r-..,..-r-T""...,.-TI-O...~Command byte
                                   IL]
                                       t              1.   ---Interrupt vector specified
                                       '----------Output these eight bits when
                                                     an interrupt request is acknowledged


Figure 1-6. Interrupt vector loading format for the PIO
                               APPENDIX B PROGRAMMING l<tFERENCE FOR THE Z80 PIO DEVICE   461

                  7    6   5    4    3   2         o ......--Bitno.
                r-1--r"'1--r"'1x--r"'1x--r"'I-1"'1-)"'1--r"'1-1~Control code



                 TT'+'                                        Mode select code
                                                              Don't care
                                                              00 Output, mode 0
                                                              01 Input, mode I
                                                              10 Bidirectional, mode 2
                                                              II Control, mode 3


Figure B-7. Mode selection format for the PIO




                                     -----
                   7   6   5     4   3   2     I   0 . . . . - Bit no.
                 t Ixlxlxlolollil                              Control code


                           t
                       ---.-'
                                             +L..-____ Interrupt enable control
                        L - - - - - - - - - - - D o n ' t care
                   1...------_______ 0 Disable interrupts
                                                    1 Enable interrupts



Rgure 1-8. Interrupt enable/disable format for the PIO
462      Z80 ASSEMBLY LANGUAGE SUBROUTINES



                     7   654         3   2         o ~Bitno.
                    I I I I I0II II II                    Control code
                                   ~
                    •
                                             t            Interrupt control word
                                                          I if interrupt select mask follows
                                                          o otherwise
                                                          I high input on selected pins is active
                                                          olow input on selected pins is active
                                                          I AND selected pins for interrupt
                                                          o OR selected pins for interrupt
                                                          I Enable interrupts
                                                          o Disable interrupts

Figure 1-,. Interrupt condition-setting format for the PIO
           (mode 3 only)




Table 1-1. PIO Select Logic                            Table 1-2. Addressing of PIO Control Registers
           Signal                                              Register                       Addressing
                               Selected Location
   CE    B/A SEL C/D SEL                                Mode control                D3 = D2 = Dl = Do = I
                                                        Input/ Output control       Next byte after mode control
    0        0           0   . Port A data buffer                                   sets mode 3
    0        0           I     Port A control buffer
                                                        Mask control register       D3 = 0, D2 = Dl = Do = I
    0        I           0     Port B data buffer
    0        I           I     Port B control buffer    Interrupt mask register     Next byte after mask control
    I        X           X     Device not selected                                  register accessed with D 4 = I
                                                        Interrupt enable            D3 = D2 = 0, Dl = Do = I
                                                        Interrupt vector            Do= I
Appendix C ASCII Character
           Set




~
              0     1     2     3    4      5       6      7
LSD
 0    0000
             000
             NUL
                   001
                   DLE
                         010
                         SP
                               011
                               0
                                     100
                                     @
                                           101
                                           P         .
                                                    110   111
                                                           P
 I    0001   SOH   DCI   !     I     A     Q        a      q
 2    0010   STX   DC2   "     2     B     R        b      r
 3    0011   ETX   DC3   #     3     C     S        c      s
 4    0100   EOT   DC4   $     4     D     T        d      t
 5    0101   ENQ   NAK   %     5     E     U        e      u
 6    0110   ACK   SYN   &     6     F     V        f     v
                         ,
 7    0111   BEL   ETB          7    G     W        g     w
 8    1000   BS    CAN    (    8     H     X        h      x
 9    1001   HT    EM     )    9     I     Y        i      y
 A    1010   LF    SUB               J     Z        j      z
                         *
 B    1011   VT    ESC   +      ,    K      [       k      }
 C    1100   FF    FS          <     L      \       I      I
 D    1101   CR    GS    -
                               =     M      ]       m      f
 E
 F
      1110
      1111
             SO
             SI
                   RS
                   US
                          •
                          I
                               >
                                ?
                                     N
                                     0
                                               1\
                                                    n
                                                    0
                                                           -
                                                          DEL
                                           -



                                                                463
Glossary



A
Absolute address. An address that identifies a storage location or an I/O device
  without the use of a base, offset, or other factor. See also Effective address, Relative
  offset.
Absolute addressing. An addressing mode in which the instruction contains the actual
  address required for its execution, as opposed to modes in which the instruction
  contains a relative offset or identifies a base register.
Accumulator. A register that is the implied source of one operand and the destination
  of the result in most arithmetic and logical operations.
Active transition. The edge on a strobe line that sets an indicator. The alternatives are a
  negative edge (l to 0 transition) or a positive edge (0 to 1 transition).
Address. The identification code that distinguishes one memory location or I/O port
  from another and that can be used to select a specific one.
Addressing mode. The method for specifying the addresses to be used in executing an
  instruction. Common addressing modes are direct, immediate, indexed, indirect,
  and relative.
Address register. A register that contains a memory address.
Address space. The total range of addresses to which a particular computer may refer.
ALU. See Arithmetic-logic unit.
Arithmetic-logic unit (ALU). A device that can perform a variety of arithmetic and
  logical functions; function inputs select which one the device performs during a
  particular cycle.

                                                                                    465
466     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Arithmetic shift. A shift operation that keeps the sign (most significant) bit the same.
  In a right shift, this results in copies of the sign bit moving right (called sign
  extension).
Arm. Usually refers specifically to interrupts. See Enable.
Array. A collection of related data items, usually stored in consecutive memory
  addresses.
ASCII (American Standard Code for Information Interchange). A 7-bit character
 code widely used in computers and communications.
Assembler. A computer program that converts assembly language programs into a
  form (machine language) that the computer can execute directly. The assembler
  translates mnemonic operation codes and names into their numerical equivalents
  and assigns locations in memory to data and instructions.
Assembly language. A computer language in which the programmer can use mne-
  monic operation codes, labels, and names to refer to their numerical equivalents.
Asynchronous. Operating without reference to an overall timing source, that is, at
  irregular intervals.
Autodecrementing. The automatic decrementing of an address register as part of the
  execution of an instruction that uses it.
Autoincrementing. The automatic incrementing of an address register as part of the
  execution of an instruction that uses it.
Automatic mode (of a peripheral chip). An operating mode in which the peripheral
  chip produces control signals automatically without specific program intervention.


B
Base address. The address in memory at which an array or table starts. Also called
  starting address or base.
Baud. A measure of the rate at which serial data is transmitted; bits per second,
  including both data bits and bits used for synchronization, error checking, and other
  purposes. Common baud rates are no, 300, 1200, 2400, 4800, 9600, and 19,200.
Baud rate generator. A device that generates the proper time intervals between bits for
  serial data transmission.
BCD (Binary-Coded Decimal). A representation of decimal numbers in which each
 decimal digit is coded separately into a binary number.
Bidirectional. Capable of transporting signals in.either direction.
                                                                       GLOSSARY     467

Binary-coded decimal. See BCD.
Binary search. A search method that divides the set of items to be searched into two
  equal (or nearly equal) parts in each iteration. The part containing the item being
  sought is determined and then used as the set in the next iteration. Each iteration of a
  binary search thus halves the size of the set being searched. This method obviously
  assumes an ordered set of items.
BIOS (Basic Input/Output System). The part of CP I M that allows the operating
  system to use the 110 devices for a particular computer. The computer manufacturer
  or dealer typically supplies the BIOS; Digital Research, the originator of CP 1M,
  provides only a sample BIOS with comments.
Bit test. An operation that determines whether a bit is 0 or I. Usually refers to a logical
  AND operation with an appropriate mask.
Block. An entire group or section, such as a set of registers or a section of memory.
Block comparison (or block compare). A search that extends through a block of
  memory until either the item being sought is found or the entire block is examined.
Block move. Moving an entire set of data from one area of memory to another.
Block search. See Block comparison.
Boolean variable. A variable that has only two possible values, which may be repre-
  sented as true and false or as I and O. See also Flag.
Borrow. A bit that is set to I if a subtraction produces a negative result and to 0 if it
  produces a positive or zero result. The borrow is commonly used to subtract num-
  bers that are too long to be handled in a single operation.
Bounce. Move back and forth between states before reaching a final state. Usually
  refers to mechanical switches that do not open or close cleanly, but rather move back
  and forth between positions for a while before settling down.
Branch instruction. See Jump instruction.
Breakpoint. A condition specified by the user under which program execution is to end
  temporarily, used as an aid in debugging programs. The specification of the condi-
  tions under which execution will end is referred to as setting breakpoints, and the
  deactivation of those conditions is referred to as clearing breakpoints.
BSC (Binary Synchronous Communications or Bisync). An older line protocol often
 used by IBM computers and terminals.
Bubble sort. A sorting technique that works through the elements of an array consecu-
  tively, exchanging an element with its successor if they are out of order.
468      Z80 ASSEMBLY LANGUAGE SUBROUTINES


Buffer. Temporary storage area generally used to hold data before they are transferred
  to their final destinations.
Buffer empty. A signal that is active when all data entered into a buffer or register have
  been transferred to their final destinations.
Buffer full. A signal that is active when a buffer or register is completely occupied with
  data that have not been transferred to their final destinations.
Buffer index. The index of the next available address in a buffer.
Buffer pointer. A storage location that contains the next available address in a buffer.
Bug. An error or flaw in a program.
Byte. A unit of eight bits. May be described as consisting of a high nibble or digit (the
  four most significant bits) and a low nibble or digit (the four least significant bits).
Byte-length. A length of eight bits per item.



c
Call (a subroutine). Transfer control to a subroutine while retaining the information
  required to resume the current program. A call differs from ajump or branch in that
  a call remembers the previous position in the program, whereas a jump or branch
  does not.
Carry. A bit that is I if an addition overflows into the succeeding digit position.
Carry flag. A flag that is I if the last operation generated a carry from the most sig-
  nificant bit and 0 if it did not.
CASE statement. A statement in a high-level computer language that directs the
 computer to perform one of several subprograms, depending on the value of a
 variable. That is, the computer performs the first subprogram if the variable has the
 first value specified, and so on. The computed GO TO statement serves a similar
 function in FORTRAN.
Central processing unit (CPU). The control section of the computer; the part that
  controls its operations, fetches and executes instructions, and performs arithmetic
  and logical functions.
Checksum. A logical sum that is included in a block of data to guard against recording
  or transmission errors. Also referred to as longitudinal parity or longitudinal
 redundancy check (LRC).
Circular shift. See Rotate.
                                                                     GLOSSARY     469

Cleaning the stack. Removing unwanted items from the stack, usually by adjusting the
  stack pointer.
Clear. Set to zero.
Clock. A regular timing signal that governs transitions in a system.
Close (a file). To make a file inactive. The final contents of the file are the last
  information the user stored in it. The user must generally close a file after working
  with it.
Coding. Writing instructions in a computer language.
Combo chip. See Multifunction device.
Command register. See Control register.
Comment. A section of a program that has no function other than documentation.
 Comments are neither translated nor executed, but are simply copied into the
 program listing.
Complement. Invert; see also One's complement, Two's complement.
Concatenation. Linking together, chaining, or uniting in a series. In string operations,
  concatenation refers to the placing of one string after another.
Condition code. See Flag.
Control (or command) register. A register whose contents determine the state of a
 transfer or the operating mode of a device.
CP/M (Control Programl Microcomputer). A widely used disk operating system for
 Z80-based computers developed by Digital Research (Pacific Grove, CA).
CTC (Clock/Timer Circuit). A programmable timer chip in the Z80 family. A CTC
 contains four 8-bit timers, range controls (prescalers), and other circuits.
Cyclic redundancy check (CRC). An error-detecting code generated from a poly-
  nomial that can be added to a block of data or a storage area.

D
Data accepted. A signal that is active when the most recent data have been transferred
 successfully.
Data direction register. A register that determines whether bidirectional 110 lines are
 being used as inputs or outputs.
Data-link control. Conventions governing the format and timing of data exchange
 between communicating systems. Also called a protocol.
470     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Data-link controller. A chip that performs all or most of the functions required by a
 data-link control. The SIO is a data-link controller in the Z80 family.
Data ready. A signal that is active when new data are available to the receiver. Same as
 valid data.
DDCMP (Digital Data Communications Message Protocol). A protocol that sup-
 ports any method of physical data transfer (synchronous or asynchronous, serial or
 parallel).
Debounce. Convert the output from a contact with bounce into a single clean transi-
  tion between states. Debouncing is most commonly applied to outputs from
  mechanical keys or switches that bounce back and forth before settling into their
 final positions.
Debounce time. The amount of time required to debounce a change of state.
Debugger. A systems program that helps users locate and correct errors in their
  programs. Some versions are referred to as dynamic debugging tools, or DDTs after
  the famous insecticide. Popular CP 1M debuggers are SID (Symbolic Instruction
  Debugger) and ZSID (Z80 Symbolic Instruction Debugger) from Digital Research.

Debugging. Locating and correcting errors in a program.

Device address. The address of a port associated with an 110 device.

Diagnostic. A program that checks the operation of a device and reports its findings.

Digit shift. A shift of one BCD digit position or four bit positions.

Direct addressing. An addressing mode in which the instruction contains the address
  required for its execution. Note that the standard Z80 assembler requires paren-
  theses around an address that is to be used directly.
Disable (or disarm). Prevent an activity from proceeding or a signal (such as an
  interrupt) from being recognized.
Disarm. Usually refers specifically to interrupts. See Disable.
Double word. When dealing with microprocessors, a unit of 32 bits.
Driver. See 110 driver.
Dump. A facility that displays the contents of an entire section of memory or group of
 registers on an output device.
Dynamic allocation (of memory). The allocation of memory for a subprogram from
 whatever is available when the subprogram is called. An alternative is static alloca-
 tion of a fixed area of storage to each subprogram. Dynamic allocation often
                                                                           GLOSSARY      471
    reduces overall memory usage because subprograms can share areas; it does,
    however, generally require additional execution time and overhead spent in memory
    management.


E
EBCDIC (Expanded Binary-Coded Decimal Interchange Code). An 8-bit character
  code often used in large computers.
Echo. Reflect transmitted information back to the transmitter; send back to a terminal
  the information received from it.
Editor. A program that manipulates text material and allows the user to make
  corrections, additions, deletions, and other changes. A popular CP / M editor is ED
  from Digital Research.
Effective address. The actual address used by an instruction to fetch or store data.
EIA RS-232. See RS-232.
Enable (or arm). Allow an activity to proceed or a signal (such as an interrupt) to be
  recognized.
Endless loop orjump-to-se/finstruction. An instruction that transfers control to itself,
  thus executing indefinitely (or until a hardware signal interrupts it).
Error-correcting code. A code that the receiver can use to correct errors in messages;
  the code itself does not contain any additional message.
Error-detecting code. A code that the receiver can use to detect errors in messages; the
  code itself does not contain any additional message.
Even parity. A I-bit error-detecting code that makes the total number of 1 bits in a unit
  of data (including the parity bit) even.
EXCLUSIVE OR function. A logical function that is true if either, but not both, of its
 inputs is true. It is thus true if its inputs are not equal (that is, if one of them is a logic
  I and the other is a logic 0).
Extend (a number). Add digits to a number to conform to a format without changing
  its value. For example, one may extend an 8-bit unsigned result with zeros to fill a
  16-bit word.
External reference. The use in a program of a name that is defined in another program.

F
F register. See Flag register.
472      Z80 ASSEMBLY LANGUAGE SUBROUTINES


Field. A set of one or more positions within a larger unit, such as a byte, word, or
  record.
File. A collection of related information that is treated as a unit for purposes of storage
   or retrieval.
Fill. Placing values in storage areas not previously in use, initializing memory or
   storage.
Flag (or condition code or status bit). A single bit that indicates a condition within the
  computer, often used to choose between alternative instruction sequences.
Flag (software). An indicator that is either on or off and can be used to select between
  two alternative courses of action. Boolean variable and semaphore are other terms
  with the same meaning.
Flag register. A Z80 register that holds all the flags. Also called the (processor) status
  register.
Free-running mode. An operating mode for a timer in which it indicates the end of a
  time interval and then starts another of the same length. Also called a continuous
  mode.
Function key. A key that causes a system to execute a procedure or perform a function
  (such as clearing the screen of a video terminal).

G
Global variable. A variable that is used in more than one section of a computer pro-
  gram rather than only locally.

H
Handshake. An asynchronous transfer in which sender and receiver exchange signals
 to establish synchronization and to indicate the status of the data transfer. Typically,
 the sender indicates that new data are available and the receiver reads the data and
 indicates that it is ready for more.
Hardware stack. A stack that the computer manages automatically when executing
 instructions that use it.
Head (of a queue). The location of the item most recently entered into a queue.
Header, queue. See Queue header.
Hexadecimal (or hex). Number system with base 16. The digits are the decimal
 numbers 0 through 9, followed by the letters A through F (representing 10 through
  15 decimal).
                                                                    GLOSSARY     473

Hex code. See Object code.
High-level language. A programming language that is aimed toward the solution of
  problems, rather than being designed for convenient conversion into computer
  instructions. A compiler or interpreter translates a program written in a high-level
  language into a form that the computer can execute. Common high-level languages
  include Ada, BASIC, C, COBOL, FORTRAN, and Pascal.




Immediate addressing. An addressing mode in which the data required by an instruc-
  tion are part of the instruction. The data immediately follow the operation code in
  memory.
Index. A data item used to identify a particular element of an array or table.
Indexed addressing. An addressing mode in which the address is modified by the
  contents of an index register to determine the effective address (the actual address
  used).
Indexed indirect addressing. See Preindexing.
Index register. A register that can be used to modify memory addresses.
Indirect addressing. An addressing mode in which the effective address is the contents
  of the address included in the instruction, rather than the address itself.
Indirect indexed addressing. See Postindexing.
Indirect jump. A jump instruction that transfers control to the address stored in a
  register or memory location rather than to a fixed address.
Input / output control block (lOCB). A group of storage locations that contains the
  information required to control the operation of an I/O device. Typically included
  in the information are the addresses of routines that perform operations such as
  transferring a single unit of data or determining device status.
Input / output control system (IOCS). A set of computer routines that controls the
  performance of I/O operations.
Instruction. A group of bits that defines a computer operation and is part of the
  instruction set.
Instruction cycle. The process of fetching, decoding, and executing an instruction.
Instruction execution time. The time required to fetch, decode, and execute an
  instruction.
474     Z80 ASSEMBLV LANGUAGE SUBROUTINES


InstructionJetch. The process of addressing memory and reading an instruction into
  the CPU for decoding and execution.

Instruction length. The amount of memory needed to store a complete instruction.

Instruction set. The set of general-purpose instructions available on a given computer;
  the set of inputs to which the CPU will produce a known response when they are
  fetched, decoded, and executed.
Interpolation. Estimating values of a function at points between those at which the
  values are already known.

Interrupt. A signal that temporarily suspends the computer's normal sequence of
  operations and transfers control to a special routine.
Interrupt-driven. Dependent on interrupts for its operation; may idle until it receives
  an interrupt.

Interrupt flag. A bit in the input/ output section that is set when an event occurs that
  requires servicing by the CPU. Typical events include an active transition on a
  control line and the exhaustion of a count by a timer.
Interrupt mask (or interrupt enable). A bit that determines whether interrupts will be
  recognized. A mask or disable bit must be cleared to allow interrupts, whereas an
  enable bit must be set.

Interrupt request. A signal that is active when a peripheral is requesting service, often
  used to cause a CPU interrupt. See also Interrupt flag.
Interrupt service routine. A program that performs the actions required to respond to
  an interrupt.

Interrupt vector. An address to which an interrupt directs the computer, usulllly the
  starting address of a service routine.
Inverted borrow. A bit that is set to 0 if a subtraction produces a negative result and to
  1 if it produces a positive or 0 result. An inverted borrow can be used like a true
  borrow, except that the complement of its value (i.e., 1 minus its value) must be used
  in the extension to longer numbers.

IOCB. See Input/ output control block.

laCs. See Input/ output control system.

1/ a device table. A table that establishes the correspondence between the logical
   devices to which programs refer and the physical devices that are actually used in
   data transfers. An I/O device table must be placed in memory in order to run a
                                                                       GLOSSARV     475

    program that refers to logical devices on a computer with a particular set of actual
    (physical) devices. The 110 device table may, for example, contain the starting
    addresses of the 110 drivers that handle the various devices.
110 driver. A computer program that transfers data to or from an 110 device, also
  called a driver or 110 utility. The driver must perform initialization functions and
  handle status and control, as well as physically transfer the actual data.
Isolated input I output. An addressing method for 110 ports that uses a decoding
  system distinct from that used by the memory section. I 10 ports thus do not occupy
  memory addresses.


J
Jump instruction (or branch instruction). An instruction that places a new value in the
  program counter, thus departing from the normal one-step incrementing. Jump
  instructions may be conditional; that is, the new value may be placed in the program
  counter only if a condition holds.
Jump table. A table consisting of the starting addresses of executable routines, used to
  transfer control to one of them.


L
Label. A name attached to an instruction or statement in a program that identifies the
  location in memory of the machine language code or assignment produced from
  that instruction or statement.
Latch. A device that retains its contents until new data are specifically entered into it.
Leading edge (of a binary pulse). The edge that marks the beginning of a pulse.
Least significant bit. The rightmost bit in a group of bits, that is, bit 0 of a byte or a
  l6-bit word.
Library program. A program that is part of a collection of programs and is written and
  documented according to a standard format.
LIFO (last-in,first-out) memory. A memory that is organized according to the order in
  which elements are entered and from which elements can be retrieved only in the
  order opposite of that in which they were entered. See also Stack.
Linearization. The mathematical approximation of a function by a straight line
  between two points at which its values are known.
Linked list. A list in which each item contains a pointer (or link) to the next item. Also
  called a chain or chained list.
476     Z80 ASSEMBLY LAI\JGUAGE SUBROUTI\JES


List. An ordered set of items.
Logical device. The input or output device to which a program refers. The actual or
  physical device is determined by looking up the logical device in an 110 device table
  -a table containing actual I 10 addresses (or starting addresses for 110 drivers)
  corresponding to the logical device numbers.
Logical shift. A shift operation that moves zeros in at either end as the original data are
  shifted.
Logical sum. A binary sum with no carries between bit positions. See also Checksum,
  EXCLUSIVE OR function.
Longitudinal parity. See Checksum.
Longitudinal redundancy check (LRC). See Checksum.
Lookup table. An array of data organized so that the answer to a problem may be
  determined merely by selecting the correct entry (without any calculations).
Low-level language. A computer language in which each statement is translated
  directly into a single machine language instruction.



M
Machine language. The programming language that the computer can execute directly
 with no translation other than numeric conversions.
Maintenance (of programs). Updating and correcting computer programs that are in
 use.
Majority logic. A combinational logic function that is true when more than half the
 inputs are true.
Mark. The 1 state on a serial data communications line.
Mask. A bit pattern that isolates one or more bits from a group of bits.
Maskable interrupt. An interrupt that the system can disable.
Memory capacity. The total number of different memory addresses (usually specified
 in bytes) that can be attached to a particular computer.
Memory-mapped 1/ O. An addressing method for I 10 ports that uses the same
 decoding system used by the memory section. The 110 ports thus occupy memory
 addresses.
Microcomputer. A computer that has a microprocessor as its central processing unit.
                                                                           GLOSSARY      477
Microprocessor. A complete central processing unit for a computer constructed from
  one or a few integrated circuits.
Mnemonic. A memory jogger, a name that suggests the actual meaning or purpose of
 the object to which it refers.
Modem (Modulator/demodulator). A device that adds or removes a carrier
 frequency, thereby allowing data to be transmitted on a high-frequency channel or
 received from such a channel.
Modular programming. A programming method whereby the overall program is
 divided into logically separate sections or modules.
Module. A part or section of a program.
Monitor. A program that allows the computer user to enter programs and data, run
 programs, examine the contents of the computer's memory and registers, and utilize
 the computer's peripherals. See also Operating system .
      •
Most significant bit. The leftmost bit in a group of bits, that is, bit 7 of a byte or bit 15 of
 a 16-bit word.
Multifunction device. A device that performs more than one function in a computer
 system; the term commonly refers to devices containing memory, input/ output
 ports, timers, and so forth.
Multitasking. Executing many tasks during a single period of time, usually by working
 on each one for a specified part of the period and suspending tasks that must wait for
 input, output, the completion of other tasks, or external events.
Murphy's Law. The famous maxim that "whatever can go wrong, will."



N
Negate. Find the two's complement (negative) of a number.
Negative edge (of a binary pulse). A I-to-O transition.
Negative flag. See Sign flag.
Negative logic. Circuitry in which a logic zero is the active or ON state.
Nesting. Constructing programs in a hierarchical manner with one level contained
  within another. The nesting level is the number of transfers of control required to
  reach a particular part of a program without ever returning to a higher level.
Nibble. A unit of four bits. A byte (eight bits) may be described as consisting ofa high
  nibble (four most significant bits) and a low nibble (four least significant bits).
478     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Nine ~ complement. The result of subtracting a decimal number from a number having
  nines in all digit positions.
Non-maskable interrupt. An interrupt that cannot be disabled within the CPU.
Non-volatile memory. A memory that retains its contents when power is removed.
Nop (or no operation). An instruction that does nothing except increment the
  program counter.
Normalization (of numbers). Adjusting a number into a regular or standard format. A
 typical example is the scaling of a binary fraction to make its most significant bit 1.



o
Object code (or object program). The program that is the output of a translator
 program, such as an assembler-usually a machine language program reaay for
 execution.
Odd parity. A I-bit error-detecting code that makes the total number of 1 bits in a unit
 of data (including the parity bit) odd.
One ~ complement. A bit-by-bit logical complement of a number, obtained by replac-
  ing each 0 bit with a 1 and each 1 bit with a o.
One-shot. A device that produces a pulse output of known duration in response to a
 pulse input. A timer operates in a one-shot mode when it indicates the end of a single
 interval of known duration.
Open (a file). Make a file ready for use. The user generally must open a file before
 working with it.
Operating system (OS). A computer program that controls the overall operations of a
 computer and performs such functions as assigning places in memory to programs
 and data, scheduling the execution of programs, processing interrupts, and control-
 ling the overall input/ output system. Also known as a monitor, executive, or
 master-control program, although the term monitor is usually reserved for a simple
 operating system with limited functions.
Operation code (op code). The part of an instruction that specifies the operation to be-
 performed.
OS. See Operating system.
Overflow (of a stack). Exceeding the amount of memory allocated to a stack.
Overflow,   two~   complement. See Two's complement overflow.
                                                                     GLOSSARY     479
p
Packed decimal. A binary-coded decimal format in which each byte contains two
  decimal digits.
Page. A subdivision of the memory. In byte-oriented computers, a page is generally a
  256-byte section of memory in which all addresses have the same eight most
  significant bits (or page number). For example, page C6 would consist of memory
  addresses C600 through C6FF.
Paged address. The identifier that characterizes a particular memory address on a
  known page. In byte-oriented computers, this is usually the eight least significant
  bits of a memory address.
Page number. The identifier that characterizes a particular page of memory. In
  byte-oriented computers, this is usually the eight most significant bits of a memory
  address.
Parallel interface. An interface between a CPU and input or output devices that handle
  data in parallel (more than one bit at a time). The PIa is a parallel interface in the
  Z80 family.
Parameter. An item that must be provided to a subroutine or program for it to be
  executed.
Parity. A I-bit error-detecting code that makes the total number of I bits in a unit of
  data, including the parity bit, odd (odd parity) or even (even parity). Also called
  vertical parity or vertical redundancy check (VRC).
Passing parameters. Making the required parameters available to a subroutine.
Peripheral ready. A signal that is active when a peripheral can accept more data.
Physical device. An actual input or output device, as opposed to a logical device.
PIO(Parallel Input( Output Device}. A parallel interface chip in the Z80 family. A PIa
  contains two 8-bit I( a ports, four control lines, and other circuitry.
Pointer. A storage place that contains the address of a data item rather than the item
  itself. A pointer tells where the item is located.
Polling. Determining which I( a devices are ready by examining the status of one
  device at a time.
Polling interrupt system. An interrupt system in which a program determines the
  source of a particular interrupt by examining the status of potential sources one at a
  time.
Pop. Remove an operand from a stack.
480     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Port. The basic addressable unit of the computer's input/ output section.
Positive edge (of a binary pulse). A O-to-l transition.
Postdecrementing. Decrementing an address register after using it.
Postincrementing. Incrementing an address register after using it.
Postindexing. An addressing mode in which the effective address is determined by first
  obtaining the base address indirectly and then indexing from that base address. The
  "post" refers to the fact that the indexing is performed after the indirection.
Power fail interrupt. An interrupt that informs the CPU of an impending loss of power.
Predecrementing. Decrementing an address register before using it.
Preincrementing. Incrementing an address register before using it.
Preindexing. An addressing mode in which the effective address is determined by
  indexing from the base address and then using the indexed address indirectly. The
  "pre" refers to the fact that the indexing is performed before the indirection. Of
  course, the array starting at the given base address must consist of addresses that can
  be used indirectly.
Priority interrupt system. An interrupt system in which some interrupts have
  precedence over others; that is, they will be serviced first or can interrupt the others'
  service routines.
Program counter (PC register). A register that contains the address of the next
  instruction to be fetched from memory.
Programmable I/O device. An I/O device that can have its mode of operation
  determined by loading registers under program control.
Programmable peripheral chip (or programmable peripheral interface). A chip that.
  can operate in a variety of modes; its current operating mode is determined by
  loading control registers under program control.
Programmable timer. A device that can handle a variety of timing tasks, including the
  generation of delays, under program control. The CTC is a programmable timer in
  the Z80 family.
Programmed input/output. Input or output performed under program control
  without using interrupts or other special hardware techniques.
Program relative addressing. A form of relative addressing in which the base address
  is the program counter. Use of this form of addressing makes it easy to move
  programs from one place in memory to another.
Protocol. See Data-link control.
                                                                         GLOSSARY     481
Pseudo-operation (or pseudo-op or pseudo-instruction). An assembly language
  operation code that directs the assembler to perform some action but does not
  result in the generation of a machine language instruction.
Pull. Remove an operand from a stack; same as pop.
Push. Store an operand in a stack.


Q
Queue. A set of tasks, storage addresses, or other items that are used in a first-in,
 first-out manner; that is, the first item entered into the queue is the first to be used or
 removed.
Queue header. A set of storage locations describing the current location and status of
 a queue.


R
RAM. See Random-access memory.
Random-access (read/write) memory (RAM). A memory that can be both read and
  altered (written) in normal operation.
Read-only memory (ROM). A memory that can be read but not altered in normal
  operation.
Ready for data. A signal that is active when the receiver can accept more data.
Real-time. In synchronization with the actual occurrence of events.
Real-time clock. A device that interrupts a CPU at regular time intervals.
Real-time operating system. An operating system that can act as a supervisor for
  programs that have real-time requirements. May also be referred to as a real-time
  executive or real-time monitor.
Reentrant. A program or routine that can be executed concurrently while the same
  routine is being interrupted or otherwise held in abeyance.
Refresh. Rewriting data into a memory before its contents are lost. Dynamic RAM
  must be refreshed periodically (typically every few milliseconds) or it will lose its
  contents spontaneously.
Register. A storage location inside the CPU.
Register pair. In Z80 terminology, two 8-bit registers that can be referenced as a 16-bit
  unit.
482      Z80 ASSEMBLY LANGUAGE SUBROUTINES


Relative addressing. An addressing mode in which the address specified in the
  instruction is the offset from a base address.
Relative offset. The difference between the actual address to be used in an instruction
  and the current value of the program counter.
Relocatable. Can be placed anywhere in memory without changes; that is, a program
  that can occupy any set of consecutive memory addresses.
Return (from a subroutine). Transfer control back to the program that originally
  called the subroutine and resume its execution.
ROM. See Read-only memory.
Rotate. A shift operation that treats the data as if they were arranged in a circle; that is,
  as if the most significant and least significant bits were connected either directly or
  through a Carry bit.
Row major order. Storing elements of a multidimensional array in memory by
 changing the indexes starting with the rightmost first. For example, if a typical
 element is A(I,J,K) and the elements begin with A(O,O,O), the order is A(O,O,O),
 A(O,O, l), ... ,A(O, I ,0), A(O, 1,1 ), .... The opposite technique (changing the leftmost
 index first) is called column major order.
RS-232 (or EIA RS-232). A standard interface for the transmission of digital data,
  sponsored by the Electronic Industries Association of Washington, D.C. It has been
  partially superseded by RS-449.


s
Scheduler. A program that determines when other programs should be started and
  terminated.
Scratchpad. An area of memory that is generally easy and quick to use for storing
  variable data or intermediate results.
SDLC. (Synchronous Data Link Control). The successor protocol to BSC for IBM
  computers and terminals.
Semaphore. See Flag.
Serial. One bit at a time.
Serial interface. An interface between a CPU and input or output devices that handle
  data serially. The SIO is a popular serial interface chip in the Z80 family. See also
  UART.
Setpoint. The value of a variable that a controller is expected to maintain.
                                                                      GLOSSARY     483
Shift instruction. An instruction that moves all the bits of the data by a certain
  number of bit positions, just as in a shift register.
Signed number. A number in which one or more bits represent whether the number is
  positive or negative. A common format is for the most significant bit to represent
  the sign (0 = positive, 1 = negative).
Sign extension. The process of copying the sign (most significant) bit to the right as in
  an arithmetic shift. Sign extension preserves the sign when two's complement
  numbers are being divided or normalized.
SignJlag. A flag that contains the most significant bit of the result of the previous
  operation. It is sometimes called a negative Jlag, since a value of 1 indicates a
  negative signed number.
Signfunction. A function that is 0 if its parameter is positive and 1 if its parameter is
  negative.
SID (Serial Input/ Output Device). A serial interface chip in the Z80 family. An SIO
  can be used as an asynchronous or synchronous serial interface (i.e., as a UART or
  USRT) or as a data-link controller.
Size (of an array dimension). The distance in memory between elements that are
  ordered consecutively in a particular dimension; the number of bytes between the
  starting address of an element and the starting address of the element with an index
  one larger in a particular dimension but the same in all other dimensions.
Software delay. A program that has no function other than to waste time.

Software interrupt. See Trap.

Software stack. A stack that is managed by means of specific instructions, as opposed
  to a hardware stack which the computer manages automatically.
Source code (or source program). A computer program written in assembly language
  or in a high-level language.

Space. The zero state on a serial data communications line.
Stack. A section of memory that can be accessed only in a last-in, first-out manner.
  That is, data can be added to or removed from the stack only through its top; new
  data are placed above the old data and the removal of a data item makes the item
  below it the new top.
Stack pointer. A register that contains the address of the top of a stack.
Standard (or 8,4,2, 1) BCD. A BCD representation in which the bit positions have the
  same weight as in ordinary binary numbers.
484     Z80 ASSEMBLY LANGUAGE SUBROUTINES


Standard teletypewriter. A teletypewriter that operates asynchronously at a rate of
  ten characters per second.
Start bit. A I-bit signal that indicates the start of data transmission by an asynchro-
  nous device.
Static allocation (of memory). Assignment of fixed storage areas for data and pro-
  grams; an alternative is dynamic allocation, in which storage areas are assigned
  when they are needed.
Status register. A register whose contents indicate the current state or operating mode
  of a device.
Status signal. A signal that describes the current state of a transfer or the operating
  mode of a device.
Stop bit. A I-bit signal that indicates the end of data transmission by an asynchro-
  nous device.
String. An array (set of data) consisting of characters.
String functions. Procedures that allow the programmer to operate on data consist-
  ing of characters rather than numbers. Typical functions are insertion, deletion,
  concatenation, search, and replacement.

Strobe. A signal that identifies or describes another set of signals and can be used to
  control a buffer, latch, or register.
Subroutine. A subprogram that can be executed (called) from more than one place in
  a main program.
Subroutine call. The process whereby a computer transfers control from its current
  program to a subroutine while retaining the information required to resume the
  current program.
Subroutine linkage. The mechanism whereby a computer retains the information
  required to resume its current program after it completes the execution of a
  subroutine.
Suspend (a task). Halt execution and preserve the status of a task until some future
  time.
Synchronization (or sync) character. A character that is used only to syncllf"on~ethe
  transmitter and the receiver.
Synchronous. Operating according to an overall timing source or clock, that is, at
  regular intervals.
                                                                      GLOSSARY     485

Systems software. Programs that perform administrative functions or aid in the
  development of other programs but do not actually perform any of the computer's
  workload.

T
Tail (of a queue). The location of the oldest item in the queue, that is, the earliest
  entry.
Task. A self-contained program that can serve as part of an overall system under the
  control of a supervisor.
Task status. The set of parameters that specifies the current state of a task. A task can
  be suspended and resumed as long as its status is saved and restored.
Teletypewriter. A device containing a keyboard and a serial printer that is often used in
  communications and with computers. Also referred to as a Teletype (a registered
  trademark of Teletype Corporation of Skokie, Illinois) or TTY.
Ten s complement. The result of subtracting a decimal number from zero (ignoring the
  minus sign); the nine's complement plus one.
Terminator. A data item that has no function other than to signify the end of an array.
Threaded code. A program consisting of subroutines, each of which automatically
  transfers control to the next one upon its completion.
Timeout. A period during which no activity is allowed to proceed; an inactive period.
Top of the stack. The address containing the item most recently entered into the
  stack.
Trace. A debugging aid that provides information about a program while the pro-
  gram is being executed. The trace usually prints all or some of the intermediate
  results.
Trailing edge (of a binary pulse). The edge that marks the end of a pulse.
Translate instruction. An instruction that converts its operand into the correspond-
  ing entry in a table.
Transparent routine. A routine that operates without interfering with the operations
  of other routines.
Trap (or software interrupt). An instruction that forces a jump to a specific (CPV-
  dependent) address, often used to produce breakpoints or to indicate hardware or
  software errors.
True borrow. See Borrow.
486    Z80 ASSEMBLY LANGUAGE SUBROUTINES


True comparison. A comparison that finds the two operands to be equal.
Two's complement. A binary number that, when added to the original number in a
 binary adder, produces a zero result. The two's complement of a number may be
  obtained by subtracting the number from zero or by adding I to the one's com-
  plement.
Two ~ complement overflow. A situation in which a signed arithmetic operation
  produces a result that cannot be represented correctly; that is, the magnitude
  overflows into the sign bit.

u
UART(Universal Asynchronous Receiver/Transmitter). An LSI device that acts as
 an interface between systems that handle data in parallel and devices that handle
 data in asynchronous serial form.
Underflow (of a stack). Attempting to remove more data from a stack than has been
 entered into it.
Unsigned number. A number in which all the bits are used to represent magnitude.
USART (Universal Synchronous/ Asynchronous Receiver/Transmitter). An LSI
 device (such as the SIO) that can serve as either a UART or a USRT.
USRT (Universal Synchronous Receiver/Transmitter). An LSI device that acts as an
 interface between systems that handle data in parallel and devices that handle data
 in synchronous serial form.
Utility. A general-purpose program, usually supplied by the computer manufacturer
  or part of an operating system, that executes a standard or common operation such
  as sorting, converting data from one format to another, or copying a file.

v
Valid data. A signal that is active when new data are available to the receiver.
Vectored interrupt. An interrupt that produces an identification code (or vector) that
  the CPU can use to transfer control to the appropriate service routine. The process
  whereby control is transferred to the service routine is called vectoring.
Volatile memory. A memory that loses its contents when power is removed.

w
Walking bit test. A procedure whereby a single I bit is moved through each bit
 position in an area of memory and a check is made as to whether it can be read back
 correctly.
                                                                        GLOSSARY     487

Word. The basic grouping of bits that a computer can process at one time. When
 dealing with microprocessors, the term often refers to a 16-bit unit of data.
Word boundary. A boundary between 16-bit storage units containing two bytes of
 information. If information is being stored in word-length units, only pairs of bytes
 conforming to (aligned with) word boundaries contain valid information. Mis-
 aligned pairs of bytes contain one byte from one word and one byte from another.
Word-length. A length of 16 bits per item.
Wraparound. Organization in a circular manner as if the ends were connected. A
 storage area exhibits wraparound if operations on it act as if the boundary
 locations were contiguous.
Write-only register. A register that the CPU can change but cannot read. If a program
 must determine the contents of such a register, it must save a copy of the data
 placed there.

z
Zero flag. A flag that is 1 if the last operation produced a result of zero and 0 if it did
  not.
Zoned decimal. A binary-coded decimal format in which each byte contains a single
  decimal digit.
Index

A                                                 AND,85-86
                                                    clearing bits, 18, 19, 85
A register. See Accumulator                         masking, 268, 271
Abbreviations, recognition of, 289, 297, 298        testing bits, 18, 19
Absolute branches, 3-4                            Apostrophe indicating ASCII character x
Absolute value, 82-83, 84-85, 186, 222-23         Arithmetic                              '
Accumulator (register A), 5, 6, 7, 8, 9
                                                    BCD, 72-78, 248-66
  clearing, 15                                      binary, 16-18,72-80,217-47
  decimal operations, 73, 74, 124                   decimal, 72-78, 248-66
  decision sequences, 31                            8-bit, 16-18,72-80
  functions, 5, 6, 7                                mUltiple-precision, 41-42, 228-66
  instructions, 7                                   16-bit, 73-80, 217-27
  special features, 2, 8                          Arithmetic expressions, evaluation of, 132
  testing, 92                                     Arithmetic instructions, 72-84
Accumulator rotates, 3, 20, 23                      addressing modes, 2
ADC, 42, 73-74                                      8-bit, 445, 446
  decimal version, 73                               mUltiple operands, 16
  result, 42                                        16-bit, 143,447
  rotate (ADC A,A), 91                            Arithmetic shift, 80, 89, 273-75
ADC, 42, 73-74                                    Arrays, 33-38, 128-37, 319-55
  logical shifts (A, HL, xy), 23, 35, 89            addresses, 39, 129-30, 131,352-55
Addition                                            initialization, 195-97
  BCD, 72, 73, 248-50                               manipulation, 33-38
  binary, 16,41-42,72-74,228-30
                                                  ASCII, 150, 463
  decimal, 72, 73, 248-50
                                                     assembler notations, x
  8-bit, 16, 72, 73
                                                     control characters, 357
  multiple-precision, 41-42, 228-30 248-50
                                                     conversions, 172-94
  16-bit, 72-73, 74                  '
                                                     table, 463
Addition instructions
                                                  ASCII to EBCDIC conversion, 189-91
  with Carry, 42, 73-74
                                                  Assembler
  without Carry, 16, 72-73
                                                     defaults, x, 149, 155, 455
Address addition, 3, 4, 33, 34
                                                     error recognition, 155-56
Address arrays, 35, 39
                                                     format, x, 455
Address format in memory (upside-down) 5 11
Addressing modes, 10, 13                   ' ,       pseudo-operations, x, 455
                                                     summary, 455
  arithmetic and logical instructions 2
                                                  Autoindexing, 129-34
  autoindexing, 129-34                 '
                                                  Autopostdecrementing, 133-34
  default (immediate), 17, 149
                                                  Autopostincrementing, 130-31
  direct, 10-11, 13,94,95,96,97
                                                  Autopredecrementing, 131-32
  immediate, 11, 95
                                                  Autopreincrementing, 129-30
  indexed, 3, 12, 14, 103, 127-29
                                                  Auxiliary carry (Ad flag, ix. See also Half-carry
  !ndirect, 2, 3, 11-12, 13,94-95,96-97, 126-27
 Jump and call instructions, 148
  postindexed, 136-37                             B
  preindexed, 134-36                              B (indicating binary number), x
  register, 2                                     B register, special features of, 5, 6, 9, 30, 32, 54
  register indirect, 2                            Backspace, destructive, 362-63
Add/ subtract (N) flag, ix, 74                    Base a~dress of an array or table, 33-35, 38-39
Adjust instructions, 124                          BC regIster pair, 5, 9, 12, 36
AF register pair, 12                              BCD (decimal) arithmetic, 72-78, 248-66
Aligning bit fields, 272                          BCD representation, 150
Alternate (primed) registers, 4, 96, 97           BCD to binary conversion, 170-71


                                                                                                         489
490      Z80 ASSEMBLY LANGUAGE SUBROUTINES


BOOS calls (in CP 1M), 359-63, 366-67, 379-84   Carry (C) flag (continued)
  table, 357                                      shifts, 3, 20
Bidirectional mode of PIO, 62                     subtracting from accumulator, 76
Bidirectional ports, 61-62, 63-64, 158            subtraction, 42, 76
Binary search, 331-35                           Case statements, 39
Binary to BCD conversion, 167-69                Character manipulation, 39-40. See also String
BIT, 18, 19, 93-94, 341                           manipUlation
Bit field extraction, 267-69                    Checksum, 87. See also Parity
Bit field insertion, 270-72                     Circular shift (rotation), 20-22, 91-92, 282-87
Bit manipulation, 18-20,85-87,88,93-94, 101,    Cleaning the stack, 49-51
  102,267-72                                    Clear instructions, 100-01
  instructions, 449                             Clearing accumulator, 100
Block compare, 35-38, 288-91,444                Clearing an array, 196-97, 258, 262
  flags, 37                                     Clearing bits, 18, 19, 85, 101
  registers, 36, 37                             Clearing flags, 86
Block inputl output instructions, 54-55, 452    Clearing memory, 258, 262
  initialization, 385, 387                      Clearing peripheral status, 61-62, 157, 158, 159,
  limitations, 54                                 389,399
  registers, 54                                 Clock interrupt, 425-32
Block move, 35-38, 99, 198-200                  Code conversion, 40-41, 167-94
Block search, 444. See also Block compare       Colon (delimiter after label), x
Boolean algebra, 18-20                          Command register. See Control register
Borrow, 27, 76                                  Commands, execution of, 134
Branch instructions, 24-31, 102-18, 450         Comment, x
  absolute branches, 3-4                        Common programming errors, 139-59
  conditional branches, 104-18                    interrupt service routines, 158-59
  decision sequences, 31                          110 drivers, 156-58
  relative branches, 3-4, 32                    Communications between main program and
  signed branches, 112-13                         interrupt service routines, 159, 394-95,
  unconditional branches, 102-04                  413-14
  unsigned branches, 113-18                     Communications reference, 369
Buffered interrupts, 413-24                     Compacting a string, 311
Byte shift, 181                                 Comparison instructions, 81-82
                                                  bit-by-bit (logical EXCLUSIVE OR), 81
C                                                 Carry flag, 27, 144
C register, special use of, 6, 9, 54              decimal, 266
Calendar, 425-32                                  multiple-precision, 245-47
Call instructions, 118-20,451                     operation, 26
Carry (C) flag, 453                               16-bit, 81-82, 225-27
  adding to accumulator, 72                       string, 288-91
  arithmetic applications, 41-42                  Zero flag, 26
  borrow, 142                                   Complementing (inverting) bits, 18, 19, 20, 88
  branches, 27-28                               Complementing the accumulator, 87-88
  clearing, 101                                 Complement (logical NOn instructions, 87-89
  comparison instructions, 27-28, 142, 144      Concatenation of strings, 292-96
  decimal arithmetic, 72, 74                    Condition code. See Flags; Status register
  decrement instructions (no effect), 4         Conditional call instructions, 120
  extending across accumulator, 84              Conditional jump instructions, 104-18
  increment instructions (no effect), 4           execution time (variable), 450
  instructions affecting, 3, 453                Conditional return instructions, 120
  inverted borrow, 76, 142                      Control characters (ASCII), 357
  logical instructions, 3                         deletion, 362-63
  mUltiple-precision arithmetic, 41-42            printing, 360
  position in F register, ix, 434               Control register, 59-64, 157-58
  SBC,42                                        Control signal, 57-58
                                                                                         INDEX     491
Copying a substring, 302-07                         Direct addressing, 10-11, 13
Conventions, 5                                        arithmetic and logical instructions, lack of, 2
CP, 26-29, 142, 144                                   parentheses around addresses, x, 149, 155
CPD,36                                              Direction of stack growth, 46
CPDR,36                                             Disassembly of numerical operation codes,
CPI, 36, 40, 350                                        439-41
CPIR, 36, 37, 40, 153                               Division, 80
CP / M operating system, 356-67, 379-84               by 2, 80, 333
  BDOS functions, 357                                 by 4, 80
  buffer format, 367, 382                             by 10, 168
  string terminator, 359, 363                         by 100, 168
CRC (cyclic redundancy check), 368-72                 decimal, 260-65
CTC (clock/timer circuit), 388, 427-28                mUltiple-precision binary, 239-44
                                                      remainder, sign of, 221
                                                      simple cases, 43, 80
D                                                     16-bit, 220-24
                                                    DJNZ, 30, 32
DAA,151                                             Documentation of programs, 60
Data direction (I/O control) register, 60           Double operands in arithmetic instructions, 16
Data structures, 44-46, 148-49,414                  Doubling an index, 35, 39
Data transfer instructions, 94-102, 142             Drivers (I/O routines), 57, 373-74
DB pseudo-operation, x                              Dynamic allocation of memory, 49, 66, 125-26
DE register pair, special features of, 2, 5, 6, 9
Debugging, 139-59
  interrupt service routines, 158-59                E
  I/O drivers, 156-58                               EBCDIC to ASCII conversion, 192-94
DEC, 4, 32                                          EI, 65,124
  differences between 8- and 16-bit versions, 4       position in return sequence, 121
  flags, 4                                          8080 additions, 4, 22, 29, 74, 124
Decimal (BCD) arithmetic, 151,248-66                  incompatibility (Parity flag), 29
  addition, 248-50                                  Enabling and disabling interrupts, 124-25
  binary conversions, 167-71                          accepting an interrupt, 64
  comparison, 266                                     DI,I24
  decrement by 1,78, 124                              EI,65,124
  division, 260-65                                    interrupt status, saving and restoring, 124-25
  8-bit, 72-78                                        interrupt status, testing, 105, 107, 124-25
  increment by I, 77, 124                             unserviced output interrupt, 405
  multibyte, 248-66                                   when required, 158-59
  multiplication, 254-59                            END pseudo-operation, x
  subtraction, 231-33                               Endless loop (wait) instruction, 123
  validity check, 124                               EQU pseudo-operation, x
Decimal default in assembler, 149, 150              Equal values, comparison of, 26-27, 142
Decision sequences, 31                              Error-correcting codes. See CRC
Decrement instructions, 77-78                       Error-detecting codes. See Parity ,
  decimal, 78, 124                                  Error handling, 162-63
  setting Carry, 78                                 Errors in programs, 139-59
Defaults in assembler, x, 149, 155, 455             Even parity (parity / overflow) flag, 29
DEFB pseudo-operation, x, 48                        EX, 64, 96, 97, 99, 121,444
DEFS pseudo-operation, x                            EXDE,HL,IO
DEFW pseudo-operation, x, 48                        EX (SP), 12, 67, 119, 121
Delay program, 391-93                               Exchange instructions, 99-100
Deletion of a substring, 308-12                     Exchanging elements, 34
Device numbers, 56-57, 373-84                       Exchanging pointers, 100
Digit (4-bit) shift, 90, 152-53,256,257, 264        EXCLUSIVE OR function, 18, 19
Digit swap, 90                                      EXCLUSIVE OR instructions, 87
492       ZSO ASSEMBLY LANGUAGE SUBROUTINES


Execution time, reducing, 67-68                        Indexed jump, 39, 103, 119
Execution times for instructions, 442-52               Indexing of arrays, 33-35, 201-16
Extend instructions, 84                                   byte arrays, 42-43, 201-04
EXX,64                                                    multidimensional arrays, 209-16
                                                          two-dimensional byte array, 42-43, 201-04
F                                                         two-dimensional word array, 205-08
F (flag) register, ix, 86-87, 95, 97, 434                 word arrays, 205-08
FIFO buffer (queue), 45-46, 414                        Index registers, 3
Fill memory, 99, 195-97                                   backup to HL, 9
Flag register, ix, 86-87, 95, 97, 434                     features, 9
Flags, 434, 453                                           instructions, 6
  instructions, effects of, 3, 453                        secondary status, 4
   loading, 95                                            uses, 5
   organization in flag register, ix, 434              Indirect addressing, 3, 11-12, 13, 126-27
  storing, 97                                             indexed addressing with zero offset, 12
  summary, 453                                            jump instructions, 102-03
   use, 31                                                multilevel versions, 127
Format errors, 149-51                                     subroutine calls, 119-20
Format for storing 16-bit addresses, 5, 11             Indirect call, 119-20, 352-55
                                                       Indirect jump, 102-03
H                                                      INDR,54
H (half-carry) flag, 434                               INI, 54, 55
H (indicating hexadecimal number), x, 150              INIR, 54, 55
Handshake, 61-62                                       Initialization
Head of a queue, 45, 414                                  arrays, 195-97
Hexadecimal ASCII to bihary conversion, 175-77            CTC,388
Hexadecimal to ASCII conversion, 172-74                   indirect addresses, 15
Hexadecimal numbers, zero in front, 149                   interrupt service routines, 64-66
HL register pair, special features, 2, 8-9                interrupt vectors, 398,408,418
  use, 3, 5                                               I/O devices, 63-64, 385-90
                                                          PIO, 63-64, 390,410-11
                                                          RAM, 15-16, 195-97
IFFI (interrupt flip-flop 1),435                          SIO, 388-89, 400-02, 421-22
IFF2 (interrupt flip-flop 2), 105, 107, 123, 124-25,   Initialization errors, 154
   435                                                 Input/ Output (I/O)
Immediate addressing, 11, 17                              block I/O instructions, 54-55
   assembler notation, 17, 148                            control block (lOCB), 373-84
   default, 17, 148                                       device-independent, 56-57
   use of, 11                                             device table, 56-57, 373-84
Implicit effects of instructions, 152-53                  differences between input and output, 157, 395
INC, 3,4                                                  errors, 156-58
   differences between 8- and 16-bit versions, 4          indirect addressing, 51-52, 58
   flags, 3,4                                             initialization, 63-64, 385-90
Increment instructions, 76-77                             instructions, 51-55, 452
   decimal, 77, 124                                       interrupt-driven, 64-66, 394-424
   setting Carry, 76                                      logical devices, 56-57
IND,54                                                    output, generalized, 365-67
Indexed addressing, 33-35, 38-39, 127-29                  peripheral chips, 58
    data structures, 5, 377-78, 384                       physical devices, 56-57
    generalized form, 3                                   read-only ports, 53, 158
    limitations, 3                                        status and control, 57-58
    loading, 12                                           terminal handler, 356-64
    parameter retrieval, 47-48                            write-only ports, 53-54, 57-58, 62, 65-66, 157
    storing, 14                                         Inserting a character, 181
 Indexed call, 119-20, 352-55                           Insertion into a string, 313-18
    leaving register pairs unchanged, 353-54            Instruction execution times, 442-52
                                                                                   INDEX     493
Instruction set, 433-55                        Jump instructions, 450
  alphabetical list, 436-39                    Jump table, 39, 103, 119, 149, 352-55
  asymmetry, 5
  numerical list, 439-41                       L
Interrupt enable flip-flops (IFFI and          LO, 10-12, 13, 14-16
     IFF2),4, 105, 107, 123, 124-25,435          8080 instruction set, additions. 38
Interrupt latency, 65                            order of operands, 10, 141
Interrupt response, 64, 435                    LOO, 36, 37
Interrupts. See also Enabling and disabling    LOOR, 36, 37,181,200,318
     interrupts                                LDI, 36, 37
  buffered, 413-24                             LDIR, 36, 37, 99, 196, 200. 295, 306, 311, 318
  elapsed time, 425-32                         Limit checking, 27-30
  handshake, 394-424                           Linked list, 45-46, 373, 374, 377-79
  initialization, 158, 398, 408, 418, 427-28   List processing, 45-46, 377-79
  instructions, 446                            Load instructions, 10-16,94-96
  latency, 65                                    8-bit,442
  modes, 64, 158, 398, 435                       flags, 3, 142
  order in stack, 65                             order of operands, 10, 141
   PIO, 60, 404-12, 459, 460, 461                16-bit,443
  programming guidelines, 64-66, 158-59        Logical I/O devices, 56-57, 373-84
  real-time clock, 425-32                      Logical instructions, 85-94, 445
  reenabling, 64, 123, 159,410                   addressing modes, 2
  response, 64, 435                              Carry, clearing of, 3, 143
  service routines, 394-432                      limitations, 2
  structure, 435                               Logical shift, 20, 22, 23, 89-90, 276-81
Interrupt service routines, 394-432            Logical sum, 87. See also Parity
  CTC, 425-32                                  Long instructions, 4
  errors, 158-59                               Lookup tables, 38-39, 41, 68, 69, 125, 189-94
  examples, 394-432                            Loops, 30, 32-33
  main program, communicating with, 159,         reorganizing to save time, 67
     394-95,413-14                             Lower-case ASCII letters, 187-88
   PIO, 404-12
  programming guidelines, 64-66, 158-59
                                               M
  real-time clock, 425-32                      Masking bits, 18, 268, 271
   SID, 394-403, 413-24                        Maximum, 325-27
  terminating instructions, 66                 Median (of 3 elements), 342-44
Interrupt status, 5, 105, 107, 124-25          Memory fill, 99, 195-97
Interrupt vector register, 95, 97, 398, 435    Memory-mapped I/O, 51-53
Inverted borrow in subtraction, 75, 76, 142    Memory test, 347-51
Inverting bits, 18-20, 88                      Memory usage, reduction of, 68-69
Inverting decision logic, 140, 142             Millisecond delay program, 391-93
I/O control block (IOCB), 373-84               Minimum, 328-30
  example, 381                                 Missing addressing modes, 126-37
  format, 374                                  Missing instructions, 3, 71-126
I/O device table, 56-57, 373-84                Move instructions, 97-99
I/O instructions, 452                          Move left (bottom-up), 198, 199-200
                                               Move mUltiple, 99
J                                              Move right (top-down), 198, 199-200
JP,24-31                                       Multi bit shifts, 23, 273-87
  addressing terminology, 148                  Multibyte entries in arrays or tables, 34-35, 38-39,
  block move or block compare, 37                125, 205-16
  overflow branches, 28-30, 112-13             Multidimensional arrays, 209-16
JR, 25-29, 68                                  Multilevel indirect addressing, 127
  comparison with absolute branches, 3-4       Multiple names for registers, 2
  flag limitations, 3-4                        Multiple-precision arithmetic, 41-42, 228-66
Jump and link, 103-04                          Multiple-precision shifts, 273-87
494       Z80 ASSEMBLY LANGUAGE SUBROUTINES


Multiple-precision shifts (continued)                    Parentheses around addresses (indicating "con-
 arithmetic right, 273-75                                     tents of"), x, 149, 155
 digit (4-bit) left, 264                                 Parity I overflow flag, 3, 35-36, 434
 logical left, 276-78                                      block moves and compares, 35-36, 37
 logical right, 279-81                                     interrupt enable flag, 4, 124-25
 rotate left, 285-87                                       overflow indicator, 28, 112, 225, 227
 rotate right, 282-84                                      reversed polarity in block move and compare, 37
Multiplexing displays, 62                                Passing parameters, 46-51, 161
Multiplication, 42-43, 78-79                               memory, 47-48
 by a small integer, 42-43                                 registers, 46-47
 by 10, 171, 185                                           stack, 49-51
 by 2,35                                                   subroutine convention, 161
 decimal, 254-59                                         PC register. See Program counter
 multiple-precision, 234-38, 254-59                      Physical 110 device, 56-57
 16-bit,217-19                                           PIO (parallel input I output device), 58-64,457-62
Multiway branches (jump table), 39, 103, 119,352-55        addressing, 59-60
                                                           control lines, 61-62
N                                                          initialization, 63-64, 390, 410-11
N (add I subtract) flag, 74,434                            interrupt-driven 1/0, 404-12
Negative, calculation of, 82-83, 222-23                    operating modes, 61-62
Nega\ive logic, 89, 157                                    reference, 457-62
Nested loops, 32-33                                        registers, 59-60
New line string, 356, 361-62                             Pointer
Nibble (4 bits), 171, 173                                  exchanging, 99-100, 243, 265
Nine's complement, 83                                      loading, 96
Non-maskable interrupt, 65, 66, 123                      Polling, 57-58
NOP, filling with, 195                                   POP, 12
Normalization, 90-91                                     Pop instructions, 122-23
Normalizing array bounds, 215-16                         Position of a substring, 297-301
NOT instructions, 87-89, 268                             Postdecrement, 133-34
Numerical comparisons, 26-31                             Postincrement, 12, 130-31
                                                         Postindexing, 136-37
o                                                        Predecrement, 12, 131-32
One-dimensional arrays, 33-38                            Preincrement, 129-30
One's complement, 87-89                                  Preindexing, 134-36
Operation (op) codes                                     Primed (alternate) registers, 4, 96, 97
  alphabetical order, 436-39                             Processor status (flag) register, 434
  numerical order, 439-41                                Program counter
OR, 18, 86-87, 268, 272                                    CALL, 118-20
Ordering elements, 34                                      RET, 120-21
ORG pseudo-operation, x                                  Programmable I10 devices, 58
OTDR,54                                                    advantages, 58
OTIR, 54, 387                                              CTC, 388, 427-28
OUTD,54                                                    initialization, 385-90
OUTI, 54, 55, 153                                          operating modes, 58
Output interrupts, unserviced, 395, 405                    PIO, 58-64, 404-12, 457-62
Output line routine, 365-67                                SIO, 388-89, 394-403, 413-24
Overflow (P I V) flag, 3, 28                             Programming model of microprocessor, 433
  branches (PE, PO), 28, 29, 112                         Pseudo-operations, x, 455
Overflow of a stack, 46, 108, 109                        PUSH, 14, 141
Overflow, two's complement, 28-30, 112-13                Push instructions, 122
Overlapping memory areas, 198-200
p                                                        Q
P I V (parity I overflow) flag, 434. See also Parity I   Queue, 45-46, 414
    overflow flag                                        Quicksort, 336-46
Parameters, passing, 46-51, 161                          Quotation marks around ASCII string, x
                                                                                          INDEX     495

R                                                     s
RAM,481                                               Saving and restoring interrupt status, 5, 105, 107,
  filling, 99, 195-97                                   124-25
  initialization, 15-16, 154                          Saving and restoring registers, 12, 14, 64-66, 121
  saving data, 13-14                                  SBC A,A (extend Carry across A), 84
  testing, 347-51                                     Searching, 35-38, 331-35
Read-only memory, 48                                  Secondary instructions, 4, 38
Read-only ports, 53, 158                              Secondary registers, 4
Ready flag (for use with interrupts), 394-95          Semicolon indicating comment, x
Real-time clock, 425-32                               Serial input/ output, 394-403, 413-24
Recursive program (quicksort), 336-46                 SET, 18-20, 53
Reenabling interrupts, 65, 124-25                     Set instructions, 102
Reentrancy, 47                                        Set Origin (ORG) pseUdo-operation, x
Refresh (R) register, 95, 97                          Setting bits to I, 18-20, 102
Register pairs, ix, 2, 433                            Setting directions
  instructions, 6, 8                                    initialization, 158
  loading, II                                            PIO (control mode), 60, 63-64, 459
Registers, 5-15                                       Setting flags, 86-87
  functions, 5                                        Shift instructions, 20-24, 89-92, 448
  instructions, 6-8                                      byte, 181
  length, ix                                            diagrams, 21-23
  names, 2                                              digit, 152-53
  order in stack, 65                                    multibit, 23, 273-87
  passing parameters, 46-47                             muItibyte, 273-87
  primed, 4, 96, 97                                     32-bit left shift, 223
  programming model, 433                                24-bit left shift, 180
  saving and restoring, 65, 121                       Sign byte, 184-85
  secondary, 4                                        Sign extension, 20, 23-24, 273-75
  special features, 8-9                               Sign flag, 28-30, 142-43
  transfers, 10                                       Sign function, 84
Register transfers, 10                                Signed division, 220-24
Relative branches, 3-4, 32                            Signed branches, 28-30, 112-13
RES, 18, 19, 53-54                                    Signed numbers, 28-30
Reset                                                 Signs, comparison of, 29, 222
  CTC, 388                                            SIO (Serial Input/Output Device), 388-89,
  PIO, 61, 63                                           394- 403, 413-24
  S10,389                                             16-bit address format, 5
Restart instructions, 64, 65, 451, 454                16-bit operations, 217-27
RETI,66                                                 absolute value, 83
RETN,66                                                 addition, 72-73, 74
Return address, changing of, 120-21                     average, 333
Return instructions, 120-21                             comparison, 81-82, 225-27
Return from interrupt instructions, 121                 counter, 32-33, 35
Return with skip instructions, 120-21                   division, 220-24
RL, 20, 53                                              flags, effect on, 3
RLC, 20                                                 indexing, 128
RLD,264                                                 instructions, 443, 447
ROM (read-only memory), 48                              multiplication, 217-19
Rotation (circular shift), 20-22, 24, 91-92, 282-87     pop, 12
Row major order (for storing arrays), 205, 209          push,14
RR, 20,80                                               registers, ix
RRC, 20                                                 shifts, 89-92
RRD, 152-53, 257                                        subtraction, 27, 74-76
RST, 64, 65, 451, 454                                   test for zero, 93
496       Z80 ASSEMBLY LANGUAGE SUBROUTINES


6800 microprocessor, differences from, 5             Strobe, 61-62
6809 microprocessor, differences from, 5             SUB, single operand in, 16
Skip instructions, 118, 120-21                       Subroutine call, 49, 118-20
SLA,20                                                 saving memory, 68-69
Slow instructions, 4, 38                               variable addresses, 118-20
Software delay, 391-93                               Subroutine linkage, 49, 103-04, 161
Software stack, 46                                   Subscript, size of, 206, 209, 210
Sorting, 336-46                                      Subtraction, 74-76
  references, 338                                      BCD, 74-76, 231-33
SP register. See Stack pointer                         binary, 74-76, 231-33
Special cases, 162-63                                  Carry flag, 27, 76
Special features of processor, 2-5                     decimal, 74-76, 231-33
SRA, 20, 23, 80                                        8-bit, 74-76
SRL, 20, 80                                            inverted borrow, 75, 76, 142
Stack, 12, 14, 49-51                                   multiple-precision, 231-33
  cleaning, 49, 50                                     reverse, 75
  data transfers, 12, 14                                16-bit, 27, 74-76
  diagrams, 50, 51                                   Subtraction instructions, 74-76
  downward growth, 5, 12                               in reverse, 75
  overflow, 46                                         with borrow, 76
  passing parameters, 49-51                            without borrow, 74-75
  pointer, 6, 7, 12, 49-51                           Summation, 33
  POP, 12                                              binary, 33
  PUSH, 14                                             8-bit, 33, 319-21
  saving registers, 65                                  16-bit, 322-24
  software, 46                                       Systems programs, conflict with, 140
  underflow, 46
    Stack pointer                                    T
      automatic change when used, 12                 Table, 38-39, 41, 68, 69, 125, 189-94
      comparison, 82                                 Table lookup, 38-39, 41, 125
      contents, 5, 12                                Tail of a queue, 414
      decrementing, 12                               Ten's complement, 82-83
      definition, 12                                 Terminal I/O, 356-67
      dynamic allocation of memory, 49, 66, 125-26   Testing, 92-94
      features, 9                                      array, 241, 262
      incrementing, 14                                 bits, 18, 19,25-26, 85
      moving to HL, 49                                 bytes, 92-93
      transfers, 98                                    multiple-precision number, 241, 262
    Stack transfers, 12, 14, 46                        16-bit number, 93
    Status bit. See Flags; Flag register             32-bit left shift, 223
    Status signals, 57-58                            Threaded code, 44
    Status values in I/O, 375                        Threshold checking, 27-31
    Store instructions, effect on flags (none), 3    Timeout, 391-93
    String operations, 39-40, 288-318                Timing for instructions, 442-52
      abbreviations, recognition of, 289, 297, 298   Top of stack, 12
      compacting, 311                                Transfer instructions, effect on flags, 3
      comparison, 288-91                             Translate instructions, 125
      concatenation, 292-96                          Trivial cases, 162
      copying a substring, 302-07                    True comparison, 35, 38
      deletion, 308-12                               24-bit left shift, 180
      insertion, 313-18                              Two-byte entries, 34-35, 38-39, 125
      matching a substring, 300                      Two-dimensional arrays, 42-43, 201-08
      position of substring, 297-301                 Two's complement, 82-83
      search, 39-40                                  Two's complement overflow, 28-30, 112-13
                                                                                    INDEX    497

u                                                z
Unconditional jump instructions, 102-04          Zero flag, 142
Underflow of stack, 46                             block compares, 37
Upside-down addresses, 5, II                       block 1(0, 54
                                                   branches, 142
v                                                  comparisons, 26
Validity check for BCD number, 124                 inversion in masking, 19,25
                                                   load instructions, 3
w                                                  masking, 19, 93
Wait instructions, 123                             position in flag register, ix, 434
Walking bit test, 347-49                           transfer instructions, 3
Wraparound of buffer, 414                          uses, 25-27, 31
Write-only ports, 53-54, 57-58, 62, 65-66, 157   Zero in front of hexadecimal numbers, 149
              Other Osbome/McGraw-HIII PubllcaHons
An Introduction to Microcomputers: Volume 0- The Beginner's Book, 3rd Edition
An Introduction to Microcomputers: Volume 1-Basic Concepts, 2nd Edition
Osborne 4 & 8-Bit Microprocessor Handbook
Osborne l6-Bit Microprocessor Handbook
8089 I/O Processor Handbook
CRT Controller Handbook
68000 Microprocessor Handbook
8080A/8085 Assembly Language Programming
6800 Assembly Language Programming
Z80® Assembly Language Programming
6502 Assembly Language Programming
Z8000® Assembly Language Programming
6809 Assembly Language Programming
Running Wild - The Next Industrial Revolution
The 8086 Book
PET®/CBM'M and the IEEE 488 Bus (GP1B)
PET® Personal Computer Guide
CBM'" Professional Computer Guide
Business System Buyer's Guide
Osborne CP/M® User Guide, 2nd Edition
Apple II® User's Guide
Microprocessors for Measurement and Control
Some Common BASIC Programs
Some Common BASIC Programs - Atari® Edition
Some Common BASIC Programs- TRS-80™ Level II Edition
Some Common BASIC Programs-Apple II® Edition
Some Common BASIC Programs-IBM® Personal Computer Edition
Some Common Pascal Programs
Practical BASIC Programs
Practical BASIC Programs - TRS-80™ Level II Edition
Practical BASIC Programs-Apple II® Edition
Practical BASIC Programs-IBM® Personal Computer Edition
Practical Pascal Programs
Payroll with Cost Accounting
Accounts Payable and Accounts Receivable
Accounts Payable and Accounts Receivable CBASICTM
General Ledger
CBASIC" User Guide
Science and Engineering Programs-Apple II® Edition
Interfacing to S-IOO/IEEE 696 Microcomputers
A User Guide to the UNIX'M System
PET® Fun and Games
Trade Secrets: How to Protect Your Ideas and Assets
Assembly Language Programming for the Apple II®
VisiCalC®: Home and Office Companion
Discover FORTH
6502 Assembly Language Subroutines
8080/8085 Assembly Language Subroutines
Your ATARr" Computer
The HP-IL System
Wordstar® Made Easy, 2nd Edition
Armchair BASIC
Data Base Management Systems
The HHC" User Guide
VIC 20™ User Guide
Your IBM® PC: A Guide to the IBM® Personal Computer
