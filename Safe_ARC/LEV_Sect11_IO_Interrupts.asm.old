
			Section IOLIB
					
					
					; Interrupts
					; 11A    Unbuffered Input/Output Using an DART          394
					; 11B    Unbuffered Input/Output Using a PIO 		404
					; 11C    Buffered Input/Output Using an DART          413
					; 11D   Real-Time Clock and Calendar 425


					;*************************************************************************************************************
					;*************************************************************************************************************
					; Unbuffered Input/Output
					; 														I if full
					; 														5. INIT: none
					; 		Title                 Simple interrupt input and output using an DART
					; 								and single character buffers
					; 		Name:                 SINTIO
					; 		Purpose:       This program consists of 5 subroutines which
					; 					perform-interrupt driven input and output using
					; 					an DART.
					; 					ReadChar
					; 						Read a character
					; 					INST
					; 						Determine input status (whether input
					; 						buffer is empty)
					; 					OUTCH
					; 						Write a character
					; 					OUTST
					; 						Determine output status (whether output
					; 						buffer is full)
					; 					INIT
					; 						Initialize DART and interrupt system
					; 		Entry:         ReadChar
					; 						No parameters
					; 					INST
					; 						No parameters
					; 					OUTCH
					; 						Register A = character to transmit
					; 					OUTST
					; 						No parameters
					; 					INIT
					; 						No parameters
					; 		Exit:          ReadChar
					; 						Register A = character
					; 					INST
					; 						Carry = 0 if input buffer is empty,
					; 						1 if character is available
					; 					OUTCH
					; 						No parameters
					; 					OUTST
					; 						Carry = 0 if output buffer is not
					; 						full, 1 if i t is full
					; 					INIT
					; 						No parameters
					; 		Registers used: ReadChar - AF
					; 						INST - AF
					; 						OUTCH - AF
					; 						OUTST - AF
					; 						INIT - AF,BC,HL,I

					; 		Time:           ReadChar
					; 						72 cycles if a character is available
					; 						INST
					; 						27 cycles
					; 							OUTCH
					; 							150 cycles if output buffer is not full
					; 								and output interrupt is expected
					; 							OUTST
					; 							27 cycles
					; 							INIT
					; 							618 cycles
					; 							RDHDLR
					; 							82 cycles
					; 							WRHDLR
					; 							160 cycles
					; 		Size:              Program 202 bytes
					; 							Data      5 bytes

					; 		,DART EQUATES
					; 		DART IS PROGRAMMED FOR:
					; 			ASYNCHRONOUS OPERATION
					; 			16 X BAUD RATE
					; 			8-BIT CHARACTERS
					; 		, 1 1/2 STOP BITS
					; 		,ARBITRARY DART PORT ADDRESSES
					;***********************************************************************************************************************
					;***********************************************************************************************************************
		INCLUDE "Z80_Params_.inc"


INCH_11A:
		CALL	INST_11A				;GET INPUT STATUS
		JR		NC,INCH_11A				;WAIT IF NO CHARACTER AVAILABLE
		DI							;DISABLE INTERRUPTS
		SUB		A
		LD		(RECDF),A			;INDICATE INPUT BUFFER EMPTY
		LD		A,(RECDAT)			;GET CHARACTER FROM INPUT BUFFER
		EI							;ENABLE INTERRUPTS
		RET
			;RETURN INPUT STATUS (CARRY = 1 IF INPUT DATA IS AVAILABLE)
INST_11A:
		LD		A,(RECDF)			;GET DATA READY FLAG
		RRA							;SET CARRY FROM DATA READY FLAG
									;IF CARRY = 1, CHARACTER IS AVAILABLE
		RET
			;WRITE CHARACTER

OUTCH_11A:
		PUSH	AF					;SAVE CHARACTER TO WRITE
		;WAIT FOR CHARACTER BUFFER TO EMPTY, THEN STORE NEXT CHARACTER
WAITOOC_11A:
		CALL	OUTST_11A				;GET OUTPUT STATUS
		JR		C,WAITOOC_11A		;WAIT IF OUTPUT BUFFER IS FULL
		DI							;DISABLE INTERRUPTS WHILE LOOKING AT
									; SOFTWARE FLAGS
		POP		AF					;GET CHARACTER
		LD		(TRNDAT),A			;STORE CHARACTER IN OUTPUT BUFFER
		LD		A,0FFH				;INDICATE OUTPUT BUFFER FULL
		LD		(TRNDF),A
		LD		A,(OIE)				;TEST OUTPUT INTERRUPT EXPECTED FLAG
		OR		A
		CALL	Z,OUTDAT_11A			;OUTPUT CHARACTER IMMEDIATELY IF
									; NO OUTPUT INTERRUPT EXPECTED
		EI                     	    ;ENABLE INTERRUPTS
		RET
			;OUTPUT STATUS (CARRY    =1   IF OUTPUT BUFFER IS FULL)
OUTST_11A:
		LD		A,(TRNDF)			;GET TRANSMIT FLAG
		RRA							;SET CARRY FROM TRANSMIT FLAG
		RET							; CARRY = 1 IF BUFFER FULL
		;INITIALIZE INTERRUPT SYSTEM AND DART
INIT_11A:
		DI							;DISABLE INTERRUPTS FOR INITIALIZATION
			; INITIALIZE SOFTWARE FLAGS
		SUB		A
		LD		(RECDF),A			;NO INPUT DATA AVAILABLE
		LD		(TRNDF),A			;OUTPUT BUFFER EMPTY
		LD		(OIE),A				;NO OUTPUT INTERRUPT EXPECTED
									; DART IS READY TO TRANSMIT INITIALLY
			;INITIALIZE INTERRUPT VECTORS
		LD      A,DART_Int_Vec >> 8			;GET INTERRUPT PAGE NUMBER
		LD      I,A				;SET INTERRUPT VECTOR IN zao
		IM      2				;INTERRUPT MODE 2 - VECTORS IN TABLE
								; ON INTERRUPT PAGE
		LD		HL,RDHDLR_11A			;STORE READ VECTOR (INPUT INTERRUPT)
		LD		(DART_Int_Read_Vec),HL
		LD		HL,WRHDLR_11A			;STORE WRITE VECTOR (OUTPUT INTERRUPT)
		LD		(DART_Int_WR_Vec),HL
		LD		HL,EXHDLR_11A			;STORE EXTERNAL/STATUS VECTOR
		LD		(DART_Int_EXT_Vec),HL
		LD		HL,REHDLR_11A			;STORE RECEIVE ERROR VECTOR
		LD		(DART_Int_Spec_Vec),HL
			; INITIALIZE DART
		LD		HL,DARTINT			;GET BASE OF INITIALIZATION ARRAY
		CALL	IPORTS_11A            	;INITIALIZE DART
		EI							;ENABLE INTERRUPTS
		RET

			;INPUT (READ) INTERRUPT HANDLER
RDHDLR_11A:
		PUSH	AF					;SAVE AF
RD1_11A:	IN		A, (DART_A_D)			;READ DATA FROM DART
		LD		(RECDAT), A			;SAVE DATA IN INPUT BUFFER
		LD		A,0FFH
		LD		(RECDF),A			;INDICATE INPUT DATA AVAILABLE
		POP		AF					;RESTORE AF
		EI							;REENABLE INTERRUPTS
		RETI
			;OUTPUT (WRITE) INTERRUPT HANDLER
WRHDLR_11A:
		PUSH	AF
		LD		A,(TRNDF)			;GET DATA AVAILABLE FLAG
		RRA
		JR		NC,NODATA_11A			;JUMP IF NO DATA TO TRANSMIT
		CALL	OUTDAT_11A				;OUTPUT DATA TO DART
		JR		WRDONE_11A

		; IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE.
		; WE MUST RESET IT TO AVOID AN ENDLESS LOOP. LATER. WHEN A
		; CHARACTER BECOMES AVAILABLE, WE NEED TO KNOW THAT AN OUTPUT
		; INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED. THE KEY HERE
		; IS THE OUTPUT INTERRUPT EXPECTED FLAG OlE. THIS FLAG IS
		; CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT
		; BEEN SERVICED. IT IS ALSO CLEARED INITIALLY SINCE THE
		; DART STARTS OUT READY. OlE IS SET WHENEVER DATA IS ACTUALLY
		; SENT TO THE DART. THUS THE OUTPUT ROUTINE OUTCH CAN CHECK
		; OlE TO DETERMINE WHETHER TO SEND THE DATA IMMEDIATELY
		; OR WAIT FOR AN OUTPUT INTERRUPT.
		; THE PROBLEM IS THAT AN.OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
		; THE COMPUTER HAS ANYTHING TO SEND (UNLIKE AN INPUT DEVICE
		; THAT HAS DATA WHEN IT REQUESTS SERVICE). THE OlE FLAG
		; SOLVES THE PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING
		; ITSELF REPEATEDLY. WHILE STILL ENSURING THE RECOGNITION OF
		; OUTPUT INTERRUPTS.
NODATA_11A:
		SUB		A
		LD		(OIE),A				;DO NOT EXPECT AN INTERRUPT
		OUT		(DART_A_C),A			;SELECT REGISTER 0
		LD		A,00101000B			;RESET DART TRANSMITTER INTERRUPT
		OUT		(DART_A_C),A
WRDONE_11A:
		POP		AF					;RESTORE AF
		EI
		RETI
			;EXTERNAL/STATUS CHANGED INTERRUPT HANDLER
EXHDLR_11A:
		PUSH	AF
		LD		A,00010000B			;RESET STATUS INTERRUPT
		OUT		(DART_A_C),A
		EI							;DCD OR CTS CHANGED STATE, OR A BREAK

		POP		AF					; WAS DETECTED
		RETI						; SERVICE HERE IF NECESSARY
			;SPECIAL RECEIVE ERROR INTERRUPT
REHDLR_11A:
		PUSH	AF
		LD		A,00110000B			;RESET RECEIVE ERROR INTERRUPT
		OUT		(DART_A_C),A
		EI							; FRAMING ERROR OR OVERRUN ERROR
		POP		AF					; OCCURRED
		RETI						; SERVICE HERE IF NECESSARY

		;*************************************
		; ROUTINE: OUTDAT
		;PURPOSE: SEND CHARACTER TO DART
		;ENTRY: TRNDAT = CHARACTER
		;EXIT: NONE
		;REGISTERS USED: AF
		;***************************************
OUTDAT_11A:
		LD		A,(TRNDAT)			; GET DATA FROM OUTPUT BUFFER
		OUT		(DART_A_D),A			; SEND DATA TO DART
		SUB		A					; INDICATE OUTPUT BUFFER EMPTY
		LD		(TRNDF),A
		DEC		A					; INDICATE OUTPUT INTERRUPT EXPECTED
		LD		(OIE),A				; OlE = FF HEX
		RET
		
		;**************************************
		;ROUTINE: IPORTS
		;PURPOSE: INITIALIZE 1/0 PORTS
		;ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
		;EXIT: DATA OUTPUT TO PORTS
		;REGISTERS USED: AF.BC.HL
		;************************************

IPORTS_11A:
			;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
			;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
		LD		A,(HL)				;GET NUMBER OF BYTES
		OR		A					;TEST FOR ZERO (TERMINATOR)
		RET		Z					;RETURN IF NUMBER OF BYTES = 0
		LD		B,A
		INC		HL					;POINT TO PORT ADDRESS (NEXT BYTE)
			;C = PORT ADDRESS
			;HL = BASE ADDRESS OF OUTPUT DATA
		LD      C,(HL)				;GET PORT ADDRESS
		INC     HL					;POINT TO FIRST DATA VALUE (NEXT BYTE)
			;OUTPUT DATA AND CONTINUE TO NEXT PORT
		OTIR						;SEND DATA VALUES TO PORT
		JR      IPORTS_11A				;CONTINUE TO NEXT PORT ENTRY
			;DART INITIALIZATION DATA
DARTINT_11A:
			;RESET CHANNEL A
		DB		1					;OUTPUT 1 BYTE
		DB		DART_A_C				;DESTINATION IS CHANNEL A COMMAND/STATUS
		DB		00011000B			;SELECT WRITE REGISTER 0
									;BITS 2,1,0 = 0 (WRITE REGISTER 0)
									;BITS 5.4.3 = 011 (CHANNEL RESET)
									;BITS 7,6 = 0 (DO NOT CARE)
			;SET INTERRUPT VECTOR AND ALLOW STATUS TO AFFECT IT
		DB		4					;OUTPUT 2 BYTES
		DB		DART_B_C				;DESTINATION IS COMMAND REGISTER B
		DB		00000010B			; SELECT WRITE REGISTER 2
		DB		DART_Int_Vec&0FFH			;SET INTERRUPT VECTOR FOR DART
		DB		00000001B			;SELECT WRITE REGISTER 1
		DB		00000100B			;ALLOW STATUS TO AFFECT VECTOR
			; INITIALIZE CHANNEL A
		DB		8					;OUTPUT 8 BYTES
		DB		DART_A_C				;DESTINATION IS COMMAND REGISTER A
			; INITIALIZE BAUD RATE CONTROL
		DB		00010100B			;SELECT WRITE REGISTER 4
									; RESET EXTERNAL/STATUS INTERRUPT
		DB		01001000B			;BIT 0 = 0 (NO PARITY)
									;BIT 1 = 0 (DON'T CARE)
									;BITS 3.2 = 10 (1 1/2 STOP BITS)
									;BITS 5,4 = 00 <nOWT CARE)
									;BITS 7,6 = 01 (16 TIMES CLOCK)
			;INITIALIZE RECEIVE CONTROL
		DB		00000011B			;SELECT WRITE REGISTER 3
		DB		11000001B			;BIT 0 = 1 (RECEIVE ENABLE)
									; BITS 4,3,2,1 = 0 (DON"T CARE)
									;BIT 5 = 0 (NO AUTO ENABLE)
									;BIT 7,6 = 11 (RECEIVE 8 BITS/CHAR)
			; INITIALIZE TRANSMIT CONTROL
		DB		00000101B			;SELECT WRITE REGISTER 5
		DB		11101010B			;BIT 0 = 0 (NO CRC ON TRANSMIT)
									;BIT 1 = 1 (REQUEST TO SEND)
									;BIT 2 = 0 (DON'T CARE)
									;BIT 3 = 1 (TRANSMIT ENABLE)
									;BIT 4 = 0 (DO NOT SEND BREAK)
									;BITS 6,5 = 11 (TRANSMIT 8 BITS/CHAR)
									;BIT 7 = 1 (DATA TERMINAL READY)
		DB		00000001B			;SELECT WRITE REGISTER 1
		DB		00011011B			;BIT 0 = 1 (EXTERNAL INTERRUPTS)
									;BIT 1 = 1 (ENABLE TRANSMIT INTERRUPT)
									;IBIT 2 = 0 (DO NOT CARE)
									;BITS 4,3 = 11 (RECEIVE INTERRUPTS ON
									; ALL CHARS, PARITY DOES NOT AFFECT
									; VECTOR)
									;BITS 7,6,5 = 000 (NO WAIT/READY
									; FUNCTION)

		DB	0						;TERMINATOR FOR INITIALIZATION ARRAY
		; DATA SECTION
RECDAT:	DS		1					;RECEIVE DATA
RECDF: 	DS		1					;RECEIVE DATA FLAG
									; (0 = NO DATA. FF = DATA AVAILABLE)
TRNDAT: DS		1					; TRANSMIT DATA
TRNDF: 	DS		1					;TRANSMIT DATA FLAG
									; (0 = BUFFER EMPTY. FF = BUFFER FULL)
OIE:	DS		1					;OUTPUT INTERRUPT EXPECTED
									; (0 = NO INTERRUPT EXPECTED,
									; FF = INTERRUPT EXPECTED)



		; SAMPLE EXECUTION:


		;CHARACTER EQUATES
ESCAPE		EQU		1BH                ;ASCII ESCAPE CHARACTER
TESTCH		EQU		'A'             ;TEST CHARACTER = A
SC11A:
		CALL	INIT_11A            ; INITIALIZE DART. INTERRUPT SYSTEM
			;SIMPLE EXAMPLE - READ AND ECHO CHARACTERS
			;UNTIL AN ESC IS RECEIVED
LOOP_11A:
		CALL	INCH_11A			; READ CHARACTER
		PUSH	AF
		CALL	OUTCH_11A			; ECHO CHARACTER
		POP		AF
		CP		ESCAPE			;IS CHARACTER AN ESCAPE?
		JR		NZ,LOOP_11A			;STAY IN LOOP IF NOT
			;AN ASYNCHRONOUS EXAMPLE
			; OUTPUT "An TO CONSOLE CONTINUOUSLY. BUT ALSO LOOK AT
			; INPUT SIDE. READING AND ECHOING ANY INPUT CHARACTERS
ASYNLP_11A:
			;OUTPUT    AN "A" IF OUTPUT IS NOT BUSY
		CALL	OUTST_11A			;IS OUTPUT BUSY?
		JR		C,ASYNLP_11A        ;JUMP IF IT IS
		LD		A,TESTCH
		CALL	OUTCH_11A			;OUTPUT TEST CHARACTER
			; CHECK INPUT PORT
			; ECHO CHARACTER IF ONE IS AVAILABLE
			; EXIT ON ESCAPE CHARACTER
		CALL	INST_11A			; IS INPUT DATA AVAILABLE?
		JR		NC,ASYNLP_11A		;JUMP IF NOT (SEND ANOTHER "A")
		CALL	INCH_11A			;GET CHARACTER
		CP		ESCAPE			;IS IT AN ESCAPE?
		JR		Z,DONE_11A			;BRANCH IF IT IS
		CALL	OUTCH_11A			;ELSE ECHO CHARACTER
		JP		ASYNLP_11A			;AND CONTINUE
DONE_11A:
		JP     LOOP_11A



					;***********************************************************************************************************************
					;***********************************************************************************************************************
					; Unbuffered Input/Output
					; 													5. INIT: none
					; 		Title                Simple interrupt input and output usinQ a                zao
					; 							PIa and single character buffers
					; 		Name:                PINTIO
					; 	Purpose:        This program consists of 5 subroutines which
					; 					perform interrupt driven input and output using
					; 					a Z80 PIO.
					; 					INCH
					; 						Read a character
					; 					INST
					; 						Determine input status (whether input
					; 						buffer is empty)
					; 					OUTCH
					; 						Write a character
					; 					OUTST
					; 						Determine output status (whether output
					; 						buffer is full)
					; 					INIT
					; 						Initialize PIO and interrupt system
					; 	Entry:          INCH
					; 						No parameters
					; 					INST
					; 						No parameters
					; 					OUTCH
					; 						Register A = character to transmit
					; 					OUTST
					; 						No parameters
					; 					INIT
					; 						No parameters
					; 	Exit :          INCH
					; 						Register A = character
					; 					INST
					; 						Carry = 0 if input buffer is empty,
					; 						1 if character is available
					; 					OUTCH
					; 						No parameters
					; 					OUTST
					; 						Carry = 0 if output buffer is not
					; 						full, 1 if it is full
					; 					INIT
					; 						No parameters
					; 	Registers used: INCH
					; 						A.F
					; 					INST
					; 						A,F
					; 					OUTCH
					; 						A,F
					; 					OUTST
					; 						A,F
					; 					INIT
					; 						A,F,eC,HL,I
					; 		Time:               INCH
					; 							72 cycles if a character is available
					; 							INST
					; 							27 cycles
					; 							OUTCH
					; 							150 cycles if output buffer is not full
					; 								and output interrupt is expected
					; 							OUTST
					; 							27 cycles
					; 							INIT
					; 							377 cycles
					; 							RDHDLR
					; 							82 cycles
					; 							WRHDLR
					; 							178 cycles
					; 		Size:               Program 166 bytes
					; 							Data      5 bytes
					; 		;PIO EQUATES
					; 		; PIO IS PROGRAMMED FOR:
					; 			PORT A INPUT
					; 			PORT B OUTPUT
					; 		;ARBITRARY PIO PORT ADDRESSES
					;***********************************************************************************************************************
					;***********************************************************************************************************************


; PIOAD    EQU      90H             ;PORT A DATA
; PIOAC    EQU      91H             ;PORT A CONTROL
; PIOBD    EQU      92H             ;PORT B DATA
; PIOBC    EQU      93H             :PORT B CONTROL
; INTRPV   EQU      8000H           ;BASE OF INTERRUPT VECTORS
; PIOIVA   EQU      INTRPV          ; INTERRUPT VECTOR FOR PORT A
; PI0IVB   EQU      INTRPV+2        ; INTERRUPT VECTOR FOR PORT B
; 		:READ CHARACTER
; INCH:
; 		CALL      INST              ~GET INPUT STATUS
; 		JR        NC,INCH           ;WAIT IF NO CHARACTER AVAILABLE
; 		Dl                          ;DISABLE INTERRUPTS
; 		SUB       A
; 		LD        (RECDF),A         ;INDICATE INPUT BUFFER EMPTY
; 		LD        A. (RECDAT)       :OET CHARACTER FROM INPUT BUFFER
; 		El                          ;REENABLE INTERRUPTS
; 		RET
; 		~RETURN   INPUT STATUS (CARRY    =1   IF INPUT DATA IS AVAILABLE)
; INST:
; 		LD        A, (RECDF)        ;GET DATA READY FLAG
; 		RRA                         ;SET CARRY FROM DATA READY FLAG
; 									: IF CARRY = 1, CHARACTER IS AVAILABLE
; 		RET
; 		; WRITE CHARACTER
; OUTCH:
; 		PUSH      AF                :SAVE CHARACTER TO WRITE


; 		;WAIT FOR CHARACTER BUFFER TO EMPTY, THEN STORE NEXT CHARACTER
; WAITOC:
; 		CALL        OUTST           ;GET OUTPUT STATUS
; 		JR          C, WAITOC       ;WAIT IF OUTPUT BUFFER IS FULL
; 		01                          :DISABLE INTERRUPTS WHILE LOOKING AT
; 									~ SOFTWARE FLAGS
; 		POP         AF              :GET CHARACTER
; 		LD          <TRNDAT> .A     :STORE CHARACTER IN OUTPUT BUFFER
; 		LD          A.OFFH          : INDICATE OUTPUT BUFFER FULL
; 		LD          <TRNDF)'A
; 		LD          A,(OIE)         :TEST OUTPUT INTERRUPT EXPECTED FLAG
; 		OR          A
; 		CALL        Z.OUTDAT        :OUTPUT CHARACTER IMMEDIATELY IF
; 									: NO OUTPUT INTERRUPT EXPECTED
; 		EI                          :ENABLE INTERRUPTS
; 		RET
; 		,OUTPUT STATUS (CARRY = 1 IF OUTPUT BUFFER IS FULL)
; OUTST:
; 		LD          A. <TRNDF)      ;GET TRANSMIT FLAG
; 		RRA                         ~SET CARRY FROM TRANSMIT FLAG
; 		RET                         ; CARRY = 1 IF OUTPUT BUFFER FULL
; 		: INITIALIZE PIO AND INTERRUPT SYSTEM
; INIT:
; 		DI                          :DISABLE INTERRUPTS
; 		;INITIALIZE SOFTWARE FLAGS
; 		SUB     A
; 		LD      (RECDF>.A       ;NO INPUT DATA AVAILABLE
; 		LD      (TRNDF>.A       :OUTPUT BUFFER EMPTY
; 		LD      (OIE>.A         :NO OUTPUT INTERRUPT EXPECTED
; 								: DEVICE IS READY INITIALLY
; 		~INITIALIZE      INTERRUPT VECTORS
; 		LD          A.INTRPV SHR 8 :GET HIGH BYTE OF INTERRUPT PAGE
; 		LD          I.A              ;SET INTERRUPT VECTOR IN zao
; 		1M          2                ; INTERRUPT MODE 2 - VECTORS IN TABLE
; 									~ ON INTERRUPT PAGE
; 		LD          HL.RDHDLR        ,STORE READ VECTOR (INPUT INTERRUPT)
; 		LD          (PIOIVA).HL
; 		LD          HL.WRHDLR        ,STORE WRITE VECTOR (OUTPUT INTERRUPT)
; 		LD          (PIOIVB).HL
; 		,INITIALIZE PIO
; 		LD      HL.PIOINT           :BASE ADDRESS OF INITIALIZATION ARRAY
; 		CALL    IPORTS              ; INITIALIZE PIO
; 		EI                          , ENABLE INTERRUPTS
; 		RET
; 		;INPUT (READ) INTERRUPT HANDLER
; RDHDLR:
; 		PUSH        AF
; 		IN          A.(PIOAD)       :READ DATA FROM PIO
; 		LD          (RECDAT> .A     ,SAVE DATA IN INPUT BUFFER
; 		LD     A,OFFH           ;INDICATE INPUT DATA AVAILABLE
; 		LD     (RECDF),A
; 		POP    AF
; 		EI                      ;REENABLE INTERRUPTS
; 		RETI
; 		;OUTPUT (WRITE) INTERRUPT HANDLER
; WRHDLR:
; 		PUSH    AF
; 		LD      A, <TRNDF)      ;GET DATA AVAILABLE FLAG
; 		RRA
; 		JR     NC,NODATA        ;JUMP IF NO DATA TO TRANSMIT
; 		CALL   OUTDAT           ;OUTPUT DATA TO PIO
; 		JR     WRDONE
; 		;IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE,
; 			WE MUST DISABLE IT TO AVOID AN ENDLESS LOOP. LATER, WHEN A
; 			CHARACTER BECOMES AVAILABLE. WE NEED TO KNOW THAT AN OUTPUT
; 			INTERRUPT HAS OCCURRED WITHOUT BEING SERVICED. THE KEY HERE
; 		; IS THE OUTPUT INTERRUPT EXPECTED FLAG OlE. THIS FLAG IS
; 			CLEARED WHEN AN OUTPUT INTERRUPT HAS OCCURRED BUT HAS NOT
; 			BEEN SERVICED. IT IS ALSO CLEARED INITIALLY SINCE THE
; 			OUTPUT DEVICE IS ASSUMED TO START OUT READY. OlE IS SET
; 		, WHENEVER DATA IS ACTUALLY SENT TO THE PIO. THUS THE OUTPUT ROUTINE
; 			OUTCH CAN CHECK OlE TO DETERMINE WHETHER TO SEND THE DATA
; 		; IMMEDIATELY OR WAIT FOR AN OUTPUT INTERRUPT.
; 		;THE PROBLEM IS THAT AN OUTPUT DEVICE MAY REQUEST SERVICE BEFORE
; 			THE COMPUTER HAS ANYTHING TO SEND (UNLIKE AN INPUT DEVICE
; 			THAT HAS DATA WHEN IT REQUESTS SERVICE). THE OlE FLAG SOLVES
; 		, THE PROBLEM OF AN UNSERVICED OUTPUT INTERRUPT ASSERTING ITSELF
; 			REPEATEDLY, WHILE STILL ENSURING THE RECOGNITION OF
; 			OUTPUT INTERRUPTS.
; NODATA:
; 		SUB     A
; 		LD      (OlE) .A        ; INDICATE NO OUTPUT INTERRUPT EXPECTED
; 		LD      A.OOOOOOllB     ,DISABLE OUTPUT INTERRUPTS
; 		OUT     (PIOBC).A
; WRDONE:
; 		POP     AF              ;RESTORE REGISTERS
; 		EI
; 		RETI

; 		'*************************************
; 		; ROUTINE: OUTDAT
; 		; PURPOSE: SEND CHARACTER TO PIO PORT B
; 		; ENTRY: TRNDAT = CHARACTER
; 		,EXIT: NONE
; 		;REGISTERS USED: AF
; 		;***************************************
; OUTDAT:
; 		LD      A. <TRNDAT>     ;GET DATA FROM OUTPUT BUFFER
; 		OUT     (PIOBD).A       ,SEND DATA TO PIO
; 		SUB     A               ; INDICATE OUTPUT BUFFER EMPTY


; 		LD       (TRNDF),A
; 		DEC      A                 ;INDICATE OUTPUT INTERRUPT EXPECTED
; 		LD       (OIE),A           ; OlE = FF HEX
; 		LD       A,10000011B       ;ENABLE OUTPUT INTERRUPTS
; 		OUT      (PIOBC).A
; 		RET
; 		;**************************************
; 		; ROUTINE: IPORTS
; 		; PURPOSE: INITIALIZE I/O PORTS
; 		; ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
; 		:EXIT: DATA OUTPUT TO PORTS
; 		;REGISTERS USED: AF,BC,HL
; 		;************************************
; IPORTS:
; 		;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
; 		;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
; 		LD      A, (HL)          ; GET NUMBER OF BYTES
; 		OR      A               ;TEST FOR ZERO (TERMINATOR)
; 		RET     Z               :RETURN IF NUMBER OF BYTES = 0
; 		LD      B,A
; 		INC     HL              ;POINT TO PORT ADDRESS (NEXT BYTE)
; 		:C = PORT ADDRESS
; 		;HL = BASE ADDRESS OF OUTPUT DATA
; 		LD      C.(HL)          :GET PORT ADDRESS
; 		INC     HL              ;POINT TO FIRST DATA VALUE (NEXT BYTE)
; 		;OUTPUT DATA AND CONTINUE TO NEXT PORT
; 		OTIR                    ;SEND DATA VALUES TO PORT
; 		JR      IPORTS          tCONTINUE TO NEXT PORT ENTRY
; 		;PIO INITIALIZATION DATA
; 		t PORT A = INPUT
; 		; PORT B = OUTPUT
; PIOINT:
; 		DB       3               ;OUTPUT 3 BYTES
; 		DB       PIOAC           tDESTINATION IS PORT A CONTROL
; 		DB       PIOIVA AND OFFH ;SET INTERRUPT VECTOR FOR PORT A
; 		DB       10001111B       ;BITS 3,2,1,0 = 1111 (MODE SELECT)
; 								; BITS 5,4 = 00 (DON"T CARE)
; 								;BITS 7,6 = 01 (INPUT MODE)
; 		DB       10000111B       ;BITS 3.2.1.0 = 0111 (INTERRUPT CONTROL)
; 								:BITS 6.5.4 = 000 (DON'T CARE)
; 								;BITS 7 = 1 (ENABLE INTERRUPTS)
; 		DB       3               :OUTPUT 3 BYTES
; 		DB       PIOBC           tDESTINATION IS PORT B CONTROL
; 		DB       PIOIVB AND OFFH ;SET INTERRUPT VECTOR FOR PORT B
; 		DB       11001111B       ;BITS 3,2,1,0 = 1111 (MODE SELECT)
; 								;BITS 5,4 = 00 (DON'T CARE)
; 								;BITS 7.6 = 00 (CONTROL MODE)
; 		DB       00000111B       :BITS 3.2.1.0 = 0111 (INTERRUPT CONTROL)
; 								:BIT 4,5,6 = 000 (DON'T CARE)
; 								;BITS 7 = 0 (DISABLE INTERRUPTS)

; 		DB        0               ;TERMINATOR FOR INITIALIZATION ARRAY
; 		; DATA SECTION
; RECDAT: DS       1                  ;RECEIVE DATA
; RECDF: DS        1                  ;RECEIVE DATA FLAG
; 									; (0 = NO DATA. FF      = DATA)
; TRNDAT: DS          1               ;TRANSMIT DATA
; TRNDF: DS           1               ;TRANSMIT DATA FLAG
; 									; (0 = BUFFER EMPTY. FF = BUFFER FULL)
; OlE:      DS        1               ;OUTPUT INTERRUPT EXPECTED
; 									; (0 = NO INTERRUPT EXPECTED,
; 									; FF = INTERRUPT EXPECTED)



; 		SAMPLE EXECUTION:


; 		;CHARACTER EQUATES
; ESCAPE    EQU     1BH               ; ASCI I ESCAPE CHARACTER
; TESTCH    EQU     ~A~               ;TEST CHARACTER = A
; SCllB:
; 		CALL      INIT            ; INITIALIZE PIO, INTERRUPT SYSTEM
; 		;SIMPLE EXAMPLE - READ AND ECHO CHARACTERS
; 		: UNTIL AN ESC IS RECEIVED
; LOOP:
; 		CALL      INCH            ;READ CHARACTER
; 		PUSH      AF
; 		CALL      OUTCH           ;ECHO CHARACTER
; 		POP       AF
; 		CP        ESCAPE          ;IS CHARACTER AN ESCAPE?
; 		â€¢.JR      NZ,LOOP         ;STAY IN LOOP IF NOT
; 		;AN ASYNCHRONOUS EXAMPLE
; 		; OUTPUT "A" TO CONSOLE CONTINUOUSLY. BUT ALSO LOOK AT
; 		; INPUT SIDE, READING AND ECHOING ANY INPUT CHARACTERS
; ASYNLP:
; 		;OUTPUT   AN "A" IF OUTPUT IS NOT BUSY
; 		CALL      OUTST           ;IS OUTPUT BUSY?
; 		JR        C,ASYNLP        ;JUMP IF IT IS
; 		LD        A,TESTCH
; 		CALL      OUTCH           ;OUTPUT TEST CHARACTER
; 		;CHECK INPUT PORT
; 		;ECHO CHARACTER IF ONE IS AVAILABLE
; 		,EXIT ON ESCAPE CHARACTER
; 		CALL    INST            ;IS INPUT DATA AVAILABLE?
; 		JR      NC.ASYNLP       ;JUMP IF NOT (SEND ANOTHER "A")
; 		CALL    INCH            ;GET THE CHARACTER
; 		CP      ESCAPE          ;IS IT AN ESCAPE CHARACTER?


; 		JR       Z.ASDONE   I JUMP IF IT IS
; 		CALL     OUTCH      ;ELSE ECHO CHARACTER
; 		JP       ASVNLP     ;AND CONTINUE
; ASDONE:
; 		JP       LOOP





			;****************************************************************************************************************
			;****************************************************************************************************************
			; Buffered Input/Output
			; Using an DART (SINTB)                                                                                    11C
			; 		Title              Interrupt input and output using a ZSO DART and
			; 						multiple-character buffers
			; 		Name:              SINTB
			; 		Purpose:           This program consists of 5 subroutines which
			; 						perform interrupt driven input and output using
			; 						a ZSO DART.
			; 						ReadChar
			; 							Read a character
			; 						RetInpStatus
			; 							Determine input status (whether input
			; 							buffer is empty)
			; 						WriteChar
			; 							Write a character
			; 						RetOutStatus
			; 							Determine output status (whether output
			; 							buffer is full)
			; 						InitBuffers
			; 							Initialize DART and interrupt system
			; 		Entry:             ReadChar
			; 							No parameters
			; 						RetInpStatus
			; 							No pat'ameters
			; 						WriteChar
			; 							Register A = character to transmit
			; 						RetOutStatus
			; 							No parameters
			; 						InitBuffers
			; 							No parameters
			; 		Exit :          ReadChar
			; 							Register A = character
			; 						RetInpStatus
			; 							Carry = 0 if input buffer is empty,
			; 							1 if character is available
			; 						WriteChar
			; 							No parameters
			; 						OUT5T
			; 							Carry = 0 if output buffer is not
			; 							full. 1 if it is full
			; 						InitBuffers
			; 							No parameters
			; 		Reqisters used: ReadChar
			; 							AF,C,DE,HL
			; 						RetInpStatus
			; 							AF
			; 						WriteChar
			; 							AF,DE,HL
			; 						RetOutStatus
			; 							AF
			; 						InitBuffers
			; 							AF,BC,HL,I
			; 		Time:           ReadChar
			; 							Approximately 197 cycles if a character is
			; 							available
			; 						RetInpStatus
			; 							39 cycles
			; 						WriteChar
			; 							Approximately 240 cycles if output buffer
			; 							is not full and output interrupt is expected
			; 						RetOutStatus
			; 							34 cycles
			; 						InitBuffers
			; 							732 cycles
			; 						ReadINTHandler
			; 							Approximately 249 cycles
			; 						WriteINTHandler
			; 							Approximately 308 cycles
			; 		Size:           Program 299 bytes
			; 						Data     11 bytes plus size of buffers
			; 		:DART EQUATES
			; 			DART IS PROGRAMMED FOR:
			; 			ASYNCHRONOUS OPERATION
			; 			16 X BAUD RATE
			; 			8-BIT CHARACTERS
			; 		; 1 1/2 STOP BITS
			;****************************************************************************************************************
			;****************************************************************************************************************

		; Section IOLIB


		xdef 	InitBuffers,ReadChar,WriteChar, WriteLine, WriteLineCRNL, ReadLine, CRLF
		xdef	S_head_tail, EIBUF, IBUF, writeSTRBelow


			;ARBITRARY DART PORT ADDRESSES
								; INTERRUPT VECTOR
			;READ   CHARACTER
		;*************************************
		; ROUTINE: ReadLine
		; PURPOSE: Read a line up to CR and store in (HL)
		; ENTRY: HL = POINTER
		;EXIT: HL = POINTER 
		;      A = length of input string (Textbuf)
		;REGISTERS USED: AF.DE.HL
		;***************************************

ReadLine:
R_LOOP:
		CALL	ReadChar				;READ CHARACTER
		PUSH	AF
		CALL	WriteChar				;ECHO CHARACTER
		POP		AF
		CP		CRChar				;IS CHARACTER AN CR?
		JR		NZ,R_LOOP				;STAY IN LOOP IF NOT

		call	CRNL
			; copy from inbuf to cursor buffer...

		call	S_head_tail			; save input heads and tails


		ld		hl,(Comm_Ptr_list)
		ld 		de,(Comm_Ptr_list+2)		; next item in list
		or 		a				; clear carry
		SBC		hl,de 			; number of chars in string (in L)
		ld 		b,l			; store in B

			; detect wraparound (hl)<(de)
		jp 		P,cont2			;positive result 	(hl)>(de)
		ld 		a,SZIBUF 			; length of input buffer
		add		a,b
		ld		b,a				; correct count in B when wraparound
cont2:
		ld	 	ix,Textbuf				; get address of text buffer
		ld		(ix),B		; save length to start of str.
		inc 	ix			; resulting  string adr, skip byte with length

		ld		hl,(Comm_Ptr_list+2)		; first string start

		ld		DE,EIBUF
c_nextchar:
			;	copy from inbuffer to Textbuf...
		ld 		a,(hl)				; char from inbuffer
		ld		(ix),a			; save char in textbuf
		inc		hl
		inc 	ix

			; check if upper buffer adr 
		or 		A		; clear carry
		push 	hl	
		SBC		hl,de		; S and Z set  hl=de -> EIBUF encountered
		pop 	hl
		jr 		NZ, cont1			; continue
			; turnaround (HL) hl = ibuf.	
		ld 		hl,IBUF			; hl = start of input buf
cont1:
		djnz 	c_nextchar		; count no chars.
		xor 	a				; clear a
		ld 		(ix),A			; end with 00H
		ld		hl,Textbuf
		ld		a,(hl)			; A = string length (num)
		inc		hl				; HL = addr to first char in string
		ret 					; string stored in textbuffer

ReadChar:
		CALL	RetInpStatus	;GET INPUT STATUS
		JR		NC,ReadChar		;WAIT IF NO CHARACTER AVAILABLE
		DI                      ;DISABLE INTERRUPTS
		LD		HL,ICNT			;REDUCE INPUT BUFFER COUNT BY 1
		DEC		(HL)
		LD		HL, (IHEAD)		;GET   CHARACTER FROM HEAD OF INPUT BUFFER
		LD		C, (HL)
		CALL	INCIPTR			;MOVE HEAD POINTER UP 1
		LD		(IHEAD) ,HL
		LD		A,C
		EI						;REENABLE INTERRUPTS
		RET
			;RETURN INPUT STATUS (CARRY    =1   IF INPUT DATA IS AVAILABLE)
RetInpStatus:
		LD		A, (ICNT)		;TEST INPUT BUFFER COUNT
		OR		A				;CLEAR CARRY ALWAYS
		RET		Z				; RETURN, CARRY = 0 IF NO DATA
		SCF                     ;SET CARRY
		RET                     ; RETURN. CARRY = 1 IF DATA AVAILABLE


			; Save copies of Ihead and Itail to memory...
S_head_tail:

		ld 		ix,Comm_Ptr_list+2
				ld b,list_len-2
bmve:
				ld 	a,(ix)
				ld 	(ix+2),A
				dec	ix
				djnz bmve		; shift data upwards...

		LD		HL, (IHEAD)		;GET   CHARACTER FROM HEAD OF INPUT BUFFER
		ld 		(Comm_Ptr_list),HL
		ret
			; Write line from address in iy (until char = 00)
WriteLine:
		ld 		b,(iy)		; get length
		inc		iy
nxtchr:
		ld 		a,(iy)
		or		A			; = 0 ??
		ret 	z
		push	hl
		call	WriteChar
		pop 	hl
		inc		iy
		djnz	nxtchr
		ret					; return on maxlength
			; WriteLine from address (iy) (until char = 00)and add CRLF 
WriteLineCRNL:
		call	WriteLine
			; Entry for excl. output CRNL
CRNL:
CRLF:
		ld 		A,CRChar
		call	WriteChar
		ld 		A,LFChar
		call	WriteChar
		ret

			;WRITE CHARACTER
WriteChar:
		PUSH	AF				;SAVE CHARACTER TO OUTPUT
			;WAIT FOR OUTPUT BUFFER NOT FULL,      THEN STORE NEXT CHARACTER
WaitOutBuff:
		CALL	RetOutStatus			;GET OUTPUT STATUS
		JR		C,WaitOutBuff		;WAIT IF OUTPUT BUFFER IS FULL
		DI                      ;DISABLE INTERRUPTS WHILE LOOKING AT
								; BUFFER, INTERRUPT STATUS
		LD		HL,OutBufCount			;INCREASE OUTPUT BUFFER COUNT BY 1
		INC		(HL)
		LD		HL, (OTAIL)		;POINT TO NEXT EMPTY BYTE IN BUFFER
		POP		AF				;GET CHARACTER
		LD		(HL),A			;STORE CHARACTER AT TAIL OF BUFFER
		CALL	INCOPTR			;MOVE TAIL POINTER UP 1
		LD		(OTAIL),HL
		LD		A, (OIE)		;TEST OUTPUT INTERRUPT EXPECTED FLAG
		OR		A
		CALL	Z,CharTODart		;OUTPUT CHARACTER IMMEDIATELY IF
								; OUTPUT INTERRUPT NOT EXPECTED
		EI						;REENABLE INTERRUPTS
		RET
			;OUTPUT STATUS (CARRY   =1   IF BUFFER IS FULL)
RetOutStatus:
		LD		A, (OutBufCount)		;GET CURRENT OUTPUT BUFFER COUNT
		CP		SZOBUF			;COMPARE TO MAXIMUM
		CCF						;COMPLEMENT CARRY
		RET						;CARRY = 1 IF BUFFER FULL, 0 IF NOT
			; INITIALIZE DART, INTERRUPT SYSTEM
InitBuffers:
		DI						;DISABLE INTERRUPTS
			; INITIALIZE BUFFER COUNTERS AND POINTERS. INTERRUPT FLAG
		SUB		A
		LD		(OIE),A			; INDICATE NO OUTPUT INTERRUPTS
		LD		(ICNT),A		;BUFFER COUNTERS = 0
		LD		(OutBufCount),A
		LD		HL,IBUF			;ALL BUFFER POINTERS = BASE ADDRESS
		LD		(IHEAD),HL
		LD		(ITAIL),HL
		LD		HL,OBUF
		LD		(OHEAD),HL
		LD		(OTAIL),HL
			;INITIALIZE INTERRUPT VECTORS
		LD		A,DART_Int_Vec>>8		;GET HIGH BYTE OF INTERRUPT PAGE
		LD		I,A             ;SET INTERRUPT VECTOR IN zao
		IM		2               ; INTERRUPT MODE 2 - VECTORS IN TABLE
		LD		HL,ReadINTHandler       ; ON INTERRUPT PAGE
		LD		(DART_Int_Read_Vec),HL		;STORE READ VECTOR
		LD		HL,WriteINTHandler
		LD		(DART_Int_WR_Vec),HL		;STORE WRITE VECTOR
		LD		HL,ExternINTHandler
		LD		(DART_Int_EXT_Vec),HL		;STORE EXTERNAL/STATUS VECTOR
		LD		HL,SpecINTHandler
		LD		(DART_Int_Spec_Vec),HL		;STORE SPECIAL RECEIVE VECTOR
		;INITIALIZE I/O PORTS
		LD      HL,DARTINT		;BASE ADDRESS OF INITIALIZATION ARRAY
		CALL    InitDARTPorts			; INITIALIZE DART
		EI						; ENABLE INTERRUPTS
		RET
			;INPUT (READ) INTERRUPT HANDLER
ReadINTHandler:
		PUSH	AF				;SAVE REGISTERS
		PUSH	BC
		PUSH	DE
		PUSH   	    HL
RD1:
		IN		A,(DART_A_D)		;READ DATA FROM DART
		LD		C,A				;SAVE DATA IN REGISTER C
		LD		HL,ICNT			;ANY ROOM IN INPUT BUFFER?
		LD		A, (HL)
		CP		SZIBUF
		JR		NC,XITRH		;JUMP IF NO ROOM
		INC		(HL)			;INCREMENT INPUT BUFFER COUNTER
		LD		HL, (ITAIL)		;STORE CHARACTER AT TAIL OF INPUT BUFFER
		LD		(HL),C
		CALL	INCIPTR			; INCREMENT TAIL POINTER
		LD		(ITAIL), HL
XITRH:
		POP		HL				;RESTORE REGISTERS
		POP		DE
		POP		BC
		POP		AF
		EI						;REENABLE INTERRUPTS
		RETI
			;OUTPUT (WRITE) INTERRUPT HANDLER
WriteINTHandler:
		PUSH	AF					;SAVE REGISTERS
		PUSH	BC
		PUSH	DE
		PUSH	HL
		LD		A, (OutBufCount)			;GET OUTPUT BUFFER COUNTER
		OR		A					;TEST FOR EMPTY BUFFER
		JR		Z,NODATA			;JUMP IF NO DATA TO TRANSMIT
		CALL	CharTODart				;ELSE OUTPUT DATA
		JR		WRDONE
			;IF AN OUTPUT INTERRUPT OCCURS WHEN NO DATA IS AVAILABLE.
			; WE MUST DISABLE OUTPUT INTERRUPTS TO AVOID AN ENDLESS LOOP.
			; WHEN THE NEXT CHARACTER IS READY, IT MUST BE SENT IMMEDIATELY
			; SINCE NO INTERRUPT WILL OCCUR. THIS STATE IN WHICH AN OUTPUT
			; INTERRUPT HAS OCCURRED BUT HAS NOT BEEN SERVICED IS INDICATED
			; BY CLEARING OlE (OUTPUT INTERRUPT EXPECTED FLAG).
NODATA:
		SUB		A
		LD		(OIE),A				;00 NOT EXPECT AN INTERRUPT
		OUT		(DART_A_C),A			;SELECT REGISTER 0
		LD		A,00101000B			;RESET TRANSMITTER INTERRUPT
		OUT		(DART_A_C),A
WRDONE:
		POP		HL					;RESTORE REGISTERS
		POP		DE
		POP		BC
		POP		AF
		EI
		RETI
			;EXTERNAL/STATUS CHANGED INTERRUPT HANDLER
ExternINTHandler:
		PUSH	AF
		LD		A,00010000B			;RESET STATUS INTERRUPT

		OUT		(DART_A_C),A
		POP		AF
		EI							;DCD OR CTS LINE CHANGED STATE. OR A
		RETI						; BREAK WAS DETECTED
									;SERVICE HERE IF NECESSARY
			;SPECIAL RECEIVE ERROR INTERRUPT
SpecINTHandler:
		PUSH	AF
		LD		A,00110000B			;RESET RECEIVE ERROR INTERRUPT
		OUT		(DART_A_C),A
		POP		AF
		EI							;FRAMING ERROR OR OVERRUN ERROR OCCURRED
		RETI						; SERVICE HERE IF NECESSARY

		;*************************************
		; ROUTINE: CharTODart
		; PURPOSE: SEND CHARACTER TO DART
		; ENTRY: NONE
		;EXIT: NONE
		;REGISTERS USED: AF.DE.HL
		;***************************************
CharTODart:
		LD		HL,(OHEAD)
		LD		A, (HL)				;GET DATA FROM HEAD OF OUTPUT BUFFER
		OUT		(DART_A_D),A			;OUTPUT DATA
		CALL	INCOPTR				; INCREMENT HEAD POINTER
		LD		(OHEAD),HL
		LD		HL,OutBufCount				;DECREMENT OUTPUT BUFFER COUNT
		DEC		(HL)
		LD		A,0FFH
		LD		(OIE),A				;EXPECT AN OUTPUT INTERRUPT
		RET


		;*************************************
		; ROUTINE: INCIPTR
		; PURPOSE: INCREMENT POINTER INTO INPUT
		;			BUFFER WITH WRAPAROUND
		; ENTRY: HL = POINTER
		;EXIT: HL = POINTER INCREMENTED WITH WRAPAROUND
		;REGISTERS USED: AF.DE.HL
		;***************************************
INCIPTR:
		INC		HL					; INCREMENT POINTER
		LD		DE,EIBUF			;COMPARE POINTER. END OF BUFFER
		LD		A,L
		CP		E
		RET		NZ
		LD		A,H
		CP		D
		RET		NZ					;RETURN IF NOT EQUAL
		LD		HL,IBUF				;IF POINTER AT END OF BUFFER.
		RET                   	  ; SET IT BACK TO BASE ADDRESS
		
		
		;*************************************
		; ROUTINE: INCOPTR
		; PURPOSE: INCREMENT POINTER INTO OUTPUT
		;			BUFFER WITH WRAPAROUND
		; ENTRY: HL =  POINTER
		;EXIT: HL   =  POINTER INCREMENTED WITH WRAPAROUND
		;REGISTERS USED: AF.DE.HL
		;***************************************
INCOPTR:
		INC		HL					; INCREMENT POINTER
		LD		DE, EOBUF			;COMPARE POINTER. END OF BUFFER
		LD		A,L
		CP		E
		RET		NZ
		LD		A,H
		CP		D
		RET		NZ
		LD		HL,OBUF				;IF POINTER AT END OF BUFFER.
		RET							; SET IT BACK TO BASE ADDRESS


		;**************************************
		; ROUTINE: InitDARTPorts
		; PURPOSE: INITIALIZE I/O PORTS
		; ENTRY: HL = BASE ADDRESS OF INITIALIZATION ARRAY
		;EXIT: DATA OUTPUT TO PORTS
		;REGISTERS USED: AF.BC.HL
		;************************************
InitDARTPorts:
		;GET NUMBER OF DATA BYTES TO SEND TO CURRENT PORT
		;EXIT IF NUMBER OF BYTES IS O. INDICATING TERMINATOR
		LD		A,(HL)			;GET NUMBER OF BYTES
		OR		A				;TEST FOR ZERO (TERMINATOR)
		RET		Z				;RETURN IF NUMBER OF BYTES = 0
		LD		B,A
		INC		HL				;POINT TO PORT ADDRESS (NEXT BYTE)

			;C = PORT ADDRESS
			;HL   BASE ADDRESS OF OUTPUT DATA
		LD		C,(HL)			;GET PORT ADDRESS
		INC		HL				;POINT TO FIRST DATA VALUE (NEXT BYTE)
			;OUTPUT DATA AND CONTINUE TO NEXT PORT
		OTIR					;SEND DATA VALUES TO PORT
		JR      InitDARTPorts			;CONTINUE TO NEXT PORT ENTRY
		;DART INITIALIZATION DATA
DARTINT:
		; RESET CHANNEL A
		DB	1					;OUTPUT 1 BYTE
		DB	DART_A_C				;TO CHANNEL A COMMAND/STATUS
		DB	00011000B			;SELECT WRITE REGISTER 0
								;BITS 2.1.0    0 (WRITE REGISTER 0)
								;BITS 5,4,3 = 011 (CHANNEL RESET)
								;BITS 7,6 = 0 (DO NOT CARE)


		;SET INTERRUPT VECTOR AND ALLOW STATUS TO AFFECT IT
		DB	4					;OUTPUT 2 BYTES
		DB	DART_B_C				;DESTINATION IS COMMAND REGISTER B
		DB	00000010B			;SELECT WRITE REGISTER 2
		DB	DART_Int_Vec&0FFH			;SET INTERRUPT VECTOR FOR DART
		DB	00000001B			;SELECT WRITE REGISTER 1
		DB	00000100B			;TURN ON STATUS AFFECTS VECTOR
		; INITIALIZE CHANNEL A
		DB	8					;OUTPUT 8 BYTES
		DB	DART_A_C				;DESTINATION IS COMMAND REGISTER A
			;INITIALIZE BAUD RATE CONTROL
		DB	00010100B			;SELECT WRITE REGISTER 4
								; RESET EXTERNAL/STATUS INTERRUPT
		DB	01001000B			;BIT 0 = 0 (NO PARITY)
								;BIT 1 = 0 (DON'T CARE)
								;BITS 3,2 = 10 (1 1/2 STOP BITS)
								; BITS 5.4 = 00 (DON-'T CARE)
								;BITS 7.6 = 01 (16 TIMES CLOCK)
			; INITIALIZE RECEIVE CONTROL
		DB	00000011B			;SELECT WRITE REGISTER 3
		DB	11000001B			;BIT 0 = 1 (RECEIVE ENABLE)
								; BITS 4,3,2,1 = 0 (DON-'T CARE)
								;BIT 5 = 0 (NO AUTO ENABLE)
								;BIT 7.6 = 11 (RECEIVE 8 BITS/CHAR)
			;INITIALIZE TRANSMIT CONTROL
		DB	00000101B			;SELECT WRITE REGISTER 5
		DB	11101010B			;BIT 0 = 0 (NO CRC ON TRANSMIT)
								;BIT 1 = 1 (REQUEST TO SEND)
								;BIT 2 = 0 (DON'T CARE)
								;BIT 3 = 1 (TRANSMIT ENABLE)
								;BIT 4 = 0 (DO NOT SEND BREAK)
								;BITS 6.5 = 11 (TRANSMIT 8 BITS/CHAR)
								;BIT 7 = 1 (DATA TERMINAL READY)
		DB	00000001B			;SELECT WRITE REGISTER 1
		DB	00011011B			;BIT 0 = 1 (EXTERNAL INTERRUPTS)
								;BIT 1 = 1 (ENABLE TRANSMIT INTERRUPT)
								;BIT 2 = 0 (DO NOT CARE)
								; BITS 4. 3 = 11 (RECE I VE I NTERRUPTS ON
								; ALL CHARS. PARITY DOES NOT AFFECT
								; VECTOR)
								;BITS 7.6.5 = 000 (NO WAIT/READY
								; FUNCTION)
		DB	0               ; END OF TABLE
		; DATA SECTION
IHEAD:	DS	2					; ADDRESS OF OLDEST CHARACTER IN INPUT
								; BUFFER
ITAIL:	DS	2					; ADDRESS OF NEWEST CHARACTER IN INPUT
								; BUFFER
ICNT:	DS	1					;NUMBER OF CHARACTERS IN INPUT BUFFER
OHEAD:	DS	2					;ADDRESS OF OLDEST CHARACTER IN OUTPUT
								; BUFFER
OTAIL:	DS	2					;ADDRESS OF NEWEST CHARACTER IN OUTPUT
								; BUFFER
OutBufCount:	DS	1					;NUMBER OF CHARACTERS IN OUTPUT BUFFER
; OIE:	DS	1					;OUTPUT INTERRUPT EXPECTED
								; (0 = NO INTERRUPT EXPECTED.
								; FF = INTERRUPT EXPECTED)


		; SAMPLE EXECUTION:


		;CHARACTER EQUATES
; ; ESCAPE	EQU     1BH					;ASCII ESCAPE CHARACTER
; ; TESTCH	EQU     'A'					;TEST CHARACTER = A
; 		global SC11C
; SC11C:
; 		CALL	InitBuffers				;INITIALIZE DART. INTERRUPT SYSTEM
; 			;SIMPLE EXAMPLE - READ AND ECHO CHARACTER
; 			; UNTIL AN ESC IS RECEIVED
; LOOP:
; 		CALL	ReadChar				;READ CHARACTER
; 		PUSH	AF
; 		CALL	WriteChar				;ECHO CHARACTER
; 		POP		AF
; 		CP		ESCAPE				;IS CHARACTER AN ESCAPE?
; 		JR		NZ,LOOP				;STAY IN LOOP IF NOT
; 			;AN ASYNCHRONOUS EXAMPLE
; 			; OUTPUT "A" TO CONSOLE CONTINUOUSLY BUT ALSO LOOK AT
; 			; INPUT SIDE. READING AND ECHOING ANY INPUT CHARACTERS
; ASYNLP:
; 			;OUTPUT   AN "A" IF OUTPUT IS NOT BUSY
; 		CALL	RetOutStatus				;IS OUTPUT BUSY?
; 		JR		C,ASYNLP			;JUMP IF IT IS
; 		LD		A,TESTCH
; 		CALL	WriteChar				;OUTPUT CHARACTER
; 			;CHECK INPUT PORT
; 			;ECHO CHARACTER IF ONE IS AVAILABLE
; 			;EXIT ON ESCAPE CHARACTER
; 		CALL	RetInpStatus				;IS INPUT DATA AVAILABLE?
; 		JR		NC, ASYNLP			;JUMP I F NOT (SEND ANOTHER .. A" )
; 		CALL	ReadChar				; GET CHARACTER
; 		CP		ESCAPE				;IS IT AN ESCAPE CHARACTER?
; 		JR		Z,DONE				;BRANCH IF IT IS


; 		CALL	WriteChar				;ELSE ECHO CHARACTER
; 		JP		ASYNLP				;AND CONTINUE
; DONE:
; 		JP		LOOP


;##############################################################
; Write the null-terminated string starting after the call
; instruction invoking this subroutine to the console.
; Clobbers AF, C
;##############################################################
writeSTRBelow:
        ex      (sp),iy                 ; hl = @ of string to print
		call	WriteLineCRNL
        inc     iy                      ; point past the end of the string
        ex      (sp),iy
        ret


;##############################################################
; Print a CRLF 
; Clobbers AF, C
;##############################################################
puts_crlf:
        call    writeSTRBelow
        defb    '\r\n\0'
        ret



; Real-Time Clock and Calendar (CLOCK)                                                              11 D

; Maintains a time-of-day 24-hour clock and           Registers Used:

; Entry Conditions                                     Exit Conditions
; 1. CLOCK: none                                       1. CLOCK: base address of clock variables in
; 2. ICLK: none                                           HL
; 3. CLKINT: none                                      2. ICLK: none
; 													3. CLKINT: none



; Examples
; These examples assume that the tick rate is                         Result:
; 																	March 8, 1982, 12:00.00 A.M. and DTICK ticks
; DnCK Hz (less than 256 Hz - typical values
; 																	(TICK) = DTICK (SEC) = 0           (DAY) = 08
; would be 60 Hz or 100 Hz) and that the clock                                               (MIN) = 0      (MONTH) = 03
; and calendar are saved in memory locations:                                                (HOUR) = 0 (YEAR) = 1982

; TICK                     ticks before a carry, counted down
; 						from DTICK                            2.    Data:
; 																	Dec. 31, 1982, 11:59.59 P.M. and I tick left
; SEC                      seconds (0 to 59)
; MIN                      minutes (0 to 59)                             (TICK) = I (SEC) = 59          (DAY) = 31
; 																					(MIN) = 59        (MONTH) = 12
; HOUR                     hour of day (0 to 23)
; 																					(HOUR) = 23 (YEAR) = 1982
; DAY                      day of month (I to 28, 29, 30, or 31)
; MONTH                    month of year (I through 12)
; YEAR and                 current year                                 Result:
; YEAR+I                                                                Jan. I, 1983,12:00.00 A.M./and DTICK ticks
; 																	(TICK) = DTICK (SEC) = 0          (DA Y) = 1
; 1.   Data:                                                                                  (MIN) = 0 (MONTH) = 1
; 			March 7, 1982, 11 :59.59 P.M. and I tick left                                  (HOUR) = 0 (YEAR) = I
; 			(TICK) = I (SEC) = 59            (DAY) = 07
; 						(MIN) = 59          (MONTH) = 03
; 						(HOUR) = 23         (YEAR) = 1982




; 			Title                    Real-time clock and calendar
; 			Name:                   CLOCK



; 			Put"pose:                This program maintains a time-of-day 24-hour
; 										clock and a calendar based on a real-time clock
; 										interrupt from a ZSO CTC.
; 										CLOCK
; 										Returns base address of clock variables
; 										ICLK
; 										Initializes CTC and clock interrupt
; 										CLKINT
; 										Updates clock variables for each tick
; 			Entry:                   CLOCK
; 										None
; 										ICLK
; 										None
; 			Exit:                    CLOCK
; 						Register HL = Base address of time variables
; 						ICLI(
; 						None
; 		Registers used: CLOCK
; 							HL
; 						ICLI<.:
; 							AF,HL,I
; 						CLKINT
; 							None
; 		Time:           CLOCK
; 						20 cycles
; 						ICLK
; 						251 cycles
; 						CLKINT
; 						93 cycles normally if decrementing tick
; 						498 cycles maximum if changing to a new year

; 		Size:           Program 171 bytes
; 						Data      8 bytes



; 		:ARBITRARV PORT ADDRESSES FOR ZSO CTC
; CTCCHO EQU      80H             ;CTC CHANNEL 0 PORT
; CTCITRP EQU     08000H          ;CTC INTERRUPT ADDRESS
; CTCCMD EQU      10100111B       :BIT 7 = 1 INTERRUPTS ENABLED
; 								;BIT 6 = o TIMER MODE
; 								;BIT 5 = 1 256 COUNT PRESCALER
; 								:BIT 4 = 0 NEGATIVE EDGE TRIGGER
; 								;BIT 3 = o START TIMER AFTER TIME CONST
; 								,BIT 2 = 1 TIME CONSTANT FOLLOWS
; 								:BIT 1 = 1 RESET CHANNEL
; 								;BIT 0 = 1 CONTROL WORD
; CTCTC   EQU     250             ; TIME CONSTANT
; 		;CALCULATION FOR TICK
; 		ASSUME A 4 MHZ CLOCK FOR CTC WITH PRESCALER = 256
; 			AND COUNT = 250 = (4 * 10 4 6) I (256 * 250)
; 			IS ABOUT 62 TICKS PER SECOND
; DFLTS:
; DTICK    EQU     62                ; DEFAULT TICK
; 		:RETURN BASE ADDRESS OF CLOCK VARIABLES
; CLOCK:
; 		LD      HL.CLKVAR         :GET BASE ADDRESS OF CLOCK VARIABLES
; 		RET
; 		;INITIALIZE CTC CHANNEL 0 AS A REAL-TIME CLOCK INTERRUPT
; ICLK:
; 		DI                        ;DISABLE INTERRUPTS
; 		LD      A,CTCITRP SHR 8
; 		LD      IrA               ;SET UP INTERRUPT VECTOR
; 		1M      2                 ;SET INTERRUPT MODE 2 - VECTORS IN
; 								; TABLE ON INTERRUPT pAGE

; 		LD         HL,CLKINT
; 		LD         (CTCITRP) .HL   ;SET INTERRUPT ADDRESS
; 		LD         A.l
; 		OUT        (CTCCHO).A      ;DISABLE CHANNEL 0
; 		LD         A.CTCITRP AND OFFH      :LOW BYTE OF CTC INTERRUPT
; 		OUT        (CTCCHO>,A      ,VECTOR TO CTC
; 		LD         A.CTCCMD
; 		OUT        (CTCCHO),A      ,OUTPUT CTC COMMAND
; 		LD         A.CTCTC
; 		OUT        (CTCCHO>,A      ;OUTPUT TIME CONSTANT
; 		;INITIALIZE CLOCK VARIABLES TO ARBITRARY VALUE
; 		: JANUARY 1. 1980 00: 00. 00
; 		;A REAL CLOCK WOULD NEED OUTSIDE INTERVENTION
; 		: TO SET OR CHANGE VALUES
; 		LD       HL. TICK
; 		LD       (HL).DTICK        :INITIALIZE TICKS
; 		INC      HL
; 		SUB      A
; 		LD       (HL),A            ; SECOND   0
; 		INC      HL
; 		LD       (HL). A            : MINUTE   0
; 		INC      HL
; 		LD       (HL).A             :HOUR = 0
; 		INC      A                 ;A = 1
; 		INC      HL
; 		LD       (HL), A            ; DAY = 1 (FIRST>
; 		INC      HL
; 		LD       ( HL) , A         ,MONTH = 1 ( .,JANUARY )
; 		LD       HL. 1980
; 		LD       (YEAR),HL         ;YEAR = 1980
; 		EI
; 		RET
; 		: HANDLE CLOCK INTERRUPT
; CLKINT:
; 		PUSH       AF              :SAVE AF.HL
; 		PUSH       HL
; 		LD         HL, TICK
; 		DEC        (HL)             ;DECREMENT TICK COUNT
; 		JR         NZ,EXITl        ;JUMP IF TICK NOT ZERO
; 		LD         (HL), DTICK      ;SET TICK COUNT BACK TO DEFAULT
; 		PUSH       BC              :SAVE BC.DE
; 		PUSH       DE
; 		LD         B,O             ;0   = DEFAULT   FOR SECONDS, MINUTES, HOURS
; 		; INCREMENT SECONDS
; 		INC      HL               ;POINT AT SECONDS
; 		INC      (HL)              : INCREMENT TO NEXT SECOND
; 		LD        A, (HL)
; 		CP        60               :SECONDS = 60?
; 		,..IR     C,EXITO          ;EXIT IF LESS THAN 60 SECONDS
; 		LD       (HL>. B        ;ELSE SECONDS = 0
; 		; INCREMENT MINUTES
; 		INC      HL             ;POINT AT MINUTES
; 		INC      (HL>           ; INCREMENT TO NEXT MINUTE
; 		LD       A, (HL)
; 		CP       60             ;MINUTES = 60?
; 		JR       C,EXITO        ;EXIT IF LESS THAN 60 MINUTES
; 		LD       (HL>.B         :ELSE MINUTES = 0
; 		; I NCREMENT HOUR
; 		INC       HL            :POINT AT HOUR
; 		INC       (HL>          ; INCREMENT TO NEXT HOUR
; 		LD        A, (HL)
; 		CP        24            ;HOURS = 24?
; 		JR        C,EXITO       ,EXIT IF LESS THAN 24 HOURS
; 		LD        (HL>.B        :ELSE HOUR = 0
; 		; INCREMENT DAY
; 		EX       DE.HL          :SAVE ADDRESS OF HOUR
; 		LD       HL,LASTDY-l
; 		LD       A.(MONTH)      :GET CURRENT MONTH
; 		LD       C,A            ,REGISTER C = MONTH
; 		LD       B.O
; 		ADD      HL,BC          ;POINT AT LAST DAY OF MONTH
; 		EX       DE,HL          ,RESTORE ADDRESS OF HOUR
; 		INC      HL             :POINT AT DAY
; 		LD       A, (HL>        ,GET CURRENT DAY
; 		INC      (HL>           :INCREMENT TO NEXT DAY
; 		EX       DE,HL          ,DE = ADDRESS OF DAY
; 		LD       B,A            ,REGISTER B = DAY
; 		CP       (HL>           :IS CURRENT DAY END OF MONTH?
; 		EX       DE,HL          ,HL = ADDRESS OF DAY
; 		JR       C,EXITO        ,EXIT IF NOT AT END OF MONTH
; 		:DETERMINE IF THIS IS END OF FEBRUARY IN A LEAP
; 		, YEAR (YEAR DIVISIBLE BY 4)
; 		LD      A, C            ; GET MONTH
; 		CP      2               ; IS TH I S FEBRUARY?
; 		JR      NZ,INCMTH       :JUMP IF NOT. INCREMENT MONTH
; 		LD      A, (YEAR)       ;IS IT A LEAP YEAR?
; 		AND     00000011B
; 		JR      NZ,INCMTH       ,JUMP IF NOT
; 		;FEBRUARY OF A LEAP YEAR HAS 29 DAYS. NOT 28 DAYS
; 		LD      A, B            ,GET DAY
; 		CP      29
; 		JR      C,EXITO         ,EXIT IF NOT 1ST OF MARCH
; INCMTH:
; 		LD       B,l            ,DEFAULT IS   1   FOR DAY AND MONTH
; 		LD       (HL>. B        :DAY = 1
; 		INC     HL
; 		INC     (HL>            : INCREMENT MONTH
; 		LD      A,C             ,GET OLD MONTH



; 		CP          12           ;WAS OLD MONTH DECEMBER?
; 		,JR         He. EX ITO   ;EXIT IF NOT
; 		LD          (HL) .~      ; ELSE
; 									; CHANGE MONTH TO 1 (,JANUARY)
; 		tINCREMENT YEAR
; 		LD      HL.(YEAR)
; 		INC     HL
; 		LD      (YEAR).HL
; EXITO:
; 		;RESTORE REGISTERS
; 		POP     DE               tRESTORE BC.DE
; 		POP     BC
; EXIT1 :
; 		POP         HL           tRESTORE HL.AF
; 		POP         AF
; 		EI                       tREENABLE INTERRUPTS
; 		RETI                     ; RETURN
; 			tARRAY OF LAST DAYS OF EACH MONTH
; LASTDY:
; 		DB          31           t,JANUARY
; 		DB          28           ,FEBRUARY (EXCEPT LEAP YEARS)
; 		DB          31           tMARCH
; 		DB          30           ,APRIL
; 		DB          31           tMAY
; 		DB          30           ,,JUNE
; 		DB          31           t,JULY
; 		DB          31           ; AUGUST
; 		DB          30           tSEPTEMBER
; 		DB          31           ,OCTOBER
; 		DB          30           tNOVEMBER
; 		DB          31           ; DECEMBER
; 			tCLOCK VARIABLES
; CLKVAR:
; TICK:      DS          1            ;TICKS LEFT IN CURRENT SECOND
; SECt       DS          1            ;SECONDS (0 TO 59)
; MINt       DS          1            ,MINUTES (0 TO 59)
; HOUR:      DS          1            ,HOURS (0 TO 23)
; DAY:       DS          1            tDAY (1 TO NUMBER OF DAYS IN A MONTH)
; MONTH:     DS          1            ,MONTH 1=,JANUARY â€¢â€¢ 12=DECEMBER
; YEAR:      DS          2            ,YEAR



; 		SAMPLE EXECUTION


; 			,CLOCK VARIABLE INDEXES
; TCKIDX      EQU     0               ,INDEX TO TICK
; SECIDX   EQU     1               ,INDEX   TO   SECOND
; MINIDX   EQU     2               ,INDEX   TO   MINUTE
; HRIDX    EQU     3               ,INDEX   TO   HOUR
; DAYIDX   EQU     4               ;INDEX   TO   DAY
; MTHIDX   EQU     5               ,INDEX   TO   MONTH
; YRIDX    EQU     6               ;INDEX   TO   YEAR
; SCllD:
; 		CALL    ICLK            ; INITIALIZE CLOCK
; 		,INITIALIZE CLOCK TO 2/7/83 14100:00 (2 PM. FEB. 7. 1983)
; 		CALL    CLOCK            ;HL = BASE ADDRESS OF CLOCK VARIABLES
; 		DI
; 		PUSH    HL
; 		POP     IX               ,IX = ADDRESS OF TICKS
; 		LD      (IX+SECIDX),O    ,SECONDS = 0
; 		LD       (I X+MINIDX), 0 ,MINUTES = 0
; 		LD       (IX+HRIDX),14   ,HOUR = 14 (2 PM)
; 		LD       (IX+DAYIDX).7   ,DAY = 7
; 		LD       (IX+MTHIDX).2   ;MONTH = 2 (FEBRUARY)
; 		LD      HL.1983
; 		LD       (IX+YRIDX>. L   ,YEAR = 1983
; 		LD       (IX+YRIDX+1). H
; 		EI
; 		;WAIT FOR CLOCK TO BE 2/7/83 14101120 (2101.20 PM. FEB.7. 1983)
; 		,IX = BASE ADDRESS OF CLOCK VARIABLES
; 		,NOTE: MUST BE CAREFUL TO EXIT IF CLOCK IS ACCIDENTALLY
; 		, SET AHEAD. IF WE CHECK ONLY FOR EQUALITY. WE MIGHT NEVER
; 		; FIND IT. THUS WE HAVE >= IN TESTS BELOW, NOT JUST =.
; 		,WAIT FOR YEAR >= 1983
; 		LD      DE. 1983
; WAITYR: DI                       ;DISABLE INTERRUPTS TO LOAD 2-BYTE YEAR
; 		LD      H.(IX+YRIDX+1)   :GET YEAR
; 		LD      L,(IX+YRIDX)
; 		EI
; 		OR      A                ,CLEAR CARRY
; 		SBC     HL.DE            ;COMPARE YEAR. 1983
; 		JR      C.WAITYR         :JUMP IF NOT 1983
; 		;WAIT FOR MONTH >= 2
; 		PUSH    IX
; 		POP     HL              ;HL   = BASE   ADDRESS OF CLOCK VARIABLES
; 		LD      DE.MTHIDX
; 		ADD     HL.DE           ;POINT AT MONTH
; 		LD      B.2
; 		CALL    WAIT            ;WAIT FOR FEBRUARY OR LATER
; 		,WAIT FOR DAY >= 7
; 		DEC     HL              ;POINT AT DAY
; 		LD      B.7
; 		CALL    WAIT            :WAIT FOR 7TH OR LATER
; 		;WAIT FOR HOUR >= 14
; 		DEC     HL              ,POINT AT HOUR


; 		LD          B,14
; 		CALL        WAIT          ,WAIT FOR 2 PM OR LATER
; 		,WAIT FOR MINUTE >= 1
; 		DEC     HL                ;POINT AT MINUTE
; 		LD      B.1
; 		CALL    WAIT              ,WAIT FOR 2:01 OR LATER
; 		; WAIT FOR SECOND >= 20
; 		DEC      HL               ;POINT AT SECOND
; 		LD       B,20
; 		CALL     WAIT             ;WAIT FOR 2:01.20 OR LATER
; 		; DONE
; HERE:
; 		.JP         HERE          ,IT IS NOW TIME OR LATER

; 		JMMM****M************************
; 		; ROUTINE: WA IT
; 		; PURPOSE. WAIT FOR VALUE POINTED TO BY HL
; 		,          TO BECOME GREATER THAN OR EQUAL TO VALUE IN B
; 		JENTRY: HL = ADDRESS OF VARIABLE TO WATCH
; 		;        B = VALUE TO WAIT FOR
; 		JEXIT: WHEN B >= (HL)
; 		; USED: AF
; 		;*******************************
; WAIT:
; 		LD          A, (HL)        ;GET PART OF CLOCK TIME
; 		CP          B             ;COMPARE TO TARGET
; 		.JR         C,WAIT        ;WAIT IF TARGET NOT REACHED
; 		RET
; 		END



